---
sidebar_position:  86
---

# 10.1 Separate Compilation

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[ A <em>program unit</em> is either a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal. Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units. <br /></p>

<AnnotatedOnly>
<MarginText>1.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>program unit</strong> &mdash; language construct that is a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal<br /><br /></Admonition>
</AnnotatedOnly>

<MarginText>2</MarginText>
<p>The text of a program can be submitted to the compiler in one or more <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>s. Each <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> is a succession of <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>s. A <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> contains either the declaration, the body, or a renaming of a program unit.] The representation for a <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> is implementation-defined. <br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The representation for a <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Some implementations might choose to make a <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> be a source (text) file. Others might allow multiple source files to be automatically concatenated to form a single <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>. Others still may represent the source in a nontextual form such as a parse tree. Note that the RM95 does not even define the concept of a source file.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.c</MarginText>
<Admonition type="aarm" aarm="note">
Note that a protected subprogram is a subprogram, and therefore a program unit. An instance of a generic unit is a program unit.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.d</MarginText>
<Admonition type="aarm" aarm="note">
A protected entry is a program unit, but protected entries cannot be separately compiled. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.e/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>compilation unit</strong> &mdash; program unit that is separately compiled<br /><code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> contains either the declaration, the body, or a renaming of a program unit.<br /></Admonition>
</AnnotatedOnly>

<MarginText>3</MarginText>
<p>A library unit is a separately compiled program unit, and is  a package, subprogram, or generic unit. Library units may have other (logically nested) library units as children, and may have other program units physically nested within them. A root library unit, together with its children and grandchildren and so on, form a <em>subsystem</em>. <br /></p>

<AnnotatedOnly>
<MarginText>3.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>library unit</strong> &mdash; separately compiled program unit, which is a package, a subprogram, or a generic unit<br /><br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>4</MarginText>
<p>An implementation may impose implementation-defined restrictions on <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>s that contain multiple <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>s. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>Any restrictions on <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>s that contain multiple <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>s.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For example, an implementation might disallow a <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> that contains two versions of the same compilation unit, or that contains the declarations for library packages P1 and P2, where P1 precedes P2 in the <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> but P1 has a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that mentions P2. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.c</MarginText>
<Admonition type="aarm" aarm="note">
The interactions between language issues and environmental issues are left open in Ada 95. The environment concept is new. In Ada 83, the concept of the program library, for example, appeared to be quite concrete, although the rules had no force, since implementations could get around them simply by defining various mappings from the concept of an Ada program library to whatever data structures were actually stored in support of separate compilation. Indeed, implementations were encouraged to do so.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.d</MarginText>
<Admonition type="aarm" aarm="note">
In RM83, it was unclear which was the official definition of &ldquo;program unit&rdquo;. Definitions appeared in RM83-5, 6, 7, and 9, but not 12. Placing it here seems logical, since a program unit is sort of a potential compilation unit. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.1"></a>

## 10.1.1  Compilation Units - Library Units

<MarginText>1</MarginText>
<p>[A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is a compilation unit that is the declaration, body, or renaming of a library unit. Each library unit (except Standard) has a <em>parent unit</em>, which is a library package or generic library package.] A library unit is a <em>child</em> of its parent unit. The <em>root</em> library units are the children of the predefined library package Standard. <br /></p>

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Standard is a library unit. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>compilation</code><a id="S0285"></a><code> ::= </code>{"{"}<code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>{"}"}<br />

</CodeBlock>
<MarginText>3</MarginText>

<CodeBlock>
<code>compilation_unit</code><a id="S0286"></a><code> ::= </code><br />    <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code><br />  | <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code><br />

</CodeBlock>
<MarginText>4</MarginText>

<CodeBlock>
<code>library_item</code><a id="S0287"></a><code> ::= </code>[<strong>private</strong>] <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code><br />  | <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code><br />  | [<strong>private</strong>] <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code><br />

</CodeBlock>
<MarginText>5</MarginText>

<CodeBlock>
<code>library_unit_declaration</code><a id="S0288"></a><code> ::= </code><br />     <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>	| <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code><br />   | <code><a href="../AA-12/AA-12.1#S0310">generic_declaration</a></code>	| <code><a href="../AA-12/AA-12.3#S0315">generic_instantiation</a></code><br />

</CodeBlock>
<MarginText>6</MarginText>

<CodeBlock>
<code>library_unit_renaming_declaration</code><a id="S0289"></a><code> ::= </code><br />   <code><a href="../AA-8/AA-8.5#S0241">package_renaming_declaration</a></code><br /> | <code><a href="../AA-8/AA-8.5#S0243">generic_renaming_declaration</a></code><br /> | <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code><br />

</CodeBlock>
<MarginText>7</MarginText>

<CodeBlock>
<code>library_unit_body</code><a id="S0290"></a><code> ::= </code><code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> | <code><a href="../AA-7/AA-7.2#S0231">package_body</a></code><br />

</CodeBlock>
<MarginText>8</MarginText>

<CodeBlock>
<code>parent_unit_name</code><a id="S0291"></a><code> ::= </code><code><a href="../AA-4/AA-4.1#S0091">name</a></code><br />

</CodeBlock>
<MarginText>8.1/2</MarginText>
<MarginInfo items={["AI95-00397-01"]} />
<p class="Indented2">An <code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code> is not allowed in a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>, <code><a href="../AA-12/AA-12.3#S0315">generic_instantiation</a></code>, or <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code> that declares a library unit.<br /></p>

<AnnotatedOnly>
<MarginText>8.a.1/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>All of the listed items syntactically include <code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code>, but a library unit can never override anything. A majority of the ARG thought that allowing <strong>not overriding</strong> in that case would be confusing instead of helpful. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9</MarginText>
<p>A <em>library unit</em> is a program unit that is declared by a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. When a program unit is a library unit, the prefix &ldquo;library&rdquo; is used to refer to it (or &ldquo;generic library&rdquo; if generic), as well as to its declaration and body, as in &ldquo;library procedure&rdquo;, &ldquo;library <code><a href="../AA-7/AA-7.2#S0231">package_body</a></code>&rdquo;, or &ldquo;generic library package&rdquo;. The term <em>compilation unit</em> is used to refer to a <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>. When the meaning is clear from context, the term is also used to refer to the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> of a <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> or to the <code><a href="../AA-3/AA-3.11#S0090">proper_body</a></code> of a <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code> [(that is, the <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> without the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> and the <strong>separate</strong> (<code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>))]. <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>In this example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b</MarginText>
<CodeBlock language="ada">
with Ada.Text_IO;{"\n"}package P is{"\n"}    ...{"\n"}end P;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>9.c</MarginText>
<Admonition type="aarm" aarm="note">
the term &ldquo;compilation unit&rdquo; can refer to this text: &ldquo;<strong>with</strong> Ada.Text_IO; <strong>package</strong> P <strong>is</strong> ... <strong>end</strong> P;&rdquo; or to this text: &ldquo;<strong>package</strong> P <strong>is</strong> ... <strong>end</strong> P;&rdquo;. We use this shorthand because it corresponds to common usage.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.d</MarginText>
<Admonition type="aarm" aarm="note">
We like to use the word &ldquo;unit&rdquo; for declaration-plus-body things, and &ldquo;item&rdquo; for declaration or body separately (as in <code><a href="../AA-3/AA-3.11#S0087">declarative_item</a></code>). The terms &ldquo;<code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>&rdquo;, &ldquo;compilation unit&rdquo;, and &ldquo;<code><a href="../AA-10/AA-10.1#S0302">subunit</a></code>&rdquo; are exceptions to this rule. We considered changing &ldquo;<code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>&rdquo;, &ldquo;compilation unit&rdquo; to &ldquo;<code>compilation_item</code>&rdquo;, &ldquo;compilation item&rdquo;, respectively, but we decided not to. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10</MarginText>
<p>The <em>parent declaration</em> of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> (and of the library unit) is the declaration denoted by the <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>, if any, of the <code><a href="../AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> of the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. If there is no <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>, the parent declaration is the declaration of Standard, the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is a <em>root</em> <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>, and the library unit (renaming) is a <em>root</em> library unit (renaming). The declaration and body of Standard itself have no parent declaration. The <em>parent unit</em> of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or library unit is the library unit declared by its parent declaration. <br /></p>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The declaration and body of Standard are presumed to exist from the beginning of time, as it were. There is no way to actually write them, since there is no syntactic way to indicate lack of a parent. An attempt to compile a package Standard would result in Standard.Standard. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Library units (other than Standard) have &ldquo;parent declarations&rdquo; and &ldquo;parent units&rdquo;. Subunits have &ldquo;parent bodies&rdquo;. We didn't bother to define the other possibilities: parent body of a library unit, parent declaration of a subunit, parent unit of a subunit. These are not needed, and might get in the way of a correct definition of &ldquo;child&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>
<p>[The children of a library unit occur immediately within the declarative region of the declaration of the library unit.] The <em>ancestors</em> of a library unit are itself, its parent, its parent's parent, and so on. [(Standard is an ancestor of every library unit.)] The <em>descendant</em> relation is the inverse of the ancestor relation. <br /></p>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>These definitions are worded carefully to avoid defining subunits as children. Only library units can be children.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b</MarginText>
<Admonition type="aarm" aarm="note">
We use the unadorned term &ldquo;ancestors&rdquo; here to concisely define both &ldquo;ancestor unit&rdquo; and &ldquo;ancestor declaration&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12</MarginText>
<p>A <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> or a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> is <em>private</em> if the declaration is immediately preceded by the reserved word <strong>private</strong>; it is otherwise <em>public</em>. A library unit is private or public according to its declaration. The <em>public descendants</em> of a library unit are the library unit itself, and the public descendants of its public children. Its other descendants are <em>private descendants</em>. <br /></p>

<AnnotatedOnly>
<MarginText>12.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The first concept defined here is that a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is either public or private (not in relation to anything else &mdash; it's just a property of the library unit). The second concept is that a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is a public descendant or private descendant <em>of a given ancestor</em>. A given <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> can be a public descendant of one of its ancestors, but a private descendant of some other ancestor.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.b</MarginText>
<Admonition type="aarm" aarm="note">
A subprogram declared by a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> (as opposed to a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>) is always public, since the syntax rules disallow the reserved word <strong>private</strong> on a body.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.c</MarginText>
<Admonition type="aarm" aarm="note">
Note that a private library unit is a <em>public</em> descendant of itself, but a <em>private</em> descendant of its parent. This is because it is visible outside itself &mdash; its privateness means that it is not visible outside its parent.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.d</MarginText>
<Admonition type="aarm" aarm="note">
Private children of Standard are legal, and follow the normal rules. It is intended that implementations might have some method for taking an existing environment, and treating it as a package to be &ldquo;imported&rdquo; into another environment, treating children of Standard in the imported environment as children of the imported package. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.e</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Suppose we have a public library unit A, a private library unit A.B, and a public library unit A.B.C. A.B.C is a public descendant of itself and of A.B, but a private descendant of A; since A.B is private to A, we don't allow A.B.C to escape outside A either. This is similar to the situation that would occur with physical nesting, like this: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.f</MarginText>
<CodeBlock language="ada">
package A is{"\n"}private{"\n"}    package B is{"\n"}        package C is{"\n"}        end C;{"\n"}    private{"\n"}    end B;{"\n"}end A;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>12.g</MarginText>
<Admonition type="aarm" aarm="note">
Here, A.B.C is visible outside itself and outside A.B, but not outside A. (Note that this example is intended to illustrate the visibility of program units from the outside; the visibility within child units is not quite identical to that of physically nested units, since child units are nested after their parent's declaration.) <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.1/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>For each library <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> in the environment, there is an implicit declaration of a <em>limited view</em> of that library package. The limited view of a package contains:<br /></p>

<MarginText>12.2/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI05-0129-1", "AI05-0262-1"]} />
<ul>
<li>For each <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> occurring immediately within the visible part, a declaration of the limited view of that package, with the same <code><a href="../AA-6/AA-6.1#S0201">defining_program_unit_name</a></code>.<br /></li>
<MarginText>12.3/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI95-00326-01", "AI05-0108-1", "AI05-0129-1", "AI05-0262-1"]} />
<li>For each <code><a href="../AA-3/AA-3.2#S0023">type_declaration</a></code> occurring immediately within the visible part that is not an <code><a href="../AA-3/AA-3.10#S0085">incomplete_type_declaration</a></code>, an incomplete view of the type with no <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>; if the <code><a href="../AA-3/AA-3.2#S0023">type_declaration</a></code> is tagged, then the view is a tagged incomplete view. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>12.g.1/3</MarginText>
<MarginInfo items={["AI05-0108-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The incomplete view of a type does not have a discriminant_part even if the <code><a href="../AA-3/AA-3.2#S0023">type_declaration</a></code> does have one. This is necessary because semantic analysis (and the associated dependence on <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s) would be necessary to determine the types of the discriminants.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.g.2/3</MarginText>
<MarginInfo items={["AI05-0129-1"]} />
<Admonition type="aarm" aarm="note">
No incomplete views of incomplete types are included in the limited view. The rules of <a href="../AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a> ensure that the completion of any visible incomplete type is declared in the same visible part, so such an incomplete view would simply be redundant. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.g.3/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>The implementation model of a limited view is that it can be determined solely from the syntax of the source of the unit, without any semantic analysis. That allows it to be created without the semantic dependences of a full unit, which is necessary for it to break mutual dependences of units. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.g.4/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The limited view does not include package instances and their contents. Semantic analysis of a unit (and dependence on its <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s) would be needed to determine the contents of an instance. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.4/2</MarginText>
<p>The limited view of a library <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> is private if that library <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> is immediately preceded by the reserved word <strong>private</strong>.<br /></p>

<MarginText>12.5/2</MarginText>
<p>[There is no syntax for declaring limited views of packages, because they are always implicit.] The implicit declaration of a limited view of a library package [is not the declaration of a library unit (the library <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> is); nonetheless, it] is a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. The implicit declaration of the limited view of a library package forms an (implicit) compilation unit whose <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is empty.<br /></p>

<MarginText>12.6/2</MarginText>
<p>A library <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> is the completion of the declaration of its limited view.<br /></p>

<AnnotatedOnly>
<MarginText>12.h/2</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This is notwithstanding the rule in <a href="../AA-3/AA-3.11#Subclause_3.11.1">3.11.1</a> that says that implicit declarations don't have completions. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.i/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule explains where to find the completions of the incomplete views defined by the limited view. <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>13</MarginText>
<p>The parent unit of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> shall be a [library] package or generic [library] package.<br /></p>

<MarginText>14</MarginText>
<p>If a <code><a href="../AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> of a given declaration or body has a <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>, then the given declaration or body shall be a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. The body of a program unit shall be a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> if and only if the declaration of the program unit is a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. In a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>, the [(old)] <code><a href="../AA-4/AA-4.1#S0091">name</a></code> shall denote a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>14.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We could have allowed nested program units to be children of other program units; their semantics would make sense. We disallow them to keep things simpler and because they wouldn't be particularly useful. <br /></Admonition>
</AnnotatedOnly>

<MarginText>15/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> [(which can be used within a <code><a href="../AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> and in the <strong>separate</strong> clause of a <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code>)], and each of its <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code>es, shall not denote a <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code>. [On the other hand, a name that denotes a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> is allowed in a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code> and other places where the name of a library unit is allowed.]<br /></p>

<MarginText>16</MarginText>
<p>If a library package is an instance of a generic package, then every child of the library package shall either be itself an instance or be a renaming of a library unit. <br /></p>

<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>A child of an instance of a given generic unit will often be an instance of a (generic) child of the given generic unit. This is not required, however. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Instances are forbidden from having noninstance children for two reasons: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.c</MarginText>
<dt><br/>1.</dt>
<dl>
<dd>We want all source code that can depend on information from the private part of a library unit to be inside the "subsystem" rooted at the library unit. If an instance of a generic unit were allowed to have a noninstance as a child, the source code of that child might depend on information from the private part of the generic unit, even though it is outside the subsystem rooted at the generic unit.<br /></dd>
<MarginText>16.d</MarginText>
<dt><br/>2.</dt>
<dd>Disallowing noninstance children simplifies the description of the semantics of children of generic packages. <br /></dd>
</dl>
</AnnotatedOnly>
<MarginText>17/3</MarginText>
<MarginInfo items={["AI05-0004-1"]} />
<p>A child of a generic library package shall either be itself a generic unit or be a renaming of some other child of the same generic unit.<br /></p>

<MarginText>18</MarginText>
<p>A child of a parent generic package shall be instantiated or renamed only within the declarative region of the parent generic.<br /></p>

<MarginText>19/2</MarginText>
<MarginInfo items={["AI95-00331-01"]} />
<p>For each child <em>C</em> of some parent generic package <em>P</em>, there is a corresponding declaration <em>C</em> nested immediately within each instance of <em>P</em>. For the purposes of this rule, if a child <em>C</em> itself has a child <em>D</em>, each corresponding declaration for <em>C</em> has a corresponding child <em>D</em>. [The corresponding declaration for a child within an instance is visible only within the scope of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that mentions the (original) child generic unit.]<br /></p>

<AnnotatedOnly>
<MarginText>19.a</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Within the child, like anything nested in a generic unit, one can make up-level references to the current instance of its parent, and thereby gain access to the formal parameters of the parent, to the types declared in the parent, etc. This &ldquo;nesting&rdquo; model applies even within the <code><a href="../AA-12/AA-12.1#S0313">generic_formal_part</a></code> of the child, as it does for a generic child of a nongeneric unit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Suppose P is a generic library package, and P.C is a generic child of P. P.C can be instantiated inside the declarative region of P. Outside P, P.C can be mentioned only in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. Conceptually, an instance I of P is a package that has a nested generic unit called I.C. Mentioning P.C in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> allows I.C to be instantiated. I need not be a library unit, and the instantiation of I.C need not be a library unit. If I is a library unit, and an instance of I.C is a child of I, then this instance has to be called something other than C.<br /></Admonition>
</AnnotatedOnly>

<MarginText>20</MarginText>
<p>A library subprogram shall not override a primitive subprogram. <br /></p>

<AnnotatedOnly>
<MarginText>20.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This prevents certain obscure anomalies. For example, if a library subprogram were to override a subprogram declared in its parent package, then in a compilation unit that depends <em>in</em>directly on the library subprogram, the library subprogram could hide the overridden operation from all visibility, but the library subprogram itself would not be visible.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that even without this rule, such subprograms would be illegal for tagged types, because of the freezing rules. <br /></Admonition>
</AnnotatedOnly>

<MarginText>21</MarginText>
<p>The defining name of a function that is a compilation unit shall not be an <code><a href="../AA-6/AA-6.1#S0202">operator_symbol</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Since overloading is not permitted among compilation units, it seems unlikely that it would be useful to define one as an operator. Note that a subunit could be renamed within its parent to be an operator. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>22</MarginText>
<p>A <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code> that is a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> is a renaming-as-declaration, not a renaming-as-body.<br /></p>

<MarginText>23</MarginText>
<p>[There are two kinds of dependences among compilation units:] <br /></p>

<MarginText>24/5</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<ul>
<li>[The <em>semantic dependences</em> (see below) are the ones necessary  to check the compile-time rules across compilation unit boundaries; a compilation unit depends semantically on the other compilation units necessary  to determine its legality. The visibility rules are based on the semantic dependences.<br /></li>
<MarginText>25</MarginText>
<li>The <em>elaboration dependences</em> (see <a href="../AA-10/AA-10.2">10.2</a>) determine the order of elaboration of <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s.] <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>25.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Don't confuse these kinds of dependences with the run-time dependences among tasks and masters defined in <a href="../AA-9/AA-9.3">9.3</a>, &ldquo;<a href="../AA-9/AA-9.3">Task Dependence - Termination of Tasks</a>&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>26/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> depends semantically upon its parent declaration. A subunit depends semantically upon its parent body. A <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> depends semantically upon the corresponding <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code>, if any. The declaration of the limited view of a library package depends semantically upon the declaration of the limited view of its parent. The declaration of a library package depends semantically upon the declaration of its limited view. A compilation unit depends semantically upon each <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> mentioned in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of the compilation unit. In addition, if a given compilation unit contains an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. The semantic dependence relationship is transitive.<br /></p>

<AnnotatedOnly>
<MarginText>26.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The &ldquo;if any&rdquo; in the third sentence is necessary because library subprograms are not required to have a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.b</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>If a given compilation unit contains a <code><a href="../AA-11/AA-11.2#S0306">choice_parameter_specification</a></code>, then the given compilation unit depends semantically upon the declaration of Ada.Exceptions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.c</MarginText>
<Admonition type="aarm" aarm="note">
If a given compilation unit contains a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> with an argument of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.d</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For example, a compilation unit containing X'Address depends semantically upon the declaration of package System.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.e</MarginText>
<Admonition type="aarm" aarm="note">
For the Address attribute, this fixes a hole in Ada 83. Note that in almost all cases, the dependence will need to exist due to <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s, even without this rule. Hence, the rule has very little effect on programmers.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.f</MarginText>
<Admonition type="aarm" aarm="note">
Note that the semantic dependence does not have the same effect as a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>; in order to denote a declaration in one of those packages, a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> will generally be needed.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.g</MarginText>
<Admonition type="aarm" aarm="note">
Note that no special rule is needed for an <code><a href="../AA-13/AA-13.3#S0349">attribute_definition_clause</a></code>, since an expression after <strong>use</strong> will require semantic dependence upon the compilation unit containing the <code><a href="../AA-3/AA-3.2#S0023">type_declaration</a></code> of interest.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.h/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
Unlike a full view of a package, a limited view does not depend semantically on units mentioned in <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s of the <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> that defines the package. Formally, this is achieved by saying that the limited view has an empty <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>. This is necessary so that they can be useful for their intended purpose: allowing mutual dependences between packages. The lack of semantic dependence limits the contents of a limited view to the items that can be determined solely from the syntax of the source of the package, without any semantic analysis. That allows it to be created without the semantic dependences of a full package. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>26.1/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>The elaboration of the declaration of the limited view of a package has no effect. <br /></p>

<AnnotatedOnly>
<MarginText>27/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   A simple program can  consist of a single compilation unit. A <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> can have no  compilation units; for example, its text can consist of <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Such <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s cannot have any arguments that are <code><a href="../AA-4/AA-4.1#S0091">name</a></code>s, by a previous rule of this subclause. A <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> can even be entirely empty, which is probably not useful.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b</MarginText>
<Admonition type="aarm" aarm="note">
Some interesting properties of the three kinds of dependence: The elaboration dependences also include the semantic dependences, except that subunits are taken together with their parents. The semantic dependences partly determine the order in which the compilation units appear in the environment at compile time. At run time, the order is partly determined by the elaboration dependences.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.c</MarginText>
<Admonition type="aarm" aarm="note">
The model whereby a child is inside its parent's declarative region, after the parent's declaration, as explained in <a href="../AA-8/AA-8.1">8.1</a>, has the following ramifications: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.d</MarginText>
<ul>
<li>The restrictions on &ldquo;early&rdquo; use of a private type (RM83-7.4.1(4)) or a deferred constant (RM83-7.4.3(2)) do not apply to uses in child units, because they follow the full declaration.<br /></li>
<MarginText>27.e</MarginText>
<li>A library subprogram is never primitive, even if its profile includes a type declared immediately within the parent's <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code>, because the child is not declared immediately within the same <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code> as the type (so it doesn't declare a new primitive subprogram), and because the child is forbidden from overriding an old primitive subprogram. It is immediately within the same declarative region, but not the same <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code>. Thus, for a tagged type, it is not possible to call a child subprogram in a dispatching manner. (This is also forbidden by the freezing rules.) Similarly, it is not possible for the user to declare primitive subprograms of the types declared in the declaration of Standard, such as Integer (even if the rules were changed to allow a library unit whose name is an operator symbol).<br /></li>
<MarginText>27.f</MarginText>
<li>When the parent unit is &ldquo;used&rdquo; the simple names of the with'd child units are directly visible (see <a href="../AA-8/AA-8.4">8.4</a>, &ldquo;<a href="../AA-8/AA-8.4">Use Clauses</a>&rdquo;).<br /></li>
<MarginText>27.g</MarginText>
<li>When a parent body with's its own child, the defining name of the child is directly visible, and the parent body is not allowed to include a declaration of a homograph of the child unit immediately within the <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> of the body (RM83-8.3(17)). <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.h</MarginText>
<Admonition type="aarm" aarm="note">
Note that &ldquo;declaration of a library unit&rdquo; is different from &ldquo;<code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code>&rdquo; &mdash; the former includes <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>. Also, we sometimes really mean &ldquo;declaration of a view of a library unit&rdquo;, which includes <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>s.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.i</MarginText>
<Admonition type="aarm" aarm="note">
The visibility rules generally imply that the renamed view of a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> has to be mentioned in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of the <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.j</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>The real rule is that the renamed library unit has to be visible in the <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.k</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>In most cases, &ldquo;has to be visible&rdquo; means there has to be a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. However, it is possible in obscure cases to avoid the need for a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>; in particular, a compilation unit such as &ldquo;<strong>package</strong> P.Q <strong>renames</strong> P;&rdquo; is legal with no <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s (though not particularly interesting). ASCII is physically nested in Standard, and so is not a library unit, and cannot be renamed as a library unit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   The <code><a href="../AA-6/AA-6.1#S0199">designator</a></code> of a library function cannot be an <code><a href="../AA-6/AA-6.1#S0202">operator_symbol</a></code>, but a nonlibrary <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code> is allowed to rename a library function as an operator. Within a partition, two library subprograms are required to have distinct names and hence cannot overload each other. However, <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code>s are allowed to define overloaded names for such subprograms, and a locally declared subprogram is allowed to overload a library subprogram. The expanded name Standard.L can be used to denote a root library unit L (unless the declaration of Standard is hidden) since root library unit declarations occur immediately within the declarative region of package Standard. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>29</MarginText>
<p><em>Examples of library units:</em> <br /></p>

<MarginText>30</MarginText>
<CodeBlock language="ada">
package Rational_Numbers.IO is  -- public child of Rational_Numbers, see <a href="../AA-7/AA-7.1">7.1</a>{"\n"}   procedure Put(R : in  Rational);{"\n"}   procedure Get(R : out Rational);{"\n"}end Rational_Numbers.IO;{"\n"}
<MarginText>31</MarginText>
private procedure Rational_Numbers.Reduce(R : in out Rational);{"\n"}                                -- private child of Rational_Numbers{"\n"}
<MarginText>32</MarginText>
with Rational_Numbers.Reduce;   -- refer to a private child{"\n"}package body Rational_Numbers is{"\n"}   ...{"\n"}end Rational_Numbers;{"\n"}
<MarginText>33</MarginText>
with Rational_Numbers.IO; use Rational_Numbers;{"\n"}with Ada.Text_io;               -- see <a href="../AA-A/AA-A.10">A.10</a>{"\n"}procedure Main is               -- a root library procedure{"\n"}   R : Rational;{"\n"}begin{"\n"}   R := 5/3;                    -- construct a rational number, see <a href="../AA-7/AA-7.1">7.1</a>{"\n"}   Ada.Text_IO.Put("The answer is: ");{"\n"}   IO.Put(R);{"\n"}   Ada.Text_IO.New_Line;{"\n"}end Main;{"\n"}
<MarginText>34</MarginText>
with Rational_Numbers.IO;{"\n"}package Rational_IO renames Rational_Numbers.IO;{"\n"}                                -- a library unit renaming declaration{"\n"}

</CodeBlock>
<MarginText>35</MarginText>
<p>Each of the above <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s can be submitted to the compiler separately. <br /></p>

<AnnotatedOnly>
<MarginText>35.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong><em>Example of a generic package with children:</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.b</MarginText>
<CodeBlock language="ada">
generic{"\n"}   type Element is private;{"\n"}   with function Image(E : Element) return String;{"\n"}package Generic_Bags is{"\n"}   type Bag is limited private; -- A bag of Elements.{"\n"}   procedure Add(B : in out Bag; E : Element);{"\n"}   function Bag_Image(B : Bag) return String;{"\n"}private{"\n"}   type Bag is ...;{"\n"}end Generic_Bags;{"\n"}
<MarginText>35.c</MarginText>
generic{"\n"}package Generic_Bags.Generic_Iterators is{"\n"}   ... -- various additional operations on Bags.{"\n"}
<MarginText>35.d</MarginText>
   generic{"\n"}      with procedure Use_Element(E : in Element);{"\n"}         -- Called once per bag element.{"\n"}   procedure Iterate(B : in Bag);{"\n"}end Generic_Bags.Generic_Iterators;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.e</MarginText>
<Admonition type="aarm" aarm="note">
A package that instantiates the above generic units: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.f</MarginText>
<CodeBlock language="ada">
with Generic_Bags;{"\n"}with Generic_Bags.Generic_Iterators;{"\n"}package My_Abstraction is{"\n"}    type My_Type is ...;{"\n"}    function Image(X : My_Type) return String;{"\n"}    package Bags_Of_My_Type is new Generic_Bags(My_Type, Image);{"\n"}    package Iterators_Of_Bags_Of_My_Type is new Bags_Of_My_Type.Generic_Iterators;{"\n"}end My_Abstraction;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.g</MarginText>
<Admonition type="aarm" aarm="note">
In the above example, Bags_Of_My_Type has a nested generic unit called Generic_Iterators. The second <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> makes that nested unit visible.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.h</MarginText>
<Admonition type="aarm" aarm="note">
Here we show how the generic body could depend on one of its own children: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.i</MarginText>
<CodeBlock language="ada">
with Generic_Bags.Generic_Iterators;{"\n"}package body Generic_Bags is{"\n"}   procedure Add(B : in out Bag; E : Element) is ... end Add;{"\n"}
<MarginText>35.j</MarginText>
   package Iters is new Generic_Iterators;{"\n"}
<MarginText>35.k</MarginText>
   function Bag_Image(B : Bag) return String is{"\n"}      Buffer : String(1..10_000);{"\n"}      Last : Integer := 0;{"\n"}
<MarginText>35.l</MarginText>
      procedure Append_Image(E : in Element) is{"\n"}         Im : constant String := Image(E);{"\n"}      begin{"\n"}         if Last /= 0 then -- Insert a comma.{"\n"}            Last := Last + 1;{"\n"}            Buffer(Last) := ',';{"\n"}         end if;{"\n"}         Buffer(Last+1 .. Last+Im'Length) := Im;{"\n"}         Last := Last + Im'Length;{"\n"}      end Append_Image;{"\n"}
<MarginText>35.m</MarginText>
      procedure Append_All is new Iters.Iterate(Append_Image);{"\n"}   begin{"\n"}      Append_All(B);{"\n"}      return Buffer(1..Last);{"\n"}   end Bag_Image;{"\n"}end Generic_Bags;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.n</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is modified to allow the reserved word <strong>private</strong> before a <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.o</MarginText>
<Admonition type="aarm" aarm="note">
Children (other than children of Standard) are new in Ada 95.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.p</MarginText>
<Admonition type="aarm" aarm="note">
Library unit renaming is new in Ada 95. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.q</MarginText>
<Admonition type="aarm" aarm="note">
Standard is considered a library unit in Ada 95. This simplifies the descriptions, since it implies that the parent of each library unit is a library unit. (Standard itself has no parent, of course.) As in Ada 83, the language does not define any way to recompile Standard, since the name given in the declaration of a library unit is always interpreted in relation to Standard. That is, an attempt to compile a package Standard would result in Standard.Standard. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.r/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
The concept of a limited view is new. Combined with <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>s (see <a href="../AA-10/AA-10.1#Subclause_10.1.2">10.1.2</a>), they facilitate construction of mutually recursive types in multiple packages. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.s/2</MarginText>
<MarginInfo items={["AI95-00331-01"]} />
<Admonition type="aarm" aarm="note">
Clarified the wording so that a grandchild generic unit will work as expected. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.t/3</MarginText>
<MarginInfo items={["AI05-0108-1", "AI05-0129-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified the wording so that it is clear that limited views of types never have discriminants and never are of incomplete types. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.2"></a>

## 10.1.2  Context Clauses - With Clauses

<MarginText>1</MarginText>
<p>[A <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is used to specify the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s whose names are needed within a compilation unit.] <br /></p>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="note">
The reader should be able to understand a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> without looking ahead. Similarly, when compiling a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, the compiler should not have to look ahead at subsequent <code><a href="../AA-10/AA-10.1#S0293">context_item</a></code>s, nor at the compilation unit to which the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is attached. (We have not completely achieved this.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
A <em>ripple effect</em> occurs when the legality of a compilation unit could be affected by adding or removing an otherwise unneeded <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> on some compilation unit on which the unit depends, directly or indirectly. We try to avoid ripple effects because they make understanding and maintenance more difficult. However, ripple effects can occur because of direct visibility (as in child units); this seems impossible to eliminate. The ripple effect for <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s is somewhat similar to the Beaujolais effect (see <a href="../AA-8/AA-8.4">8.4</a>) for <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s, which we also try to avoid. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>context_clause</code><a id="S0292"></a><code> ::= </code>{"{"}<code><a href="../AA-10/AA-10.1#S0293">context_item</a></code>{"}"}<br />

</CodeBlock>
<MarginText>3</MarginText>

<CodeBlock>
<code>context_item</code><a id="S0293"></a><code> ::= </code><code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> | <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code><br />

</CodeBlock>
<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00217-06", "AI95-00262-01"]} />

<CodeBlock>
<code>with_clause</code><a id="S0294"></a><code> ::= </code><code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> | <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code><br />

</CodeBlock>
<MarginText>4.1/2</MarginText>

<CodeBlock>
<code>limited_with_clause</code><a id="S0295"></a><code> ::= </code><strong>limited</strong> [<strong>private</strong>] <strong>with</strong> <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> {"{"}, <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"}"};<br />

</CodeBlock>
<MarginText>4.2/2</MarginText>

<CodeBlock>
<code>nonlimited_with_clause</code><a id="S0296"></a><code> ::= </code>[<strong>private</strong>] <strong>with</strong> <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> {"{"}, <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"}"};<br />

</CodeBlock>
<AnnotatedOnly>
<MarginText>4.a/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>A <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> makes a limited view of a unit visible.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<Admonition type="aarm" aarm="note">
A <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> containing the reserved word <strong>private</strong> is called a <em>private with_clause</em>. It can be thought of as making items visible only in the private part, although it really makes items visible everywhere except the visible part. It can be used both for documentation purposes (to say that a unit is not used in the visible part), and to allow access to private units that otherwise would be prohibited. <br /></Admonition>
</AnnotatedOnly>


#### Name Resolution Rules

<MarginText>5</MarginText>
<p>The <em>scope</em> of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that appears on a <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> or <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> consists of the entire declarative region of the declaration[, which includes all children and subunits]. The scope of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that appears on a body consists of the body[, which includes all subunits]. <br /></p>

<AnnotatedOnly>
<MarginText>5.a/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>Suppose a nonprivate  <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of a public library unit mentions one of its private siblings. (This is only allowed on the body of the public library unit.) We considered making the scope of that <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> not include the visible part of the public library unit. (This would only matter for a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>, since those are the only kinds of body that have a visible part, and only if the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> completes a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>, since otherwise the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> would be illegal.) We did not put in such a rule for two reasons: (1) It would complicate the wording of the rules, because we would have to split each <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> into pieces, in order to correctly handle &ldquo;<strong>with</strong> P, Q;&rdquo; where P is public and Q is private. (2) The conformance rules prevent any problems. It doesn't matter if a type name in the spec of the body denotes the completion of a <code><a href="../AA-7/AA-7.3#S0232">private_type_declaration</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b</MarginText>
<Admonition type="aarm" aarm="note">
A <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> also affects visibility within subsequent <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s and <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s of the same <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, even though those are not in the scope of the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> (and the corresponding library unit) is <em>named</em> in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> if it is denoted by a <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> in the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> (and the corresponding library unit) is <em>mentioned</em> in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> if it is named in the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> or if it is denoted by a <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> in the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong><code><a href="../AA-10/AA-10.1#S0294">With_clause</a></code>s control the visibility of declarations or renamings of library units. Mentioning a root library unit in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> makes its declaration directly visible. Mentioning a nonroot library unit makes its declaration visible. See Clause <a href="../AA-8/">8</a> for details.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.b/2</MarginText>
<MarginInfo items={["AI95-00114-01"]} />
<Admonition type="aarm" aarm="note">
Note that this rule implies that &ldquo;<strong>with</strong> A.B.C;&rdquo; is almost equivalent to &ldquo;<strong>with</strong> A, A.B, A.B.C;&rdquo;. The reason for making a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> apply to all the ancestor units is to avoid &ldquo;visibility holes&rdquo; &mdash; situations in which an inner program unit is visible while an outer one is not. Visibility holes would cause semantic complexity and implementation difficulty. (This is not exactly equivalent because the latter <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> names A and A.B, while the previous one does not. Whether a unit is &ldquo;named&rdquo; does not have any effect on visibility, however, so it is equivalent for visibility purposes.)<br /></Admonition>
</AnnotatedOnly>

<MarginText>7</MarginText>
<p>[Outside its own declarative region, the declaration or renaming of a library unit can be visible only within the scope of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that mentions it. The visibility of the declaration or renaming of a library unit otherwise follows from its placement in the environment.] <br /></p>


#### Legality Rules

<MarginText>8/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<p>If a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of a given <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> mentions a private child of some library unit, then the given <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> shall be one of: <br /></p>

<MarginText>9/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<ul>
<li>the declaration, body, or subunit of a private descendant of that library unit;<br /></li>
<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00220-01", "AI95-00262-01"]} />
<li>the body or subunit of a public descendant of that library unit, but not a subprogram body acting as a subprogram declaration (see <a href="../AA-10/AA-10.1#Subclause_10.1.4">10.1.4</a>); or<br /></li>
<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<li>the declaration of a public descendant of that library unit, in which case the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> shall include the reserved word <strong>private</strong>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>11.a/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The purpose of this rule is to prevent a private child from being visible from outside the subsystem rooted at its parent. A private child can be semantically depended-on without violating this principle if it is used in a private <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This rule violates the one-pass <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>s Language Design Principle. We rationalize this by saying that at least that Language Design Principle works for legal compilation units.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.c</MarginText>
<Admonition type="aarm" aarm="note">
Example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.d</MarginText>
<CodeBlock language="ada">
package A is{"\n"}end A;{"\n"}
<MarginText>11.e</MarginText>
package A.B is{"\n"}end A.B;{"\n"}
<MarginText>11.f</MarginText>
private package A.B.C is{"\n"}end A.B.C;{"\n"}
<MarginText>11.g</MarginText>
package A.B.C.D is{"\n"}end A.B.C.D;{"\n"}
<MarginText>11.h</MarginText>
with A.B.C; -- (1){"\n"}private package A.B.X is{"\n"}end A.B.X;{"\n"}
<MarginText>11.i</MarginText>
package A.B.Y is{"\n"}end A.B.Y;{"\n"}
<MarginText>11.j</MarginText>
with A.B.C; -- (2){"\n"}package body A.B.Y is{"\n"}end A.B.Y;{"\n"}
<MarginText>11.j.1/2</MarginText>
private with A.B.C; -- (3){"\n"}package A.B.Z is{"\n"}end A.B.Z;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.k/2</MarginText>
<MarginInfo items={["AI95-00262-01"]} />
<Admonition type="aarm" aarm="note">
(1) is OK because it's a private child of A.B &mdash; it would be illegal if we made A.B.X a public child of A.B. (2) is OK because it's the body of a child of A.B. (3) is OK because it's a child of A.B, and it is a private <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>. It would be illegal to say &ldquo;<strong>with</strong> A.B.C;&rdquo; on any <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> whose name does not start with &ldquo;A.B&rdquo;. Note that mentioning A.B.C.D in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> automatically mentions A.B.C as well, so &ldquo;<strong>with</strong> A.B.C.D;&rdquo; is illegal in the same places as &ldquo;<strong>with</strong> A.B.C;&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12/5</MarginText>
<MarginInfo items={["AI95-00262-01", "AI05-0005-1", "AI05-0077-1", "AI05-0122-1", "AI12-0261-1"]} />
<p>A <code><a href="../AA-4/AA-4.1#S0091">name</a></code> denoting a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> (or the corresponding declaration for a child of a generic within an instance &mdash; see <a href="../AA-10/AA-10.1#Subclause_10.1.1">10.1.1</a>), if it is visible only due to being mentioned in one or more <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s of a unit <em>U</em> that include the reserved word <strong>private</strong>, shall appear only within: <br /></p>

<MarginText>13/2</MarginText>
<ul>
<li>a private part;<br /></li>
<MarginText>14/5</MarginText>
<MarginInfo items={["AI12-0261-1"]} />
<li>a body of a public descendant of <em>U</em>, but not within the <code><a href="../AA-6/AA-6.1#S0196">subprogram_specification</a></code> of a  body of a subprogram that is a public descendant of <em>U</em>;<br /></li>
<MarginText>15/5</MarginText>
<MarginInfo items={["AI12-0261-1"]} />
<li>a private descendant of <em>U</em> or its body ; or<br /></li>
<MarginText>16/2</MarginText>
<li>a pragma within a context clause. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>16.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>These rules apply only if all of the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s that mention the name include the reserved word <strong>private</strong>. They do not apply if the name is mentioned in any <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> that does not include <strong>private</strong>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b/3</MarginText>
<MarginInfo items={["AI05-0077-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>These rules make the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> visible anywhere that is not visible outside the subsystem rooted at the <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> having the private <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>, including private parts of packages nested in the visible part, private parts of child packages, the visible part of private children, and context clause pragmas like Elaborate_All.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.c/2</MarginText>
<Admonition type="aarm" aarm="note">
We considered having the scope of a private <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> not include the visible part. However, that rule would mean that moving a declaration between the visible part and the private part could change its meaning from one legal interpretation to a different legal interpretation. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.d/2</MarginText>
<CodeBlock language="ada">
package A is{"\n"}    function B return Integer;{"\n"}end A;{"\n"}
<MarginText>16.e/2</MarginText>
function B return Integer;{"\n"}
<MarginText>16.f/2</MarginText>
with A;{"\n"}private with B;{"\n"}package C is{"\n"}    use A;{"\n"}    V1 : Integer := B; -- (1){"\n"}private{"\n"}    V2 : Integer := B; -- (2){"\n"}end C;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.g/2</MarginText>
<Admonition type="aarm" aarm="note">
If we say that library subprogram B is not in scope in the visible part of C, then the B at (1) resolves to A.B, while (2) resolves to library unit B. Simply moving a declaration could silently change its meaning. With the legality rule defined above, the B at (1) is illegal. If the user really meant A.B, they still can say that. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>[A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> shall be the implicit declaration of the limited view of a library package, not the declaration of a subprogram, generic unit, generic instance, or a renaming.]<br /></p>

<AnnotatedOnly>
<MarginText>17.a/2</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>This is redundant because only such implicit declarations are visible in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>. See <a href="../AA-10/AA-10.1#Subclause_10.1.6">10.1.6</a>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>18/2</MarginText>
<MarginInfo items={["AI95-00217-06", "AI95-00412-01"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> shall not appear on a <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code>, <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code>, or <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>18.a/2</MarginText>
<MarginInfo items={["AI95-00412-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We don't allow a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> on a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code> because it would be useless and therefore probably is a mistake. A renaming cannot appear in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> (by the rule prior to this one), and a renaming of a limited view cannot appear in a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code> (because the name would not be within the scope of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> denoting the package, see <a href="../AA-8/AA-8.5#Subclause_8.5.3">8.5.3</a>). Nor could it be the parent of another unit. That doesn't leave anywhere that the name of such a renaming <strong>could</strong> appear, so we simply make writing it illegal. <br /></Admonition>
</AnnotatedOnly>

<MarginText>19/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> that names a library package shall not appear:<br /></p>

<MarginText>20/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI05-0040-1"]} />
<ul>
<li>in the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> for the explicit declaration of the named library package or any of its descendants;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>20.a/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We have to explicitly disallow <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b/2</MarginText>
<CodeBlock language="ada">
limited with P;{"\n"}package P is ...{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>20.c/2</MarginText>
<Admonition type="aarm" aarm="note">
as we can't depend on the semantic dependence rules to do it for us as with regular withs. This says &ldquo;named&rdquo; and not &ldquo;mentioned&rdquo; in order that <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.d/2</MarginText>
<CodeBlock language="ada">
limited private with P.Child;{"\n"}package P is ...{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>20.e/2</MarginText>
<Admonition type="aarm" aarm="note">
can be used to allow a mutual dependence between the private part of P and the private child P.Child, which occurs in interfacing and other problems. Since the child always semantically depends on the parent, this is the only way such a dependence can be broken.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.f/3</MarginText>
<MarginInfo items={["AI05-0040-1"]} />
<Admonition type="aarm" aarm="note">
The part about descendants catches examples like <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.g/3</MarginText>
<CodeBlock language="ada">
limited with P;{"\n"}package P.Child is ...{"\n"}

</CodeBlock>
</AnnotatedOnly>
<MarginText>21/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI05-0077-1", "AI05-0262-1"]} />
<ul>
<li>within a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> for a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> that is within the scope of a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code> that mentions the same library package; or<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>21.a.1/3</MarginText>
<MarginInfo items={["AI05-0077-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This applies to <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>s found in the same <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, as well as <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>s found on parent units. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.a/3</MarginText>
<MarginInfo items={["AI05-0077-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>Such a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> could have no effect, and would be confusing. If a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code> for the same package is inherited from a parent unit or given in the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, the full view is available, which strictly provides more information than the limited view. <br /></Admonition>
</AnnotatedOnly>

<MarginText>22/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI05-0077-1", "AI05-0262-1"]} />
<ul>
<li>within a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> for a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> that is within the scope of a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code> that names an entity declared within the declarative region of the library package.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.a.1/3</MarginText>
<MarginInfo items={["AI05-0077-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This applies to <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s found in the same <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, as well as <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s found in (or on) parent units. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>22.a/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This prevents visibility issues, where whether an entity is an incomplete or full view depends on how the name of the entity is written. The <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> cannot be useful, as we must have the full view available in the parent in order for the <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code> to be legal. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
NOTE   A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> mentioned in a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code> of a compilation unit is visible within the compilation unit and hence acts just like an ordinary declaration. Thus, within a compilation unit that mentions its declaration, the name of a library package can be given in <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s and can be used to form expanded names, a library subprogram can be called, and instances of a generic library unit can be declared. If a child of a parent generic package is mentioned in a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>, then the corresponding declaration nested within each visible instance is visible within the compilation unit. Similarly, a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> of a compilation unit is visible within the compilation unit and thus can be used to form expanded names.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The rules given for <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s are such that the same effect is obtained whether the name of a library unit is mentioned once or more than once by the applicable <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s, or even within a given <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.b</MarginText>
<Admonition type="aarm" aarm="note">
If a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> mentions a <code><a href="../AA-10/AA-10.1#S0289">library_unit_renaming_declaration</a></code>, it only &ldquo;mentions&rdquo; the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code>es appearing explicitly in the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> (and the renamed view itself); the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> is not defined to mention the ancestors of the renamed entity. Thus, if X renames Y.Z, then &ldquo;with X;&rdquo; does not make the declarations of Y or Z visible. Note that this does not cause the dreaded visibility holes mentioned above. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>24/5</MarginText>
<MarginInfo items={["AI12-0429-1"]} />
<p><em>Examples of use of with clauses, limited with clauses, and private with clauses:</em> <br /></p>

<MarginText>25/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
<CodeBlock language="ada">
package Office is{"\n"}end Office;{"\n"}
<MarginText>26/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
with Ada.Strings.Unbounded;{"\n"}package Office.Locations is{"\n"}   type Location is new Ada.Strings.Unbounded.Unbounded_String;{"\n"}end Office.Locations;{"\n"}
<MarginText>27/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
limited with Office.Departments;  -- types are incomplete{"\n"}private with Office.Locations;    -- only visible in private part{"\n"}package Office.Employees is{"\n"}   type Employee is private;{"\n"}
<MarginText>28/2</MarginText>
   function Dept_Of(Emp : Employee) return access Departments.Department;{"\n"}   procedure Assign_Dept(Emp  : in out Employee;{"\n"}                         Dept : access Departments.Department);{"\n"}
<MarginText>29/2</MarginText>
   ...{"\n"}private{"\n"}   type Employee is{"\n"}      record{"\n"}         Dept : access Departments.Department;{"\n"}         Loc : Locations.Location;{"\n"}         ...{"\n"}      end record;{"\n"}end Office.Employees;{"\n"}
<MarginText>30/5</MarginText>
<MarginInfo items={["AI12-0178-1"]} />
limited with Office.Employees;{"\n"}package Office.Departments is{"\n"}   type Department is ... ;{"\n"}
<MarginText>31/2</MarginText>
   function Manager_Of(Dept : Department) return access Employees.Employee;{"\n"}   procedure Assign_Manager(Dept : in out Department;{"\n"}                            Mgr  : access Employees.Employee);{"\n"}   ...{"\n"}end Office.Departments;{"\n"}

</CodeBlock>
<MarginText>32/5</MarginText>
<MarginInfo items={["AI95-00433-01", "AI12-0429-1", "AI12-0440-1"]} />
<p><em>The</em> <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> <em>can be used to support mutually dependent abstractions that are split across multiple packages. In this case, an employee is assigned to a department, and a department has a manager who is an employee. If a</em> <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> <em>with the reserved word <strong>private</strong> appears on one library unit and mentions a second library unit, it provides visibility to the second library unit, but restricts that visibility to the private part and body of the first unit. The compiler checks that no use is made of the second unit in the visible part of the first unit.</em>  <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.a</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> is modified to allow expanded name notation.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.b</MarginText>
<Admonition type="aarm" aarm="note">
A <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code> in a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> may be for a package (or type) nested in a library package. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.c</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is modified to more closely reflect the semantics. The Ada 83 syntax rule implies that the <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s that appear immediately after a particular <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> are somehow attached to that <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>, which is not true. The new syntax allows a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code> to appear first, but that is prevented by a textual rule that already exists in Ada 83.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.d</MarginText>
<Admonition type="aarm" aarm="note">
The concept of &ldquo;scope of a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>&rdquo; (which is a region of text) replaces RM83's notion of &ldquo;apply to&rdquo; (a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> applies to a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>) The visibility rules are interested in a region of text, not in a set of compilation units.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.e</MarginText>
<Admonition type="aarm" aarm="note">
No need to define &ldquo;apply to&rdquo; for <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s. Their semantics are fully covered by the &ldquo;scope (of a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>)&rdquo; definition in <a href="../AA-8/AA-8.4">8.4</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.f/2</MarginText>
<MarginInfo items={["AI95-00220-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> A subprogram body acting as a declaration cannot <strong>with</strong> a private child unit. This would allow public export of types declared in private child packages, and thus cannot be allowed. This was allowed by mistake in Ada 95; a subprogram that does this will now be illegal. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.g/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
<code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>s are new. They make a limited view of a package visible, where all of the types in the package are incomplete. They facilitate construction of mutually recursive types in multiple packages.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.h/3</MarginText>
<MarginInfo items={["AI95-00262-01", "AI05-0077-1"]} />
<Admonition type="aarm" aarm="note">
The syntax rules for <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> are modified to allow the reserved word <strong>private</strong>. Private <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s do not allow the use of their <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> in the visible part of their <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>. They also allow using private units in more locations than in Ada 95. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.i/3</MarginText>
<MarginInfo items={["AI05-0040-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added missing rule that a limited with clause cannot name an ancestor unit. This is incompatible if an Ada 2005 program does this, but as this is a new Ada 2005 feature and the unintentionally allowed capability is not useful, the incompatibility is very unlikely to occur in practice. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.j/3</MarginText>
<MarginInfo items={["AI05-0077-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Fixed wording so that we are not checking whether something in a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is &ldquo;within the scope of&rdquo; something, as <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>s are never included in anything's scope. The intended meaning is unchanged, however.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.k/3</MarginText>
<MarginInfo items={["AI05-0122-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Fixed wording so the rules for private with clauses also apply to "sprouted" generic child units. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.l/5</MarginText>
<MarginInfo items={["AI12-0261-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Fixed wording so the privately withed units are visible in the subprogram specification of the body of a private descendant; otherwise, the private specification is legal but the completion is not. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.3"></a>

## 10.1.3  Subunits of Compilation Units

<MarginText>1</MarginText>
<p>[Subunits are like child units, with these (important) differences: subunits support the separate compilation of bodies only (not declarations); the parent contains a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> to indicate the existence and place of each of its subunits; declarations appearing in the parent's body can be visible within the subunits.] <br /></p>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>body_stub</code><a id="S0297"></a><code> ::= </code><br />    <code><a href="../AA-10/AA-10.1#S0298">subprogram_body_stub</a></code> | <code><a href="../AA-10/AA-10.1#S0299">package_body_stub</a></code><br />  | <code><a href="../AA-10/AA-10.1#S0300">task_body_stub</a></code> | <code><a href="../AA-10/AA-10.1#S0301">protected_body_stub</a></code><br />

</CodeBlock>
<MarginText>3/3</MarginText>
<MarginInfo items={["AI95-00218-03", "AI05-0267-1"]} />

<CodeBlock>
<code>subprogram_body_stub</code><a id="S0298"></a><code> ::= </code><br />    [<code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code>]<br />    <code><a href="../AA-6/AA-6.1#S0196">subprogram_specification</a></code> <strong>is</strong> <strong>separate</strong><br />       [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Although this syntax allows a <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>, that is disallowed by <a href="../AA-10/AA-10.1#Subclause_10.1.1">10.1.1</a>, &ldquo;<a href="../AA-10/AA-10.1#Subclause_10.1.1">Compilation Units - Library Units</a>&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4/3</MarginText>
<MarginInfo items={["AI05-0267-1"]} />

<CodeBlock>
<code>package_body_stub</code><a id="S0299"></a><code> ::= </code><br />   <strong>package</strong> <strong>body</strong> <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> <strong>is</strong> <strong>separate</strong><br />      [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<MarginText>5/3</MarginText>
<MarginInfo items={["AI05-0267-1"]} />

<CodeBlock>
<code>task_body_stub</code><a id="S0300"></a><code> ::= </code><br />   <strong>task</strong> <strong>body</strong> <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> <strong>is</strong> <strong>separate</strong><br />      [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<MarginText>6/3</MarginText>
<MarginInfo items={["AI05-0267-1"]} />

<CodeBlock>
<code>protected_body_stub</code><a id="S0301"></a><code> ::= </code><br />   <strong>protected</strong> <strong>body</strong> <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> <strong>is</strong> <strong>separate</strong><br />      [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<MarginText>7</MarginText>

<CodeBlock>
<code>subunit</code><a id="S0302"></a><code> ::= </code><strong>separate</strong> (<code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>) <code><a href="../AA-3/AA-3.11#S0090">proper_body</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>8/2</MarginText>
<MarginInfo items={["AI95-00243-01"]} />
<p>The <em>parent body</em> of a subunit is the body of the program unit denoted by its <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>. The term <em>subunit</em> is used to refer to a <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code> and also to the <code><a href="../AA-3/AA-3.11#S0090">proper_body</a></code> of a <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code>. The <em>subunits of a program unit</em> include any subunit that names that program unit as its parent, as well as any subunit that names such a subunit as its parent (recursively). <br /></p>

<AnnotatedOnly>
<MarginText>8.a.1/2</MarginText>
<MarginInfo items={["AI95-00243-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We want any rule that applies to a subunit to apply to a subunit of a subunit as well. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>subunit</strong> &mdash; body of a program unit that can be compiled separately from its enclosing program unit<br /></Admonition>
</AnnotatedOnly>

<MarginText>9</MarginText>
<p>The parent body of a subunit shall be present in the current environment, and shall contain a corresponding <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as the subunit. <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This can't be a Name Resolution Rule, because a <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code> is not a complete context. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10/3</MarginText>
<MarginInfo items={["AI05-0004-1"]} />
<p>A <code><a href="../AA-10/AA-10.1#S0299">package_body_stub</a></code> shall be the completion of a <code><a href="../AA-7/AA-7.1#S0229">package_declaration</a></code> or <code><a href="../AA-12/AA-12.1#S0312">generic_package_declaration</a></code>; a <code><a href="../AA-10/AA-10.1#S0300">task_body_stub</a></code> shall be the completion of a task declaration; a <code><a href="../AA-10/AA-10.1#S0301">protected_body_stub</a></code> shall be the completion of a protected declaration.<br /></p>

<MarginText>11/5</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>In contrast, a <code><a href="../AA-10/AA-10.1#S0298">subprogram_body_stub</a></code> can be defined without it being  the completion of a previous declaration, [in which case the <code>_stub</code> declares the subprogram]. If the <code>_stub</code> is a completion, it shall be the completion of a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code> or <code><a href="../AA-12/AA-12.1#S0311">generic_subprogram_declaration</a></code>. The profile of a <code><a href="../AA-10/AA-10.1#S0298">subprogram_body_stub</a></code> that completes a declaration shall conform fully to that of the declaration. <br /></p>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The part about <code><a href="../AA-10/AA-10.1#S0298">subprogram_body_stub</a></code>s echoes the corresponding rule for <code>subprogram_bodies</code> in <a href="../AA-6/AA-6.3">6.3</a>, &ldquo;<a href="../AA-6/AA-6.3">Subprogram Bodies</a>&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12</MarginText>
<p>A subunit that corresponds to a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> shall be of the same kind (<code>package_</code>, <code>subprogram_</code>, <code>task_</code>, or <code>protected_</code>) as the <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>. The profile of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> subunit shall be fully conformant to that of the corresponding <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>. <br /></p>

<MarginText>13</MarginText>
<p>A <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> shall appear immediately within the <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> of a compilation unit body. This rule does not apply within an instance of a generic unit. <br /></p>

<AnnotatedOnly>
<MarginText>13.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This is a methodological restriction; that is, it is not necessary for the semantics of the language to make sense. <br /></Admonition>
</AnnotatedOnly>

<MarginText>14</MarginText>
<p>The <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>s of all <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>s that appear immediately within a particular <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> shall be distinct. <br /></p>


#### Post-Compilation Rules

<MarginText>15</MarginText>
<p>For each <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>, there shall be a subunit containing the corresponding <code><a href="../AA-3/AA-3.11#S0090">proper_body</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>16</MarginText>
<Admonition type="aarm" aarm="note">
NOTE   The rules in <a href="../AA-10/AA-10.1#Subclause_10.1.4">10.1.4</a>, &ldquo;<a href="../AA-10/AA-10.1#Subclause_10.1.4">The Compilation Process</a>&rdquo; say that a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> is equivalent to the corresponding <code><a href="../AA-3/AA-3.11#S0090">proper_body</a></code>. This implies: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17</MarginText>
<ul>
<li>Visibility within a subunit is the visibility that would be obtained at the place of the corresponding <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> (within the parent body) if the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> of the subunit were appended to that of the parent body. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Recursively. Note that this transformation might make the parent illegal; hence it is not a true equivalence, but applies only to visibility within the subunit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18</MarginText>
<ul>
<li>The effect of the elaboration of a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> is to elaborate the subunit. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>18.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The elaboration of a subunit is part of its parent body's elaboration, whereas the elaboration of a child unit is not part of its parent declaration's elaboration. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> that is mentioned in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of a subunit can be hidden (from direct visibility) by a declaration (with the same <code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>) given in the subunit. Moreover, such a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> can even be hidden by a declaration given within the parent body since a library unit is declared in its parent's declarative region; this however does not affect the interpretation of the <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s themselves, since only <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s are visible or directly visible in <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.c</MarginText>
<Admonition type="aarm" aarm="note">
The body of a protected operation cannot be a subunit. This follows from the syntax rules. The body of a protected unit can be a subunit. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>19/5</MarginText>
<MarginInfo items={["AI12-0429-1"]} />
<p><em>Example that defines package Parent without subunits:</em>  <br /></p>

<MarginText>20</MarginText>
<CodeBlock language="ada">
package Parent is{"\n"}    procedure Inner;{"\n"}end Parent;{"\n"}
<MarginText>21</MarginText>
with Ada.Text_IO;{"\n"}package body Parent is{"\n"}    Variable : String := "Hello, there.";{"\n"}    procedure Inner is{"\n"}    begin{"\n"}        Ada.Text_IO.Put_Line(Variable);{"\n"}    end Inner;{"\n"}end Parent;{"\n"}

</CodeBlock>
<MarginText>22/5</MarginText>
<MarginInfo items={["AI12-0429-1", "AI12-0440-1"]} />
<p><em>Example showing how the body of procedure Inner can be turned into a subunit by rewriting the package body as follows (with the declaration of Parent remaining the same):</em>  <br /></p>

<MarginText>23</MarginText>
<CodeBlock language="ada">
package body Parent is{"\n"}    Variable : String := "Hello, there.";{"\n"}    procedure Inner is separate;{"\n"}end Parent;{"\n"}
<MarginText>24</MarginText>
with Ada.Text_IO;{"\n"}separate(Parent){"\n"}procedure Inner is{"\n"}begin{"\n"}    Ada.Text_IO.Put_Line(Variable);{"\n"}end Inner;{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="note">
Subunits of the same ancestor library unit are no longer restricted to have distinct identifiers. Instead, we require only that the full expanded names be distinct. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.b/2</MarginText>
<MarginInfo items={["AI95-00218-03"]} />
<Admonition type="aarm" aarm="note">
An <code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code> (see <a href="../AA-8/AA-8.3#Subclause_8.3.1">8.3.1</a>) is allowed on a subprogram stub. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.c/2</MarginText>
<MarginInfo items={["AI95-00243-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that a subunit of a subunit is still a subunit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.d/3</MarginText>
<MarginInfo items={["AI05-0267-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>. This is described in <a href="../AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.4"></a>

## 10.1.4  The Compilation Process

<MarginText>1</MarginText>
<p>Each compilation unit submitted to the compiler is compiled in the context of an <em>environment</em> <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> (or simply, an <em>environment</em>), which is a conceptual <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> that forms the outermost declarative region of the context of any <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>. At run time, an environment forms the <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> of the body of the environment task of a partition (see <a href="../AA-10/AA-10.2">10.2</a>, &ldquo;<a href="../AA-10/AA-10.2">Program Execution</a>&rdquo;). <br /></p>

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>At compile time, there is no particular construct that the declarative region is considered to be nested within &mdash; the environment is the universe. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>The environment is really just a portion of a <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code>, since there might, for example, be bodies that do not yet exist. <br /></Admonition>
</AnnotatedOnly>

<MarginText>2/5</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<p>The <code><a href="../AA-3/AA-3.11#S0087">declarative_item</a></code>s of the environment are <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s appearing in an order such that there are no forward semantic dependences. Each included subunit occurs in place of the corresponding stub. The visibility rules apply as if the environment were the outermost declarative region, except that <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s are necessary  to make declarations of library units visible (see <a href="../AA-10/AA-10.1#Subclause_10.1.2">10.1.2</a>).<br /></p>

<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>The mechanisms for creating an environment and for adding and replacing compilation units within an environment are implementation defined. The mechanisms for adding a compilation unit mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> to an environment are implementation defined. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The mechanisms for creating an environment and for adding and replacing compilation units.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.a.1/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The mechanisms for adding a compilation unit mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> to an environment.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The traditional model, used by most Ada 83 implementations, is that one places a compilation unit in the environment by compiling it. Other models are possible. For example, an implementation might define the environment to be a directory; that is, the compilation units in the environment are all the compilation units in the source files contained in the directory. In this model, the mechanism for replacing a compilation unit with a new one is simply to edit the source file containing that compilation unit. <br /></Admonition>
</AnnotatedOnly>


#### Name Resolution Rules

<MarginText>4/3</MarginText>
<MarginInfo items={["AI95-00192-01", "AI05-0264-1"]} />
<p>{"{"}<em>8652/0032</em>{"}"} If a <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> that is a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is submitted to the compiler, it is interpreted only as a completion if a <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> with the same <code><a href="../AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> already exists in the environment for a subprogram other than an instance of a generic subprogram or for a generic subprogram (even if the profile of the body is not type conformant with that of the declaration); otherwise, the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is interpreted as both the declaration and body of a library subprogram. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The principle here is that a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> should be interpreted as only a completion if and only if it &ldquo;might&rdquo; be legal as the completion of some preexisting declaration, where &ldquo;might&rdquo; is defined in a way that does not require overload resolution to determine.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b</MarginText>
<Admonition type="aarm" aarm="note">
Hence, if the preexisting declaration is a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code> or <code><a href="../AA-12/AA-12.1#S0311">generic_subprogram_declaration</a></code>, we treat the new <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> as its completion, because it &ldquo;might&rdquo; be legal. If it turns out that the profiles don't fully conform, it's an error. In all other cases (the preexisting declaration is a package or a generic package, or an instance of a generic subprogram, or a renaming, or a &ldquo;spec-less&rdquo; subprogram, or in the case where there is no preexisting thing), the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> declares a new subprogram.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.c</MarginText>
<Admonition type="aarm" aarm="note">
See also AI83-00266/09. <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>5</MarginText>
<p>When a compilation unit is compiled, all compilation units upon which it depends semantically shall already exist in the environment; the set of these compilation units shall be <em>consistent</em> in the sense that the new compilation unit shall not semantically depend (directly or indirectly) on two different versions of the same compilation unit, nor on an earlier version of itself. <br /></p>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For example, if package declarations A and B both say &ldquo;<strong>with</strong> X;&rdquo;, and the user compiles a compilation unit that says &ldquo;<strong>with</strong> A, B;&rdquo;, then the A and B have to be talking about the same version of X. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>What it means to be a &ldquo;different version&rdquo; is not specified by the language. In some implementations, it means that the compilation unit has been recompiled. In others, it means that the source of the compilation unit has been edited in some significant way.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.c</MarginText>
<Admonition type="aarm" aarm="note">
Note that an implementation cannot require the existence of compilation units upon which the given one does not semantically depend. For example, an implementation is required to be able to compile a compilation unit that says "<strong>with</strong> A;" when A's body does not exist. It has to be able to detect errors without looking at A's body.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.d/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
Similarly, the implementation has to be able to compile a call to a subprogram for which aspect Inline has been specified without seeing the body of that subprogram &mdash; inlining would not be achieved in this case, but the call is still legal.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.e/3</MarginText>
<MarginInfo items={["AI95-00217-06", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
The consistency rule applies to limited views as well as the full view of a compilation unit. That means that an implementation needs a way to enforce consistency of limited views, not just of full views. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<p>The implementation may require that a compilation unit be legal before it can be mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> or it can be inserted into the environment.<br /></p>

<MarginText>7/3</MarginText>
<MarginInfo items={["AI95-00214-01", "AI05-0229-1"]} />
<p>When a compilation unit that declares or renames a library unit is added to the environment, the implementation may remove from the environment any preexisting <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code> with the same full expanded name. When a compilation unit that is a subunit or the body of a library unit is added to the environment, the implementation may remove from the environment any preexisting version of the same compilation unit. When a compilation unit that contains a <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> is added to the environment, the implementation may remove any preexisting <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or <code><a href="../AA-10/AA-10.1#S0302">subunit</a></code> with the same full expanded name as the <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code>. When a given compilation unit is removed from the environment, the implementation may also remove any compilation unit that depends semantically upon the given one. If the given compilation unit contains the body of a subprogram for which aspect Inline is True, the implementation may also remove any compilation unit containing a call to that subprogram. <br /></p>

<AnnotatedOnly>
<MarginText>7.a/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The permissions given in this paragraph correspond to the traditional model, where compilation units enter the environment by being compiled into it, and the compiler checks their legality at that time. An implementation model in which the environment consists of all source files in a given directory might not want to take advantage of these permissions. Compilation units would not be checked for legality as soon as they enter the environment; legality checking would happen later, when compilation units are compiled. In this model, compilation units might never be automatically removed from the environment; they would be removed when the user explicitly deletes a source file.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that the rule is recursive: if the above permission is used to remove a compilation unit containing an inlined subprogram call, then compilation units that depend semantically upon the removed one may also be removed, and so on.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.c</MarginText>
<Admonition type="aarm" aarm="note">
Note that here we are talking about dependences among existing compilation units in the environment; it doesn't matter what <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>s are attached to the new compilation unit that triggered all this.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.d/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
An implementation may have other modes in which compilation units in addition to the ones mentioned above are removed. For example, an implementation might inline subprogram calls without an explicit aspect Inline. If so, it either has to have a mode in which that optimization is turned off, or it has to automatically regenerate code for the inlined calls without requiring the user to resubmit them to the compiler. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.d.1/2</MarginText>
<MarginInfo items={["AI95-00077-01", "AI95-00114-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>{"{"}<em>8652/0108</em>{"}"} In the standard mode, implementations may only remove units from the environment for one of the reasons listed here, or in response to an explicit user command to modify the environment. It is not intended that the act of compiling a unit is one of the &ldquo;mechanisms&rdquo; for removing units other than those specified by this document.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.e/2</MarginText>
<MarginInfo items={["AI95-00214-01"]} />
<Admonition type="aarm" aarm="note">
These rules are intended to ensure that an implementation never need keep more than one compilation unit with any full expanded name. In particular, it is not necessary to be able to have a subunit and a child unit with the same name in the environment at one time.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   The rules of the language are enforced across <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code> and compilation unit boundaries, just as they are enforced within a single compilation unit. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.a/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that Clause <a href="../AA-1/">1</a> requires an implementation to detect illegal compilation units at compile time. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   An implementation can  support a concept of a <em>library</em>, which contains <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s. If multiple libraries are supported, the implementation can document  how a single environment is constructed when a compilation unit is submitted to the compiler. Naming conflicts between different libraries can, for example,  be resolved by treating each library as the root of a hierarchy of child library units. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Alternatively, naming conflicts could be resolved via some sort of hiding rule. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For example, the implementation might support a command to import library Y into library X. If a root library unit called LU (that is, Standard.LU) exists in Y, then from the point of view of library X, it could be called Y.LU. X might contain library units that say, &ldquo;<strong>with</strong> Y.LU;&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   A compilation unit containing an instantiation of a separately compiled generic unit does not semantically depend on the body of the generic unit. Therefore, replacing the generic body in the environment does not result in the removal of the compilation unit containing the instantiation. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Therefore, implementations have to be prepared to automatically instantiate generic bodies at link-time, as needed. This might imply a complete automatic recompilation, but it is the intent of the language that generic bodies can be (re)instantiated without forcing all of the compilation units that semantically depend on the compilation unit containing the instantiation to be recompiled. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.b/2</MarginText>
<MarginInfo items={["AI95-00077-01", "AI95-00114-01"]} />
<Admonition type="aarm" aarm="note">
Ada 83 allowed implementations to require that the body of a generic unit be available when the instantiation is compiled; that permission is dropped in Ada 95. This isn't really an extension (it doesn't allow Ada users to write anything that they couldn't in Ada 83), but there isn't a more appropriate category, and it does allow users more flexibility when developing programs. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.c/2</MarginText>
<MarginInfo items={["AI95-00192-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0032</em>{"}"} <strong>Corrigendum:</strong> The wording was clarified to ensure that a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is not considered a completion of an instance of a generic subprogram.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.d/2</MarginText>
<MarginInfo items={["AI95-00214-01"]} />
<Admonition type="aarm" aarm="note">
The permissions to remove a unit from the environment were clarified to ensure that it is never necessary to keep multiple (sub)units with the same full expanded name in the environment.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.e/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
Units mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> were added to several rules; limited views have the same presence in the environment as the corresponding full views. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.5"></a>

## 10.1.5  Pragmas and Program Units

<MarginText>1/5</MarginText>
<MarginInfo items={["AI12-0417-1"]} />
<p>[This subclause discusses pragmas related to  <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>s.] <br /></p>


#### Name Resolution Rules

<MarginText>2/5</MarginText>
<MarginInfo items={["AI12-0417-1"]} />
<p> <br /></p>

<AnnotatedOnly>
<MarginText>2.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong> <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>3/5</MarginText>
<MarginInfo items={["AI12-0417-1"]} />
<p> <br /></p>

<MarginText>4/5</MarginText>
<ul>
<li> <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>4.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong> <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/5</MarginText>
<MarginInfo items={["AI95-00136-01"]} />
<ul>
<li>{"{"}<em>8652/0033</em>{"}"}  <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>5.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong> <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/5</MarginText>
<ul>
<li> <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>6.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong> <br /></Admonition>
</AnnotatedOnly>

<MarginText>7/5</MarginText>
<MarginInfo items={["AI05-0132-1", "AI12-0417-1"]} />
<p> <br /></p>

<AnnotatedOnly>
<MarginText>7.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong> <br /></Admonition>
</AnnotatedOnly>

<p><em>Paragraphs 2 through 7 were moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo;.</em> <br /></p>


#### Static Semantics

<MarginText>7.1/5</MarginText>
<MarginInfo items={["AI95-00041-01", "AI12-0417-1"]} />
<p>{"{"}<em>8652/0034</em>{"}"}  <br /></p>


#### Post-Compilation Rules

<MarginText>8</MarginText>
<p>Certain <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s are defined to be <em>configuration pragmas</em>; they shall appear before the first <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> of a <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>. [They are generally used to select a partition-wide or system-wide option.] The <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> applies to all <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>s appearing in the <code><a href="../AA-10/AA-10.1#S0285">compilation</a></code>, unless there are none, in which case it applies to all future <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code>s compiled into the same environment. <br /></p>


#### Implementation Permissions

<MarginText>9/2</MarginText>
<MarginInfo items={["AI95-00212-01"]} />
<p>An implementation may require that configuration pragmas that select partition-wide or system-wide options be compiled when the environment contains no <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s other than those of the predefined environment. In this case, the implementation shall still accept configuration pragmas in individual compilations that confirm the initially selected partition-wide or system-wide options.<br /></p>


#### Implementation Advice

<MarginText>10/5</MarginText>
<MarginInfo items={["AI95-00041-01", "AI12-0417-1"]} />
<p>{"{"}<em>8652/0034</em>{"}"}  <br /></p>

<AnnotatedOnly>
<MarginText>10.a/5</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<em>This paragraph was deleted.</em><strong></strong> <br /></Admonition>
</AnnotatedOnly>

<p><em>Paragraph 10 was moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo;.</em> <br /></p>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.b/5</MarginText>
<MarginInfo items={["AI95-00136-01", "AI12-0417-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em>{"{"}<em>8652/0033</em>{"}"}  <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.c/5</MarginText>
<MarginInfo items={["AI95-00041-01", "AI12-0417-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em>{"{"}<em>8652/0034</em>{"}"}  <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.d/5</MarginText>
<MarginInfo items={["AI12-0417-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em> <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.e/2</MarginText>
<MarginInfo items={["AI95-00212-01"]} />
<Admonition type="aarm" aarm="note">
The permission to place restrictions was clarified to: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.f/2</MarginText>
<ul>
<li>Ensure that it applies only to partition-wide configuration pragmas, not ones like Assertion_Policy (see <a href="../AA-11/AA-11.4#Subclause_11.4.2">11.4.2</a>), which can be different in different units; and<br /></li>
<MarginText>10.g/2</MarginText>
<li>Ensure that confirming pragmas are always allowed. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.h/5</MarginText>
<MarginInfo items={["AI05-0132-1", "AI12-0417-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em> <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.i/5</MarginText>
<MarginInfo items={["AI12-0417-1"]} />
<Admonition type="aarm" aarm="note">
The terms &ldquo;program unit pragma&rdquo; and &ldquo;library unit pragma&rdquo; were moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo; (specifically to <a href="../AA-J/AA-J.15">J.15</a>) as all of the <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s that use these terms are now in that annex. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_10.1.6"></a>

## 10.1.6  Environment-Level Visibility Rules

<MarginText>1</MarginText>
<p>[The normal visibility rules do not apply within a <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> or a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, nor within a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> that appears at the place of a compilation unit. The special visibility rules for those contexts are given here.] <br /></p>


#### Static Semantics

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00217-06", "AI95-00312-01"]} />
<p>Within the <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> at the beginning of an explicit <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>, and within a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>, the only declarations that are visible are those that are explicit <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s of the environment, and the only declarations that are directly visible are those that are explicit root <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s of the environment. Within a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>, the only declarations that are visible are those that are the implicit declaration of the limited view of a library package of the environment, and the only declarations that are directly visible are those that are the implicit declaration of the limited view of a root library package.<br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>In &ldquo;<strong>package</strong> P.Q.R <strong>is</strong> ... <strong>end</strong> P.Q.R;&rdquo;, this rule requires P to be a root library unit, and Q to be a library unit (because those are the things that are directly visible and visible). Note that visibility does not apply between the &ldquo;<strong>end</strong>&rdquo; and the &ldquo;;&rdquo;.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b</MarginText>
<Admonition type="aarm" aarm="note">
Physically nested declarations are not visible at these places.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.c</MarginText>
<Admonition type="aarm" aarm="note">
Although Standard is visible at these places, it is impossible to name it, since it is not directly visible, and it has no parent.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.c.1/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
Only compilation units defining limited views can be mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>, while only compilation units defining full views (that is, the explicit declarations) can be mentioned in a <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>. This resolves the conflict inherent in having two compilation units with the same defining name. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.d/2</MarginText>
<MarginInfo items={["AI95-00312-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<MarginText>3</MarginText>
<p>Within a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code> or <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> that is within a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, each <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> mentioned in a previous <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of the same <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is visible, and each root <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> so mentioned is directly visible. In addition, within such a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, if a given declaration is visible or directly visible, each declaration that occurs immediately within the given declaration's visible part is also visible. No other declarations are visible or directly visible. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Note the word &ldquo;same&rdquo;. For example, if a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> on a declaration mentions X, this does not make X visible in <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s and <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s that are on the body. The reason for this rule is the one-pass <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>s Language Design Principle.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that the second part of the rule does not mention <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4</MarginText>
<p>Within the <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> of a subunit, <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s are visible as they are in the <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>; in addition, the declaration corresponding to each <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> in the environment is also visible. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>For a subprogram without a separate <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>, the <code><a href="../AA-10/AA-10.1#S0297">body_stub</a></code> itself is the declaration. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5</MarginText>
<p>Within a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> that appears at the place of a compilation unit, the immediately preceding <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> and each of its ancestors is visible. The ancestor root <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> is directly visible.<br /></p>

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00312-01"]} />
<p>Notwithstanding the rules of <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>, an expanded name in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>, a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> in a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, or a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> that appears at the place of a compilation unit may consist of a <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> that denotes a generic package and a <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> that denotes a child of that generic package. [(The child is necessarily a generic unit; see <a href="../AA-10/AA-10.1#Subclause_10.1.1">10.1.1</a>.)] <br /></p>

<AnnotatedOnly>
<MarginText>6.a/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule allows <strong>with</strong> A.B; and <strong>pragma</strong> Elaborate(A.B); where A is a generic library package and B is one of its (generic) children. This is necessary because it is not normally legal to use an expanded name to reach inside a generic package. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>6.b</MarginText>
<Admonition type="aarm" aarm="note">
The special visibility rules that apply within a <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code> or a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>, and within a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> that appears at the place of a <code><a href="../AA-10/AA-10.1#S0286">compilation_unit</a></code> are clarified.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.c</MarginText>
<Admonition type="aarm" aarm="note">
Note that a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> is not part of any declarative region.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.d</MarginText>
<Admonition type="aarm" aarm="note">
We considered making the visibility rules within <code><a href="../AA-10/AA-10.1#S0291">parent_unit_name</a></code>s and <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>s follow from the context of compilation. However, this attempt failed for various reasons. For example, it would require <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>s in <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>s to be within the declarative region of Standard, which sounds suspiciously like a kludge. And we would still need a special rule to prevent seeing things (in our own <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>) that were with-ed by our parent, etc. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>6.e/2</MarginText>
<MarginInfo items={["AI95-00217-06"]} />
<Admonition type="aarm" aarm="note">
Added separate visibility rules for <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>s; the existing rules apply only to <code><a href="../AA-10/AA-10.1#S0296">nonlimited_with_clause</a></code>s.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.f/2</MarginText>
<MarginInfo items={["AI95-00312-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that the name of a generic child unit may appear in a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> in a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>. <br /></Admonition>
</AnnotatedOnly>

