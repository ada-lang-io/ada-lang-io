---
sidebar_position:  85
---

# 10.2 Program Execution

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

<p>An Ada <em>program</em> consists of a set of <em>partitions</em>[, which can execute in parallel with one another, possibly in a separate address space, and possibly on a separate computer.] <br /></p>


#### Post-Compilation Rules

<p>{"{"}<em>{"AI12-0439-1"}</em>{"}"} <br />A partition is a program or part of a program that can be invoked from outside the Ada implementation. [For example, on many systems, a partition can be an executable file generated by the system linker.] The user can <em>explicitly assign</em> library units to a partition. The assignment is done in an implementation-defined manner. The compilation units included in a partition are those of the explicitly assigned library units, as well as other compilation units <em>needed by</em> those library units. The compilation units needed by a given compilation unit are determined as follows (unless specified otherwise via an implementation-defined <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>, or by some other implementation-defined means): <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>From a run-time point of view, an Ada 95 partition is identical to an Ada 83 program - implementations were always allowed to provide inter-program communication mechanisms. The additional semantics of partitions is that interfaces between them can be defined to obey normal language rules (as is done in Annex E, "Distributed Systems"), whereas interfaces between separate programs had no particular semantics. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The manner of explicitly assigning library units to a partition.<br /></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The implementation-defined means, if any, of specifying which compilation units are needed by a given compilation unit.<br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>There are no pragmas that "specify otherwise" defined by the core language. However, an implementation is allowed to provide such pragmas, and in fact Annex E, "Distributed Systems" defines some pragmas whose semantics includes reducing the set of compilation units described here. <br /></Admonition>

<ul>
<li>A compilation unit needs itself;<br /></li>
<li>If a compilation unit is needed, then so are any compilation units upon which it depends semantically;<br /></li>
<li>If a <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> is needed, then so is any corresponding <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code>;<br /></li>
<li>{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />If a compilation unit with stubs is needed, then so are any corresponding subunits;<br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Note that in the environment, the stubs are replaced with the corresponding <code>proper_bodies</code>. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />If the (implicit) declaration of the limited view of a library package is needed, then so is the explicit declaration of the library package.<br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Note that a child unit is not included just because its parent is included - to include a child, mention it in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />A package is included in a partition even if the only reference to it is in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>. While this isn't strictly necessary (no objects of types imported from such a unit can be created), it ensures that all incomplete types are eventually completed, and is the least surprising option. <br /></Admonition>

<p>The user can optionally designate (in an implementation-defined manner) one subprogram as the <em>main subprogram</em> for the partition. A main subprogram, if specified, shall be a subprogram. <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>This may seem superfluous, since it follows from the definition. But we would like to have every error message that might be generated (before run time) by an implementation correspond to some explicitly stated "shall" rule.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Of course, this does not mean that the "shall" rules correspond one-to-one with an implementation's error messages. For example, the rule that says overload resolution "shall" succeed in producing a single interpretation would correspond to many error messages in a good implementation - the implementation would want to explain to the user exactly why overload resolution failed. This is especially true for the syntax rules - they are considered part of overload resolution, but in most cases, one would expect an error message based on the particular syntax rule that was violated. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The manner of designating the main subprogram of a partition.<br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>An implementation cannot require the user to specify, say, all of the library units to be included. It has to support, for example, perhaps the most typical case, where the user specifies just one library unit, the main program. The implementation has to do the work of tracking down all the other ones. <br /></Admonition>

<p>Each partition has an anonymous <em>environment task</em>[, which is an implicit outermost task whose execution elaborates the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s of the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code>, and then calls the main subprogram, if there is one. A partition's execution is that of its tasks.] <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>An environment task has no master; all nonenvironment tasks have masters.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
An implementation is allowed to support multiple concurrent executions of the same partition. <br /></Admonition>

<p>[The order of elaboration of library units is determined primarily by the <em>elaboration dependences</em>.] There is an elaboration dependence of a given <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> upon another if the given <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or any of its subunits depends semantically on the other <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. In addition, if a given <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or any of its subunits has a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All that names another library unit, then there is an elaboration dependence of the given <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> upon the body of the other library unit, and, for Elaborate_All only, upon each <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> needed by the declaration of the other library unit. <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>{"{"}<em>8652/0107</em>{"}"} {"{"}<em>{"AI95-00180-01"}</em>{"}"} {"{"}<em>{"AI95-00256-01"}</em>{"}"} <br />"Mentions" was used informally in the above rule; it was not intended to refer to the definition of <em>mentions</em> in 10.1.2. It was changed to "names" to make this clear.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
See above for a definition of which <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s are "needed by" a given declaration.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />Note that elaboration dependences are among <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s, whereas the other two forms of dependence are among compilation units. Note that elaboration dependence includes semantic dependence. It's a little bit sad that the Elaborate_Body  aspect can't be folded into this mechanism. It follows from the definition that the elaboration dependence relationship is transitive. Note that the wording of the rule does not need to take into account a semantic dependence of a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> or one of its subunits upon a subunit of a different library unit, because that can never happen. <br /></Admonition>

<p>The environment task for a partition has the following structure: <br /></p>

<CodeBlock>
task Environment_Task;{"\n"}
task body Environment_Task is{"\n"}    ... (1) -- The environment <a href="../AA-3/AA-3.11#S0086">declarative_part</a>{"\n"}            -- (that is, the sequence of <a href="../AA-10/AA-10.1#S0287">library_item</a>s) goes here.{"\n"}begin{"\n"}    ... (2) -- Call the main subprogram, if there is one.{"\n"}end Environment_Task;{"\n"}

</CodeBlock>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The name of the environment task is written in italics here to indicate that this task is anonymous. <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>The model is different for a "passive partition" (see E.1). Either there is no environment task, or its <code><a href="../AA-5/AA-5.1#S0166">sequence_of_statements</a></code> is an infinite loop rather than a call on a main subprogram. <br /></Admonition>

<p>The environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> at (1) is a sequence of <code><a href="../AA-3/AA-3.11#S0087">declarative_item</a></code>s consisting of copies of the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s included in the partition[. The order of elaboration of <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s is the order in which they appear in the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code>]: <br /></p>

<ul>
<li>The order of all included <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s is such that there are no forward elaboration dependences. <br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>This rule is written so that if a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> depends on itself, we don't require it to be elaborated before itself. See AI83-00113/12. This can happen only in pathological circumstances. For example, if a library <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> has no corresponding <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>, and one of the subunits of the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> mentions the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> in a <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code>, the <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> will depend on itself. For another example, if a <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> applies a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate_All to its own declaration, then the <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> will depend on itself. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI05-0229-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />Any included <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> for which aspect Elaborate_Body is True is immediately followed by its <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code>, if included. <br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>This implies that the body of such a library unit shall not "with" any of its own children, or anything else that depends semantically upon the declaration of the library unit. <br /></Admonition>

<ul>
<li>All <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s declared pure occur before any that are not declared pure.<br /></li>
<li>All preelaborated <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s occur before any that are not preelaborated. <br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Normally, if two partitions contain the same compilation unit, they each contain a separate <em>copy</em> of that compilation unit. See Annex E, "Distributed Systems" for cases where two partitions share the same copy of something.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
There is no requirement that the main subprogram be elaborated last. In fact, it is possible to write a partition in which the main subprogram cannot be elaborated last. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>This <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> has the properties required of all environments (see 10.1.4). However, the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> of a partition will typically contain fewer compilation units than the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> used at compile time - only the "needed" ones are included in the partition. <br /></Admonition>

<p>There shall be a total order of the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s that obeys the above rules. The order is otherwise implementation defined. <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />The only way to violate this rule is to have Elaborate or Elaborate_All <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s or Elaborate_Body aspects that cause circular ordering requirements, thus preventing an order that has no forward elaboration dependences. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The order of elaboration of <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>To be honest: </strong>{"{"}<em>{"AI12-0005-1"}</em>{"}"} <br />Notwithstanding what the RM says elsewhere, each rule that requires a declaration to have a corresponding completion is considered to be a Post-Compilation Rule when the declaration is that of a library unit. <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Such rules may be checked at "link time", for example. Rules requiring the completion to have certain properties, on the other hand, are checked at compile time of the completion. <br /></Admonition>

<p>The full expanded names of the library units and subunits included in a given partition shall be distinct.<br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>This is a Post-Compilation Rule because making it a Legality Rule would violate the Language Design Principle labeled "legality determinable via semantic dependences". <br /></Admonition>

<p>The <code><a href="../AA-5/AA-5.1#S0166">sequence_of_statements</a></code> of the environment task (see (2) above) consists of either: <br /></p>

<ul>
<li>A call to the main subprogram, if the partition has one. If the main subprogram has parameters, they are passed; where the actuals come from is implementation defined. What happens to the result of a main function is also implementation defined. <br /></li>
</ul>
<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>Parameter passing and function return for the main subprogram.<br /></Admonition>

<p>or: <br /></p>

<ul>
<li>A <code><a href="../AA-5/AA-5.1#S0170">null_statement</a></code>, if there is no main subprogram. <br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>For a passive partition, either there is no environment task, or its <code><a href="../AA-5/AA-5.1#S0166">sequence_of_statements</a></code> is an infinite loop. See E.1. <br /></Admonition>

<p>{"{"}<em>{"AI12-0439-1"}</em>{"}"} <br />The mechanisms for building and running partitions are implementation defined. [These can be combined into one operation, as, for example, in dynamic linking, or "load-and-go" systems.] <br /></p>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The mechanisms for building and running partitions.<br /></Admonition>


#### Dynamic Semantics

<p>The execution of a program consists of the execution of a set of partitions. Further details are implementation defined. The execution of a partition starts with the execution of its environment task, ends when the environment task terminates, and includes the executions of all tasks of the partition. [The execution of the (implicit) <code><a href="../AA-9/AA-9.1#S0248">task_body</a></code> of the environment task acts as a master for all other tasks created as part of the execution of the partition. When the environment task completes (normally or abnormally), it waits for the termination of all such tasks, and then finalizes any remaining objects of the partition.] <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The "further details" mentioned above include, for example, program termination - it is implementation defined. There is no need to define it here; it's entirely up to the implementation whether it wants to consider the program as a whole to exist beyond the existence of individual partitions. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The details of program execution, including program termination.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>To be honest: </strong>The execution of the partition terminates (normally or abnormally) when the environment task terminates (normally or abnormally, respectively). <br /></Admonition>


#### Bounded (Run-Time) Errors

<p>Once the environment task has awaited the termination of all other tasks of the partition, any further attempt to create a task (during finalization) is a bounded error, and may result in the raising of Program_Error either upon creation or activation of the task. If such a task is activated, it is not specified whether the task is awaited prior to termination of the environment task. <br /></p>


#### Implementation Requirements

<p>The implementation shall ensure that all compilation units included in a partition are consistent with one another, and are legal according to the rules of the language. <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>The consistency requirement implies that a partition cannot contain two versions of the same compilation unit. That is, a partition cannot contain two different library units with the same full expanded name, nor two different bodies for the same program unit. For example, suppose we compile the following: <br /></Admonition>

<CodeBlock>
package A is -- Version 1.{"\n"}    ...{"\n"}end A;{"\n"}
with A;{"\n"}package B is{"\n"}end B;{"\n"}
package A is -- Version 2.{"\n"}    ...{"\n"}end A;{"\n"}
with A;{"\n"}package C is{"\n"}end C;{"\n"}

</CodeBlock>
<Admonition type="aarm" aarm="note" title="Note: ">
It would be wrong for a partition containing B and C to contain both versions of A. Typically, the implementation would require the use of Version 2 of A, which might require the recompilation of B. Alternatively, the implementation might automatically recompile B when the partition is built. A third alternative would be an incremental compiler that, when Version 2 of A is compiled, automatically patches the object code for B to reflect the changes to A (if there are any relevant changes - there might not be any).<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
An implementation that supported fancy version management might allow the use of Version 1 in some circumstances. In no case can the implementation allow the use of both versions in the same partition (unless, of course, it can prove that the two versions are semantically identical).<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
The core language says nothing about inter-partition consistency; see also Annex E, "Distributed Systems". <br /></Admonition>


#### Implementation Permissions

<p>{"{"}<em>{"AI05-0299-1"}</em>{"}"} <br />The kind of partition described in this subclause is known as an <em>active</em> partition. An implementation is allowed to support other kinds of partitions, with implementation-defined semantics. <br /></p>

<Admonition type="aarm" aarm="implementation-defined" title="Implementation defined: ">
<strong></strong>The semantics of any nonactive partitions supported by the implementation.<br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Annex E, "Distributed Systems" defines the concept of passive partitions; they may be thought of as a partition without an environment task, or as one with a particularly simple form of environment task, having an infinite loop rather than a call on a main subprogram as its <code><a href="../AA-5/AA-5.1#S0166">sequence_of_statements</a></code>. <br /></Admonition>

<p>An implementation may restrict the kinds of subprograms it supports as main subprograms. However, an implementation is required to support all main subprograms that are public parameterless library procedures. <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The implementation is required to support main subprograms that are procedures declared by <code><a href="../AA-12/AA-12.3#S0315">generic_instantiation</a></code>s, as well as those that are children of library units other than Standard. Generic units are, of course, not allowed to be main subprograms, since they are not subprograms.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Note that renamings are irrelevant to this rule. This rules says which subprograms (not views) have to be supported. The implementation can choose any way it wants for the user to indicate which subprogram should be the main subprogram. An implementation might allow any name of any view, including those declared by renamings. Another implementation might require it to be the original name. Another implementation still might use the name of the source file or some such thing. <br /></Admonition>

<p>If the environment task completes abnormally, the implementation may abort any dependent tasks. <br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>If the implementation does not take advantage of this permission, the normal action takes place - the environment task awaits those tasks.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
The possibility of aborting them is not shown in the <em>Environment_Task</em> code above, because there is nowhere to put an <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> that can handle exceptions raised in both the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> and the main subprogram, such that the dependent tasks can be aborted. If we put an <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> in the body of the environment task, then it won't handle exceptions that occur during elaboration of the environment <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code>. If we were to move those things into a nested <code><a href="../AA-5/AA-5.6#S0191">block_statement</a></code>, with the <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> outside that, then the <code><a href="../AA-5/AA-5.6#S0191">block_statement</a></code> would await the library tasks we are trying to abort.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Furthermore, this is merely a permission, and is not fundamental to the model, so it is probably better to state it separately anyway.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Note that implementations (and tools like debuggers) can have modes that provide other behaviors in addition. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 1   {"{"}<em>{"AI12-0440-1"}</em>{"}"} <br />An implementation can provide inter-partition communication mechanism(s) via special packages and pragmas. Standard pragmas for distribution and methods for specifying inter-partition communication are defined in Annex E, "Distributed Systems". If no such mechanisms are provided, then each partition is isolated from all others, and behaves as a program in and of itself. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>Not providing such mechanisms is equivalent to disallowing multi-partition programs.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
An implementation may provide mechanisms to facilitate checking the consistency of library units elaborated in different partitions; Annex E, "Distributed Systems" does so. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 2   {"{"}<em>{"AI12-0440-1"}</em>{"}"} <br />Partitions are not required to run in separate address spaces. For example, an implementation can support dynamic linking via the partition concept.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 3   {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />An order of elaboration of <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s that is consistent with the partial ordering defined above does not always ensure that each <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> is elaborated before any other compilation unit whose elaboration necessitates that the <code><a href="../AA-10/AA-10.1#S0290">library_unit_body</a></code> be already elaborated. (In particular, there is no requirement that the body of a library unit be elaborated as soon as possible after the <code><a href="../AA-10/AA-10.1#S0288">library_unit_declaration</a></code> is elaborated, unless the pragmas or aspects in subclause 10.2.1 are used.)<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 4   {"{"}<em>{"AI12-0442-1"}</em>{"}"} <br />A partition (active or otherwise) does not necessarily have a main subprogram. In such a case, all the work done by the partition would be done by elaboration of various <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s, and by tasks created by that elaboration. Passive partitions, which cannot have main subprograms, are defined in Annex E, "Distributed Systems". <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The environment task is the outermost semantic level defined by the language.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Standard has no private part. This prevents strange implementation-dependences involving private children of Standard having visibility upon Standard's private part. It doesn't matter where the body of Standard appears in the environment, since it doesn't do anything. See Annex A, "Predefined Language Environment".<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Note that elaboration dependence is carefully defined in such a way that if (say) the body of something doesn't exist yet, then there is no elaboration dependence upon the nonexistent body. (This follows from the fact that "needed by" is defined that way, and the elaboration dependences caused by a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All are defined in terms of "needed by".) This property allows us to use the environment concept both at compile time and at partition-construction time/run time. <br /></Admonition>


#### Extensions to Ada 83

<Admonition type="aarm" aarm="note" title="Note: ">
The concept of partitions is new to Ada 95.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
A main subprogram is now optional. The language-defined restrictions on main subprograms are relaxed. <br /></Admonition>


#### Wording Changes from Ada 83

<Admonition type="aarm" aarm="note" title="Note: ">
Ada 95 uses the term "main subprogram" instead of Ada 83's "main program" (which was inherited from Pascal). This is done to avoid confusion - a main subprogram is a subprogram, not a program. The program as a whole is an entirely different thing. <br /></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00256-01"}</em>{"}"} <br />The mistaken use of "mentions" in the elaboration dependence rule was fixed.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />The <em>needs</em> relationship was extended to include limited views. <br /></Admonition>


## 10.2.1  Elaboration Control

<p>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />[ This subclause defines aspects and pragmas that help control the elaboration order of <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s.] <br /></p>


#### Language Design Principles

<Admonition type="aarm" aarm="note" title="Note: ">
The rules governing preelaboration are designed to allow it to be done largely by bulk initialization of statically allocated storage from information in a "load module" created by a linker. Some implementations may require run-time code to be executed in some cases, but we consider these cases rare enough that we need not further complicate the rules.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
It is important that programs be able to declare data structures that are link-time initialized with <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s, <code><a href="../AA-2/AA-2.6#S0016">string_literal</a></code>s, and concatenations thereof. It is important to be able to write link-time evaluated expressions involving the First, Last, and Length attributes of such data structures (including variables), because they might be initialized with positional <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s or <code><a href="../AA-2/AA-2.6#S0016">string_literal</a></code>s, and we don't want the user to have to count the elements. There is no corresponding need for accessing discriminants, since they can be initialized with a static constant, and then the constant can be referred to elsewhere. It is important to allow link-time initialized data structures involving discriminant-dependent components. It is important to be able to write link-time evaluated expressions involving pointers (both access values and addresses) to the above-mentioned data structures.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
The rules also ensure that no Elaboration_Check need be performed for calls on library-level subprograms declared within a preelaborated package. This is true also of the Elaboration_Check on task activation for library level task types declared in a preelaborated package. However, it is not true of the Elaboration_Check on instantiations.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
A static expression should never prevent a library unit from being preelaborable.<br /></Admonition>

<p><em>Paragraphs 2 through 4 were moved to Annex J, "Obsolescent Features".</em> <br /></p>


#### Legality Rules

<p>An elaborable construct is preelaborable unless its elaboration performs any of the following actions: <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>A <em>preelaborable</em> construct can be elaborated without using any information that is available only at run time. Note that we don't try to prevent exceptions in preelaborable constructs; if the implementation wishes to generate code to raise an exception, that's OK.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Because there is no flow of control and there are no calls (other than to predefined subprograms), these run-time properties can actually be detected at compile time. This is necessary in order to require compile-time enforcement of the rules. <br /></Admonition>

<ul>
<li>The execution of a <code><a href="../AA-5/AA-5.1#S0167">statement</a></code> other than a <code><a href="../AA-5/AA-5.1#S0170">null_statement</a></code>. <br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>A preelaborable construct can contain <code><a href="../AA-5/AA-5.1#S0171">label</a></code>s and <code><a href="../AA-5/AA-5.1#S0170">null_statement</a></code>s. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI12-0175-1"}</em>{"}"} <br />A call to a subprogram other than: <br /></li>
<li>a static function;<br /></li>
<li>an instance of Unchecked_Conversion (see 13.9);<br /></li>
<li>a function declared in System.Storage_Elements (see 13.7.1); or<br /></li>
<li>the functions To_Pointer and To_Address declared in an instance of System.Address_to_Access_Conversions (see 13.7.2). <br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI12-0175-1"}</em>{"}"} <br />The parameters of any such function have to pass the preelaborability rules, so they typically have to be static expressions. The extra allowed functions are all forms of conversion that the compiler understands, so there should be little implementation burden. Note that such a call might raise an exception; preelaborable is not the same as elaborable with no code. <br /></Admonition>

<ul>
<li>The evaluation of a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that is a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> of an object, unless the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> is a static expression, or statically denotes a discriminant of an enclosing type. <br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>One can evaluate such a <code><a href="../AA-4/AA-4.1#S0091">name</a></code>, but not as a <code><a href="../AA-4/AA-4.4#S0141">primary</a></code>. For example, one can evaluate an attribute of the object. One can evaluate an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code>, so long as it does not denote an object, and its <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, and Obj'Address are generally legal in preelaborated library units. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI95-00161-01"}</em>{"}"} {"{"}<em>{"AI05-0028-1"}</em>{"}"} <br />The creation of an object [(including a component)] that is initialized by default, if its type does not have preelaborable initialization. Similarly, the evaluation of an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code> with an ancestor <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denoting a subtype of such a type.<br /></li>
</ul>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>One can declare these kinds of types, but one cannot create objects of those types.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
It is also nonpreelaborable to create an object if that will cause the evaluation of a default expression that will call a user-defined function. This follows from the rule above forbidding nonnull statements. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<em>This paragraph was deleted.</em>{"{"}<em>{"AI95-00161-01"}</em>{"}"} <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />The elaboration of any elaborable construct that is not preelaborable. <br /></li>
</ul>
<p>{"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />A generic declaration is preelaborable unless every instance would perform one of the above actions.<br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI12-0232-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />A generic declaration is preelaborable unless there is no instance that could be declared preelaborated. For instance, a generic package declaration that directly contains a variable initialized by a non-static function that is not a formal function is not preelaborable (and thus would be illegal if the Preelaborate aspect were applied to it). <br /></Admonition>

<p>{"{"}<em>{"AI95-00403-01"}</em>{"}"} <br />A generic body is preelaborable only if elaboration of a corresponding instance body would not perform any such actions, presuming that: <br /></p>

<ul>
<li>{"{"}<em>{"AI95-00403-01"}</em>{"}"} {"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />the actual for each discriminated formal derived type, formal private type, or formal private extension declared within the formal part of the generic unit is a type that does not have preelaborable initialization, unless the Preelaborable_Initialization aspect was specified for the formal type;<br /></li>
<li>{"{"}<em>{"AI95-00403-01"}</em>{"}"} <br />the actual for each formal type is nonstatic;<br /></li>
<li>{"{"}<em>{"AI95-00403-01"}</em>{"}"} <br />the actual for each formal object is nonstatic; and<br /></li>
<li>{"{"}<em>{"AI95-00403-01"}</em>{"}"} <br />the actual for each formal subprogram is a user-defined subprogram. <br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>{"{"}<em>{"AI95-00403-01"}</em>{"}"} <br />This is an "assume-the-worst" rule. The elaboration of a generic unit doesn't perform any of the actions listed above, because its sole effect is to establish that the generic can from now on be instantiated. So the elaboration of the generic itself is not the interesting part when it comes to preelaboration rules. The interesting part is what happens when you elaborate "any instantiation" of the generic. For instance, declaring an object of a limited formal private type might well start tasks, call functions, and do all sorts of nonpreelaborable things. We prevent these situations by assuming that the actual parameters are as badly behaved as possible. <br /></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>Without this rule about generics, we would have to forbid instantiations in preelaborated library units, which would significantly reduce their usefulness. <br /></Admonition>

<p>{"{"}<em>8652/0035</em>{"}"} {"{"}<em>{"AI95-00002-01"}</em>{"}"} {"{"}<em>{"AI05-0034-1"}</em>{"}"} {"{"}<em>{"AI05-0243-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />When the library unit aspect (see 13.1.1) Preelaborate of a program unit is True, the unit is said to be <em>preelaborated</em>. When the Preelaborate aspect is specified True for a library unit, all compilation units of the library unit are preelaborated. The declaration and body of a preelaborated library unit, and all subunits that are elaborated as part of elaborating the library unit, shall be preelaborable. All compilation units of a preelaborated library unit shall depend semantically only on declared pure or preelaborated <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s. In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit. [ If a library unit is preelaborated, then its declaration, if any, and body, if any, are elaborated prior to all nonpreelaborated <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s of the partition.] <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>In a generic body, we assume the worst about formal private types and extensions.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>8652/0035</em>{"}"} {"{"}<em>{"AI95-00002-01"}</em>{"}"} <br />Subunits of a preelaborated subprogram unit do not need to be preelaborable. This is needed in order to be consistent with units nested in a subprogram body, which do not need to be preelaborable even if the subprogram is preelaborated. However, such subunits cannot depend semantically on nonpreelaborated units, which is also consistent with nested units.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />If a unit is not preelaborated, the value of the Preelaborate aspect for that unit is False. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>Aspect Description for </strong><strong>Preelaborate: </strong>Code execution during elaboration is avoided for a given package.<br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />Rules for specifying a library unit aspect (like Preelaborate) are found in 13.1.1. <br /></Admonition>

<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} {"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />The following rules specify which entities have <em>preelaborable initialization</em>, namely that the Preelaborable_Initialization aspect of the entity is True:<br /></p>

<ul>
<li>{"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI12-0409-1"}</em>{"}"} {"{"}<em>{"AI12-0444-1"}</em>{"}"} <br />The partial view of a private type or private extension, a protected type without <code><a href="../AA-9/AA-9.5#S0257">entry_declaration</a></code>s, a generic formal private type, or a generic formal derived type, has preelaborable initialization if and only if the Preelaborable_Initialization aspect has been specified True for them. [A protected type with <code><a href="../AA-9/AA-9.5#S0257">entry_declaration</a></code>s or a task type never has preelaborable initialization.] The Preelaborable_Initialization aspect of a partial view of a type may be specified as False, even if the full view of the type has preelaborable initialization. Similarly, a generic formal type may be specified with Preelaborable_Initialization False, even if the actual type in an instance has preelaborable initialization.<br /></li>
<li>A component (including a discriminant) of a record or protected type has preelaborable initialization if its declaration includes a <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code> whose execution does not perform any actions prohibited in preelaborable constructs as described above, or if its declaration does not include a default expression and its type has preelaborable initialization.<br /></li>
<li>{"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI05-0221-1"}</em>{"}"} <br />A derived type has preelaborable initialization if its parent type has preelaborable initialization and if the noninherited components all have preelaborable initialization. However, a controlled type with an Initialize procedure that is not a null procedure does not have preelaborable initialization.<br /></li>
<li>{"{"}<em>{"AI95-00161-01"}</em>{"}"} {"{"}<em>{"AI95-00345-01"}</em>{"}"} <br />A view of a type has preelaborable initialization if it is an elementary type, an array type whose component type has preelaborable initialization, a record type whose components all have preelaborable initialization, or an interface type. <br /></li>
</ul>
<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} {"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />The following attribute is defined for a nonformal composite subtype S declared within the visible part of a package or a generic package, or a generic formal private subtype or formal derived subtype:<br /></p>

<dt><br/>S'Preelaborable_Initialization</dt>
<dl>
<dd>{"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />This attribute is of Boolean type, and its value reflects whether the type of S has preelaborable initialization. The value of this attribute, the type-related Preelaborable_Initialization aspect, may be specified for any type for which the attribute is defined. The value shall be specified by a static expression, unless the type is not a formal type but is nevertheless declared within a generic package. In this latter case, the value may also be specified by references to the Preelaborable_Initialization attribute of one or more formal types visible at the point of the declaration of the composite type, conjoined with <strong>and</strong>.<br /></dd>
</dl>
<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />"Formal types visible at the point of the declaration" includes all visible formal types, including those that might have been declared in formal packages or in child packages. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>Aspect Description for </strong><strong>Preelaborable_Initialization: </strong>Declares that a type has preelaborable initialization.<br /></Admonition>

<p>{"{"}<em>{"AI95-00161-01"}</em>{"}"} {"{"}<em>{"AI95-00345-01"}</em>{"}"} {"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />If the Preelaborable_Initialization aspect is specified True for a private type or a private extension, the full view of the type shall have preelaborable initialization. If the aspect is specified True for a protected type, the protected type shall not have entries, and each component of the protected type shall have preelaborable initialization.  If the aspect is specified True for a generic formal type, then in a <code><a href="../AA-12/AA-12.3#S0315">generic_instantiation</a></code> the corresponding actual type shall have preelaborable initialization. If the aspect definition includes one or more Preelaborable_Initialization <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code>s, then the full view of the type shall have preelaborable initialization presuming the types mentioned in the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code>es of the <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code>s all have preelaborable initialization. For any other composite type, the  aspect shall be specified statically True or False only if it is confirming. In addition to the places where Legality Rules normally apply (see 12.3), these rules apply also in the private part of an instance of a generic unit.<br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>{"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />The reason why we need to be allowed to specify the aspect for private types, private extensions, and protected types is fairly clear: the properties of the full view determine whether the type has preelaborable initialization or not; in order to preserve privacy we need a way to express on the partial view that the full view is well-behaved. The reason why we need to be allowed to specify the aspect for other composite types is more subtle: a nonnull override for Initialize might occur in the private part, even for a nonprivate type; in order to preserve privacy, we need a way to express on a type declared in a visible part that the private part does not contain any nasty override of Initialize. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />Not only do protected types with <code><a href="../AA-9/AA-9.5#S0257">entry_declaration</a></code>s and task types not have preelaborable initialization, but they cannot have Preelaborable_Initialization aspect specified True for them. <br /></Admonition>


#### Implementation Advice

<p>In an implementation, a type declared in a preelaborated package should have the same representation in every elaboration of a given version of the package, whether the elaborations occur in distinct executions of the same program, or in executions of distinct programs or partitions that include the given version. <br /></p>

<Admonition type="aarm" aarm="implementation-advice" title="Implementation Advice">
<strong></strong>A type declared in a preelaborated package should have the same representation in every elaboration of a given version of the package.<br /></Admonition>

<p><em>Paragraphs 13 through 15 were moved to Annex J, "Obsolescent Features".</em> <br /></p>


#### Static Semantics

<p>{"{"}<em>{"AI95-00366-01"}</em>{"}"} {"{"}<em>{"AI05-0035-1"}</em>{"}"} {"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />A <em>pure</em> program unit is a preelaborable program unit whose elaboration does not perform any of the following actions:<br /></p>

<ul>
<li>the elaboration of a variable declaration;<br /></li>
<li>the evaluation of an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> of an access-to-variable type; for the purposes of this rule, the partial view of a type is presumed to have nonvisible components whose default initialization evaluates such an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>;<br /></li>
</ul>
<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>{"{"}<em>{"AI05-0004-1"}</em>{"}"} <br />Such an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> would provide a backdoor way to get a global variable into a pure unit, so it is prohibited. Most such <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s are illegal anyway, as their type is required to have Storage_Size = 0 (see the next two rules). But access parameters and access discriminants don't necessarily disallow <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s. However, a call is also illegal here (by the preelaboration rules), so access parameters cannot cause trouble. So this rule is really about prohibiting allocators in discriminant constraints:<br /></Admonition>

<CodeBlock>
type Rec (Acc : access Integer) is record{"\n"}    C : Character;{"\n"}end record;{"\n"}
Not_Const : constant Rec (Acc ={">"} new Integer'(2)); -- Illegal in a pure unit.{"\n"}

</CodeBlock>
<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI05-0004-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />The second half of the rule is needed because aggregates can specify the default initialization of a private type or extension using {"<"}{">"} or the ancestor subtype of an extension aggregate. The subtype of a component could use an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> to initialize an access discriminant; the type still could have the Preelaborable_Initialization aspect specified. Ada 95 did not allow such private types to have preelaborable initialization, so such a default initialization could not have occurred. Thus this rule is not incompatible with Ada 95. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI05-0035-1"}</em>{"}"} <br />the elaboration of the declaration of a nonderived named access-to-variable type unless the Storage_Size of the type has been specified by a static expression with value zero or is defined by the language to be zero;<br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>A remote access-to-class-wide type (see E.2.2) has its Storage_Size defined to be zero. <br /></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br />We disallow most named access-to-object types because an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> has a side effect; the pool constitutes variable data. We allow access-to-subprogram types because they don't have <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s. We even allow named access-to-object types if they have an empty predefined pool (they can't have a user-defined pool as System.Storage_Pools is not pure). In this case, most attempts to use an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> are illegal, and any others (in a generic body) will raise Storage_Error. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI05-0035-1"}</em>{"}"} {"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />the elaboration of the declaration of a nonderived named access-to-constant type for which the Storage_Size has been specified by an expression other than a static expression with value zero;<br /></li>
</ul>
<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>We allow access-to-constant types so long as there is no user-specified nonzero Storage_Size; if there were a user-specified nonzero Storage_Size restricting the size of the storage pool, allocators would be problematic since the package is supposedly 'stateless', and the allocated size count for the storage pool would represent state. <br /></Admonition>

<ul>
<li>{"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />the elaboration of any program unit that is not pure.<br /></li>
</ul>
<p>{"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />A generic declaration is pure unless every instance would perform one of the above actions.<br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI12-0232-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />A generic declaration is pure unless there is no instance that could be declared pure. For instance, a generic package declaration that directly contains a variable declaration is not pure (and thus would be illegal if aspect Pure is specified for it). <br /></Admonition>

<p>{"{"}<em>{"AI05-0035-1"}</em>{"}"} {"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />A generic body is pure only if elaboration of a corresponding instance body would not perform any such actions presuming any composite formal types have nonvisible components whose default initialization evaluates an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> of an access-to-variable type.<br /></p>

<p>{"{"}<em>{"AI95-00366-01"}</em>{"}"} {"{"}<em>{"AI12-0232-1"}</em>{"}"} <br />The Storage_Size for an anonymous access-to-variable type declared at library level in a library unit that is declared pure is defined to be zero.<br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>This makes <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s illegal for such types (see 4.8), making a storage pool unnecessary for these types. A storage pool would represent state.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Note that access discriminants and access parameters are never library-level, even when they are declared in a type or subprogram declared at library-level. That's because they have their own special accessibility rules (see 3.10.2). <br /></Admonition>


#### Legality Rules

<p><em>This paragraph was deleted.</em>{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br /></p>

<p>{"{"}<em>{"AI95-00366-01"}</em>{"}"} {"{"}<em>{"AI05-0034-1"}</em>{"}"} {"{"}<em>{"AI05-0035-1"}</em>{"}"} {"{"}<em>{"AI05-0243-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />When the library unit aspect Pure of a program unit is True, the unit is said to be <em>declared pure</em>. When the Pure aspect is specified True for a library unit, all compilation units of the library unit are declared pure. In addition, the limited view of any library package is declared pure. The declaration and body of a declared pure library unit, and all subunits that are elaborated as part of elaborating the library unit, shall be pure. All compilation units of a declared pure library unit shall depend semantically only on declared pure <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s. In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit. Furthermore, the full view of any partial view declared in the visible part of a declared pure library unit that has any available stream attributes shall support external streaming (see 13.13.2). <br /></p>

<Admonition type="aarm" aarm="note" title="Note: ">
<em>This paragraph was deleted.</em>{"{"}<em>{"AI05-0243-1"}</em>{"}"} <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>A declared-pure package is useful for defining types to be shared between partitions with no common address space. <br /></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>Note that generic packages are not mentioned in the list of things that can contain variable declarations. Note that the Ada 95 rules for deferred constants make them allowable in library units that are declared pure; that isn't true of Ada 83's deferred constants. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br />Anonymous access types are allowed.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI05-0243-1"}</em>{"}"} <br />A limited view is not a library unit, so any rule that starts "declared pure library unit" does not apply to a limited view. In particular, the 3rd and last sentences never apply to limited views. However, a limited view is a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>, so rules that discuss "declared pure <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>s" do include limited views.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />If a unit is not declared pure, the value of the Pure aspect for that unit is False. <br /></Admonition>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br />Ada 95 didn't allow any access types as these (including access-to-subprogram types) cause trouble for Annex E, "Distributed Systems", because such types  allow access values in a shared passive partition to designate objects in an active partition, thus allowing inter-address space references. We decided to disallow such uses in the relatively rare cases where they cause problems, rather than making life harder for the majority of users. Types declared in a pure package can be used in remote operations only if they are externally streamable. That simply means that there is a means to transport values of the type; that's automatically true for nonlimited types that don't have an access part. The only tricky part about this is to avoid privacy leakage; that was handled by ensuring that any private types (and private extensions) declared in a pure package that have available stream attributes (which include all nonlimited types by definition) have to be externally streamable. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>Aspect Description for </strong><strong>Pure: </strong>Side effects are avoided in the subprograms of a given package.<br /></Admonition>


#### Erroneous Execution

<p>{"{"}<em>{"AI12-0076-1"}</em>{"}"} <br />Execution is erroneous if some operation (other than the initialization or finalization of the object) modifies the value of a constant object declared at library-level in a pure package.<br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>This could be accomplished via a self-referencing pointer or via squirrelling a writable pointer to a controlled object. <br /></Admonition>


#### Implementation Permissions

<p>{"{"}<em>{"AI95-00366-01"}</em>{"}"} {"{"}<em>{"AI05-0219-1"}</em>{"}"} <br />If a library unit is declared pure, then the implementation is permitted to omit a call on a library-level subprogram of the library unit if the results are not needed after the call. In addition, the implementation may omit a call on such a subprogram and simply reuse the results produced by an earlier call on the same subprogram, provided that none of the parameters nor any object accessible via access values from the parameters have any part that is of a type whose full type is an immutably limited type, and the addresses and values of all by-reference actual parameters, the values of all by-copy-in actual parameters, and the values of all objects accessible via access values from the parameters, are the same as they were at the earlier call. [This permission applies even if the subprogram produces other side effects when called.] <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>{"{"}<em>{"AI95-00366-01"}</em>{"}"} {"{"}<em>{"AI05-0005-1"}</em>{"}"} {"{"}<em>{"AI05-0299-1"}</em>{"}"} <br />A declared-pure <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> has no variable state. Hence, a call on one of its (nonnested) subprograms cannot normally have side effects. Side effects are still possible via dispatching calls and via indirect calls through access-to-subprogram values. Other mechanisms that might be used to modify variable state include machine code insertions, imported subprograms,  and unchecked conversion to an access type declared within the subprogram; this list is not exhaustive. Thus, the permissions described in this subclause may apply to a subprogram whose execution has side effects. The compiler may omit a call to such a subprogram even if  side effects exist, so the writer of such a subprogram has to keep this in mind. <br /></Admonition>


#### Syntax

<p>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />The following <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s are defined with the given forms: <br /></p>

<p>  <strong>pragma</strong> Elaborate(<em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"{"}, <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"}"});<br /></p>

<p>  <strong>pragma</strong> Elaborate_All(<em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"{"}, <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code>{"}"});<br /></p>

<p><em>This paragraph was deleted.</em>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br /></p>

<p>A <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All is only allowed within a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>. <br /></p>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>"Within a <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>" allows it to be the last item in the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>. It can't be first, because the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> has to denote something mentioned earlier. <br /></Admonition>

<p><em>This paragraph was deleted.</em>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br /></p>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>Hence, a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All is not elaborated, not that it makes any practical difference.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Note that a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All is neither a program unit pragma, nor a library unit pragma.<br /></Admonition>


#### Legality Rules

<p>{"{"}<em>{"AI05-0229-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />If the aspect Elaborate_Body is True for a declaration, then the declaration requires a completion [(a body)].<br /></p>

<p>{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />The <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> of a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All shall denote a nonlimited view of a library unit. <br /></p>

<Admonition type="aarm" aarm="reason" title="Reason: ">
<strong></strong>These <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s are intended to prevent elaboration check failures. But a limited view does not make anything visible that has an elaboration check, so the <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s cannot do anything useful. Moreover, the <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s would probably reintroduce the circularity that the <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code> was intended to break. So we make such uses illegal. <br /></Admonition>


#### Static Semantics

<p>{"{"}<em>{"AI05-0229-1"}</em>{"}"} <br />[A <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate specifies that the body of the named library unit is elaborated before the current <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>. A <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate_All specifies that each <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> that is needed by the named library unit declaration is elaborated before the current <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>.]<br /></p>

<Admonition type="aarm" aarm="proof" title="Proof: ">
<strong></strong>The official statement of the semantics of these <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s is given in 10.2. <br /></Admonition>

<p>{"{"}<em>{"AI05-0229-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />[If the Elaborate_Body aspect of a library unit is True, the body of the library unit is elaborated immediately after its declaration.]<br /></p>

<Admonition type="aarm" aarm="proof" title="Proof: ">
<strong></strong>The official statement of the semantics of this aspect is given in 10.2. <br /></Admonition>

<Admonition type="aarm" aarm="implementation-note" title="Implementation Note: ">
<strong></strong>{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />The specification of the Elaborate_Body aspect simplifies the removal of unnecessary Elaboration_Checks. For a subprogram declared immediately within a library unit for which the Elaborate_Body  aspect is specified as True, the only calls that can fail the Elaboration_Check are those that occur in the library unit itself, between the declaration and body of the called subprogram; if there are no such calls (which can easily be detected at compile time if there are no <code>stub</code>s), then no Elaboration_Checks are needed for that subprogram. The same is true for Elaboration_Checks on task activations and instantiations, and for library subprograms and generic units. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>The fact that the unit of elaboration is the <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> means that if a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is not a completion, it is impossible for any <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code> to be elaborated between the declaration and the body of such a subprogram. Therefore, it is impossible for a call to such a subprogram to fail its Elaboration_Check. <br /></Admonition>

<Admonition type="aarm" aarm="discussion" title="Discussion: ">
<strong></strong>The visibility rules imply that each <em>library_unit_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> of a <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Elaborate or Elaborate_All has to denote a library unit mentioned by a previous <code><a href="../AA-10/AA-10.1#S0294">with_clause</a></code> of the same <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code>. <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
<strong>Aspect Description for </strong><strong>Elaborate_Body: </strong>A given package will have a body, and that body is elaborated immediately after the declaration.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 1   A preelaborated library unit is allowed to have nonpreelaborable children. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>8652/0035</em>{"}"} {"{"}<em>{"AI95-00002-01"}</em>{"}"} <br />But generally not nonpreelaborated subunits. (Nonpreelaborated subunits of subprograms are allowed as discussed above.) <br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
NOTE 2   A library unit that is declared pure is allowed to have impure children. <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>{"{"}<em>8652/0035</em>{"}"} {"{"}<em>{"AI95-00002-01"}</em>{"}"} <br />But generally not impure subunits. (Impure subunits of subprograms are allowed as discussed above.) <br /></Admonition>

<Admonition type="aarm" aarm="ramification" title="Ramification: ">
<strong></strong>Pragma Elaborate is mainly for closely related library units, such as when two package bodies 'with' each other's declarations. In such cases, Elaborate_All sometimes won't work. <br /></Admonition>


#### Extensions to Ada 83

<Admonition type="aarm" aarm="note" title="Note: ">
The concepts of preelaborability and purity are new to Ada 95. The Elaborate_All, Elaborate_Body, Preelaborate, and Pure <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code>s are new to Ada 95.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
Pragmas Elaborate are allowed to be mixed in with the other things in the <code><a href="../AA-10/AA-10.1#S0292">context_clause</a></code> - in Ada 83, they were required to appear last. <br /></Admonition>


#### Incompatibilities With Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br />The requirement that a partial view with available stream attributes be externally streamable can cause an incompatibility in rare cases. If there is a limited tagged type declared in a pure package with available attributes, and that type is used to declare a private extension in another pure package, and the full type for the private extension has a component of an explicitly limited record type, a protected type, or a type with access discriminants, then the stream attributes will have to be user-specified in the visible part of the package. That is not a requirement for Ada 95, but this combination seems very unlikely in pure packages. Note that this cannot be an incompatibility for a nonlimited type, as all of the types that are allowed in Ada 95 that would require explicitly defined stream attributes are limited (and thus cannot be used as components in a nonlimited type).<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI95-00403-01"}</em>{"}"} <strong><br />Amendment </strong> Added wording to cover missing cases for preelaborated generic units. This is incompatible as a preelaborated unit could have used a formal object to initialize a library-level object; that isn't allowed in Ada 2005. But such a unit wouldn't really be preelaborable, and Ada 95 compilers can reject such units (as this is a Binding Interpretation), so such units should be very rare. <br /></Admonition>


#### Extensions to Ada 95

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI95-00161-01"}</em>{"}"} <strong><br />Amendment </strong> The concept of preelaborable initialization and <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization are new. These allow more types of objects to be created in preelaborable units, and fix holes in the old rules.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00366-01"}</em>{"}"} <br />Access-to-subprogram types and access-to-object types with a Storage_Size of 0 are allowed in pure units. The permission to omit calls was adjusted accordingly (which also fixes a hole in Ada 95, as access parameters are allowed, and changes in the values accessed by them must be taken into account). <br /></Admonition>


#### Wording Changes from Ada 95

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00002-01"}</em>{"}"} <strong><br />Corrigendum:</strong> The wording was changed so that subunits of a preelaborated subprogram are also preelaborated.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI95-00217-06"}</em>{"}"} <br />Disallowed pragma Elaborate and Elaborate_All for packages that are mentioned in a <code><a href="../AA-10/AA-10.1#S0295">limited_with_clause</a></code>. <br /></Admonition>


#### Incompatibilities With Ada 2005

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0028-1"}</em>{"}"} <strong><br /></strong> Corrected a serious unintended incompatibility with Ada 95 in the new preelaboration wording - explicit initialization of objects of types that don't have preelaborable initialization was not allowed. Ada 2012 switches back to the Ada 95 rule in these cases. This is unlikely to occur in practice, as it is unlikely that a compiler would have implemented the more restrictive rule (it would fail many ACATS tests if it did).<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0035-1"}</em>{"}"} <strong><br /></strong> Added an assume-the-worst rule for generic bodies (else they would never be checked for purity) and added the boilerplate so that the entire generic specification is rechecked. Also fixed wording to have consistent handling for subunits for Pure and Preelaborate. An Ada 95 program could have depended on marking a generic pure that was not really pure, although this would defeat the purpose of the categorization and likely cause problems with distributed programs. <br /></Admonition>


#### Extensions to Ada 2005

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0035-1"}</em>{"}"} <strong><br /></strong> Adjusted wording so that a subunit can be pure (it is not a <code><a href="../AA-10/AA-10.1#S0287">library_item</a></code>, but it is a compilation unit).<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0035-1"}</em>{"}"} <strong><br /></strong> Adjusted wording so that the rules for access types only apply to nonderived types (derived types share their storage pool with their parent, so if the parent access type is legal, so is any derived type.)<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI05-0229-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />Elaborate_Body is now an aspect, so it can be specified by an <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code><br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI05-0243-1"}</em>{"}"} {"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />Pure and Preelaborate are now aspects, so they can be specified by an <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code> <br /></Admonition>


#### Wording Changes from Ada 2005

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0034-1"}</em>{"}"} <strong><br /></strong> Added wording so that a limited view is always treated as pure, no matter what categorization is used for the originating unit. This was undefined in Ada 2005.<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0028-1"}</em>{"}"} {"{"}<em>{"AI05-0221-1"}</em>{"}"} <strong><br /></strong> Fixed minor issues with preelaborable initialization (PI): null Initialize procedures do not make a type non-PI; formal types with pragma PI can be assumed to have PI; formal extensions are assumed to not have PI; all composite types can have pragma PI (so that the possibility of hidden Initialize routines can be handled); added discriminants of a derived type are not considered in calculating PI.<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI05-0219-1"}</em>{"}"} <strong><br /></strong> Clarified that the implementation permission to omit pure subprogram calls does not apply if any part of the parameters or any designated object has a part that is immutably limited. The old wording just said "limited type", which can change via visibility and thus isn't appropriate for dynamic semantics permissions. <br /></Admonition>


#### Incompatibilities With Ada 2012

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI12-0232-1"}</em>{"}"} <strong><br /></strong> Added a rule that a generic declaration is not pure if no instance could be pure (for instance, because the generic declaration would elaborates a variable.) This was legal in Ada 2012, but of course no instance could have been declared pure. A similar rule (with a similar effect) was added for preelaborable generic declarations. <br /></Admonition>


#### Extensions to Ada 2012

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0175-1"}</em>{"}"} <br />Added some intrinsic conversion functions to those allowed to be called during the elaboration of a preelaborated unit. This is necessary to allow a portable Address aspect in a preelaborated unit, important on small embedded systems.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0409-1"}</em>{"}"} <br />Aspect Preelaborable_Initialization is new; <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization is now obsolescent. <br /></Admonition>


#### Wording Changes from Ada 2012

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0076-1"}</em>{"}"} <strong><br />Corrigendum:</strong> Explicitly stated that modifying a library-level constant in a pure package is erroneous. We don't document this as inconsistent as implementations certainly can still do whatever they were previously doing (no change is required); moreover, this case (and many more) were erroneous in Ada 2005 and before, so we're just restoring the previous semantics.<br /></Admonition>

<Admonition type="aarm" aarm="correction" title="Correction:">
{"{"}<em>{"AI12-0232-1"}</em>{"}"} <strong><br /></strong> Explicitly stated that the pure and preelaborate rules are recursive; that is, they apply to the contents of nested packages and generic packages.<br /></Admonition>

<Admonition type="aarm" aarm="note" title="Note: ">
{"{"}<em>{"AI12-0417-1"}</em>{"}"} <br />The pragmas that set aspects (Pure, Preelaborate, Elaborate_Body) are now obsolescent. <br /></Admonition>

