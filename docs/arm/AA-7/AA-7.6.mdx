---
sidebar_position:  65
---

# 7.6 Assignment and Finalization

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[ Three kinds of actions are fundamental to the manipulation of objects: initialization, finalization, and assignment. Every object is initialized, either explicitly or by default, after being created (for example, by an <code><a href="../AA-3/AA-3.3#S0032">object_declaration</a></code> or <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>). Every object is finalized before being destroyed (for example, by leaving a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> containing an <code><a href="../AA-3/AA-3.3#S0032">object_declaration</a></code>, or by a call to an instance of Unchecked_Deallocation). An assignment operation is used as part of <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>s, explicit initialization, parameter passing, and other operations. <br /></p>

<MarginText>2</MarginText>
<p>Default definitions for these three fundamental operations are provided by the language, but a <em>controlled</em> type gives the user additional control over parts of these operations. In particular, the user can define, for a controlled type, an Initialize procedure which is invoked immediately after the normal default initialization of a controlled object, a Finalize procedure which is invoked immediately before finalization of any of the components of a controlled object, and an Adjust procedure which is invoked as the last step of an assignment to a (nonlimited) controlled object.] <br /></p>

<AnnotatedOnly>
<MarginText>2.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>controlled type</strong> &mdash; type that supports user-defined assignment and finalization<br /><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b/2</MarginText>
<MarginInfo items={["AI95-00114-01", "AI95-00287-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Here's the basic idea of initialization, value adjustment, and finalization, whether or not user defined: When an object is created, if it is explicitly assigned an initial value, the object is either built-in-place from an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call (in which case neither Adjust nor Initialize is applied), or the assignment copies and adjusts the initial value. Otherwise, Initialize is applied to it (except in the case of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> as a whole). An <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> finalizes the target before copying in and adjusting the new value. Whenever an object goes away, it is finalized. Calls on Initialize and Adjust happen bottom-up; that is, components first, followed by the containing object. Calls on Finalize happen top-down; that is, first the containing object, and then its components. These ordering rules ensure that any components will be in a well-defined state when Initialize, Adjust, or Finalize is applied to the containing object. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>3</MarginText>
<p>The following language-defined library package exists: <br /></p>

<MarginText>4/5</MarginText>
<MarginInfo items={["AI95-00126-01", "AI05-0212-1", "AI12-0241-1"]} />
<CodeBlock language="ada">
{"{"}8652/0020{"}"} package Ada.Finalization {"\n"}    with Pure, Nonblocking ={">"} False is {"\n"}
<MarginText>5/5</MarginText>
<MarginInfo items={["AI95-00161-01", "AI12-0399-1"]} />
    type Controlled is abstract tagged private {"\n"}       with  Preelaborable_Initialization ;{"\n"}
<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
    procedure Initialize (Object : in out Controlled) is null;{"\n"}    procedure Adjust     (Object : in out Controlled) is null;{"\n"}    procedure Finalize   (Object : in out Controlled) is null;{"\n"}
<MarginText>7/5</MarginText>
<MarginInfo items={["AI95-00161-01", "AI12-0399-1"]} />
    type Limited_Controlled is abstract tagged limited private {"\n"}       with  Preelaborable_Initialization ;{"\n"}
<MarginText>8/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
    procedure Initialize (Object : in out Limited_Controlled) is null;{"\n"}    procedure Finalize   (Object : in out Limited_Controlled) is null;{"\n"}private{"\n"}    ... -- not specified by the language{"\n"}end Ada.Finalization;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>8.a/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This package must allow blocking (Nonblocking ={">"} False) for compatibility. The purpose of this package is to provide a template for overriding user-defined routines; and such routines can only allow blocking if the root type does so. Users can still declare their overridding routines nonblocking if they wish. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<p>A controlled type is a descendant of Controlled or Limited_Controlled. The predefined "=" operator of type Controlled always returns True, [since this operator is incorporated into the implementation of the predefined equality operator of types derived from Controlled, as explained in <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>.] The type Limited_Controlled is like Controlled, except that it is limited and it lacks the primitive subprogram Adjust. <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We say &ldquo;nonlimited controlled type&rdquo; (rather than just &ldquo;controlled type&rdquo;;) when we want to talk about descendants of Controlled only. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We considered making Adjust and Finalize abstract. However, a reasonable coding convention is e.g. for Finalize to always call the parent's Finalize after doing whatever work is needed for the extension part. (Unlike CLOS, we have no way to do that automatically in Ada 95.) For this to work, Finalize cannot be abstract. In a generic unit, for a generic formal abstract derived type whose ancestor is Controlled or Limited_Controlled, calling the ancestor's Finalize would be illegal if it were abstract, even though the actual type might have a concrete version.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.c</MarginText>
<Admonition type="aarm" aarm="note">
Types Controlled and Limited_Controlled are abstract, even though they have no abstract primitive subprograms. It is not clear that they need to be abstract, but there seems to be no harm in it, and it might make an implementation's life easier to know that there are no objects of these types &mdash; in case the implementation wishes to make them &ldquo;magic&rdquo; in some way.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.d/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
For Ada 2005, we considered making these types interfaces. That would have the advantage of allowing them to be added to existing trees. But that was rejected both because it would cause massive disruptions to existing implementations, and because it would be very incompatible due to the "no hidden interfaces" rule. The latter rule would prevent a tagged private type from being completed with a derivation from Controlled or Limited_Controlled &mdash; a very common idiom. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9.1/2</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<p>A type is said to <em>need finalization</em> if:<br /></p>

<MarginText>9.2/2</MarginText>
<ul>
<li>it is a controlled type, a task type or a protected type; or<br /></li>
<MarginText>9.3/3</MarginText>
<MarginInfo items={["AI05-0092-1"]} />
<li>it has a component whose type needs finalization; or<br /></li>
<MarginText>9.4/3</MarginText>
<MarginInfo items={["AI05-0013-1"]} />
<li>it is a class-wide type; or<br /></li>
<MarginText>9.5/3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<li>it is a partial view whose full view needs finalization; or<br /></li>
<MarginText>9.6/2</MarginText>
<li>it is one of a number of language-defined types that are explicitly defined to need finalization.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>9.e/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The fact that a type needs finalization does not require it to be implemented with a controlled type. It just has to be recognized by the No_Nested_Finalization restriction.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.f/2</MarginText>
<Admonition type="aarm" aarm="note">
This property is defined for the type, not for a particular view. That's necessary as restrictions look in private parts to enforce their restrictions; the point is to eliminate all controlled parts, not just ones that are visible. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00373-01"]} />
<p>During the elaboration or evaluation of a construct that causes an object to be initialized by default, for every controlled subcomponent of the object that is not assigned an initial value (as defined in <a href="../AA-3/AA-3.3#Subclause_3.3.1">3.3.1</a>), Initialize is called on that subcomponent. Similarly, if the object that is initialized by default as a whole is controlled, Initialize is called on the object.<br /></p>

<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00182-01", "AI95-00373-01"]} />
<p>{"{"}<em>8652/0021</em>{"}"} For an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code> whose <code><a href="../AA-4/AA-4.3#S0112">ancestor_part</a></code> is a <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denoting a controlled subtype, the Initialize procedure of the ancestor type is called, unless that Initialize procedure is abstract. <br /></p>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b</MarginText>
<CodeBlock language="ada">
type T1 is new Controlled with{"\n"}    record{"\n"}        ... -- some components might have defaults{"\n"}    end record;{"\n"}
<MarginText>11.c</MarginText>
type T2 is new Controlled with{"\n"}    record{"\n"}        X : T1; -- no default{"\n"}        Y : T1 := ...; -- default{"\n"}    end record;{"\n"}
<MarginText>11.d</MarginText>
A : T2;{"\n"}B : T2 := ...;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.e</MarginText>
<Admonition type="aarm" aarm="note">
As part of the elaboration of A's declaration, A.Y is assigned a value; therefore Initialize is not applied to A.Y. Instead, Adjust is applied to A.Y as part of the assignment operation. Initialize is applied to A.X and to A, since those objects are not assigned an initial value. The assignment to A.Y is not considered an assignment to A.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.f</MarginText>
<Admonition type="aarm" aarm="note">
For the elaboration of B's declaration, Initialize is not called at all. Instead the assignment adjusts B's value; that is, it applies Adjust to B.X, B.Y, and B.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.f.1/2</MarginText>
<MarginInfo items={["AI95-00182-01", "AI95-00373-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0021</em>{"}"} The <code><a href="../AA-4/AA-4.3#S0112">ancestor_part</a></code> of an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code>, {"<"}{">"} in aggregates, and the return object of an <code><a href="../AA-6/AA-6.5#S0225">extended_return_statement</a></code> are handled similarly. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12</MarginText>
<p>Initialize and other initialization operations are done in an arbitrary order, except as follows. Initialize is applied to an object after initialization of its subcomponents, if any [(including both implicit initialization and Initialize calls)]. If an object has a component with an access discriminant constrained by a per-object expression, Initialize is applied to this component after any components that do not have such discriminants. For an object with several components with such a discriminant, Initialize is applied to them in order of their <code><a href="../AA-3/AA-3.8#S0070">component_declaration</a></code>s. For an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>, any task activations follow all calls on Initialize. <br /></p>

<AnnotatedOnly>
<MarginText>12.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The fact that Initialize is done for subcomponents first allows Initialize for a composite object to refer to its subcomponents knowing they have been properly initialized.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.b</MarginText>
<Admonition type="aarm" aarm="note">
The fact that Initialize is done for components with access discriminants after other components allows the Initialize operation for a component with a self-referential access discriminant to assume that other components of the enclosing object have already been properly initialized. For multiple such components, it allows some predictability. <br /></Admonition>
</AnnotatedOnly>

<MarginText>13</MarginText>
<p>When a target object with any controlled parts is assigned a value, [either when created or in a subsequent <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>,] the <em>assignment operation</em> proceeds as follows: <br /></p>

<MarginText>14</MarginText>
<ul>
<li>The value of the target becomes the assigned value.<br /></li>
<MarginText>15</MarginText>
<li>The value of the target is <em>adjusted.</em> <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>15.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>If any parts of the object are controlled, abort is deferred during the assignment operation. <br /></Admonition>
</AnnotatedOnly>

<MarginText>16/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<p>To adjust the value of a composite object, the values of the components of the object are first adjusted in an arbitrary order, and then, if the object is nonlimited controlled, Adjust is called. Adjusting the value of an elementary object has no effect[, nor does adjusting the value of a composite object with no controlled parts.] <br /></p>

<AnnotatedOnly>
<MarginText>16.a/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Adjustment is never actually performed for values of an immutably limited type, since all assignment operations for such types are required to be built-in-place. Even so, we still define adjustment for all types in order that the canonical semantics is well-defined. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The verbiage in the Initialize rule about access discriminants constrained by per-object expressions is not necessary here, since such types are either limited or do not have defaults, so the discriminant can only be changed by an assignment to an outer object. Such an assignment could happen only before any adjustments or (if part of an outer Adjust) only after any inner (component) adjustments have completed. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17</MarginText>
<p>For an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>,[ after the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> and <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> have been evaluated, and any conversion (including constraint checking) has been done,] an anonymous object is created, and the value is assigned into it; [that is, the assignment operation is applied]. [(Assignment includes value adjustment.)] The target of the <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> is then finalized. The value of the anonymous object is then assigned into the target of the <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>. Finally, the anonymous object is finalized. [As explained below, the implementation may eliminate the intermediate anonymous object, so this description subsumes the one given in <a href="../AA-5/AA-5.2">5.2</a>, &ldquo;<a href="../AA-5/AA-5.2">Assignment Statements</a>&rdquo;.] <br /></p>

<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>An alternative design for user-defined assignment might involve an Assign operation instead of Adjust: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.b</MarginText>
<CodeBlock language="ada">
procedure Assign(Target : in out Controlled; Source : in out Controlled);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.c</MarginText>
<Admonition type="aarm" aarm="note">
Or perhaps even a syntax like this: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.d</MarginText>
<CodeBlock language="ada">
procedure ":="(Target : in out Controlled; Source : in out Controlled);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.e</MarginText>
<Admonition type="aarm" aarm="note">
Assign (or ":=") would have the responsibility of doing the copy, as well as whatever else is necessary. This would have the advantage that the Assign operation knows about both the target and the source at the same time &mdash; it would be possible to do things like reuse storage belonging to the target, for example, which Adjust cannot do. However, this sort of design would not work in the case of unconstrained discriminated variables, because there is no way to change the discriminants individually. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.f</MarginText>
<CodeBlock language="ada">
type Mutable(D : Integer := 0) is{"\n"}    record{"\n"}        X : Array_Of_Controlled_Things(1..D);{"\n"}        case D is{"\n"}            when 17 ={">"} Y : Controlled_Thing;{"\n"}            when others ={">"} null;{"\n"}        end D;{"\n"}    end record;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.g</MarginText>
<Admonition type="aarm" aarm="note">
An assignment to an unconstrained variable of type Mutable can cause some of the components of X, and the component Y, to appear and/or disappear. There is no way to write the Assign operation to handle this sort of case.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.h</MarginText>
<Admonition type="aarm" aarm="note">
Forbidding such cases is not an option &mdash; it would cause generic contract model violations. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.1/5</MarginText>
<MarginInfo items={["AI05-0067-1", "AI12-0439-1"]} />
<p>When a function call or <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> is used to initialize an object, the result of the function call or <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> is an anonymous object, which is assigned into the newly-created object. For such an assignment, the anonymous object may  be <em>built in place</em>, in which case the assignment does not involve any copying. Under certain circumstances, the anonymous object is required to be built in place. In particular:<br /></p>

<AnnotatedOnly>
<MarginText>17.i/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>We say assignment to built-in-place objects does not involve copying, which matches the intended implementation (see below). Of course, the implementation can do any copying it likes, if it can make such copying semantically invisible (by patching up access values to point to the copy, and so forth). <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.2/3</MarginText>
<ul>
<li>If the full type of any part of the object is immutably limited, the anonymous object is built in place.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.j/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We talk about the full types being immutably limited, as this is independent of the view of a type (in the same way that it is for determining the technique of parameter passing). That is, privacy is ignored for this purpose.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.k/3</MarginText>
<MarginInfo items={["AI05-0005-1", "AI05-0067-1"]} />
<Admonition type="aarm" aarm="note">
For function calls, we only require building in place for immutably limited types. These are the types that would have been return-by-reference types in Ada 95. We limited the requirement because we want to minimize disruption to Ada 95 implementations and users. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.l/5</MarginText>
<MarginInfo items={["AI05-0232-1", "AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This is a dynamic property and is determined by the specific type of the parts of the actual object. In particular, if a part has a class-wide type, the tag of the object might need to be examined in order to determine if build-in-place is required. However, we expect that most Ada implementations will determine this property at compile-time using some assume-the-worst algorithm in order to choose  the appropriate method to implement a given call or aggregate. In addition, there is no attribute or other method for a program to determine if a particular object has this property (or not), so there is no value to a more careful description of this rule. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.3/3</MarginText>
<ul>
<li>In the case of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>, if the full type of any part of the newly-created object is controlled, the anonymous object is built in place.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.m/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This is necessary to prevent elaboration problems with deferred constants of controlled types. Consider: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.m.1/3</MarginText>
<CodeBlock language="ada">
package P is{"\n"}   type Dyn_String is private;{"\n"}   Null_String : constant Dyn_String;{"\n"}   ...{"\n"}private{"\n"}   type Dyn_String is new Ada.Finalization.Controlled with ...{"\n"}   procedure Finalize(X : in out Dyn_String);{"\n"}   procedure Adjust(X : in out Dyn_String);{"\n"}{"\n"}   Null_String : constant Dyn_String :={"\n"}      (Ada.Finalization.Controlled with ...);{"\n"}   ...{"\n"}end P;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.m.2/3</MarginText>
<Admonition type="aarm" aarm="note">
When Null_String is elaborated, the bodies of Finalize and Adjust clearly have not been elaborated. Without this rule, this declaration would necessarily raise Program_Error (unless the permissions given below are used by the implementation). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.n/3</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>An <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> with a controlled part used in the return expression of a <code><a href="../AA-6/AA-6.5#S0222">simple_return_statement</a></code> has to be built in place in the anonymous return object, as this is similar to an object declaration. (This is a change from Ada 95, but it is not an inconsistency as it only serves to restrict implementation choices.) But this only covers the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>; a separate anonymous return object can still be used unless it too is required to be built in place.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.o/3</MarginText>
<Admonition type="aarm" aarm="note">
Similarly, an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> that has a controlled part but is not itself controlled and that is used to initialize an object also has to be built in place. This is also a change from Ada 95, but it is not an inconsistency as it only serves to restrict implementation choices. This avoids problems if a type like Dyn_String (in the example above) is used as a component in a type used as a deferred constant in package P. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.4/3</MarginText>
<ul>
<li>In other cases, it is unspecified whether the anonymous object is built in place.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.p/3</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This is left unspecified so the implementation can use any appropriate criteria for determining when to build in place. That includes making the decision on a call-by-call basis. Reasonable programs will not care what decision is made here anyway. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.5/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<p>Notwithstanding what this document says elsewhere, if an object is built in place:<br /></p>

<MarginText>17.6/3</MarginText>
<ul>
<li>Upon successful completion of the return statement or <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>, the anonymous object <em>mutates into</em> the newly-created object; that is, the anonymous object ceases to exist, and the newly-created object appears in its place.<br /></li>
<MarginText>17.7/3</MarginText>
<li>Finalization is not performed on the anonymous object.<br /></li>
<MarginText>17.8/3</MarginText>
<li>Adjustment is not performed on the newly-created object.<br /></li>
<MarginText>17.9/3</MarginText>
<li>All access values that designate parts of the anonymous object now designate the corresponding parts of the newly-created object.<br /></li>
<MarginText>17.10/3</MarginText>
<li>All renamings of parts of the anonymous object now denote views of the corresponding parts of the newly-created object.<br /></li>
<MarginText>17.11/3</MarginText>
<li>Coextensions of the anonymous object become coextensions of the newly-created object. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.q/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This &ldquo;mutating&rdquo; does not necessarily happen atomically with respect to abort and other tasks. For example, if a function call is used as the ancestor  part of an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code>, then the tag of the anonymous object (the function result) will be different from the tag of the newly-created object (the ancestor  part of the <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code>). In implementation terms, this involves modifying the tag field. If the current task is aborted during this modification, the object might become abnormal. Likewise, if some other task accesses the tag field during this modification, it constitutes improper use of shared variables, and is erroneous. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.r/3</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>The intended implementation is that the anonymous object is allocated at the same address as the newly-created object. Thus, no run-time action is required to cause all the access values and renamings to point to the right place. They just point to the newly-created object, which is what the return object has magically &ldquo;mutated into&rdquo;.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.s/3</MarginText>
<Admonition type="aarm" aarm="note">
There is no requirement that 'Address of the return object is equal to 'Address of the newly-created object, but that will be true in the intended implementation.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.t/3</MarginText>
<Admonition type="aarm" aarm="note">
For a function call, if the size of the newly-created object is known at the call site, the object is allocated there, and the address is implicitly passed to the function; the return object is created at that address. Otherwise, a storage pool is implicitly passed to the function; the size is determined at the point of the return statement, and passed to the Allocate procedure. The address returned by the storage pool is returned from the function, and the newly-created object uses that same address. If the return statement is left without returning (via an exception or a goto, for example), then Deallocate is called.  The storage pool might be a dummy pool that represents &ldquo;allocate on the stack&rdquo;.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.u/3</MarginText>
<Admonition type="aarm" aarm="note">
The Tag of the newly-created object may be different from that of the result object. Likewise, the master and accessibility level may be different.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.v/3</MarginText>
<Admonition type="aarm" aarm="note">
An alternative implementation model might allow objects to move around to different addresses. In this case, access values and renamings would need to be modified at run time. It seems that this model requires the full power of tracing garbage collection. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>18/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<p>An implementation is allowed to relax the above rules for <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>s in the following ways: <br /></p>

<AnnotatedOnly>
<MarginText>18.a/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b/5</MarginText>
<MarginInfo items={["AI05-0067-1", "AI12-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The relaxations apply only to nonlimited types, as <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>s are not allowed for limited types. This is important so that the programmer can count on  stricter semantics for limited controlled types. <br /></Admonition>
</AnnotatedOnly>

<MarginText>19/5</MarginText>
<MarginInfo items={["AI05-0067-1", "AI12-0444-1"]} />
<ul>
<li>If an object is assigned the value of that same object, the implementation may omit the entire assignment . <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>In other words, even if an object is controlled and a combination of Finalize and Adjust on the object might have a net side effect, they need not be performed. <br /></Admonition>
</AnnotatedOnly>

<MarginText>20/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<ul>
<li>For assignment of a noncontrolled type, the implementation may finalize and assign each component of the variable separately (rather than finalizing the entire variable and assigning the entire new value) unless a discriminant of the variable is changed by the assignment. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>20.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>For example, in a slice assignment, an anonymous object is not necessary if the slice is copied component-by-component in the right direction, since array types are not controlled (although their components may be). Note that the direction, and even the fact that it's a slice assignment, can in general be determined only at run time. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This potentially breaks a single assignment operation into many, and thus abort deferral (see <a href="../AA-9/AA-9.8">9.8</a>) needs to last only across an individual component assignment when the component has a controlled part. It is only important that the copy step is not separated (by an abort) from the adjust step, so aborts between component assignments is not harmful. <br /></Admonition>
</AnnotatedOnly>

<MarginText>21/5</MarginText>
<MarginInfo items={["AI95-00147-01", "AI05-0067-1", "AI12-0444-1"]} />
<ul>
<li>The implementation may avoid creating  an anonymous object if the value being assigned is the result of evaluating a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> denoting an object (the source object) whose storage cannot overlap with the target. If the source object can  overlap with the target object, then the implementation can avoid the need for an intermediary anonymous object by exercising one of the above permissions and perform the assignment one component at a time (for an overlapping array assignment), or not at all (for an assignment where the target and the source of the assignment are the same object). <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>21.a/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If the anonymous object is eliminated by this permission,  there is no anonymous object to be finalized and thus the Finalize call on it is eliminated.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b/3</MarginText>
<MarginInfo items={["AI95-00147-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
Note that if the anonymous object is eliminated but the new value is not built in place in the target object, that Adjust must be called directly on the target object as the last step of the assignment, since some of the subcomponents may be self-referential or otherwise position-dependent. This Adjust can be eliminated only by using one of the following permissions. <br /></Admonition>
</AnnotatedOnly>

<MarginText>22/2</MarginText>
<MarginInfo items={["AI95-00147-01"]} />
<p>Furthermore, an implementation is permitted to omit implicit Initialize, Adjust, and Finalize calls and associated assignment operations on an object of a nonlimited controlled type provided that:<br /></p>

<MarginText>23/2</MarginText>
<ul>
<li>any omitted Initialize call is not a call on a user-defined Initialize procedure, and <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>23.a/2</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This does not apply to any calls to a user-defined Initialize routine that happen to occur in an Adjust or Finalize routine. It is intended that it is never necessary to look inside of an Adjust or Finalize routine to determine if the call can be omitted. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.b/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We don't want to eliminate objects for which the Initialize might have side effects (such as locking a resource). <br /></Admonition>
</AnnotatedOnly>

<MarginText>24/2</MarginText>
<ul>
<li>any usage of the value of the object after the implicit Initialize or Adjust call and before any subsequent Finalize call on the object does not change the external effect of the program, and<br /></li>
<MarginText>25/2</MarginText>
<li>after the omission of such calls and operations, any execution of the program that executes an Initialize or Adjust call on an object or initializes an object by an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> will also later execute a Finalize call on the object and will always do so prior to assigning a new value to the object, and<br /></li>
<MarginText>26/2</MarginText>
<li>the assignment operations associated with omitted Adjust calls are also omitted. <br /></li>
</ul>
<MarginText>27/2</MarginText>
<p>This permission applies to Adjust and Finalize calls even if the implicit calls have additional external effects. <br /></p>

<AnnotatedOnly>
<MarginText>27.a/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The goal of the above permissions is to allow typical dead assignment and dead variable removal algorithms to work for nonlimited controlled types. We require that &ldquo;pairs&rdquo; of Initialize/Adjust/Finalize operations are removed. (These aren't always pairs, which is why we talk about &ldquo;any execution of the program&rdquo;.) <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.b</MarginText>
<Admonition type="aarm" aarm="note">
Controlled types and user-defined finalization are new to Ada 95. (Ada 83 had finalization semantics only for masters of tasks.) <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.c/2</MarginText>
<MarginInfo items={["AI95-00161-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Types Controlled and Limited_Controlled now have Preelaborable_Initialization, so that objects of types derived from these types can be used in preelaborated packages. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.d/2</MarginText>
<MarginInfo items={["AI95-00126-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0020</em>{"}"} <strong>Corrigendum:</strong> Clarified that Ada.Finalization is a remote types package.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.e/2</MarginText>
<MarginInfo items={["AI95-00182-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0021</em>{"}"} <strong>Corrigendum:</strong> Added wording to clarify that the default initialization (whatever it is) of an ancestor part is used.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.f/2</MarginText>
<MarginInfo items={["AI95-00083-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0022</em>{"}"} <strong>Corrigendum:</strong> Clarified that Adjust is never called on an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> used for the initialization of an object or subaggregate, or passed as a parameter.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.g/2</MarginText>
<MarginInfo items={["AI95-00147-01"]} />
<Admonition type="aarm" aarm="note">
Additional optimizations are allowed for nonlimited controlled types. These allow traditional dead variable elimination to be applied to such types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.h/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="note">
Corrected the build-in-place requirement for controlled <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s to be consistent with the requirements for limited types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.i/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<Admonition type="aarm" aarm="note">
The operations of types Controlled and Limited_Controlled are now declared as null procedures (see <a href="../AA-6/AA-6.7">6.7</a>) to make the semantics clear (and to provide a good example of what null procedures can be used for).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.j/2</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<Admonition type="aarm" aarm="note">
Types that need finalization are defined; this is used by the No_Nested_Finalization restriction (see <a href="../AA-D/AA-D.7">D.7</a>, &ldquo;<a href="../AA-D/AA-D.7">Tasking Restrictions</a>&rdquo;).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.k/2</MarginText>
<MarginInfo items={["AI95-00373-01"]} />
<Admonition type="aarm" aarm="note">
Generalized the description of objects that have Initialize called for them to say that it is done for all objects that are initialized by default. This is needed so that all of the new cases are covered. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.l/3</MarginText>
<MarginInfo items={["AI05-0212-1"]} />
<Admonition type="aarm" aarm="note">
Package Ada.Finalization now has Pure categorization, so it can be mentioned for any package. Note that this does not change the preelaborability of objects descended from Controlled and Limited_Controlled. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.m/3</MarginText>
<MarginInfo items={["AI05-0013-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Eliminated coextensions from the &ldquo;needs finalization&rdquo; rules, as this cannot be determined in general in the compilation unit that declares the type. (The designated type of the coextension may have been imported as a limited view.) Uses of &ldquo;needs finalization&rdquo; need to ensure that coextensions are handled by other means (such as in No_Nested_Finalization &ndash; see <a href="../AA-D/AA-D.7">D.7</a>) or that coextensions cannot happen.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.n/3</MarginText>
<MarginInfo items={["AI05-0013-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Corrected the &ldquo;needs finalization&rdquo; rules to include class-wide types, as a future extension can include a part that needs finalization.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.o/3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Corrected the &ldquo;needs finalization&rdquo; rules to clearly say that they ignore privacy.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.p/3</MarginText>
<MarginInfo items={["AI05-0067-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Changed &ldquo;built in place&rdquo; to Dynamic Semantics and centralized the rules here. This eliminates the fiction that built in place is just a combination of a permission and a requirement; it clearly has noticeable semantic effects. This wording change is not intended to change the semantics of any correct Ada program. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_7.6.1"></a>

## 7.6.1  Completion and Finalization

<MarginText>1</MarginText>
<p>[This subclause defines <em>completion</em> and <em>leaving</em> of the execution of constructs and entities. A <em>master</em> is the execution of a construct that includes finalization of local objects after it is complete (and after waiting for any local tasks &mdash; see <a href="../AA-9/AA-9.3">9.3</a>), but before leaving. Other constructs and entities are left immediately upon completion. ]<br /></p>


#### Dynamic Semantics

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<p>The execution of a construct or entity is <em>complete</em> when the end of that execution has been reached, or when a transfer of control (see <a href="../AA-5/AA-5.1">5.1</a>) causes it to be abandoned. Completion due to reaching the end of execution, or due to the transfer of control of an <code><a href="../AA-5/AA-5.7#S0193">exit_statement</a></code>, return statement, <code><a href="../AA-5/AA-5.8#S0194">goto_statement</a></code>, or <code><a href="../AA-9/AA-9.5#S0265">requeue_statement</a></code> or of the selection of a <code><a href="../AA-9/AA-9.7#S0275">terminate_alternative</a></code> is <em>normal completion</em>. Completion is <em>abnormal</em> otherwise [&mdash; when control is transferred out of a construct due to abort or the raising of an exception]. <br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Don't confuse the run-time concept of completion with the compile-time concept of completion defined in <a href="../AA-3/AA-3.11#Subclause_3.11.1">3.11.1</a>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI95-00162-01", "AI95-00416-01", "AI12-0406-1"]} />
<p>After execution of a construct or entity is complete, it is <em>left</em>, meaning that execution continues with the next action, as defined for the execution that is taking place. Leaving an execution happens immediately after its completion, except in the case of the execution of a <em>master construct</em> :  a body other than a <code><a href="../AA-7/AA-7.2#S0231">package_body</a></code>;  a <code><a href="../AA-5/AA-5.1#S0167">statement</a></code>; or  an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>, <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>, or <code><a href="../AA-3/AA-3.5#S0037">range</a></code> that is not part of an enclosing <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>, <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>, <code><a href="../AA-3/AA-3.5#S0037">range</a></code>, or <code><a href="../AA-5/AA-5.1#S0168">simple_statement</a></code> other than a <code><a href="../AA-6/AA-6.5#S0222">simple_return_statement</a></code>. The term <em>master</em> by itself refers to the execution of a master construct. A master is finalized after it is complete, and before it is left.<br /></p>

<AnnotatedOnly>
<MarginText>3.a/2</MarginText>
<MarginInfo items={["AI95-00162-01", "AI95-00416-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong><code><a href="../AA-4/AA-4.4#S0132">Expression</a></code>s and <code><a href="../AA-5/AA-5.1#S0167">statement</a></code>s are masters so that objects created by subprogram calls (in <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s, <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s for anonymous access-to-object types, and so on) are finalized and have their tasks awaited before the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s or <code><a href="../AA-5/AA-5.1#S0167">statement</a></code>s are left. Note that <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s like the <code><a href="../AA-4/AA-4.5#S0150">condition</a></code> of an <code><a href="../AA-5/AA-5.3#S0175">if_statement</a></code> are masters, because they are not enclosed by a <code><a href="../AA-5/AA-5.1#S0168">simple_statement</a></code>. Similarly, a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> which is renamed is a master, as it is not in a <code><a href="../AA-5/AA-5.1#S0168">simple_statement</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<Admonition type="aarm" aarm="note">
We have to include <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>s in the contexts that do not cause masters to occur so that <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s contained in a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> (that is not part of an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> or <code><a href="../AA-5/AA-5.1#S0168">simple_statement</a></code>) do not individually become masters. We certainly do not want the parameter <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s of a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> to be separate masters, as they would then be finalized before the function is called. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.c/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The fact that a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> is a master does not change the accessibility of the return object denoted by the <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>; that depends on the use of the <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>. The <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> is the master of any short-lived entities (such as <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s used as parameters of types with task or controlled parts). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.d/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>master</strong> &mdash; execution of a master construct<br /><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.e/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>master construct</strong> &mdash; one of certain executable constructs for which there can be objects or tasks whose lifetime ends when the construct completes<br /><br /></Admonition>
</AnnotatedOnly>

<MarginText>4</MarginText>
<p>For the <em>finalization</em> of a master, dependent tasks are first awaited, as explained in <a href="../AA-9/AA-9.3">9.3</a>. Then each object whose accessibility level is the same as that of the master is finalized if the object was successfully initialized and still exists. [These actions are performed whether the master is left by reaching the last statement or via a transfer of control.] When a transfer of control causes completion of an execution, each included master is finalized in order, from innermost outward. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>As explained in <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>, the set of objects with the same accessibility level as that of the master includes objects declared immediately within the master, objects declared in nested packages, objects created by <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s (if the ultimate ancestor access type is declared in one of those places) and subcomponents of all of these things. If an object was already finalized by Unchecked_Deallocation, then it is not finalized again when the master is left.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that any object whose accessibility level is deeper than that of the master would no longer exist; those objects would have been finalized by some inner master. Thus, after leaving a master, the only objects yet to be finalized are those whose accessibility level is less deep than that of the master.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.c</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>Subcomponents of objects due to be finalized are not finalized by the finalization of the master; they are finalized by the finalization of the containing object. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.d</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We need to finalize subcomponents of objects even if the containing object is not going to get finalized because it was not fully initialized. But if the containing object is finalized, we don't want to require repeated finalization of the subcomponents, as might normally be implied by the recursion in finalization of a master and the recursion in finalization of an object. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.e</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>Formally, completion and leaving refer to executions of constructs or entities. However, the standard sometimes (informally) refers to the constructs or entities whose executions are being completed. Thus, for example, &ldquo;the subprogram call or task is complete&rdquo; really means &ldquo;<em>the execution of</em> the subprogram call or task is complete&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5</MarginText>
<p>For the <em>finalization</em> of an object: <br /></p>

<MarginText>6/3</MarginText>
<MarginInfo items={["AI05-0099-1"]} />
<ul>
<li>If the full type of the object is an elementary type, finalization has no effect; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>6.a/3</MarginText>
<MarginInfo items={["AI05-0099-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We say &ldquo;full type&rdquo; in this and the following bullets as privacy is ignored for the purpose of determining the finalization actions of an object; that is as expected for Dynamic Semantics rules. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7/3</MarginText>
<MarginInfo items={["AI05-0099-1"]} />
<ul>
<li>If the full type of the object is a tagged type, and the tag of the object identifies a controlled type, the Finalize procedure of that controlled type is called;<br /></li>
<MarginText>8/3</MarginText>
<MarginInfo items={["AI05-0099-1"]} />
<li>If the full type of the object is a protected type, or if the full type of the object is a tagged type and the tag of the object identifies a protected type, the actions defined in <a href="../AA-9/AA-9.4">9.4</a> are performed;<br /></li>
<MarginText>9/3</MarginText>
<MarginInfo items={["AI95-00416-01", "AI05-0099-1"]} />
<li>If the full type of the object is a composite type, then after performing the above actions, if any, every component of the object is finalized in an arbitrary order, except as follows: if the object has a component with an access discriminant constrained by a per-object expression, this component is finalized before any components that do not have such discriminants; for an object with several components with such a discriminant, they are finalized in the reverse of the order of their <code><a href="../AA-3/AA-3.8#S0070">component_declaration</a></code>s; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This allows the finalization of a component with an access discriminant to refer to other components of the enclosing object prior to their being finalized. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b/4</MarginText>
<MarginInfo items={["AI05-0099-1", "AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>The components discussed here are all of the components that the object actually has, not just those components that are statically identified by the type of the object. These can be different if the object has a class-wide type. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9.1/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<ul>
<li>If the object has coextensions (see <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>), each coextension is finalized after the object whose access discriminant designates it.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>9.c/3</MarginText>
<MarginInfo items={["AI05-0066-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>In the case of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call that is used (in its entirety) to directly initialize a part of an object, the coextensions of the result of evaluating the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call are transfered to become coextensions of the object being initialized and are not finalized until the object being initialized is ultimately finalized, even if an anonymous object is created as part of the operation. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10</MarginText>
<p>Immediately before an instance of Unchecked_Deallocation reclaims the storage of an object, the object is finalized. [If an instance of Unchecked_Deallocation is never applied to an object created by an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>, the object will still exist when the corresponding master completes, and it will be finalized then.]<br /></p>

<MarginText>11/3</MarginText>
<MarginInfo items={["AI95-00280-01", "AI05-0051-1", "AI05-0190-1"]} />
<p>The finalization of a master performs finalization of objects created by declarations in the master in the reverse order of their creation. After the finalization of a master is complete, the objects finalized as part of its finalization cease to <em>exist</em>, as do any types and subtypes defined and created within the master. <br /></p>

<AnnotatedOnly>
<MarginText>11.a/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.c/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.d/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.e</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that a deferred constant declaration does not create the constant; the full constant declaration creates it. Therefore, the order of finalization depends on where the full constant declaration occurs, not the deferred constant declaration.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.f</MarginText>
<Admonition type="aarm" aarm="note">
An imported object is not created by its declaration. It is neither initialized nor finalized. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.g</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>An implementation has to ensure that the storage for an object is not reclaimed when references to the object are still possible (unless, of course, the user explicitly requests reclamation via an instance of Unchecked_Deallocation). This implies, in general, that objects cannot be deallocated one by one as they are finalized; a subsequent finalization might reference an object that has been finalized, and that object had better be in its (well-defined) finalized state. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11.1/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<p>Each nonderived access type <em>T</em> has an associated <em>collection</em>, which is the set of objects created by <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s of <em>T</em>, or of types derived from <em>T</em>. Unchecked_Deallocation removes an object from its collection. Finalization of a collection consists of finalization of each object in the collection, in an arbitrary order. The collection of an access type is an object implicitly declared at the following place:<br /></p>

<AnnotatedOnly>
<MarginText>11.h/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The place of the implicit declaration determines when allocated objects are finalized. For multiple collections declared at the same place, we do not define the order of their implicit declarations.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.i/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
Finalization of allocated objects is done according to the (ultimate ancestor) <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> type, not according to the storage pool in which they are allocated. Pool finalization might reclaim storage (see <a href="../AA-13/AA-13.11">13.11</a>, &ldquo;<a href="../AA-13/AA-13.11">Storage Management</a>&rdquo;), but has nothing (directly) to do with finalization of the pool elements.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.j/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
Note that finalization is done only for objects that still exist; if an instance of Unchecked_Deallocation has already gotten rid of a given pool element, that pool element will not be finalized when the master is left. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.k/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>Note that we talk about the type of the <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> here. There may be access values of a (general) access type pointing at objects created by <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s for some other type; these are not (necessarily) finalized at this point. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11.2/3</MarginText>
<ul>
<li>For a named access type, the first freezing point (see <a href="../AA-13/AA-13.14">13.14</a>) of the type.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>11.l/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The freezing point of the ultimate ancestor access type is chosen because before that point, pool elements cannot be created, and after that point, access values designating (parts of) the pool elements can be created. This is also the point after which the pool object cannot have been declared. We don't want to finalize the pool elements until after anything finalizing objects that contain access values designating them. Nor do we want to finalize pool elements after finalizing the pool object itself. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11.3/3</MarginText>
<ul>
<li>For the type of an access parameter, the call that contains the <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>.<br /></li>
<MarginText>11.4/3</MarginText>
<li>For the type of an access result, within the master of the call (see <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>). <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>11.m/3</MarginText>
<MarginInfo items={["AI05-0005-1", "AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>We mean at a place within the master consistent with the execution of the call within the master. We don't say that normatively, as it is difficult to explain that when the master of the call need not be the master that immediately includes the call (such as when an anonymous result is converted to a named access type). <br /></Admonition>
</AnnotatedOnly>

<MarginText>11.5/3</MarginText>
<ul>
<li>For any other anonymous access type, the first freezing point of the innermost enclosing declaration. <br /></li>
</ul>
<MarginText>12/2</MarginText>
<MarginInfo items={["AI95-00256-01"]} />
<p>The target of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> is finalized before copying in the new value, as explained in <a href="../AA-7/AA-7.6">7.6</a>.<br /></p>

<MarginText>13/3</MarginText>
<MarginInfo items={["AI95-00162-01", "AI95-00182-01", "AI05-0066-1", "AI05-0142-4", "AI05-0269-1"]} />
<p>{"{"}<em>8652/0021</em>{"}"} The master of an object is the master enclosing its creation whose accessibility level (see <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>) is equal to that of the object, except in the case of an anonymous object representing the result of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call. If such an anonymous object is part of the result of evaluating the actual parameter expression for an explicitly aliased parameter of a function call, the master of the object is the innermost master enclosing the evaluation of the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call, excluding the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call itself. Otherwise, the master of such an anonymous object is the innermost master enclosing the evaluation of the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call, which may be the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call itself. <br /></p>

<AnnotatedOnly>
<MarginText>13.a/2</MarginText>
<MarginInfo items={["AI95-00162-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.b/2</MarginText>
<CodeBlock language="ada">
This paragraph was deleted.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>13.c/2</MarginText>
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.d/2</MarginText>
<MarginInfo items={["AI95-00162-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This effectively imports all of the special rules for the accessibility level of renames, <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s, and so on, and applies them to determine where objects created in them are finalized. For instance, the master of a rename of a subprogram is that of the renamed subprogram.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.e/3</MarginText>
<MarginInfo items={["AI05-0066-1"]} />
<Admonition type="aarm" aarm="note">
In <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a> we assign an accessibility level to the result of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call that is used to directly initialize a part of an object based on the object being initialized. This is important to ensure that any access discriminants denote objects that live at least as long as the object being initialized. However, if the result of the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or function call is not built directly in the target object, but instead is built in an anonymous object that is then assigned to the target, the anonymous object needs to be finalized after the assignment rather than persisting until the target object is finalized (but not its coextensions). (Note than an implementation is never required to create such an anonymous object, and in some cases is required to <em>not</em> have such a separate object, but rather to build the result directly in the target.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.f/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="note">
The special case for explicitly aliased parameters of functions is needed for the same reason, as access discriminants of the returned object may designate one of these parameters. In that case, we want to lengthen the lifetime of the anonymous objects as long as the possible lifetime of the result.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.g/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="note">
We don't do a similar change for other kinds of calls, because the extended lifetime of the parameters adds no value, but could constitute a storage leak. For instance, such an anonymous object created by a procedure call in the elaboration part of a package body would have to live until the end of the program, even though it could not be used after the procedure returns (other than via Unchecked_Access). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.h/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that the lifetime of the master given to anonymous objects in explicitly aliased parameters of functions is not necessarily as long as the lifetime of the master of the object being initialized (if the function call is used to initialize an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>, for instance). In that case, the accessibility check on explicitly aliased parameters will necessarily fail if any such anonymous objects exist. This is necessary to avoid requiring the objects to live as long as the access type or having the implementation complexity of an implicit coextension. <br /></Admonition>
</AnnotatedOnly>

<MarginText>13.1/3</MarginText>
<MarginInfo items={["AI95-00162-01", "AI95-00169-01", "AI05-0066-1", "AI05-0262-1"]} />
<p>{"{"}<em>8652/0023</em>{"}"} In the case of an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> that is a master, finalization of any (anonymous) objects occurs after completing evaluation of the <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> and all use of the objects, prior to starting the execution of any subsequent construct.<br /></p>


#### Bounded (Run-Time) Errors

<MarginText>14/1</MarginText>
<MarginInfo items={["AI95-00169-01"]} />
<p>{"{"}<em>8652/0023</em>{"}"} It is a bounded error for a call on Finalize or Adjust that occurs as part of object finalization or assignment to propagate an exception. The possible consequences depend on what action invoked the Finalize or Adjust operation: <br /></p>

<AnnotatedOnly>
<MarginText>14.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>It is not a bounded error for Initialize to propagate an exception. If Initialize propagates an exception, then no further calls on Initialize are performed, and those components that have already been initialized (either explicitly or by default) are finalized in the usual way.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>14.a.1/1</MarginText>
<MarginInfo items={["AI95-00169-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0023</em>{"}"} It also is not a bounded error for an explicit call to Finalize or Adjust to propagate an exception. We do not want implementations to have to treat explicit calls to these routines specially. <br /></Admonition>
</AnnotatedOnly>

<MarginText>15</MarginText>
<ul>
<li>For a Finalize invoked as part of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>, Program_Error is raised at that point.<br /></li>
<MarginText>16/5</MarginText>
<MarginInfo items={["AI95-00193-01", "AI95-00256-01", "AI12-0445-1"]} />
<li>{"{"}<em>8652/0024</em>{"}"} For an Adjust invoked as part of assignment operations other than those invoked as part of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>, some of the  adjustments due to be performed can  be performed, and then Program_Error is raised. During its propagation, finalization may  be applied to objects whose Adjust failed. For an Adjust invoked as part of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>, any other adjustments due to be performed are performed, and then Program_Error is raised. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>16.a/2</MarginText>
<MarginInfo items={["AI95-00193-01", "AI95-00256-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>{"{"}<em>8652/0024</em>{"}"} In the case of assignments that are part of initialization, there is no need to complete all adjustments if one propagates an exception, as the object will immediately be finalized. So long as a subcomponent is not going to be finalized, it need not be adjusted, even if it is initialized as part of an enclosing composite assignment operation for which some adjustments are performed. However, there is no harm in an implementation making additional Adjust calls (as long as any additional components that are adjusted are also finalized), so we allow the implementation flexibility here. On the other hand, for an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>, it is important that all adjustments be performed, even if one fails, because all controlled subcomponents are going to be finalized. Other kinds of assignment are more like initialization than <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>s, so we include them as well in the permission. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.a.1/1</MarginText>
<MarginInfo items={["AI95-00193-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>{"{"}<em>8652/0024</em>{"}"} Even if an Adjust invoked as part of the initialization of a controlled object propagates an exception, objects whose initialization (including any Adjust or Initialize calls) successfully completed will be finalized. The permission above only applies to objects whose Adjust failed. Objects for which Adjust was never even invoked must not be finalized. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17</MarginText>
<ul>
<li>For a Finalize invoked as part of a call on an instance of Unchecked_Deallocation, any other finalizations due to be performed are performed, and then Program_Error is raised. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.a.1/1</MarginText>
<MarginInfo items={["AI95-00179-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>{"{"}<em>8652/0104</em>{"}"} The standard does not specify if storage is recovered in this case. If storage is not recovered (and the object continues to exist), Finalize may be called on the object again (when the <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>'s master is finalized). <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.1/3</MarginText>
<MarginInfo items={["AI95-00169-01", "AI05-0064-1"]} />
<ul>
<li><em>This paragraph was deleted.</em>{"{"}<em>8652/0023</em>{"}"} <br /></li>
<MarginText>17.2/1</MarginText>
<MarginInfo items={["AI95-00169-01"]} />
<li>{"{"}<em>8652/0023</em>{"}"} For a Finalize invoked due to reaching the end of the execution of a master, any other finalizations associated with the master are performed, and Program_Error is raised immediately after leaving the master.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.a/3</MarginText>
<MarginInfo items={["AI05-0064-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>This rule covers both ordinary objects created by a declaration, and anonymous objects created as part of evaluating an <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>. All contexts that create objects that need finalization are defined to be masters. <br /></Admonition>
</AnnotatedOnly>

<MarginText>18/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<ul>
<li>For a Finalize invoked by the transfer of control of an <code><a href="../AA-5/AA-5.7#S0193">exit_statement</a></code>, return statement, <code><a href="../AA-5/AA-5.8#S0194">goto_statement</a></code>, or <code><a href="../AA-9/AA-9.5#S0265">requeue_statement</a></code>, Program_Error is raised no earlier than after the finalization of the master being finalized when the exception occurred, and no later than the point where normal execution would have continued. Any other finalizations due to be performed up to that point are performed before raising Program_Error. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>18.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>For example, upon leaving a <code><a href="../AA-5/AA-5.6#S0191">block_statement</a></code> due to a <code><a href="../AA-5/AA-5.8#S0194">goto_statement</a></code>, the Program_Error would be raised at the point of the target statement denoted by the label, or else in some more dynamically nested place, but not so nested as to allow an <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> that has visibility upon the finalized object to handle it. For example, <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b</MarginText>
<CodeBlock language="ada">
procedure Main is{"\n"}begin{"\n"}    {"<"}{"<"}The_Label{">"}{">"}{"\n"}    Outer_Block_Statement : declare{"\n"}        X : Some_Controlled_Type;{"\n"}    begin{"\n"}        Inner_Block_Statement : declare{"\n"}            Y : Some_Controlled_Type;{"\n"}            Z : Some_Controlled_Type;{"\n"}        begin{"\n"}            goto The_Label;{"\n"}        exception{"\n"}            when Program_Error ={">"} ... -- Handler number 1.{"\n"}        end;{"\n"}    exception{"\n"}        when Program_Error ={">"} ... -- Handler number 2.{"\n"}    end;{"\n"}exception{"\n"}    when Program_Error ={">"} ... -- Handler number 3.{"\n"}end Main;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>18.c/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
The <code><a href="../AA-5/AA-5.8#S0194">goto_statement</a></code> will first cause Finalize(Z ) to be called. Suppose that Finalize(Z ) propagates an exception. Program_Error will be raised after leaving Inner_Block_Statement, but before leaving Main. Thus, handler number 1 cannot handle this Program_Error; it will be handled either by handler number 2 or handler number 3. If it is handled by handler number 2, then Finalize(Y ) will be done before executing the handler. If it is handled by handler number 3, then Finalize(Y ) and Finalize(X) will both be done before executing the handler. <br /></Admonition>
</AnnotatedOnly>

<MarginText>19</MarginText>
<ul>
<li>For a Finalize invoked by a transfer of control that is due to raising an exception, any other finalizations due to be performed for the same master are performed; Program_Error is raised immediately after leaving the master. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19.a/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If, in the above example, the <code><a href="../AA-5/AA-5.8#S0194">goto_statement</a></code> were replaced by a <code><a href="../AA-11/AA-11.3#S0308">raise_statement</a></code>, then the Program_Error would be handled by handler number 2, and Finalize(Y ) would be done before executing the handler. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We considered treating this case in the same way as the others, but that would render certain <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code>s useless. For example, suppose the only <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> is one for <strong>others</strong> in the main subprogram. If some deeply nested call raises an exception, causing some Finalize operation to be called, which then raises an exception, then normal execution &ldquo;would have continued&rdquo; at the beginning of the <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code>. Raising Program_Error at that point would cause that handler's code to be skipped. One would need two nested <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code>s to be sure of catching such cases!<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19.c</MarginText>
<Admonition type="aarm" aarm="note">
On the other hand, the <code><a href="../AA-11/AA-11.2#S0305">exception_handler</a></code> for a given master should not be allowed to handle exceptions raised during finalization of that master. <br /></Admonition>
</AnnotatedOnly>

<MarginText>20</MarginText>
<ul>
<li>For a Finalize invoked by a transfer of control due to an abort or selection of a terminate alternative, the exception is ignored; any other finalizations due to be performed are performed. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>20.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This case includes an asynchronous transfer of control. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This violates the general principle that it is always possible for a bounded error to raise Program_Error (see <a href="../AA-1/AA-1.1#Subclause_1.1.5">1.1.5</a>, &ldquo;<a href="../AA-1/AA-1.1#Subclause_1.1.5">Classification of Errors</a>&rdquo;). <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>20.1/3</MarginText>
<MarginInfo items={["AI05-0107-1"]} />
<p>If the execution of an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code> propagates an exception, any parts of the allocated object that were successfully initialized may be finalized as part of the finalization of the innermost master enclosing the <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>20.c/3</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This allows deallocating the memory for the allocated object at the innermost master, preventing a storage leak. Otherwise, the object would have to stay around until the finalization of the collection that it belongs to, which could be the entire life of the program if the associated access type is library level. <br /></Admonition>
</AnnotatedOnly>

<MarginText>20.2/3</MarginText>
<MarginInfo items={["AI05-0111-3", "AI05-0262-1"]} />
<p>The implementation may finalize objects created by <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s for an access type whose storage pool supports subpools (see <a href="../AA-13/AA-13.11#Subclause_13.11.4">13.11.4</a>) as if the objects were created (in an arbitrary order) at the point where the storage pool was elaborated instead of at the first freezing point of the access type.<br /></p>

<AnnotatedOnly>
<MarginText>20.d/3</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This allows the finalization of such objects to occur later than they otherwise would, but still as part of the finalization of the same master. Accessibility rules in <a href="../AA-13/AA-13.11#Subclause_13.11.4">13.11.4</a> ensure that it is the same master (usually that of the environment task). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.e/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>This permission is intended to allow the allocated objects to "belong" to the subpool objects and to allow those objects to be finalized at the time that the storage pool is finalized (if they are not finalized earlier). This is expected to ease implementation, as the remaining yet-to-be deallocated objects will only need to be accessible at run time from the subpool header and not also from the overall access type collection header. That is, they only need to belong to a single list, rather than two . <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21/5</MarginText>
<MarginInfo items={["AI05-0299-1", "AI12-0449-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   The rules of Clause <a href="../AA-10/">10</a>  imply that immediately prior to partition termination, Finalize operations are applied to library-level controlled objects (including those created by <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s of library-level access types, except those already finalized). This occurs after waiting for library-level tasks to terminate. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We considered defining a pragma that would apply to a controlled type that would suppress Finalize operations for library-level objects of the type upon partition termination. This would be useful for types whose finalization actions consist of simply reclaiming global heap storage, when this is already provided automatically by the environment upon program termination. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>22</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   A constant is only constant between its initialization and finalization. Both initialization and finalization are allowed to change the value of a constant.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   Abort is deferred during certain operations related to controlled types, as explained in <a href="../AA-9/AA-9.8">9.8</a>. Those rules prevent an abort from causing a controlled object to be left in an ill-defined state.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 4   The Finalize procedure is called upon finalization of a controlled object, even if Finalize was called earlier, either explicitly or as part of an assignment; hence, if a controlled type is visibly controlled (implying that its Finalize primitive is directly callable), or is nonlimited (implying that assignment is allowed), its Finalize procedure is ideally  designed to have no ill effect if it is applied a second time to the same object. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Or equivalently, a Finalize procedure should be &ldquo;idempotent&rdquo;; applying it twice to the same object should be equivalent to applying it once. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>A user-written Finalize procedure should be idempotent since it can be called explicitly by a client (at least if the type is "visibly" controlled). Also, Finalize is used implicitly as part of the <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> if the type is nonlimited, and an abort is permitted to disrupt an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> between finalizing the left-hand side and assigning the new value to it (an abort is not permitted to disrupt an assignment operation between copying in the new value and adjusting it). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.c/2</MarginText>
<MarginInfo items={["AI95-00287-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>Either Initialize or Adjust, but not both, is applied to (almost) every controlled object when it is created: Initialize is done when no initial value is assigned to the object, whereas Adjust is done as part of assigning the initial value. The one exception is the object initialized by an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> (both the anonymous object created for an aggregate, or an object initialized by an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> that is built-in-place); Initialize is not applied to the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> as a whole, nor is the value of the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> or object adjusted.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.d</MarginText>
<Admonition type="aarm" aarm="note">
All of the following use the assignment operation, and thus perform value adjustment: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.e</MarginText>
<ul>
<li>the <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> (see <a href="../AA-5/AA-5.2">5.2</a>);<br /></li>
<MarginText>24.f</MarginText>
<li>explicit initialization of a stand-alone object (see <a href="../AA-3/AA-3.3#Subclause_3.3.1">3.3.1</a>) or of a pool element (see <a href="../AA-4/AA-4.8">4.8</a>);<br /></li>
<MarginText>24.g</MarginText>
<li>default initialization of a component of a stand-alone object or pool element (in this case, the value of each component is assigned, and therefore adjusted, but the value of the object as a whole is not adjusted);<br /></li>
<MarginText>24.h/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<li>function return, when the result is not built-in-place (adjustment of the result happens before finalization of the function);<br /></li>
<MarginText>24.i</MarginText>
<li>predefined operators (although the only one that matters is concatenation; see <a href="../AA-4/AA-4.5#Subclause_4.5.3">4.5.3</a>);<br /></li>
<MarginText>24.j</MarginText>
<li>generic formal objects of mode <strong>in</strong> (see <a href="../AA-12/AA-12.4">12.4</a>); these are defined in terms of constant declarations; and<br /></li>
<MarginText>24.k/5</MarginText>
<MarginInfo items={["AI95-00287-01", "AI12-0005-1"]} />
<li><code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s (see <a href="../AA-4/AA-4.3">4.3</a>), when the result is not built-in-place (in this case, the value of each component, and the ancestor  part, for an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code>, is assigned, and therefore adjusted, but the value of the <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> as a whole is not adjusted; neither is Initialize called); <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.l</MarginText>
<Admonition type="aarm" aarm="note">
The following also use the assignment operation, but adjustment never does anything interesting in these cases: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.m</MarginText>
<ul>
<li>By-copy parameter passing uses the assignment operation (see <a href="../AA-6/AA-6.4#Subclause_6.4.1">6.4.1</a>), but controlled objects are always passed by reference, so the assignment operation never does anything interesting in this case. If we were to allow by-copy parameter passing for controlled objects, we would need to make sure that the actual is finalized before doing the copy back for [<strong>in</strong>] <strong>out</strong> parameters. The finalization of the parameter itself needs to happen after the copy back (if any), similar to the finalization of an anonymous function return object or <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> object.<br /></li>
<MarginText>24.n</MarginText>
<li><strong>For</strong> loops use the assignment operation (see <a href="../AA-5/AA-5.5">5.5</a>), but since the type of the loop parameter is never controlled, nothing interesting happens there, either.<br /></li>
<MarginText>24.n.1/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<li>Objects initialized by function results and <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s that are built-in-place. In this case, the assignment operation is never executed, and no adjustment takes place. While built-in-place is always allowed, it is required for some types &mdash; see <a href="../AA-7/AA-7.5">7.5</a> and <a href="../AA-7/AA-7.6">7.6</a> &mdash; and that's important since limited types have no Adjust to call. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.o/2</MarginText>
<MarginInfo items={["AI95-00287-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.p</MarginText>
<Admonition type="aarm" aarm="note">
Finalization of the parts of a protected object are not done as protected actions. It is possible (in pathological cases) to create tasks during finalization that access these parts in parallel with the finalization itself. This is an erroneous use of shared variables. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.q</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>One implementation technique for finalization is to chain the controlled objects together on a per-task list. When leaving a master, the list can be walked up to a marked place. The links needed to implement the list can be declared (privately) in types Controlled and Limited_Controlled, so they will be inherited by all controlled types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.r</MarginText>
<Admonition type="aarm" aarm="note">
Another implementation technique, which we refer to as the &ldquo;PC-map&rdquo; approach essentially implies inserting exception handlers at various places, and finalizing objects based on where the exception was raised.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.s</MarginText>
<Admonition type="aarm" aarm="note">
The PC-map approach is for the compiler/linker to create a map of code addresses; when an exception is raised, or abort occurs, the map can be consulted to see where the task was executing, and what finalization needs to be performed. This approach was given in the Ada 83 Rationale as a possible implementation strategy for exception handling &mdash; the map is consulted to determine which exception handler applies.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.t</MarginText>
<Admonition type="aarm" aarm="note">
If the PC-map approach is used, the implementation must take care in the case of arrays. The generated code will generally contain a loop to initialize an array. If an exception is raised part way through the array, the components that have been initialized must be finalized, and the others must not be finalized.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.u</MarginText>
<Admonition type="aarm" aarm="note">
It is our intention that both of these implementation methods should be possible. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.v</MarginText>
<Admonition type="aarm" aarm="note">
Finalization depends on the concepts of completion and leaving, and on the concept of a master. Therefore, we have moved the definitions of these concepts here, from where they used to be in Clause <a href="../AA-9/">9</a>. These concepts also needed to be generalized somewhat. Task waiting is closely related to user-defined finalization; the rules here refer to the task-waiting rules of Clause <a href="../AA-9/">9</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.v.1/3</MarginText>
<MarginInfo items={["AI05-0066-1"]} />
<Admonition type="aarm" aarm="correction">
<strong>Ada 2012 </strong> Changed the definition of the master of an anonymous object used to directly initialize an object, so it can be finalized immediately rather than having to hang around as long as the object. In this case, the Ada 2005 definition was inconsistent with Ada 95, and Ada 2012 changes it back. It is unlikely that many compilers implemented the rule as written in Amendment 1, so an inconsistency is unlikely to arise in practice. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.w/2</MarginText>
<MarginInfo items={["AI95-00182-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0021</em>{"}"} <strong>Corrigendum:</strong> Fixed the wording to say that anonymous objects aren't finalized until the object can't be used anymore.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.x/2</MarginText>
<MarginInfo items={["AI95-00169-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0023</em>{"}"} <strong>Corrigendum:</strong> Added wording to clarify what happens when Adjust or Finalize raises an exception; some cases had been omitted.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.y/2</MarginText>
<MarginInfo items={["AI95-00193-01", "AI95-00256-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0024</em>{"}"} <strong>Corrigendum:</strong> Stated that if Adjust raises an exception during initialization, nothing further is required. This is corrected in Ada 2005 to include all kinds of assignment other than <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>s.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.z/2</MarginText>
<MarginInfo items={["AI95-00162-01", "AI95-00416-01"]} />
<Admonition type="aarm" aarm="note">
Revised the definition of master to include <code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s and <code><a href="../AA-5/AA-5.1#S0167">statement</a></code>s, in order to cleanly define what happens for tasks and controlled objects created as part of a subprogram call. Having done that, all of the special wording to cover those cases is eliminated (at least until the Ada comments start rolling in).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.aa/2</MarginText>
<MarginInfo items={["AI95-00280-01"]} />
<Admonition type="aarm" aarm="note">
We define <em>finalization of the collection</em> here, so as to be able to conveniently refer to it in other rules (especially in <a href="../AA-4/AA-4.8">4.8</a>, &ldquo;<a href="../AA-4/AA-4.8">Allocators</a>&rdquo;).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.bb/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that a coextension is finalized at the same time as the outer object. (This was intended for Ada 95, but since the concept did not have a name, it was overlooked.) <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.cc/3</MarginText>
<MarginInfo items={["AI05-0051-1", "AI05-0190-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Better defined when objects allocated from anonymous access types are finalized. This could be inconsistent if objects are finalized in a different order than in an Ada 2005 implementation and that order caused different program behavior; however programs that depend on the order of finalization within a single master are already fragile and hopefully are rare. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.dd/3</MarginText>
<MarginInfo items={["AI05-0064-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Removed a redundant rule, which is now covered by the additional places where masters are defined.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.ee/4</MarginText>
<MarginInfo items={["AI05-0099-1", "AI12-0005-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified the finalization rules so that there is no doubt that privacy is ignored, and to ensure that objects of class-wide interface types are finalized based on their specific concrete type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.ff/3</MarginText>
<MarginInfo items={["AI05-0107-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Allowed premature finalization of parts of failed <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s. This could be an inconsistency, but the previous behavior is still allowed and there is no requirement that implementations take advantage of the permission.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.gg/3</MarginText>
<MarginInfo items={["AI05-0111-3"]} />
<Admonition type="aarm" aarm="note">
Added a permission to finalize an object allocated from a subpool later than usual.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.hh/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="note">
Added text to specially define the master of anonymous objects which are passed as explicitly aliased parameters (see <a href="../AA-6/AA-6.1">6.1</a>) of functions. The model for these parameters is explained in detail in <a href="../AA-6/AA-6.4#Subclause_6.4.1">6.4.1</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.ii/5</MarginText>
<MarginInfo items={["AI12-0406-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Defined the term &ldquo;master construct&rdquo;, so as to put static accessibility rules on a firmer basis, including ensuring that those rules apply inside of generic bodies. <br /></Admonition>
</AnnotatedOnly>

