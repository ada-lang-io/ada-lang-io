---
sidebar_position:  136
---

# A.16 The Package Directories

:::danger
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The package Directories provides operations for manipulating files and directories, and their names. <br /></p>

<AnnotatedOnly>
<MarginText>1.a/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>The notes for this subclause contain the expected interpretations of some of the operations on various target systems. &ldquo;Unix&rdquo; refers to the UNIX® operating system, and in most cases also covers Unix-like systems such as Linux and POSIX. &ldquo;Windows®&rdquo; refers to the Microsoft® Windows® 2000 operating system and usually also covers most other versions that use the Win32 API. <br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The library package Directories has the following declaration: <br /></p>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
with Ada.IO{"_"}Exceptions;{"\n"}with Ada.Calendar;{"\n"}package Ada.Directories {"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>4/2</MarginText>
   -- Directory and file operations:{"\n"}
<MarginText>5/2</MarginText>
   function Current{"_"}Directory return String;{"\n"}
<MarginText>6/2</MarginText>
   procedure Set{"_"}Directory (Directory : in String);{"\n"}
<MarginText>7/2</MarginText>
   procedure Create{"_"}Directory (New{"_"}Directory : in String;{"\n"}                               Form          : in String := "");{"\n"}
<MarginText>8/2</MarginText>
   procedure Delete{"_"}Directory (Directory : in String);{"\n"}
<MarginText>9/2</MarginText>
   procedure Create{"_"}Path (New{"_"}Directory : in String;{"\n"}                          Form          : in String := "");{"\n"}
<MarginText>10/2</MarginText>
   procedure Delete{"_"}Tree (Directory : in String);{"\n"}
<MarginText>11/2</MarginText>
   procedure Delete{"_"}File (Name : in String);{"\n"}
<MarginText>12/2</MarginText>
   procedure Rename (Old{"_"}Name, New{"_"}Name : in String);{"\n"}
<MarginText>13/2</MarginText>
   procedure Copy{"_"}File (Source{"_"}Name,{"\n"}                        Target{"_"}Name : in String;{"\n"}                        Form        : in String := "");{"\n"}
<MarginText>14/2</MarginText>
   -- File and directory name operations:{"\n"}
<MarginText>15/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Full{"_"}Name (Name : in String) return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>16/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Simple{"_"}Name (Name : in String) return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>17/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Containing{"_"}Directory (Name : in String) return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>18/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Extension (Name : in String) return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>19/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Base{"_"}Name (Name : in String) return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>20/5</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
   function Compose (Containing{"_"}Directory : in String := "";{"\n"}                     Name                 : in String;{"\n"}                     Extension            : in String := "") return String{"\n"}      with Nonblocking;{"\n"}
<MarginText>20.1/3</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
   type Name{"_"}Case{"_"}Kind is{"\n"}      (Unknown, Case{"_"}Sensitive, Case{"_"}Insensitive, Case{"_"}Preserving);{"\n"}
<MarginText>20.2/3</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
   function Name{"_"}Case{"_"}Equivalence (Name : in String) return Name{"_"}Case{"_"}Kind;{"\n"}
<MarginText>21/2</MarginText>
   -- File and directory queries:{"\n"}
<MarginText>22/2</MarginText>
   type File{"_"}Kind is (Directory, Ordinary{"_"}File, Special{"_"}File);{"\n"}
<MarginText>23/2</MarginText>
   type File{"_"}Size is range 0 .. implementation-defined;{"\n"}
<MarginText>24/2</MarginText>
   function Exists (Name : in String) return Boolean;{"\n"}
<MarginText>25/2</MarginText>
   function Kind (Name : in String) return File{"_"}Kind;{"\n"}
<MarginText>26/2</MarginText>
   function Size (Name : in String) return File{"_"}Size;{"\n"}
<MarginText>27/2</MarginText>
   function Modification{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}
<MarginText>28/2</MarginText>
   -- Directory searching:{"\n"}
<MarginText>29/2</MarginText>
   type Directory{"_"}Entry{"_"}Type is limited private;{"\n"}
<MarginText>30/2</MarginText>
   type Filter{"_"}Type is array (File{"_"}Kind) of Boolean;{"\n"}
<MarginText>31/2</MarginText>
   type Search{"_"}Type is limited private;{"\n"}
<MarginText>32/2</MarginText>
   procedure Start{"_"}Search (Search    : in out Search{"_"}Type;{"\n"}                           Directory : in String;{"\n"}                           Pattern   : in String;{"\n"}                           Filter    : in Filter{"_"}Type := (others ={">"} True));{"\n"}
<MarginText>33/2</MarginText>
   procedure End{"_"}Search (Search : in out Search{"_"}Type);{"\n"}
<MarginText>34/2</MarginText>
   function More{"_"}Entries (Search : in Search{"_"}Type) return Boolean;{"\n"}
<MarginText>35/2</MarginText>
   procedure Get{"_"}Next{"_"}Entry (Search : in out Search{"_"}Type;{"\n"}                             Directory{"_"}Entry : out Directory{"_"}Entry{"_"}Type);{"\n"}
<MarginText>36/5</MarginText>
<MarginInfo items={["AI12-0286-1"]} />
   procedure Search ({"\n"}      Directory : in String;{"\n"}      Pattern   : in String;{"\n"}      Filter    : in Filter{"_"}Type := (others ={">"} True);{"\n"}      Process   : not null access procedure ({"\n"}          Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type)){"\n"}      with Allows{"_"}Exit;{"\n"}
<MarginText>37/2</MarginText>
   -- Operations on Directory Entries:{"\n"}
<MarginText>38/2</MarginText>
   function Simple{"_"}Name (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return String;{"\n"}
<MarginText>39/2</MarginText>
   function Full{"_"}Name (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return String;{"\n"}
<MarginText>40/2</MarginText>
   function Kind (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return File{"_"}Kind;{"\n"}
<MarginText>41/2</MarginText>
   function Size (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return File{"_"}Size;{"\n"}
<MarginText>42/2</MarginText>
   function Modification{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Ada.Calendar.Time;{"\n"}
<MarginText>43/2</MarginText>
   Status{"_"}Error : exception renames Ada.IO{"_"}Exceptions.Status{"_"}Error;{"\n"}   Name{"_"}Error   : exception renames Ada.IO{"_"}Exceptions.Name{"_"}Error;{"\n"}   Use{"_"}Error    : exception renames Ada.IO{"_"}Exceptions.Use{"_"}Error;{"\n"}   Device{"_"}Error : exception renames Ada.IO{"_"}Exceptions.Device{"_"}Error;{"\n"}
<MarginText>44/3</MarginText>
<MarginInfo items={["AI05-0092-1"]} />
private{"\n"}    ... -- not specified by the language{"\n"}end Ada.Directories;{"\n"}

</CodeBlock>
<MarginText>45/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>External files may be classified as directories, special files, or ordinary files. A <em>directory</em> is an external file that is a container for files on the target system. A <em>special file</em> is an external file that cannot be created or read by a predefined Ada input-output package. External files that are not special files or directories are called <em>ordinary files</em>. <br /></p>

<AnnotatedOnly>
<MarginText>45.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A directory is an external file, although it may not have a name on some targets. A directory is not a special file, as it can be created and read by Directories. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>45.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Devices and soft links are examples of special files on Windows® and Unix.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>45.c/2</MarginText>
<Admonition type="aarm" aarm="note">
Even if an implementation provides a package to create and read soft links, such links are still special files. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>46/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>A <em>file name</em> is a string identifying an external file. Similarly, a <em>directory name</em> is a string identifying a directory. The interpretation of file names and directory names is implementation defined. <br /></p>

<AnnotatedOnly>
<MarginText>46.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The interpretation of file names and directory names.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>47/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The <em>full name</em> of an external file is a full specification of the name of the file. If the external environment allows alternative specifications of the name (for example, abbreviations), the full name should not use such alternatives. A full name typically will include the names of all of the directories that contain the item. The <em>simple name</em> of an external file is the name of the item, not including any containing directory names. Unless otherwise specified, a file name or directory name parameter in a call to a predefined Ada input-output subprogram can be a full name, a simple name, or any other form of name supported by the implementation. <br /></p>

<AnnotatedOnly>
<MarginText>47.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The full name on Unix is a complete path to the root. For Windows®, the full name includes a complete path, as well as a disk name ("C:") or network share name. For both systems, the simple name is the part of the name following the last '/' (or '\' for Windows®). For example, in the name "/usr/randy/ada-directories.ads", "ada-directories.ads" is the simple name. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>47.b/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>It is possible for a file or directory name to be neither a full name nor a simple name. For instance, the Unix name "../parent/myfile" is neither a full name nor a simple name. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>47.1/5</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<p>A <em>root directory</em> is a directory that has no containing directory.<br /></p>

<AnnotatedOnly>
<MarginText>47.c/5</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>For Unix and Unix-like systems, "/" is the root. For Windows®, "C:\" and "\\Computer\Share" are roots. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>48/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The <em>default directory</em> is the directory that is used if a directory or file name is not a full name (that is, when the name does not fully identify all of the containing directories). <br /></p>

<AnnotatedOnly>
<MarginText>48.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The default directory is the one maintained by the familiar &ldquo;cd&rdquo; command on Unix and Windows®. Note that Windows® maintains separate default directories for each disk drive; implementations should use the natural implementation. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>49/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>A <em>directory entry</em> is a single item in a directory, identifying a single external file (including directories and special files). <br /></p>

<MarginText>50/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>For each function that returns a string, the lower bound of the returned value is 1.<br /></p>

<MarginText>51/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The following file and directory operations are provided:<br /></p>

<MarginText>52/2</MarginText>
<CodeBlock language="ada">
function Current{"_"}Directory return String;{"\n"}

</CodeBlock>
<MarginText>53/2</MarginText>
<p class="Indented4">Returns the full directory name for the current default directory. The name returned shall be suitable for a future call to Set{"_"}Directory. The exception Use{"_"}Error is propagated if a default directory is not supported by the external environment.<br /></p>

<MarginText>54/2</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Directory (Directory : in String);{"\n"}

</CodeBlock>
<MarginText>55/2</MarginText>
<p class="Indented4">Sets the current default directory. The exception Name{"_"}Error is propagated if the string given as Directory does not identify an existing directory. The exception Use{"_"}Error is propagated if the external environment does not support making Directory (in the absence of Name{"_"}Error) a default directory.<br /></p>

<MarginText>56/2</MarginText>
<CodeBlock language="ada">
procedure Create{"_"}Directory (New{"_"}Directory : in String;{"\n"}                            Form          : in String := "");{"\n"}

</CodeBlock>
<MarginText>57/2</MarginText>
<p class="Indented4">Creates a directory with name New{"_"}Directory. The Form parameter can be used to give system-dependent characteristics of the directory; the interpretation of the Form parameter is implementation defined. A null string for Form specifies the use of the default options of the implementation of the new directory. The exception Name{"_"}Error is propagated if the string given as New{"_"}Directory does not allow the identification of a directory. The exception Use{"_"}Error is propagated if the external environment does not support the creation of a directory with the given name (in the absence of Name{"_"}Error) and form.<br /></p>

<MarginText>58/2</MarginText>
<CodeBlock language="ada">
procedure Delete{"_"}Directory (Directory : in String);{"\n"}

</CodeBlock>
<MarginText>59/3</MarginText>
<MarginInfo items={["AI05-0231-1"]} />
<p class="Indented4">Deletes an existing empty directory with name Directory. The exception Name{"_"}Error is propagated if the string given as Directory does not identify an existing directory. The exception Use{"_"}Error is propagated if the directory is not empty or the external environment does not support the deletion of the directory with the given name (in the absence of Name{"_"}Error).<br /></p>

<MarginText>60/2</MarginText>
<CodeBlock language="ada">
procedure Create{"_"}Path (New{"_"}Directory : in String;{"\n"}                       Form          : in String := "");{"\n"}

</CodeBlock>
<MarginText>61/3</MarginText>
<MarginInfo items={["AI05-0271-1"]} />
<p class="Indented4">Creates zero or more directories with name New{"_"}Directory. Each nonexistent directory named by New{"_"}Directory is created.[ For example, on a typical Unix system, Create{"_"}Path ("/usr/me/my"); would create directory "me" in directory "usr", then create directory "my" in directory "me".] The Form parameter can be used to give system-dependent characteristics of the directory; the interpretation of the Form parameter is implementation defined. A null string for Form specifies the use of the default options of the implementation of the new directory. The exception Name{"_"}Error is propagated if the string given as New{"_"}Directory does not allow the identification of any directory. The exception Use{"_"}Error is propagated if the external environment does not support the creation of any directories with the given name (in the absence of Name{"_"}Error) and form. If Use{"_"}Error is propagated, it is unspecified whether a portion of the directory path is created.<br /></p>

<MarginText>62/2</MarginText>
<CodeBlock language="ada">
procedure Delete{"_"}Tree (Directory : in String);{"\n"}

</CodeBlock>
<MarginText>63/2</MarginText>
<p class="Indented4">Deletes an existing directory with name Directory. The directory and all of its contents (possibly including other directories) are deleted. The exception Name{"_"}Error is propagated if the string given as Directory does not identify an existing directory. The exception Use{"_"}Error is propagated if the external environment does not support the deletion of the directory or some portion of its contents with the given name (in the absence of Name{"_"}Error). If Use{"_"}Error is propagated, it is unspecified whether a portion of the contents of the directory is deleted.<br /></p>

<MarginText>64/2</MarginText>
<CodeBlock language="ada">
procedure Delete{"_"}File (Name : in String);{"\n"}

</CodeBlock>
<MarginText>65/2</MarginText>
<p class="Indented4">Deletes an existing ordinary or special file with name Name. The exception Name{"_"}Error is propagated if the string given as Name does not identify an existing ordinary or special external file. The exception Use{"_"}Error is propagated if the external environment does not support the deletion of the file with the given name (in the absence of Name{"_"}Error).<br /></p>

<MarginText>66/2</MarginText>
<CodeBlock language="ada">
procedure Rename (Old{"_"}Name, New{"_"}Name : in String);{"\n"}

</CodeBlock>
<MarginText>67/3</MarginText>
<MarginInfo items={["AI05-0231-1"]} />
<p class="Indented4">Renames an existing external file (including directories) with name Old{"_"}Name to New{"_"}Name. The exception Name{"_"}Error is propagated if the string given as Old{"_"}Name does not identify an existing external file or if the string given as New{"_"}Name does not allow the identification of an external file. The exception Use{"_"}Error is propagated if the external environment does not support the renaming of the file with the given name (in the absence of Name{"_"}Error). In particular, Use{"_"}Error is propagated if a file or directory already exists with name New{"_"}Name.<br /></p>

<AnnotatedOnly>
<MarginText>67.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>This operation is expected to work within a single directory, and implementers are encouraged to support it across directories on a single device. Copying files from one device to another is discouraged (that's what Copy{"_"}File is for). However, there is no requirement to detect file copying by the target system. If the target system has an API that gives that for &ldquo;free&rdquo;, it can be used. For Windows®, for instance, MoveFile can be used to implement Rename. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>68/3</MarginText>
<MarginInfo items={["AI05-0092-1"]} />
<CodeBlock language="ada">
procedure Copy{"_"}File (Source{"_"}Name,{"\n"}                     Target{"_"}Name : in String;{"\n"}                     Form        : in String := "");{"\n"}

</CodeBlock>
<MarginText>69/3</MarginText>
<MarginInfo items={["AI05-0271-1"]} />
<p class="Indented4">Copies the contents of the existing external file with name Source{"_"}Name to an external file with name Target{"_"}Name. The resulting external file is a duplicate of the source external file. The Form parameter can be used to give system-dependent characteristics of the resulting external file; the interpretation of the Form parameter is implementation defined. Exception Name{"_"}Error is propagated if the string given as Source{"_"}Name does not identify an existing external ordinary or special file, or if the string given as Target{"_"}Name does not allow the identification of an external file. The exception Use{"_"}Error is propagated if the external environment does not support creating the file with the name given by Target{"_"}Name and form given by Form, or copying of the file with the name given by Source{"_"}Name (in the absence of Name{"_"}Error). If Use{"_"}Error is propagated, it is unspecified whether a portion of the file is copied. <br /></p>

<AnnotatedOnly>
<MarginText>69.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Name{"_"}Error is always raised if Source{"_"}Name identifies a directory. It is up to the implementation whether special files can be copied, or if Use{"_"}Error will be raised. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>70/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The following file and directory name operations are provided:<br /></p>

<MarginText>71/2</MarginText>
<CodeBlock language="ada">
function Full{"_"}Name (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>72/2</MarginText>
<p class="Indented4">Returns the full name corresponding to the file name specified by Name. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files). <br /></p>

<AnnotatedOnly>
<MarginText>72.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Full name means that no abbreviations are used in the returned name, and that it is a full specification of the name. Thus, for Unix and Windows®, the result should be a full path that does not contain any "." or ".." directories. Typically, the default directory is used to fill in any missing information. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>73/2</MarginText>
<CodeBlock language="ada">
function Simple{"_"}Name (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>74/5</MarginText>
<MarginInfo items={["AI12-0337-1", "AI12-0433-1"]} />
<p class="Indented4">Returns the simple name portion of the file name specified by Name. The simple name of a root directory is a name of the root itself. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).<br /></p>

<AnnotatedOnly>
<MarginText>74.a/5</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>The result of Simple{"_"}Name corresponds to the result of the &ldquo;basename&rdquo; command on Linux and Unix. If the filename ends with a '/', and is not a root, then &ldquo;basename&rdquo; returns the part in front of all of the trailing '/'s. It returns a root intact. The null string is never returned. Similar rules should be used for Windows filenames. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>75/2</MarginText>
<CodeBlock language="ada">
function Containing{"_"}Directory (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>76/2</MarginText>
<p class="Indented4">Returns the name of the containing directory of the external file (including directories) identified by Name. (If more than one directory can contain Name, the directory name returned is implementation defined.) The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file. The exception Use{"_"}Error is propagated if the external file does not have a containing directory. <br /></p>

<AnnotatedOnly>
<MarginText>76.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This is purely a string manipulation function. If Name is not given as a full name, the containing directory probably won't be one, either. For example, if Containing{"_"}Directory ("..\AARM\RM-A-8") is called on Windows®, the result should be "..\AARM". If there is no path at all on the name, the result should be "." (which represents the current directory). Use Full{"_"}Name on the result of Containing{"_"}Directory if the full name is needed. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>76.b/5</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Containing{"_"}Directory raises Use{"_"}Error when passed a string representing a root directory. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>77/2</MarginText>
<CodeBlock language="ada">
function Extension (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>78/2</MarginText>
<p class="Indented4">Returns the extension name corresponding to Name. The extension name is a portion of a simple name (not including any separator characters), typically used to identify the file class. If the external environment does not have extension names, then the null string is returned. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file. <br /></p>

<AnnotatedOnly>
<MarginText>78.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For Unix and Windows®, the extension is the portion of the simple name following the rightmost period. For example, in the simple name "RM-A-8.html", the extension is "html". <br />
</Admonition>
</AnnotatedOnly>

<MarginText>79/2</MarginText>
<CodeBlock language="ada">
function Base{"_"}Name (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>80/2</MarginText>
<p class="Indented4">Returns the base name corresponding to Name. The base name is the remainder of a simple name after removing any extension and extension separators. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files). <br /></p>

<AnnotatedOnly>
<MarginText>80.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>For Unix and Windows®, the base name is the portion of the simple name preceding the rightmost period (except for the special directory names "." and "..", whose Base{"_"}Name is "." and ".."). For example, in the simple name "RM-A-8.html", the base name is "RM-A-8". <br />
</Admonition>
</AnnotatedOnly>

<MarginText>81/2</MarginText>
<CodeBlock language="ada">
function Compose (Containing{"_"}Directory : in String := "";{"\n"}                  Name                 : in String;{"\n"}                  Extension            : in String := "") return String;{"\n"}

</CodeBlock>
<MarginText>82/5</MarginText>
<MarginInfo items={["AI05-0264-1", "AI12-0337-1"]} />
<p class="Indented4">Returns the name of the external file with the specified Containing{"_"}Directory, Name, and Extension. If Extension is the null string, then Name is interpreted as a simple name; otherwise, Name is interpreted as a base name. The exception Name{"_"}Error is propagated if: <br /></p>

<MarginText>82.1/5</MarginText>
<ul>
<li>the string given as Containing{"_"}Directory is not null and does not allow the identification of a directory;<br /></li>
<MarginText>82.2/5</MarginText>
<li>the string given as Extension is not null and is not a possible extension;<br /></li>
<MarginText>82.3/5</MarginText>
<li>the string given as Name is not a possible simple name (if Extension is null) or base name (if Extension is nonnull); or<br /></li>
<MarginText>82.4/5</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<li>the string given as Name is a root directory, and Containing{"_"}Directory or Extension is nonnull. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>82.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The above definition implies that if the Extension is null, for Unix and Windows® no '.' is added to Name. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>82.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>If Name is null, Name{"_"}Error should be raised, as nothing is not a possible simple name or base name.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>82.c/2</MarginText>
<Admonition type="aarm" aarm="note">
Generally, Compose(Containing{"_"}Directory(F), Base{"_"}Name(F),Extension(F)) = F. However, this is not true on Unix or Windows® for file names that end with a '.'; Compose(Base{"_"}Name("Fooey."),Extension("Fooey.")) = "Fooey". This is not a problem for Windows®, as the names have the same meaning with or without the '.', but these are different names for Unix. Thus, care needs to be taken on Unix; if Extension is null, Base{"_"}Name should be avoided. (That's not usually a problem with file names generated by a program.) <br />
</Admonition>
</AnnotatedOnly>

<MarginText>82.5/3</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<CodeBlock language="ada">
function Name{"_"}Case{"_"}Equivalence (Name : in String) return Name{"_"}Case{"_"}Kind;{"\n"}

</CodeBlock>
<MarginText>82.6/3</MarginText>
<MarginInfo items={["AI05-0049-1", "AI05-0248-1"]} />
<p class="Indented4">Returns the file name equivalence rule for the directory containing Name. Raises Name{"_"}Error if Name is not a full name. Returns Case{"_"}Sensitive if file names that differ only in the case of letters are considered different names. If file names that differ only in the case of letters are considered the same name, then Case{"_"}Preserving is returned if names have the case of the file name used when a file is created; and Case{"_"}Insensitive is returned otherwise. Returns Unknown if the file name equivalence is not known. <br /></p>

<AnnotatedOnly>
<MarginText>82.c.1/3</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Unix, Linux, and their relatives are Case{"_"}Sensitive systems. Microsoft® Windows® is a Case{"_"}Preserving system (unless the rarely used POSIX mode is used). Ancient systems like CP/M and early MS-DOS were Case{"_"}Insensitive systems (file names were always in UPPER CASE). Unknown is provided in case it is impossible to tell (such as could be the case for network files). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>83/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The following file and directory queries and types are provided:<br /></p>

<MarginText>84/2</MarginText>
<CodeBlock language="ada">
type File{"_"}Kind is (Directory, Ordinary{"_"}File, Special{"_"}File);{"\n"}

</CodeBlock>
<MarginText>85/2</MarginText>
<p class="Indented4">The type File{"_"}Kind represents the kind of file represented by an external file or directory.<br /></p>

<MarginText>86/2</MarginText>
<CodeBlock language="ada">
type File{"_"}Size is range 0 .. implementation-defined;{"\n"}

</CodeBlock>
<MarginText>87/2</MarginText>
<p class="Indented4">The type File{"_"}Size represents the size of an external file. <br /></p>

<AnnotatedOnly>
<MarginText>87.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The maximum value for a file size in Directories.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>88/2</MarginText>
<CodeBlock language="ada">
function Exists (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>89/2</MarginText>
<p class="Indented4">Returns True if an external file represented by Name exists, and False otherwise. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).<br /></p>

<MarginText>90/2</MarginText>
<CodeBlock language="ada">
function Kind (Name : in String) return File{"_"}Kind;{"\n"}

</CodeBlock>
<MarginText>91/2</MarginText>
<p class="Indented4">Returns the kind of external file represented by Name. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an existing external file.<br /></p>

<MarginText>92/2</MarginText>
<CodeBlock language="ada">
function Size (Name : in String) return File{"_"}Size;{"\n"}

</CodeBlock>
<MarginText>93/2</MarginText>
<p class="Indented4">Returns the size of the external file represented by Name. The size of an external file is the number of stream elements contained in the file. If the external file is not an ordinary file, the result is implementation defined. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an existing external file. The exception Constraint{"_"}Error is propagated if the file size is not a value of type File{"_"}Size. <br /></p>

<AnnotatedOnly>
<MarginText>93.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The result for Directories.Size for a directory or special file.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>93.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We allow raising Constraint{"_"}Error, so that an implementation for a system with 64-bit file sizes does not need to support full numerics on 64-bit integers just to implement this package. Of course, if 64-bit integers are available on such a system, they should be used when defining type File{"_"}Size. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>94/2</MarginText>
<CodeBlock language="ada">
function Modification{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}

</CodeBlock>
<MarginText>95/2</MarginText>
<p class="Indented4">Returns the time that the external file represented by Name was most recently modified. If the external file is not an ordinary file, the result is implementation defined. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an existing external file. The exception Use{"_"}Error is propagated if the external environment does not support reading the modification time of the file with the name given by Name (in the absence of Name{"_"}Error). <br /></p>

<AnnotatedOnly>
<MarginText>95.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The result for Directories.Modification{"_"}Time for a directory or special file.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>96/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<p>The following directory searching operations and types are provided:<br /></p>

<MarginText>97/2</MarginText>
<CodeBlock language="ada">
type Directory{"_"}Entry{"_"}Type is limited private;{"\n"}

</CodeBlock>
<MarginText>98/2</MarginText>
<p class="Indented4">The type Directory{"_"}Entry{"_"}Type represents a single item in a directory. These items can only be created by the Get{"_"}Next{"_"}Entry procedure in this package. Information about the item can be obtained from the functions declared in this package. A default-initialized object of this type is invalid; objects returned from Get{"_"}Next{"_"}Entry are valid.<br /></p>

<MarginText>99/2</MarginText>
<CodeBlock language="ada">
type Filter{"_"}Type is array (File{"_"}Kind) of Boolean;{"\n"}

</CodeBlock>
<MarginText>100/2</MarginText>
<p class="Indented4">The type Filter{"_"}Type specifies which directory entries are provided from a search operation. If the Directory component is True, directory entries representing directories are provided. If the Ordinary{"_"}File component is True, directory entries representing ordinary files are provided. If the Special{"_"}File component is True, directory entries representing special files are provided.<br /></p>

<MarginText>101/2</MarginText>
<CodeBlock language="ada">
type Search{"_"}Type is limited private;{"\n"}

</CodeBlock>
<MarginText>102/2</MarginText>
<p class="Indented4">The type Search{"_"}Type contains the state of a directory search. A default-initialized Search{"_"}Type object has no entries available (function More{"_"}Entries returns False). Type Search{"_"}Type needs finalization (see <a href="/docs/arm/AA-7/AA-7.6">7.6</a>).<br /></p>

<MarginText>103/2</MarginText>
<CodeBlock language="ada">
procedure Start{"_"}Search (Search    : in out Search{"_"}Type;{"\n"}                        Directory : in String;{"\n"}                        Pattern   : in String;{"\n"}                        Filter    : in Filter{"_"}Type := (others ={">"} True));{"\n"}

</CodeBlock>
<MarginText>104/3</MarginText>
<MarginInfo items={["AI05-0092-1", "AI05-0262-1"]} />
<p class="Indented4">Starts a search in the directory named by Directory for entries matching Pattern and Filter. Pattern represents a pattern for matching file names. If Pattern is the null string, all items in the directory are matched; otherwise, the interpretation of Pattern is implementation defined. Only items that match Filter will be returned. After a successful call on Start{"_"}Search, the object Search may have entries available, but it may have no entries available if no files or directories match Pattern and Filter. The exception Name{"_"}Error is propagated if the string given by Directory does not identify an existing directory, or if Pattern does not allow the identification of any possible external file or directory. The exception Use{"_"}Error is propagated if the external environment does not support the searching of the directory with the given name (in the absence of Name{"_"}Error). When Start{"_"}Search propagates Name{"_"}Error or Use{"_"}Error, the object Search will have no entries available. <br /></p>

<AnnotatedOnly>
<MarginText>104.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The interpretation of a nonnull search pattern in Directories.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>105/2</MarginText>
<CodeBlock language="ada">
procedure End{"_"}Search (Search : in out Search{"_"}Type);{"\n"}

</CodeBlock>
<MarginText>106/2</MarginText>
<p class="Indented4">Ends the search represented by Search. After a successful call on End{"_"}Search, the object Search will have no entries available.<br /></p>

<AnnotatedOnly>
<MarginText>106.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The only way that a call to End{"_"}Search could be unsuccessful if Device{"_"}Error (see <a href="/docs/arm/AA-A/AA-A.13">A.13</a>) is raised because of an underlying failure (or bug). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>107/2</MarginText>
<CodeBlock language="ada">
function More{"_"}Entries (Search : in Search{"_"}Type) return Boolean;{"\n"}

</CodeBlock>
<MarginText>108/2</MarginText>
<p class="Indented4">Returns True if more entries are available to be returned by a call to Get{"_"}Next{"_"}Entry for the specified search object, and False otherwise.<br /></p>

<MarginText>109/2</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Next{"_"}Entry (Search : in out Search{"_"}Type;{"\n"}                          Directory{"_"}Entry : out Directory{"_"}Entry{"_"}Type);{"\n"}

</CodeBlock>
<MarginText>110/3</MarginText>
<MarginInfo items={["AI05-0262-1"]} />
<p class="Indented4">Returns the next Directory{"_"}Entry for the search described by Search that matches the pattern and filter. If no further matches are available, Status{"_"}Error is raised. It is implementation defined as to whether the results returned by this subprogram are altered if the contents of the directory are altered while the Search object is valid (for example, by another program). The exception Use{"_"}Error is propagated if the external environment does not support continued searching of the directory represented by Search. <br /></p>

<AnnotatedOnly>
<MarginText>110.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The results of a Directories search if the contents of the directory are altered while a search is in progress.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>111/5</MarginText>
<MarginInfo items={["AI12-0286-1"]} />
<CodeBlock language="ada">
procedure Search ({"\n"}   Directory : in String;{"\n"}   Pattern   : in String;{"\n"}   Filter    : in Filter{"_"}Type := (others ={">"} True);{"\n"}   Process   : not null access procedure ({"\n"}       Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type)){"\n"}   with Allows{"_"}Exit;{"\n"}

</CodeBlock>
<MarginText>112/3</MarginText>
<MarginInfo items={["AI05-0092-1", "AI05-0262-1"]} />
<p class="Indented4">Searches in the directory named by Directory for entries matching Pattern and Filter. The subprogram designated by Process is called with each matching entry in turn. Pattern represents a pattern for matching file names. If Pattern is the null string, all items in the directory are matched; otherwise, the interpretation of Pattern is implementation defined. Only items that match Filter will be returned. The exception Name{"_"}Error is propagated if the string given by Directory does not identify an existing directory, or if Pattern does not allow the identification of any possible external file or directory. The exception Use{"_"}Error is propagated if the external environment does not support the searching of the directory with the given name (in the absence of Name{"_"}Error). <br /></p>

<AnnotatedOnly>
<MarginText>112.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>&ldquo;In turn&rdquo; means that the calls to the subprogram designated by Process are not made in parallel; they can be made in any order but must be in sequence. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>113/2</MarginText>
<CodeBlock language="ada">
function Simple{"_"}Name (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}     return String;{"\n"}

</CodeBlock>
<MarginText>114/2</MarginText>
<p class="Indented4">Returns the simple external name of the external file (including directories) represented by Directory{"_"}Entry. The format of the name returned is implementation defined. The exception Status{"_"}Error is propagated if Directory{"_"}Entry is invalid.<br /></p>

<MarginText>115/2</MarginText>
<CodeBlock language="ada">
function Full{"_"}Name (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}     return String;{"\n"}

</CodeBlock>
<MarginText>116/2</MarginText>
<p class="Indented4">Returns the full external name of the external file (including directories) represented by Directory{"_"}Entry. The format of the name returned is implementation defined. The exception Status{"_"}Error is propagated if Directory{"_"}Entry is invalid.<br /></p>

<MarginText>117/2</MarginText>
<CodeBlock language="ada">
function Kind (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}     return File{"_"}Kind;{"\n"}

</CodeBlock>
<MarginText>118/2</MarginText>
<p class="Indented4">Returns the kind of external file represented by Directory{"_"}Entry. The exception Status{"_"}Error is propagated if Directory{"_"}Entry is invalid.<br /></p>

<MarginText>119/2</MarginText>
<CodeBlock language="ada">
function Size (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}     return File{"_"}Size;{"\n"}

</CodeBlock>
<MarginText>120/2</MarginText>
<p class="Indented4">Returns the size of the external file represented by Directory{"_"}Entry. The size of an external file is the number of stream elements contained in the file. If the external file represented by Directory{"_"}Entry is not an ordinary file, the result is implementation defined. The exception Status{"_"}Error is propagated if Directory{"_"}Entry is invalid. The exception Constraint{"_"}Error is propagated if the file size is not a value of type File{"_"}Size.<br /></p>

<MarginText>121/2</MarginText>
<CodeBlock language="ada">
function Modification{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}     return Ada.Calendar.Time;{"\n"}

</CodeBlock>
<MarginText>122/2</MarginText>
<p class="Indented4">Returns the time that the external file represented by Directory{"_"}Entry was most recently modified. If the external file represented by Directory{"_"}Entry is not an ordinary file, the result is implementation defined. The exception Status{"_"}Error is propagated if Directory{"_"}Entry is invalid. The exception Use{"_"}Error is propagated if the external environment does not support reading the modification time of the file represented by Directory{"_"}Entry.<br /></p>


#### Implementation Requirements

<MarginText>123/2</MarginText>
<p>For Copy{"_"}File, if Source{"_"}Name identifies an existing external ordinary file created by a predefined Ada input-output package, and Target{"_"}Name and Form can be used in the Create operation of that input-output package with mode Out{"_"}File without raising an exception, then Copy{"_"}File shall not propagate Use{"_"}Error.<br /></p>

<AnnotatedOnly>
<MarginText>123.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This means that Copy{"_"}File will copy any file that the Ada programmer could copy (by writing some possibly complicated Ada code). <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>124/2</MarginText>
<p>If other information about a file (such as the owner or creation date) is available in a directory entry, the implementation should provide functions in a child package Directories.Information to retrieve it. <br /></p>

<AnnotatedOnly>
<MarginText>124.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Package Directories.Information should be provided to retrieve other information about a file.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>124.b/2</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>For Windows®, Directories.Information should contain at least the following routines:<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>124.c/5</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
package Ada.Directories.Information {"\n"}   with Global ={">"} in out synchronized is{"\n"}    -- System-specific directory information.{"\n"}    -- Version for the Microsoft® Windows® operating system.{"\n"}
<MarginText>124.d/2</MarginText>
    function Creation{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}
<MarginText>124.e/2</MarginText>
    function Last{"_"}Access{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}
<MarginText>124.f/2</MarginText>
    function Is{"_"}Read{"_"}Only (Name : in String) return Boolean;{"\n"}
<MarginText>124.g/2</MarginText>
    function Needs{"_"}Archiving (Name : in String) return Boolean;{"\n"}        -- This generally means that the file needs to be backed up.{"\n"}        -- The flag is only cleared by backup programs.{"\n"}
<MarginText>124.h/2</MarginText>
    function Is{"_"}Compressed (Name : in String) return Boolean;{"\n"}
<MarginText>124.i/2</MarginText>
    function Is{"_"}Encrypted (Name : in String) return Boolean;{"\n"}
<MarginText>124.j/2</MarginText>
    function Is{"_"}Hidden (Name : in String) return Boolean;{"\n"}
<MarginText>124.k/2</MarginText>
    function Is{"_"}System (Name : in String) return Boolean;{"\n"}
<MarginText>124.l/2</MarginText>
    function Is{"_"}Offline (Name : in String) return Boolean;{"\n"}
<MarginText>124.m/2</MarginText>
    function Is{"_"}Temporary (Name : in String) return Boolean;{"\n"}
<MarginText>124.n/2</MarginText>
    function Is{"_"}Sparse (Name : in String) return Boolean;{"\n"}
<MarginText>124.o/2</MarginText>
    function Is{"_"}Not{"_"}Indexed (Name : in String) return Boolean;{"\n"}
<MarginText>124.p/2</MarginText>
    function Creation{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}         return Ada.Calendar.Time;{"\n"}
<MarginText>124.q/2</MarginText>
    function Last{"_"}Access{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}         return Ada.Calendar.Time;{"\n"}
<MarginText>124.r/2</MarginText>
    function Is{"_"}Read{"_"}Only (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.s/2</MarginText>
    function Needs{"_"}Archiving (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}        -- This generally means that the file needs to be backed up.{"\n"}        -- The flag is only cleared by backup programs.{"\n"}
<MarginText>124.t/2</MarginText>
    function Is{"_"}Compressed (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.u/2</MarginText>
    function Is{"_"}Encrypted (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.v/2</MarginText>
    function Is{"_"}Hidden (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.w/2</MarginText>
    function Is{"_"}System (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.x/2</MarginText>
    function Is{"_"}Offline (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.y/2</MarginText>
    function Is{"_"}Temporary (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.z/2</MarginText>
    function Is{"_"}Sparse (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.aa/2</MarginText>
    function Is{"_"}Not{"_"}Indexed (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.bb/2</MarginText>
    -- Additional implementation-defined subprograms allowed here.{"\n"}end Ada.Directories.Information;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>124.cc/2</MarginText>
<Admonition type="aarm" aarm="note">
For Unix-like systems (Unix, POSIX, Linux, etc.), Directories.Information should contain at least the following routines:<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>124.dd/5</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
package Ada.Directories.Information {"\n"}   with Global ={">"} in out synchronized is{"\n"}    -- System-specific directory information.{"\n"}    -- Unix and similar systems version.{"\n"}
<MarginText>124.ee/2</MarginText>
    function Last{"_"}Access{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}
<MarginText>124.ff/2</MarginText>
    function Last{"_"}Status{"_"}Change{"_"}Time (Name : in String) return Ada.Calendar.Time;{"\n"}
<MarginText>124.gg/2</MarginText>
    type Permission is{"\n"}      (Others{"_"}Execute, Others{"_"}Write, Others{"_"}Read,{"\n"}       Group{"_"}Execute,  Group{"_"}Write,  Group{"_"}Read,{"\n"}       Owner{"_"}Execute,  Owner{"_"}Write,  Owner{"_"}Read,{"\n"}       Set{"_"}Group{"_"}ID,   Set{"_"}User{"_"}ID);{"\n"}
<MarginText>124.hh/2</MarginText>
    type Permission{"_"}Set{"_"}Type is array (Permission) of Boolean;{"\n"}
<MarginText>124.ii/2</MarginText>
    function Permission{"_"}Set (Name : in String) return Permission{"_"}Set{"_"}Type;{"\n"}
<MarginText>124.jj/2</MarginText>
    function Owner (Name : in String) return String;{"\n"}        -- Returns the image of the User{"_"}Id. If a definition of User{"_"}Id{"\n"}        -- is available, an implementation-defined version of Owner{"\n"}        -- returning User{"_"}Id should also be defined.{"\n"}
<MarginText>124.kk/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
    function Group (Name : in String) return String;{"\n"}        -- Returns the image of the Group{"_"}Id. If a definition of Group{"_"}Id{"\n"}        -- is available, an implementation-defined version of Group{"\n"}        -- returning Group{"_"}Id should also be defined.{"\n"}
<MarginText>124.ll/2</MarginText>
    function Is{"_"}Block{"_"}Special{"_"}File (Name : in String) return Boolean;{"\n"}
<MarginText>124.mm/2</MarginText>
    function Is{"_"}Character{"_"}Special{"_"}File (Name : in String) return Boolean;{"\n"}
<MarginText>124.nn/2</MarginText>
    function Is{"_"}FIFO (Name : in String) return Boolean;{"\n"}
<MarginText>124.oo/2</MarginText>
    function Is{"_"}Symbolic{"_"}Link (Name : in String) return Boolean;{"\n"}
<MarginText>124.pp/2</MarginText>
    function Is{"_"}Socket (Name : in String) return Boolean;{"\n"}
<MarginText>124.qq/2</MarginText>
    function Last{"_"}Access{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Ada.Calendar.Time;{"\n"}
<MarginText>124.rr/2</MarginText>
    function Last{"_"}Status{"_"}Change{"_"}Time (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Ada.Calendar.Time;{"\n"}
<MarginText>124.ss/2</MarginText>
    function Permission{"_"}Set (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Permission{"_"}Set{"_"}Type;{"\n"}
<MarginText>124.tt/2</MarginText>
    function Owner (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return String;{"\n"}       -- See Owner above.{"\n"}
<MarginText>124.uu/2</MarginText>
    function Group (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return String;{"\n"}       -- See Group above.{"\n"}
<MarginText>124.vv/2</MarginText>
    function Is{"_"}Block{"_"}Special{"_"}File (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Boolean;{"\n"}
<MarginText>124.ww/2</MarginText>
    function Is{"_"}Character{"_"}Special{"_"}File (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Boolean;{"\n"}
<MarginText>124.xx/2</MarginText>
    function Is{"_"}FIFO (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.yy/2</MarginText>
    function Is{"_"}Symbolic{"_"}Link (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type){"\n"}       return Boolean;{"\n"}
<MarginText>124.zz/2</MarginText>
    function Is{"_"}Socket (Directory{"_"}Entry : in Directory{"_"}Entry{"_"}Type) return Boolean;{"\n"}
<MarginText>124.aaa/2</MarginText>
    -- Additional implementation-defined subprograms allowed here.{"\n"}end Ada.Directories.Information;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>124.bbb/2</MarginText>
<Admonition type="aarm" aarm="note">
We give these definitions to give guidance so that every implementation for a given target is not unnecessarily different. Implementers are encouraged to make packages for other targets as similar to these as possible.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>125/5</MarginText>
<MarginInfo items={["AI05-0231-1", "AI12-0439-1"]} />
<p>Start{"_"}Search and Search should raise Name{"_"}Error if Pattern is malformed, but not if it can represent a file in the directory but does not actually do so.<br /></p>

<AnnotatedOnly>
<MarginText>125.a/3</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Directories.Start{"_"}Search and Directories.Search should raise Name{"_"}Error for malformed patterns.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>126/2</MarginText>
<p>Rename should be supported at least when both New{"_"}Name and Old{"_"}Name are simple names and New{"_"}Name does not identify an existing external file. <br /></p>

<AnnotatedOnly>
<MarginText>126.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Directories.Rename should be supported at least when both New{"_"}Name and Old{"_"}Name are simple names and New{"_"}Name does not identify an existing external file.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>126.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>&ldquo;Supported&rdquo; includes raising an exception if either name is malformed, the file to rename doesn't exist, insufficient permission for the operation exists, or similar problems. But this advice requires implementations to document what they do, and tells implementers that simply raising Use{"_"}Error isn't acceptable. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>127/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   The operations Containing{"_"}Directory, Full{"_"}Name, Simple{"_"}Name, Base{"_"}Name, Extension, and Compose operate on file names, not external files. The files identified by these operations do not necessarily exist. Name{"_"}Error is raised only if the file name is malformed and cannot possibly identify a file. Of these operations, only the result of Full{"_"}Name depends on the current default directory; the result of the others depends only on their parameters.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>128/2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   Using access types, values of Search{"_"}Type and Directory{"_"}Entry{"_"}Type can be saved and queried later. However, another task or application can modify or delete the file represented by a Directory{"_"}Entry{"_"}Type value or the directory represented by a Search{"_"}Type value; such a value can only give the information valid at the time it is created. Therefore, long-term storage of these values is not recommended.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>129/2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   If the target system does not support directories inside of directories, then Kind will never return Directory and Containing{"_"}Directory will always raise Use{"_"}Error.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>130/2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 4   If the target system does not support creation or deletion of directories, then Create{"_"}Directory, Create{"_"}Path, Delete{"_"}Directory, and Delete{"_"}Tree will always propagate Use{"_"}Error.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>131/5</MarginText>
<MarginInfo items={["AI12-0442-1", "AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 5   To move a file or directory to a different location, use Rename. Most target systems will allow renaming of files from one directory to another. If the target file or directory can already exist, it should be deleted first. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>131.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>While Rename is only guaranteed to work for name changes within a single directory, its unlikely that implementers would purposely prevent functionality present in the underlying system from working. To move a file totally portably, it's necessary to handle failure of the Rename and fall back to Copy{"_"}File and Delete: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>131.b</MarginText>
<CodeBlock language="ada">
begin{"\n"}   Rename (Source, Target);{"\n"}exception{"\n"}   when Use{"_"}Error ={">"}{"\n"}      Copy{"_"}File (Source, Target);{"\n"}      Delete (Source);{"\n"}end;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>131.c/2</MarginText>
<MarginInfo items={["AI95-00248-01"]} />
<Admonition type="aarm" aarm="note">
Package Ada.Directories is new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>131.d/3</MarginText>
<MarginInfo items={["AI05-0231-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Correction</strong>: Clarified when and which exceptions are raised for Start{"_"}Search, Search, Delete{"_"}Directory, and Rename. If an implementation followed the original incorrect wording, it might raise Use{"_"}Error instead of Name{"_"}Error for Start{"_"}Search and Search, Name{"_"}Error instead of Use{"_"}Error for Rename, and might have deleted a nonempty directory instead of raising Use{"_"}Error for Delete{"_"}Directory. The first two cases are very unlikely to matter in practice, and it unlikely that an implementation would have followed the latter implementation strategy, as it would be more work and would make Delete{"_"}Directory identical to Delete{"_"}Tree (which is obvious nonsense). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>131.e/3</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<Admonition type="aarm" aarm="note">
A new enumeration type Name{"_"}Case{"_"}Kind and a new function Name{"_"}Case{"_"}Equivalence is added to Directories. If Directories is referenced in a <code><a href="/docs/arm/AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with a <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code> of one of the new entities is defined in a package that is also referenced in a <code><a href="/docs/arm/AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>131.f/3</MarginText>
<MarginInfo items={["AI05-0271-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> We now explicitly say that the behavior of Create{"_"}Path and Copy{"_"}File is unspecified when Use{"_"}Error is raised. Nothing has changed here, as the behavior was (implicitly) unspecified in the 2007 Amendment. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>131.g/5</MarginText>
<MarginInfo items={["AI12-0337-1", "AI12-0433-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified the meaning of Simple{"_"}Name in the case that the parameter is a root directory. This was not previously described. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.16.1"></a>

## A.16.1  The Package Directories.Hierarchical_File_Names

<MarginText>1/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<p>The library package Directories.Hierarchical{"_"}File{"_"}Names is an optional package providing operations for file name construction and decomposition for targets with hierarchical file naming. <br /></p>


#### Static Semantics

<MarginText>2/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<p>If provided, the library package Directories.Hierarchical{"_"}File{"_"}Names has the following declaration:<br /></p>

<MarginText>3/5_A.16.1</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
package Ada.Directories.Hierarchical{"_"}File{"_"}Names{"\n"}   with Nonblocking, Global ={">"} in out synchronized is{"\n"}
<MarginText>4/3_A.16.1</MarginText>
   function Is{"_"}Simple{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>5/3_A.16.1</MarginText>
   function Is{"_"}Root{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>6/3_A.16.1</MarginText>
   function Is{"_"}Parent{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>7/3_A.16.1</MarginText>
   function Is{"_"}Current{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>8/3_A.16.1</MarginText>
   function Is{"_"}Full{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>9/3_A.16.1</MarginText>
   function Is{"_"}Relative{"_"}Name (Name : in String) return Boolean;{"\n"}
<MarginText>10/3_A.16.1</MarginText>
   function Simple{"_"}Name (Name : in String) return String{"\n"}      renames Ada.Directories.Simple{"_"}Name;{"\n"}
<MarginText>11/3_A.16.1</MarginText>
   function Containing{"_"}Directory (Name : in String) return String{"\n"}      renames Ada.Directories.Containing{"_"}Directory;{"\n"}
<MarginText>12/3_A.16.1</MarginText>
   function Initial{"_"}Directory (Name : in String) return String;{"\n"}
<MarginText>13/3_A.16.1</MarginText>
   function Relative{"_"}Name (Name : in String) return String;{"\n"}
<MarginText>14/3_A.16.1</MarginText>
   function Compose (Directory      : in String := "";{"\n"}                     Relative{"_"}Name  : in String;{"\n"}                     Extension      : in String := "") return String;{"\n"}
<MarginText>15/3_A.16.1</MarginText>
end Ada.Directories.Hierarchical{"_"}File{"_"}Names;{"\n"}

</CodeBlock>
<MarginText>16/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1", "AI05-0269-1"]} />
<p>In addition to the operations provided in package Directories.Hierarchical{"_"}File{"_"}Names, the operations in package Directories can be used with hierarchical file names. In particular, functions Full{"_"}Name, Base{"_"}Name, and Extension provide additional capabilities for hierarchical file names.<br /></p>

<MarginText>17/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Simple{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>18/3_A.16.1</MarginText>
<p class="Indented4">Returns True if Name is a simple name, and returns False otherwise.<br /></p>

<AnnotatedOnly>
<MarginText>18.a/5_A.16.1</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Root directories are considered simple names, so this function will return True if Name represents a root. Use Is{"_"}Root{"_"}Directory if it is necessary to distinguish roots and other simple names. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>19/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Root{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>20/3_A.16.1</MarginText>
<p class="Indented4">Returns True if Name is syntactically a root (a directory that cannot be decomposed further), and returns False otherwise.<br /></p>

<MarginText>21/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Parent{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>22/3_A.16.1</MarginText>
<p class="Indented4">Returns True if Name can be used to indicate symbolically the parent directory of any directory, and returns False otherwise.<br /></p>

<AnnotatedOnly>
<MarginText>22.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Is{"_"}Parent{"_"}Directory{"_"}Name returns True if and only if Name is ".." for both Unix and Windows®. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>23/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Current{"_"}Directory{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>24/3_A.16.1</MarginText>
<p class="Indented4">Returns True if Name can be used to indicate symbolically the directory itself for any directory, and returns False otherwise.<br /></p>

<AnnotatedOnly>
<MarginText>24.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Is{"_"}Current{"_"}Directory{"_"}Name returns True if and only if Name is "." for both Unix and Windows®. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>25/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Full{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>26/3_A.16.1</MarginText>
<p class="Indented4">Returns True if the leftmost directory part of Name is a root, and returns False otherwise.<br /></p>

<MarginText>27/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Is{"_"}Relative{"_"}Name (Name : in String) return Boolean;{"\n"}

</CodeBlock>
<MarginText>28/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1", "AI05-0269-1"]} />
<p class="Indented4">Returns True if Name allows the identification of an external file (including directories and special files) but is not a full name, and returns False otherwise.<br /></p>

<AnnotatedOnly>
<MarginText>28.a/5_A.16.1</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Relative names include simple names other than root directories as a special case. This function returns False if the syntax of the name is incorrect. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>29/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Initial{"_"}Directory (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>30/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1", "AI05-0248-1"]} />
<p class="Indented4">Returns the leftmost directory part in Name. [That is, it returns a root directory name (for a full name), or one of a parent directory name, a current directory name, or a simple name (for a relative name).] The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).<br /></p>

<MarginText>31/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Relative{"_"}Name (Name : in String) return String;{"\n"}

</CodeBlock>
<MarginText>32/3_A.16.1</MarginText>
<p class="Indented4">Returns the entire file name except the Initial{"_"}Directory portion. The exception Name{"_"}Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files), or if Name has a single part (this includes if any of Is{"_"}Simple{"_"}Name, Is{"_"}Root{"_"}Directory{"_"}Name, Is{"_"}Parent{"_"}Directory{"_"}Name, or Is{"_"}Current{"_"}Directory{"_"}Name are True).<br /></p>

<AnnotatedOnly>
<MarginText>32.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The result might be a simple name. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>33/3_A.16.1</MarginText>
<CodeBlock language="ada">
function Compose (Directory      : in String := "";{"\n"}                  Relative{"_"}Name  : in String;{"\n"}                  Extension      : in String := "") return String;{"\n"}

</CodeBlock>
<MarginText>34/3_A.16.1</MarginText>
<p class="Indented4">Returns the name of the external file with the specified Directory, Relative{"_"}Name, and Extension. The exception Name{"_"}Error is propagated if the string given as Directory is not the null string and does not allow the identification of a directory, or if Is{"_"}Relative{"_"}Name (Relative{"_"}Name) is False, or if the string given as Extension is not the null string and is not a possible extension, or if Extension is not the null string and Simple{"_"}Name (Relative{"_"}Name) is not a base name.<br /></p>

<MarginText>35/3_A.16.1</MarginText>
<p class="Indented4">The result of Compose is a full name if Is{"_"}Full{"_"}Name (Directory) is True; result is a relative name otherwise.<br /></p>

<AnnotatedOnly>
<MarginText>35.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Name{"_"}Error is raised by Compose if Directory is not the null string, and both Is{"_"}Full{"_"}Name and Is{"_"}Relative{"_"}Name return False. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.b/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>A common security problem is to include a parent directory name in the middle of a file name; this is often used to navigate outside of an intended root directory. We considered attempting to prevent that case by having Compose detect it and raise an exception. But the extra rules necessary were more confusing than helpful.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.c/5_A.16.1</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="note">
We can say more about the details of these operations by adopting the notation of a subscript to specify how many path fragments a particular result has. Then, we can abbreviate "Full Name" as "Full" and "Relative Name" as "Rel". In this notation, Unix file name "a/b" is a Rel(2), "../c/d" is a Rel(3), and "/a/b" is a Full(2). Rel(1) is equivalent to a simple name that is not a root; thus we don't have to describe that separately.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.d/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="note">
In this notation, <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.e/3_A.16.1</MarginText>
<CodeBlock language="ada">
  {"\n"}For N{">"}1,{"\n"}Containing{"_"}Directory(Rel(N)) = Leftmost Rel(N-1),{"\n"}Containing{"_"}Directory(Full(N)) = Leftmost Full(N-1),{"\n"}Else if N = 1, raise Use{"_"}Error.{"\n"}  {"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.f/3_A.16.1</MarginText>
<MarginInfo items={["AI12-0337-1"]} />
<Admonition type="aarm" aarm="note">
Similarly, <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.g/3_A.16.1</MarginText>
<CodeBlock language="ada">
For N{">"}1,{"\n"}Relative{"_"}Name(Rel(N)) = Rightmost Rel(N-1),{"\n"}Relative{"_"}Name(Full(N)) = Rightmost Full(N-1),{"\n"}Else if N = 1, raise Name{"_"}Error.{"\n"}  {"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.h/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="note">
Finally, for Compose (ignoring the extension here): <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35.i/3_A.16.1</MarginText>
<CodeBlock language="ada">
Compose (Directory ={">"} Full(N), Relative{"_"}Name ={">"} Rel(M)) ={">"} Full(N+M){"\n"}Compose (Directory ={">"} Rel(N), Relative{"_"}Name ={">"} Rel(M)) ={">"} Rel(N+M){"\n"}Name{"_"}Error if Relative{"_"}Name is a Full(M).{"\n"}  {"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>35.j/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="note">
We didn't try to write wording to reflect these details of these functions. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>36/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<p>Directories.Hierarchical{"_"}File{"_"}Names should be provided for systems with hierarchical file naming, and should not be provided on other systems. <br /></p>

<AnnotatedOnly>
<MarginText>36.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Directories.Hierarchical{"_"}File{"_"}Names should be provided for systems with hierarchical file naming, and should not be provided on other systems.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>36.b/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>This package should be provided when targeting Microsoft® Windows®, Unix, Linux, and most Unix-like systems. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37/5_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   These operations operate on file names, not external files. The files identified by these operations do not necessarily exist. Name{"_"}Error is raised only as specified or if the file name is malformed and cannot possibly identify a file. The result of these operations depends only on their parameters.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   Containing{"_"}Directory raises Use{"_"}Error if Name does not have a containing directory, including when any of Is{"_"}Simple{"_"}Name, Is{"_"}Root{"_"}Directory{"_"}Name, Is{"_"}Parent{"_"}Directory{"_"}Name, or Is{"_"}Current{"_"}Directory{"_"}Name are True.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.a/3_A.16.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>In particular, the default directory is not used to find the containing directory either when Is{"_"}Parent{"_"}Directory{"_"}Name or Is{"_"}Current{"_"}Directory{"_"}Name is True. As noted above, these functions operate purely on the syntax of the file names and do not attempt to interpret them. If interpretation is needed, Directories.Full{"_"}Name can be to expand any shorthands used before calling Containing{"_"}Directory. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>38.b/3_A.16.1</MarginText>
<MarginInfo items={["AI05-0049-1"]} />
<Admonition type="aarm" aarm="note">
Package Ada.Directories.Hierarchical{"_"}File{"_"}Names is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.16.2"></a>

## A.16.2  The Packages Wide_Directories and Wide_Wide_Directories

<MarginText>1/5_A.16.2</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
<p>The packages Wide{"_"}Directories and Wide{"_"}Wide{"_"}Directories provide operations for manipulating files and directories, and their names. <br /></p>


#### Static Semantics

<MarginText>2/5_A.16.2</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
<p>The specification of package Wide{"_"}Directories is the same as for Directories (including its optional child packages Information and Hierarchical{"_"}File{"_"}Names), except that each occurrence of String is replaced by Wide{"_"}String. <br /></p>

<MarginText>3/5_A.16.2</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
<p>The specification of package Wide{"_"}Wide{"_"}Directories is the same as for Directories (including its optional child packages Information and Hierarchical{"_"}File{"_"}Names), except that each occurrence of String is replaced by Wide{"_"}Wide{"_"}String. <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>3.a/5_A.16.2</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
<Admonition type="aarm" aarm="note">
These six packages are new. <br />
</Admonition>
</AnnotatedOnly>

