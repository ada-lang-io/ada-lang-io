---
sidebar_position:  125
---

# A.5. The Numerics Packages

:::danger
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>The library package Numerics is the parent of several child units that provide facilities for mathematical computation. One child, the generic package Generic{"_"}Elementary{"_"}Functions, is defined in <a href="/docs/arm/AA-A/AA-A.5#Subclause_A.5.1">A.5.1</a>, together with nongeneric equivalents; two others, the package Float{"_"}Random and the generic package Discrete{"_"}Random, are defined in <a href="/docs/arm/AA-A/AA-A.5#Subclause_A.5.2">A.5.2</a>. Additional (optional) children are defined in <a href="/docs/arm/AA-G/">Annex G</a>, &ldquo;<a href="/docs/arm/AA-G/">Numerics</a>&rdquo;. <br /></p>


#### Static Semantics

<MarginText>2/1</MarginText>
<p><i>This paragraph was deleted.</i><br /></p>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI95-00388-01", "AI12-0414-1"]} />
<CodeBlock language="ada">
package Ada.Numerics{"\n"}   with Pure is{"\n"}   Argument{"_"}Error : exception;{"\n"}   Pi : constant :={"\n"}          3.14159{"_"}26535{"_"}89793{"_"}23846{"_"}26433{"_"}83279{"_"}50288{"_"}41971{"_"}69399{"_"}37511;{"\n"}   &pi;  : constant := Pi;{"\n"}   e  : constant :={"\n"}          2.71828{"_"}18284{"_"}59045{"_"}23536{"_"}02874{"_"}71352{"_"}66249{"_"}77572{"_"}47093{"_"}69996;{"\n"}end Ada.Numerics;{"\n"}

</CodeBlock>
<MarginText>4</MarginText>
<p>The Argument{"_"}Error exception is raised by a subprogram in a child unit of Numerics to signal that one or more of the actual subprogram parameters are outside the domain of the corresponding mathematical function.<br /></p>


#### Implementation Permissions

<MarginText>5</MarginText>
<p>The implementation may specify the values of Pi and e to a larger number of significant digits. <br /></p>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>51 digits seem more than adequate for all present computers; converted to binary, the values given above are accurate to more than 160 bits. Nevertheless, the permission allows implementations to accommodate unforeseen hardware advances. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>5.b</MarginText>
<Admonition type="aarm" aarm="note">
Numerics and its children were not predefined in Ada 83. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>5.c/2</MarginText>
<MarginInfo items={["AI95-00388-01"]} />
<Admonition type="aarm" aarm="note">
The alternative declaration of &pi; is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.1"></a>

## A.5.1  Elementary Functions

<MarginText>1_A.5.1</MarginText>
<p>Implementation-defined approximations to the mathematical functions known as the &ldquo;elementary functions&rdquo; are provided by the subprograms in Numerics.Generic{"_"}Elementary{"_"}Functions. Nongeneric equivalents of this generic package for each of the predefined floating point types are also provided as children of Numerics. <br /></p>

<AnnotatedOnly>
<MarginText>1.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The accuracy actually achieved by the elementary functions.<br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2_A.5.1</MarginText>
<p>The generic library package Numerics.Generic{"_"}Elementary{"_"}Functions has the following declaration: <br /></p>

<MarginText>3/5_A.5.1</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
<CodeBlock language="ada">
generic{"\n"}   type Float{"_"}Type is digits {"<"}{">"};{"\n"}{"\n"}package Ada.Numerics.Generic{"_"}Elementary{"_"}Functions{"\n"}   with Pure, Nonblocking is{"\n"}
<MarginText>4_A.5.1</MarginText>
   function Sqrt    (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Log     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Log     (X, Base     : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Exp     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function "{"*"}{"*"}"    (Left, Right : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}
<MarginText>5_A.5.1</MarginText>
   function Sin     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Sin     (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Cos     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Cos     (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Tan     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Tan     (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Cot     (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Cot     (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}
<MarginText>6_A.5.1</MarginText>
   function Arcsin  (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arcsin  (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arccos  (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arccos  (X, Cycle    : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arctan  (Y           : Float{"_"}Type'Base;{"\n"}                     X           : Float{"_"}Type'Base := 1.0){"\n"}                                                    return Float{"_"}Type'Base;{"\n"}   function Arctan  (Y           : Float{"_"}Type'Base;{"\n"}                     X           : Float{"_"}Type'Base := 1.0;{"\n"}                     Cycle       : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arccot  (X           : Float{"_"}Type'Base;{"\n"}                     Y           : Float{"_"}Type'Base := 1.0){"\n"}                                                    return Float{"_"}Type'Base;{"\n"}   function Arccot  (X           : Float{"_"}Type'Base;{"\n"}                     Y           : Float{"_"}Type'Base := 1.0;{"\n"}                     Cycle       : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}
<MarginText>7_A.5.1</MarginText>
   function Sinh    (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Cosh    (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Tanh    (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Coth    (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arcsinh (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arccosh (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arctanh (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}   function Arccoth (X           : Float{"_"}Type'Base) return Float{"_"}Type'Base;{"\n"}
<MarginText>8_A.5.1</MarginText>
end Ada.Numerics.Generic{"_"}Elementary{"_"}Functions;{"\n"}

</CodeBlock>
<MarginText>9/1_A.5.1</MarginText>
<MarginInfo items={["AI95-00126-01"]} />
<p>{"{"}<i>8652/0020</i>{"}"} The library package Numerics.Elementary{"_"}Functions is declared pure and defines the same subprograms as Numerics.Generic{"_"}Elementary{"_"}Functions, except that the predefined type Float is systematically substituted for Float{"_"}Type'Base throughout. Nongeneric equivalents of Numerics.Generic{"_"}Elementary{"_"}Functions for each of the other predefined floating point types are defined similarly, with the names Numerics.Short{"_"}Elementary{"_"}Functions, Numerics.Long{"_"}Elementary{"_"}Functions, etc. <br /></p>

<AnnotatedOnly>
<MarginText>9.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>The nongeneric equivalents are provided to allow the programmer to construct simple mathematical applications without being required to understand and use generics. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>10_A.5.1</MarginText>
<p>The functions have their usual mathematical meanings. When the Base parameter is specified, the Log function computes the logarithm to the given base; otherwise, it computes the natural logarithm. When the Cycle parameter is specified, the parameter X of the forward trigonometric functions (Sin, Cos, Tan, and Cot) and the results of the inverse trigonometric functions (Arcsin, Arccos, Arctan, and Arccot) are measured in units such that a full cycle of revolution has the given value; otherwise, they are measured in radians.<br /></p>

<MarginText>11_A.5.1</MarginText>
<p>The computed results of the mathematically multivalued functions are rendered single-valued by the following conventions, which are meant to imply the principal branch: <br /></p>

<MarginText>12_A.5.1</MarginText>
<ul>
<li>The results of the Sqrt and Arccosh functions and that of the exponentiation operator are nonnegative.<br /></li>
<MarginText>13_A.5.1</MarginText>
<li>The result of the Arcsin function is in the quadrant containing the point (1.0, <i>x</i>), where <i>x</i> is the value of the parameter X. This quadrant is I or IV; thus, the range of the Arcsin function is approximately &ndash;&pi;/2.0 to &pi;/2.0 (&ndash;Cycle/4.0 to Cycle/4.0, if the parameter Cycle is specified).<br /></li>
<MarginText>14_A.5.1</MarginText>
<li>The result of the Arccos function is in the quadrant containing the point (<i>x</i>, 1.0), where <i>x</i> is the value of the parameter X. This quadrant is I or II; thus, the Arccos function ranges from 0.0 to approximately &pi; (Cycle/2.0, if the parameter Cycle is specified).<br /></li>
<MarginText>15_A.5.1</MarginText>
<li>The results of the Arctan and Arccot functions are in the quadrant containing the point (<i>x</i>, <i>y</i>), where <i>x</i> and <i>y</i> are the values of the parameters X and Y, respectively. This may be any quadrant (I through IV) when the parameter X (resp., Y) of Arctan (resp., Arccot) is specified, but it is restricted to quadrants I and IV (resp., I and II) when that parameter is omitted. Thus, the range when that parameter is specified is approximately &ndash;&pi; to &pi; (&ndash;Cycle/2.0 to Cycle/2.0, if the parameter Cycle is specified); when omitted, the range of Arctan (resp., Arccot) is that of Arcsin (resp., Arccos), as given above. When the point (<i>x</i>, <i>y</i>) lies on the negative x-axis, the result approximates <br /></li>
<MarginText>16_A.5.1</MarginText>
<li>&pi; (resp., &ndash;&pi;) when the sign of the parameter Y is positive (resp., negative), if Float{"_"}Type'Signed{"_"}Zeros is True;<br /></li>
<MarginText>17_A.5.1</MarginText>
<li>&pi;, if Float{"_"}Type'Signed{"_"}Zeros is False. <br /></li>
</ul>
<MarginText>18_A.5.1</MarginText>
<p>(In the case of the inverse trigonometric functions, in which a result lying on or near one of the axes may not be exactly representable, the approximation inherent in computing the result may place it in an adjacent quadrant, close to but on the wrong side of the axis.) <br /></p>


#### Dynamic Semantics

<MarginText>19_A.5.1</MarginText>
<p>The exception Numerics.Argument{"_"}Error is raised, signaling a parameter value outside the domain of the corresponding mathematical function, in the following cases: <br /></p>

<MarginText>20_A.5.1</MarginText>
<ul>
<li>by any forward or inverse trigonometric function with specified cycle, when the value of the parameter Cycle is zero or negative;<br /></li>
<MarginText>21_A.5.1</MarginText>
<li>by the Log function with specified base, when the value of the parameter Base is zero, one, or negative;<br /></li>
<MarginText>22_A.5.1</MarginText>
<li>by the Sqrt and Log functions, when the value of the parameter X is negative;<br /></li>
<MarginText>23_A.5.1</MarginText>
<li>by the exponentiation operator, when the value of the left operand is negative or when both operands have the value zero;<br /></li>
<MarginText>24_A.5.1</MarginText>
<li>by the Arcsin, Arccos, and Arctanh functions, when the absolute value of the parameter X exceeds one;<br /></li>
<MarginText>25_A.5.1</MarginText>
<li>by the Arctan and Arccot functions, when the parameters X and Y both have the value zero;<br /></li>
<MarginText>26_A.5.1</MarginText>
<li>by the Arccosh function, when the value of the parameter X is less than one; and<br /></li>
<MarginText>27_A.5.1</MarginText>
<li>by the Arccoth function, when the absolute value of the parameter X is less than one. <br /></li>
</ul>
<MarginText>28_A.5.1</MarginText>
<p>The exception Constraint{"_"}Error is raised, signaling a pole of the mathematical function (analogous to dividing by zero), in the following cases, provided that Float{"_"}Type'Machine{"_"}Overflows is True: <br /></p>

<MarginText>29_A.5.1</MarginText>
<ul>
<li>by the Log, Cot, and Coth functions, when the value of the parameter X is zero;<br /></li>
<MarginText>30_A.5.1</MarginText>
<li>by the exponentiation operator, when the value of the left operand is zero and the value of the exponent is negative;<br /></li>
<MarginText>31_A.5.1</MarginText>
<li>by the Tan function with specified cycle, when the value of the parameter X is an odd multiple of the quarter cycle;<br /></li>
<MarginText>32_A.5.1</MarginText>
<li>by the Cot function with specified cycle, when the value of the parameter X is zero or a multiple of the half cycle; and<br /></li>
<MarginText>33_A.5.1</MarginText>
<li>by the Arctanh and Arccoth functions, when the absolute value of the parameter X is one. <br /></li>
</ul>
<MarginText>34_A.5.1</MarginText>
<p>[Constraint{"_"}Error can also be raised when a finite result overflows (see <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.4">G.2.4</a>); this may occur for parameter values sufficiently <i>near</i> poles, and, in the case of some of the functions, for parameter values with sufficiently large magnitudes.] When Float{"_"}Type'Machine{"_"}Overflows is False, the result at poles is unspecified. <br /></p>

<AnnotatedOnly>
<MarginText>34.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>The purpose of raising Constraint{"_"}Error (rather than Numerics.Argument{"_"}Error) at the poles of a function, when Float{"_"}Type'Machine{"_"}Overflows is True, is to provide continuous behavior as the actual parameters of the function approach the pole and finally reach it. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>34.b_A.5.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>It is anticipated that an Ada binding to IEC 559:1989 will be developed in the future. As part of such a binding, the Machine{"_"}Overflows attribute of a conformant floating point type will be specified to yield False, which will permit both the predefined arithmetic operations and implementations of the elementary functions to deliver signed infinities (and set the overflow flag defined by the binding) instead of raising Constraint{"_"}Error in overflow situations, when traps are disabled. Similarly, it is appropriate for the elementary functions to deliver signed infinities (and set the zero-divide flag defined by the binding) instead of raising Constraint{"_"}Error at poles, when traps are disabled. Finally, such a binding should also specify the behavior of the elementary functions, when sensible, given parameters with infinite values. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>35/5_A.5.1</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<p>When one parameter of a function with multiple parameters represents a pole and another is outside the function's domain, the latter takes precedence and Numerics.Argument{"_"}Error is raised. <br /></p>


#### Implementation Requirements

<MarginText>36_A.5.1</MarginText>
<p>In the implementation of Numerics.Generic{"_"}Elementary{"_"}Functions, the range of intermediate values allowed during the calculation of a final result shall not be affected by any range constraint of the subtype Float{"_"}Type. <br /></p>

<AnnotatedOnly>
<MarginText>36.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>Implementations of Numerics.Generic{"_"}Elementary{"_"}Functions written in Ada should therefore avoid declaring local variables of subtype Float{"_"}Type; the subtype Float{"_"}Type'Base should be used instead. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>37_A.5.1</MarginText>
<p>In the following cases, evaluation of an elementary function shall yield the <i>prescribed result</i>, provided that the preceding rules do not call for an exception to be raised: <br /></p>

<MarginText>38_A.5.1</MarginText>
<ul>
<li>When the parameter X has the value zero, the Sqrt, Sin, Arcsin, Tan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of zero, and the Exp, Cos, and Cosh functions yield a result of one.<br /></li>
<MarginText>39_A.5.1</MarginText>
<li>When the parameter X has the value one, the Sqrt function yields a result of one, and the Log, Arccos, and Arccosh functions yield a result of zero.<br /></li>
<MarginText>40_A.5.1</MarginText>
<li>When the parameter Y has the value zero and the parameter X has a positive value, the Arctan and Arccot functions yield a result of zero.<br /></li>
<MarginText>41_A.5.1</MarginText>
<li>The results of the Sin, Cos, Tan, and Cot functions with specified cycle are exact when the mathematical result is zero; those of the first two are also exact when the mathematical result is ± 1.0.<br /></li>
<MarginText>42_A.5.1</MarginText>
<li>Exponentiation by a zero exponent yields the value one. Exponentiation by a unit exponent yields the value of the left operand. Exponentiation of the value one yields the value one. Exponentiation of the value zero yields the value zero. <br /></li>
</ul>
<MarginText>43_A.5.1</MarginText>
<p>Other accuracy requirements for the elementary functions, which apply only in implementations conforming to the Numerics Annex, and then only in the &ldquo;strict&rdquo; mode defined there (see <a href="/docs/arm/AA-G/AA-G.2">G.2</a>), are given in <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.4">G.2.4</a>.<br /></p>

<MarginText>44_A.5.1</MarginText>
<p>When Float{"_"}Type'Signed{"_"}Zeros is True, the sign of a zero result shall be as follows: <br /></p>

<MarginText>45_A.5.1</MarginText>
<ul>
<li>A prescribed zero result delivered <i>at the origin</i> by one of the odd functions (Sin, Arcsin, Sinh, Arcsinh, Tan, Arctan or Arccot as a function of Y when X is fixed and positive, Tanh, and Arctanh) has the sign of the parameter X (Y, in the case of Arctan or Arccot).<br /></li>
<MarginText>46_A.5.1</MarginText>
<li>A prescribed zero result delivered by one of the odd functions <i>away from the origin</i>, or by some other elementary function, has an implementation-defined sign. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>46.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The sign of a zero result from some of the operators or functions in Numerics.Generic{"_"}Elementary{"_"}Functions, when Float{"_"}Type'Signed{"_"}Zeros is True.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>47/5_A.5.1</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<ul>
<li>[A zero result that is not a prescribed result (that is, one that results from rounding or underflow) has the correct mathematical sign.] <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>47.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>This is a consequence of the rules specified in IEC 559:1989 as they apply to underflow situations with traps disabled. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>48/5_A.5.1</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>The nongeneric equivalent packages can be actual instantiations of the generic package for the appropriate predefined type, though that is not required. <br /></p>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>48.a_A.5.1</MarginText>
<Admonition type="aarm" aarm="note">
The semantics of Numerics.Generic{"_"}Elementary{"_"}Functions differs from Generic{"_"}Elementary{"_"}Functions as defined in ISO/IEC DIS 11430 (for Ada 83) in the following ways: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>48.b_A.5.1</MarginText>
<ul>
<li>The generic package is a child unit of the package defining the Argument{"_"}Error exception.<br /></li>
<MarginText>48.c_A.5.1</MarginText>
<li>DIS 11430 specified names for the nongeneric equivalents, if provided. Here, those nongeneric equivalents are required.<br /></li>
<MarginText>48.d_A.5.1</MarginText>
<li>Implementations are not allowed to impose an optional restriction that the generic actual parameter associated with Float{"_"}Type be unconstrained. (In view of the ability to declare variables of subtype Float{"_"}Type'Base in implementations of Numerics.Generic{"_"}Elementary{"_"}Functions, this flexibility is no longer needed.)<br /></li>
<MarginText>48.e_A.5.1</MarginText>
<li>The sign of a prescribed zero result at the origin of the odd functions is specified, when Float{"_"}Type'Signed{"_"}Zeros is True. This conforms with recommendations of Kahan and other numerical analysts.<br /></li>
<MarginText>48.f_A.5.1</MarginText>
<li>The dependence of Arctan and Arccot on the sign of a parameter value of zero is tied to the value of Float{"_"}Type'Signed{"_"}Zeros.<br /></li>
<MarginText>48.g_A.5.1</MarginText>
<li>Sqrt is prescribed to yield a result of one when its parameter has the value one. This guarantee makes it easier to achieve certain prescribed results of the complex elementary functions (see <a href="/docs/arm/AA-G/AA-G.1#Subclause_G.1.2">G.1.2</a>, &ldquo;<a href="/docs/arm/AA-G/AA-G.1#Subclause_G.1.2">Complex Elementary Functions</a>&rdquo;).<br /></li>
<MarginText>48.h_A.5.1</MarginText>
<li>Conformance to accuracy requirements is conditional. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>48.i/2_A.5.1</MarginText>
<MarginInfo items={["AI95-00126-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0020</i>{"}"} <b>Corrigendum:</b> Explicitly stated that the nongeneric equivalents of Generic{"_"}Elementary{"_"}Functions are pure. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.2"></a>

## A.5.2  Random Number Generation

<MarginText>1_A.5.2</MarginText>
<p>[Facilities for the generation of pseudo-random floating point numbers are provided in the package Numerics.Float{"_"}Random; the generic package Numerics.Discrete{"_"}Random provides similar facilities for the generation of pseudo-random integers and pseudo-random values of enumeration types. For brevity, pseudo-random values of any of these types are called <i>random numbers</i>.<br /></p>

<MarginText>2_A.5.2</MarginText>
<p>Some of the facilities provided are basic to all applications of random numbers. These include a limited private type each of whose objects serves as the generator of a (possibly distinct) sequence of random numbers; a function to obtain the &ldquo;next&rdquo; random number from a given sequence of random numbers (that is, from its generator); and subprograms to initialize or reinitialize a given generator to a time-dependent state or a state denoted by a single integer.<br /></p>

<MarginText>3_A.5.2</MarginText>
<p>Other facilities are provided specifically for advanced applications. These include subprograms to save and restore the state of a given generator; a private type whose objects can be used to hold the saved state of a generator; and subprograms to obtain a string representation of a given generator state, or, given such a string representation, the corresponding state.] <br /></p>

<AnnotatedOnly>
<MarginText>3.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>These facilities support a variety of requirements ranging from repeatable sequences (for debugging) to unique sequences in each execution of a program. <br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>4_A.5.2</MarginText>
<p>The library package Numerics.Float{"_"}Random has the following declaration: <br /></p>

<MarginText>5/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
package Ada.Numerics.Float{"_"}Random{"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>6_A.5.2</MarginText>
   -- Basic facilities{"\n"}
<MarginText>7_A.5.2</MarginText>
   type Generator is limited private;{"\n"}
<MarginText>8/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   subtype Uniformly{"_"}Distributed is Float range 0.0 .. 1.0;{"\n"}   function Random (Gen : Generator) return Uniformly{"_"}Distributed{"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>9/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Reset (Gen       : in Generator;{"\n"}                    Initiator : in Integer){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}   procedure Reset (Gen       : in Generator){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>10_A.5.2</MarginText>
   -- Advanced facilities{"\n"}
<MarginText>11_A.5.2</MarginText>
   type State is private;{"\n"}
<MarginText>12/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Save  (Gen        : in  Generator;{"\n"}                    To{"_"}State   : out State);{"\n"}   procedure Reset (Gen        : in  Generator;{"\n"}                    From{"_"}State : in  State){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>13_A.5.2</MarginText>
   Max{"_"}Image{"_"}Width : constant := implementation-defined integer value;{"\n"}
<MarginText>14_A.5.2</MarginText>
   function Image (Of{"_"}State    : State)  return String;{"\n"}   function Value (Coded{"_"}State : String) return State;{"\n"}
<MarginText>15_A.5.2</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Numerics.Float{"_"}Random;{"\n"}

</CodeBlock>
<MarginText>15.1/2_A.5.2</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<p>The type Generator needs finalization (see <a href="/docs/arm/AA-7/AA-7.6">7.6</a>).<br /></p>

<MarginText>16_A.5.2</MarginText>
<p>The generic library package Numerics.Discrete{"_"}Random has the following declaration: <br /></p>

<MarginText>17/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
generic{"\n"}   type Result{"_"}Subtype is ({"<"}{">"});{"\n"}package Ada.Numerics.Discrete{"_"}Random{"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>18_A.5.2</MarginText>
   -- Basic facilities{"\n"}
<MarginText>19_A.5.2</MarginText>
   type Generator is limited private;{"\n"}
<MarginText>20/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function Random (Gen : Generator) return Result{"_"}Subtype{"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>20.1/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1", "AI12-0302-1"]} />
   function Random (Gen   : Generator;{"\n"}                    First : Result{"_"}Subtype;{"\n"}                    Last  : Result{"_"}Subtype) return Result{"_"}Subtype{"\n"}      with Post ={">"} Random'Result in First .. Last,{"\n"}           Global ={">"} overriding in out Gen;{"\n"}
<MarginText>21/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Reset (Gen       : in Generator;{"\n"}                    Initiator : in Integer){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}   procedure Reset (Gen       : in Generator){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>22_A.5.2</MarginText>
   -- Advanced facilities{"\n"}
<MarginText>23_A.5.2</MarginText>
   type State is private;{"\n"}
<MarginText>24/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Save  (Gen        : in  Generator;{"\n"}                    To{"_"}State   : out State);{"\n"}   procedure Reset (Gen        : in  Generator;{"\n"}                    From{"_"}State : in  State){"\n"}      with Global ={">"} overriding in out Gen;{"\n"}
<MarginText>25_A.5.2</MarginText>
   Max{"_"}Image{"_"}Width : constant := implementation-defined integer value;{"\n"}
<MarginText>26_A.5.2</MarginText>
   function Image (Of{"_"}State    : State)  return String;{"\n"}   function Value (Coded{"_"}State : String) return State;{"\n"}
<MarginText>27_A.5.2</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Numerics.Discrete{"_"}Random;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>27.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The value of Numerics.Float{"_"}Random.Max{"_"}Image{"_"}Width.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The value of Numerics.Discrete{"_"}Random.Max{"_"}Image{"_"}Width.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.c/1_A.5.2</MarginText>
<MarginInfo items={["AI95-00115-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<b></b>{"{"}<i>8652/0097</i>{"}"} The following is a possible implementation of the private part of Numerics.Float{"_"}Random (assuming the presence of &ldquo;<b>with</b> Ada.Finalization;&rdquo; as a context clause): <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.d_A.5.2</MarginText>
<CodeBlock language="ada">
type State is ...;{"\n"}type Access{"_"}State is access State;{"\n"}type Generator is new Finalization.Limited{"_"}Controlled with{"\n"}   record{"\n"}      S : Access{"_"}State := new State'(...);{"\n"}   end record;{"\n"}procedure Finalize (G : in out Generator);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.d.1/2_A.5.2</MarginText>
<MarginInfo items={["AI95-00115-01", "AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0097</i>{"}"} Numerics.Discrete{"_"}Random.Generator also can be implemented this way.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.e_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
Clearly some level of indirection is required in the implementation of a Generator, since the parameter mode is <b>in</b> for all operations on a Generator. For this reason, Numerics.Float{"_"}Random and Numerics.Discrete{"_"}Random cannot be declared pure. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>27.1/2_A.5.2</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<p>The type Generator needs finalization (see <a href="/docs/arm/AA-7/AA-7.6">7.6</a>) in every instantiation of Numerics.Discrete{"_"}Random.<br /></p>

<MarginText>28_A.5.2</MarginText>
<p>An object of the limited private type Generator is associated with a sequence of random numbers. Each generator has a hidden (internal) state, which the operations on generators use to determine the position in the associated sequence. All generators are implicitly initialized to an unspecified state that does not vary from one program execution to another; they may also be explicitly initialized, or reinitialized, to a time-dependent state, to a previously saved state, or to a state uniquely denoted by an integer value. <br /></p>

<AnnotatedOnly>
<MarginText>28.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The repeatability provided by the implicit initialization may be exploited for testing or debugging purposes. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>29/5_A.5.2</MarginText>
<MarginInfo items={["AI05-0280-1", "AI12-0445-1"]} />
<p>An object of the private type State can be used to hold the internal state of a generator. Such objects are only necessary if the application is designed to save and restore generator states or to examine or manufacture them. The implicit initial value of type State corresponds to the implicit initial value of all generators.<br /></p>

<AnnotatedOnly>
<MarginText>29.a/3_A.5.2</MarginText>
<MarginInfo items={["AI05-0280-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>All generators are implicitly initialized to the same unchanging value, and using Reset on a default initialized object of type State will produce a generator with that same value. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>30_A.5.2</MarginText>
<p>The operations on generators affect the state and therefore the future values of the associated sequence. The semantics of the operations on generators and states are defined below. <br /></p>

<MarginText>31_A.5.2</MarginText>
<CodeBlock language="ada">
function Random (Gen : Generator) return Uniformly{"_"}Distributed;{"\n"}function Random (Gen : Generator) return Result{"_"}Subtype;{"\n"}

</CodeBlock>
<MarginText>32/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<p class="Indented4">Obtains the &ldquo;next&rdquo; random number from the given generator, relative to its current state, according to an implementation-defined algorithm. <br /></p>

<AnnotatedOnly>
<MarginText>32.a/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.a.1/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The algorithm is the subject of a Documentation Requirement, so we don't separately summarize this implementation-defined item. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.b_A.5.2</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>The requirement for a level of indirection in accessing the internal state of a generator arises from the desire to make Random a function, rather than a procedure. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>32.1/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<CodeBlock language="ada">
function Random (Gen   : Generator;{"\n"}                 First : Result{"_"}Subtype;{"\n"}                 Last  : Result{"_"}Subtype) return Result{"_"}Subtype{"\n"}   with Post ={">"} Random'Result in First .. Last;{"\n"}

</CodeBlock>
<MarginText>32.2/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<p class="Indented4">Obtains the &ldquo;next&rdquo; random number from the given generator, relative to its current state, according to an implementation-defined algorithm. If the range First .. Last is a null range, Constraint{"_"}Error is raised.<br /></p>

<MarginText>33_A.5.2</MarginText>
<CodeBlock language="ada">
procedure Reset (Gen       : in Generator;{"\n"}                 Initiator : in Integer);{"\n"}procedure Reset (Gen       : in Generator);{"\n"}

</CodeBlock>
<MarginText>34_A.5.2</MarginText>
<p class="Indented4">Sets the state of the specified generator to one that is an unspecified function of the value of the parameter Initiator (or to a time-dependent state, if only a generator parameter is specified). The latter form of the procedure is known as the <i>time-dependent Reset procedure</i>. <br /></p>

<AnnotatedOnly>
<MarginText>34.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>The time-dependent Reset procedure can be implemented by mapping the current time and date as determined by the system clock into a state, but other implementations are possible. For example, a white-noise generator or a radioactive source can be used to generate time-dependent states. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>35_A.5.2</MarginText>
<CodeBlock language="ada">
procedure Save  (Gen        : in  Generator;{"\n"}                 To{"_"}State   : out State);{"\n"}procedure Reset (Gen        : in  Generator;{"\n"}                 From{"_"}State : in  State);{"\n"}

</CodeBlock>
<MarginText>36_A.5.2</MarginText>
<p class="Indented4">Save obtains the current state of a generator. Reset gives a generator the specified state. A generator that is reset to a state previously obtained by invoking Save is restored to the state it had when Save was invoked.<br /></p>

<MarginText>37_A.5.2</MarginText>
<CodeBlock language="ada">
function Image (Of{"_"}State    : State)  return String;{"\n"}function Value (Coded{"_"}State : String) return State;{"\n"}

</CodeBlock>
<MarginText>38_A.5.2</MarginText>
<p class="Indented4">Image provides a representation of a state coded (in an implementation-defined way) as a string whose length is bounded by the value of Max{"_"}Image{"_"}Width. Value is the inverse of Image: Value(Image(S)) = S for each state S that can be obtained from a generator by invoking Save. <br /></p>

<AnnotatedOnly>
<MarginText>38.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The string representation of a random number generator's state.<br />
</Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>39_A.5.2</MarginText>
<p>Instantiation of Numerics.Discrete{"_"}Random with a subtype having a null range raises Constraint{"_"}Error.<br /></p>

<MarginText>40/1_A.5.2</MarginText>
<MarginInfo items={["AI95-00089"]} />
<p><i>This paragraph was deleted.</i>{"{"}<i>8652/0050</i>{"}"} <br /></p>


#### Bounded (Run-Time) Errors

<MarginText>40.1/5_A.5.2</MarginText>
<MarginInfo items={["AI95-00089", "AI12-0445-1"]} />
<p>{"{"}<i>8652/0050</i>{"}"} It is a bounded error to invoke Value with a string that is not the image of any generator state. If the error is detected, Constraint{"_"}Error or Program{"_"}Error is raised. Otherwise, a call to Reset with the resulting state will produce a generator such that calls to Random with this generator will produce a sequence of values of the appropriate subtype, but which are not necessarily random in character. That is, the sequence of values do not necessarily fulfill the implementation requirements of this subclause. <br /></p>


#### Implementation Requirements

<MarginText>40.2/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<p>Each call of a Random function has a <i>result range</i>; this is the range First .. Last for the version of Random with First and Last parameters and the range of the result subtype of the function otherwise.<br /></p>

<MarginText>41/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<p>A sufficiently long sequence of random numbers obtained by consecutive calls to Random that have the same generator and result range is approximately uniformly distributed over the result range.<br /></p>

<AnnotatedOnly>
<MarginText>41.a/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0005-1", "AI12-0144-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>In this rule, &ldquo;consecutive&rdquo; means at least that there are no intervening explicit calls involving the same generator. This restricts the rule to only applying to cases where just the Random function changes the generator. We don't mean to impose a requirement if there are intervening calls to Reset, to Random with the same generator but a different result range, or any other case that would affect the sequence of values returned. Operations that use the resulting random values (for instance, to store them somewhere) are not considered in determining if calls are consecutive. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>42/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<p>A Random function in an instantiation of Numerics.Discrete{"_"}Random is guaranteed to yield each value in its result range in a finite number of calls, provided that the number of such values does not exceed 215.<br /></p>

<MarginText>43_A.5.2</MarginText>
<p>Other performance requirements for the random number generator, which apply only in implementations conforming to the Numerics Annex, and then only in the &ldquo;strict&rdquo; mode defined there (see <a href="/docs/arm/AA-G/AA-G.2">G.2</a>), are given in <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.5">G.2.5</a>. <br /></p>


#### Documentation Requirements

<MarginText>44_A.5.2</MarginText>
<p>No one algorithm for random number generation is best for all applications. To enable the user to determine the suitability of the random number generators for the intended application, the implementation shall describe the algorithm used and shall give its period, if known exactly, or a lower bound on the period, if the exact period is unknown. Periods that are so long that the periodicity is unobservable in practice can be described in such terms, without giving a numerical bound. <br /></p>

<AnnotatedOnly>
<MarginText>44.a/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
<b>Documentation Requirement: </b>The algorithm used for random number generation, including a description of its period.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>45_A.5.2</MarginText>
<p>The implementation also shall document the minimum time interval between calls to the time-dependent Reset procedure that are guaranteed to initiate different sequences, and it shall document the nature of the strings that Value will accept without raising Constraint{"_"}Error. <br /></p>

<AnnotatedOnly>
<MarginText>45.a/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>45.b/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
<b>Documentation Requirement: </b>The minimum time interval between calls to the time-dependent Reset procedure that is guaranteed to initiate different random number sequences.<br />
</Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>46_A.5.2</MarginText>
<p>Any storage associated with an object of type Generator should be reclaimed on exit from the scope of the object. <br /></p>

<AnnotatedOnly>
<MarginText>46.a.1/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<b></b>Any storage associated with an object of type Generator of the random number packages should be reclaimed on exit from the scope of the object.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a_A.5.2</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>A level of indirection is implicit in the semantics of the operations, given that they all take parameters of mode <b>in</b>. This implies that the full type of Generator probably should be a controlled type, with appropriate finalization to reclaim any heap-allocated storage. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>47_A.5.2</MarginText>
<p>If the generator period is sufficiently long in relation to the number of distinct initiator values, then each possible value of Initiator passed to Reset should initiate a sequence of random numbers that does not, in a practical sense, overlap the sequence initiated by any other value. If this is not possible, then the mapping between initiator values and generator states should be a rapidly varying function of the initiator value. <br /></p>

<AnnotatedOnly>
<MarginText>47.a/2_A.5.2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<b></b>Each value of Initiator passed to Reset for the random number packages should initiate a distinct sequence of random numbers, or, if that is not possible, be at least a rapidly varying function of the initiator value.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>48_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   If two or more tasks are to share the same generator, then the tasks have to synchronize their access to the generator as for any shared variable (see <a href="/docs/arm/AA-9/AA-9.10">9.10</a>).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>49_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   Within a given implementation, a repeatable random number sequence can be obtained by relying on the implicit initialization of generators or by explicitly initializing a generator with a repeatable initiator value. Different sequences of random numbers can be obtained from a given generator in different program executions by explicitly initializing the generator to a time-dependent state.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>50/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0442-1", "AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   A given implementation of the Random function in Numerics.Float{"_"}Random is not guaranteed to be capable of delivering the values 0.0 or 1.0. Applications will be more portable if they assume that these values, or values sufficiently close to them to behave indistinguishably from them, can occur. If a sequence of random integers from some range is necessary, the application should use one of the Random functions in an appropriate instantiation of Numerics.Discrete{"_"}Random, rather than transforming the result of the Random function in Numerics.Float{"_"}Random. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>51/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<CodeBlock language="ada">
This paragraph was deleted.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>51.a/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>One might think that a simple transformation of the result of the floating point Random function such as Integer(Float(M) {"*"} Random(G)) <b>mod</b> M would give a uniform distribution. But this is only true if the period of the underlying generator is a multiple of M. (This usually requires that M be a power of two.) In other cases, the <b>mod</b> operation maps slightly more random values to some result values than others. It is easy to see this: consider a 4-bit random integer (with a range of 0 .. 15). If one <b>mod</b>s this by 6 to get a value in 0 .. 5 (to which one would add 1 to get the value of a die roll), 3 values would be mapped to each value 0 .. 3, but only 2 values would be mapped to 4 and 5. Even when the input is uniformly distributed, the output clearly is not. A similar effect occurs regardless of the number of bits in the random integer. Since it takes care to get this right, users should use the provided functions (which presumably do this correctly &ndash;  contains a correct algorithm) and resist the urge to &ldquo;roll-their-own&rdquo;. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>52/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 4   Exponentially distributed (floating point) random numbers with mean and standard deviation 1.0 can be obtained by the transformation <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>53/2_A.5.2</MarginText>
<MarginInfo items={["AI95-00434-01"]} />
<CodeBlock language="ada">
   -Log(Random(G) + Float'Model{"_"}Small){"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>54_A.5.2</MarginText>
<Admonition type="aarm" aarm="note">
where Log comes from Numerics.Elementary{"_"}Functions (see <a href="/docs/arm/AA-A/AA-A.5#Subclause_A.5.1">A.5.1</a>); in this expression, the addition of Float'Model{"_"}Small avoids the exception that would be raised were Log to be given the value zero, without affecting the result (in most implementations) when Random returns a nonzero value. <br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>55_A.5.2</MarginText>
<p><i>Example of a program that plays a simulated dice game:</i> <br /></p>

<MarginText>56_A.5.2</MarginText>
<CodeBlock language="ada">
with Ada.Numerics.Discrete{"_"}Random;{"\n"}procedure Dice{"_"}Game is{"\n"}   subtype Die is Integer range 1 .. 6;{"\n"}   subtype Dice is Integer range 2{"*"}Die'First .. 2{"*"}Die'Last;{"\n"}   package Random{"_"}Die is new Ada.Numerics.Discrete{"_"}Random (Die);{"\n"}   use Random{"_"}Die;{"\n"}   G : Generator;{"\n"}   D : Dice;{"\n"}begin{"\n"}   Reset (G);  -- Start the generator in a unique state in each run{"\n"}   loop{"\n"}      -- Roll a pair of dice; sum and process the results{"\n"}      D := Random(G) + Random(G);{"\n"}      ...{"\n"}   end loop;{"\n"}end Dice{"_"}Game;{"\n"}

</CodeBlock>
<MarginText>57_A.5.2</MarginText>
<p><i>Example of a program that simulates coin tosses:</i> <br /></p>

<MarginText>58_A.5.2</MarginText>
<CodeBlock language="ada">
with Ada.Numerics.Discrete{"_"}Random;{"\n"}procedure Flip{"_"}A{"_"}Coin is{"\n"}   type Coin is (Heads, Tails);{"\n"}   package Random{"_"}Coin is new Ada.Numerics.Discrete{"_"}Random (Coin);{"\n"}   use Random{"_"}Coin;{"\n"}   G : Generator;{"\n"}begin{"\n"}   Reset (G);  -- Start the generator in a unique state in each run{"\n"}   loop{"\n"}      -- Toss a coin and process the result{"\n"}      case Random(G) is{"\n"}          when Heads ={">"}{"\n"}             ...{"\n"}          when Tails ={">"}{"\n"}             ...{"\n"}      end case;{"\n"}   ...{"\n"}   end loop;{"\n"}end Flip{"_"}A{"_"}Coin;{"\n"}

</CodeBlock>
<MarginText>59_A.5.2</MarginText>
<p><i>Example of a parallel simulation of a physical system, with a separate generator of event probabilities in each task:</i> <br /></p>

<MarginText>60_A.5.2</MarginText>
<CodeBlock language="ada">
with Ada.Numerics.Float{"_"}Random;{"\n"}procedure Parallel{"_"}Simulation is{"\n"}   use Ada.Numerics.Float{"_"}Random;{"\n"}   task type Worker is{"\n"}      entry Initialize{"_"}Generator (Initiator : in Integer);{"\n"}      ...{"\n"}   end Worker;{"\n"}   W : array (1 .. 10) of Worker;{"\n"}   task body Worker is{"\n"}      G : Generator;{"\n"}      Probability{"_"}Of{"_"}Event : Uniformly{"_"}Distributed;{"\n"}   begin{"\n"}      accept Initialize{"_"}Generator (Initiator : in Integer) do{"\n"}         Reset (G, Initiator);{"\n"}      end Initialize{"_"}Generator;{"\n"}      loop{"\n"}         ...{"\n"}         Probability{"_"}Of{"_"}Event := Random(G);{"\n"}         ...{"\n"}      end loop;{"\n"}   end Worker;{"\n"}begin{"\n"}   -- Initialize the generators in the Worker tasks to different states{"\n"}   for I in W'Range loop{"\n"}      W(I).Initialize{"_"}Generator (I);{"\n"}   end loop;{"\n"}   ... -- Wait for the Worker tasks to terminate{"\n"}end Parallel{"_"}Simulation;{"\n"}

</CodeBlock>
<MarginText>61/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0452-1"]} />
<p>Although each Worker task initializes its generator to a different state, those states will be the same in every execution of the program. The generator states can be initialized uniquely in each program execution by instantiating Ada.Numerics.Discrete{"_"}Random for the type Integer in the main procedure, resetting the generator obtained from that instance to a time-dependent state, and then using random integers obtained from that generator to initialize the generators in each Worker task.<br /></p>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>62.a/2_A.5.2</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<Admonition type="aarm" aarm="correction">
<b>Amendment </b> Type Generator in Numerics.Float{"_"}Random and in an instance of Numerics.Discrete{"_"}Random is defined to need finalization. If the restriction No{"_"}Nested{"_"}Finalization (see <a href="/docs/arm/AA-D/AA-D.7">D.7</a>) applies to the partition, and Generator does not have a controlled part, it will not be allowed in local objects in Ada 2005 whereas it would be allowed in original Ada 95. Such code is not portable, as another Ada compiler may have a controlled part in Generator, and thus would be illegal. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>62.b/3_A.5.2</MarginText>
<MarginInfo items={["AI95-00089-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0050</i>{"}"} <b>Corrigendum:</b> Made the passing of an incorrect Image of a generator a bounded error, as it might not be practical to check for problems (if a generator consists of several related values). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>62.c/3_A.5.2</MarginText>
<MarginInfo items={["AI05-0280-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Specified the implicit initial value for (sub)type State. This was unspecified in Ada 95 and Ada 2005, so a program depending on some other initial value is very unlikely and certainly was not portable. An implementation can use default expressions, aspect Default{"_"}Value, or aspect Default{"_"}Component{"_"}Value to keep the representation of the type unchanged while meeting this new requirement. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>62.d/5_A.5.2</MarginText>
<MarginInfo items={["AI12-0144-1"]} />
<Admonition type="aarm" aarm="note">
 The function Random with First and Last parameters is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.3"></a>

## A.5.3  Attributes of Floating Point Types


#### Static Semantics

<MarginText>1_A.5.3</MarginText>
<p>The following <i>representation-oriented attributes</i> are defined for every subtype S of a floating point type <i>T</i>. <br /></p>

<MarginText>2_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Radix</dt>
<dl>
<dd>Yields the radix of the hardware representation of the type <i>T</i>. The value of this attribute is of the type <i>universal{"_"}integer</i>. <br /></dd>
</dl>
<MarginText>3_A.5.3</MarginText>
<p>The values of other representation-oriented attributes of a floating point subtype, and of the &ldquo;primitive function&rdquo; attributes of a floating point subtype described later, are defined in terms of a particular representation of nonzero values called the <i>canonical form</i>. The canonical form (for the type <i>T</i>) is the form<br />    ± <i>mantissa</i> · <i>T</i>'Machine{"_"}Radix<i>exponent</i><br />where <br /></p>

<MarginText>4_A.5.3</MarginText>
<ul>
<li><i>mantissa</i> is a fraction in the number base <i>T</i>'Machine{"_"}Radix, the first digit of which is nonzero, and<br /></li>
<MarginText>5_A.5.3</MarginText>
<li><i>exponent</i> is an integer. <br /></li>
</ul>
<MarginText>6_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Mantissa</dt>
<dl>
<dd>Yields the largest value of <i>p</i> such that every value expressible in the canonical form (for the type <i>T</i>), having a <i>p</i>-digit <i>mantissa</i> and an <i>exponent</i> between <i>T</i>'Machine{"_"}Emin and <i>T</i>'Machine{"_"}Emax, is a machine number (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>. This attribute yields a value of the type <i>universal{"_"}integer</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>6.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Values of a type held in an extended register are, in general, not machine numbers of the type, since they cannot be expressed in the canonical form with a sufficiently short <i>mantissa</i>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>7_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Emin</dt>
<dl>
<dd>Yields the smallest (most negative) value of <i>exponent</i> such that every value expressible in the canonical form (for the type <i>T</i>), having a <i>mantissa</i> of <i>T</i>'Machine{"_"}Mantissa digits, is a machine number (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>. This attribute yields a value of the type <i>universal{"_"}integer</i>.<br /></dd>
<MarginText>8_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Emax</dt>
<dd>Yields the largest (most positive) value of <i>exponent</i> such that every value expressible in the canonical form (for the type <i>T</i>), having a <i>mantissa</i> of <i>T</i>'Machine{"_"}Mantissa digits, is a machine number (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>. This attribute yields a value of the type <i>universal{"_"}integer</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>8.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Note that the above definitions do not determine unique values for the representation-oriented attributes of floating point types. The implementation may choose any set of values that collectively satisfies the definitions.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>9_A.5.3</MarginText>
<dt><br/>S'Denorm</dt>
<dl>
<dd>Yields the value True if every value expressible in the form<br />    ± <i>mantissa</i> · <i>T</i>'Machine{"_"}Radix<i>T</i>'Machine{"_"}Emin<br />where <i>mantissa</i> is a nonzero <i>T</i>'Machine{"_"}Mantissa-digit fraction in the number base <i>T</i>'Machine{"_"}Radix, the first digit of which is zero, is a machine number (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>; yields the value False otherwise. The value of this attribute is of the predefined type Boolean. <br /></dd>
</dl>
<MarginText>10_A.5.3</MarginText>
<p>The values described by the formula in the definition of S'Denorm are called <i>denormalized numbers</i>. A nonzero machine number that is not a denormalized number is a <i>normalized number</i>. A normalized number <i>x</i> of a given type <i>T</i> is said to be <i>represented in canonical form</i> when it is expressed in the canonical form (for the type <i>T</i>) with a <i>mantissa</i> having <i>T</i>'Machine{"_"}Mantissa digits; the resulting form is the <i>canonical-form representation</i> of <i>x</i>. <br /></p>

<AnnotatedOnly>
<MarginText>10.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The intent is that S'Denorm be True when such denormalized numbers exist and are generated in the circumstances defined by IEC 559:1989, though the latter requirement is not formalized here. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>11_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Rounds</dt>
<dl>
<dd>Yields the value True if rounding is performed on inexact results of every predefined operation that yields a result of the type <i>T</i>; yields the value False otherwise. The value of this attribute is of the predefined type Boolean. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>11.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>It is difficult to be more precise about what it means to round the result of a predefined operation. If the implementation does not use extended registers, so that every arithmetic result is necessarily a machine number, then rounding seems to imply two things: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b_A.5.3</MarginText>
<ul>
<li>S'Model{"_"}Mantissa = S'Machine{"_"}Mantissa, so that operand preperturbation never occurs;<br /></li>
<MarginText>11.c_A.5.3</MarginText>
<li>when the exact mathematical result is not a machine number, the result of a predefined operation must be the nearer of the two adjacent machine numbers. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.d_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
Technically, this attribute should yield False when extended registers are used, since a few computed results will cross over the half-way point as a result of double rounding, if and when a value held in an extended register has to be reduced in precision to that of the machine numbers. It does not seem desirable to preclude the use of extended registers when S'Machine{"_"}Rounds could otherwise be True. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>12_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Overflows</dt>
<dl>
<dd>Yields the value True if overflow and divide-by-zero are detected and reported by raising Constraint{"_"}Error for every predefined operation that yields a result of the type <i>T</i>; yields the value False otherwise. The value of this attribute is of the predefined type Boolean.<br /></dd>
<MarginText>13_A.5.3</MarginText>
<dt><br/>S'Signed{"_"}Zeros</dt>
<dd>Yields the value True if the hardware representation for the type <i>T</i> has the capability of representing both positively and negatively signed zeros, these being generated and used by the predefined operations of the type <i>T</i> as specified in IEC 559:1989; yields the value False otherwise. The value of this attribute is of the predefined type Boolean. <br /></dd>
</dl>
<MarginText>14_A.5.3</MarginText>
<p>For every value <i>x</i> of a floating point type <i>T</i>, the <i>normalized exponent</i> of <i>x</i> is defined as follows: <br /></p>

<MarginText>15_A.5.3</MarginText>
<ul>
<li>the normalized exponent of zero is (by convention) zero;<br /></li>
<MarginText>16_A.5.3</MarginText>
<li>for nonzero <i>x</i>, the normalized exponent of <i>x</i> is the unique integer <i>k</i> such that <i>T</i>'Machine{"_"}Radix<i>k</i>&ndash;1 &le; |<i>x</i>| {"<"} <i>T</i>'Machine{"_"}Radix<i>k</i>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>16.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The normalized exponent of a normalized number <i>x</i> is the value of <i>exponent</i> in the canonical-form representation of <i>x</i>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
The normalized exponent of a denormalized number is less than the value of <i>T</i>'Machine{"_"}Emin. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>17_A.5.3</MarginText>
<p>The following <i>primitive function attributes</i> are defined for any subtype S of a floating point type <i>T</i>. <br /></p>

<MarginText>18_A.5.3</MarginText>
<dt><br/>S'Exponent</dt>
<dl>
<dd>S'Exponent denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>19_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Exponent (X : T){"\n"}  return universal{"_"}integer{"\n"}

</CodeBlock>
<MarginText>20_A.5.3</MarginText>
<dl>
<dd>The function yields the normalized exponent of <i>X</i>.<br /></dd>
<MarginText>21_A.5.3</MarginText>
<dt><br/>S'Fraction</dt>
<dd>S'Fraction denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>22_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Fraction (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>23_A.5.3</MarginText>
<dl>
<dd>The function yields the value <i>X</i> · <i>T</i>'Machine{"_"}Radix&ndash;<i>k</i>, where <i>k</i> is the normalized exponent of <i>X</i>. A zero result[, which can only occur when <i>X</i> is zero,] has the sign of <i>X</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>23.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Informally, when <i>X</i> is a normalized number, the result is the value obtained by replacing the <i>exponent</i> by zero in the canonical-form representation of <i>X</i>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Except when <i>X</i> is zero, the magnitude of the result is greater than or equal to the reciprocal of <i>T</i>'Machine{"_"}Radix and less than one; consequently, the result is always a normalized number, even when <i>X</i> is a denormalized number. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.c_A.5.3</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>When <i>X</i> is a denormalized number, the result is the value obtained by replacing the <i>exponent</i> by zero in the canonical-form representation of the result of scaling <i>X</i> up sufficiently to normalize it. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>24_A.5.3</MarginText>
<dt><br/>S'Compose</dt>
<dl>
<dd>S'Compose denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>25_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Compose (Fraction : T;{"\n"}                    Exponent : universal{"_"}integer){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>26_A.5.3</MarginText>
<dl>
<dd>Let <i>v</i> be the value <i>Fraction</i> · <i>T</i>'Machine{"_"}Radix<i>Exponent</i>&ndash;<i>k</i>, where <i>k</i> is the normalized exponent of <i>Fraction</i>. If <i>v</i> is a machine number of the type <i>T</i>, or if |<i>v</i>| &ge; <i>T</i>'Model{"_"}Small, the function yields <i>v</i>; otherwise, it yields either one of the machine numbers of the type <i>T</i> adjacent to <i>v</i>. Constraint{"_"}Error is optionally raised if <i>v</i> is outside the base range of S. A zero result has the sign of <i>Fraction</i> when S'Signed{"_"}Zeros is True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>26.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Informally, when <i>Fraction</i> and <i>v</i> are both normalized numbers, the result is the value obtained by replacing the <i>exponent</i> by <i>Exponent</i> in the canonical-form representation of <i>Fraction</i>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>If <i>Exponent</i> is less than <i>T</i>'Machine{"_"}Emin and <i>Fraction</i> is nonzero, the result is either zero, <i>T</i>'Model{"_"}Small, or (if <i>T</i>'Denorm is True) a denormalized number. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>27_A.5.3</MarginText>
<dt><br/>S'Scaling</dt>
<dl>
<dd>S'Scaling denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>28_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Scaling (X : T;{"\n"}                    Adjustment : universal{"_"}integer){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>29_A.5.3</MarginText>
<dl>
<dd>Let <i>v</i> be the value <i>X</i> · <i>T</i>'Machine{"_"}Radix<i>Adjustment</i>. If <i>v</i> is a machine number of the type <i>T</i>, or if |<i>v</i>| &ge; <i>T</i>'Model{"_"}Small, the function yields <i>v</i>; otherwise, it yields either one of the machine numbers of the type <i>T</i> adjacent to <i>v</i>. Constraint{"_"}Error is optionally raised if <i>v</i> is outside the base range of S. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>29.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Informally, when <i>X</i> and <i>v</i> are both normalized numbers, the result is the value obtained by increasing the <i>exponent</i> by <i>Adjustment</i> in the canonical-form representation of <i>X</i>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>29.b/5_A.5.3</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>If <i>Adjustment</i> is sufficiently small (that is, sufficiently negative), the result is either zero, <i>T</i>'Model{"_"}Small, or (if <i>T</i>'Denorm is True) a denormalized number. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>30_A.5.3</MarginText>
<dt><br/>S'Floor</dt>
<dl>
<dd>S'Floor denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>31_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Floor (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>32/5_A.5.3</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<dl>
<dd>The function yields the value &lfloor;<i>X</i>&rfloor;, that is, the largest (most positive) integral value less than or equal to <i>X</i>. When <i>X</i> is zero, the result has the sign of <i>X</i>; a zero result otherwise has a positive sign.<br /></dd>
<MarginText>33_A.5.3</MarginText>
<dt><br/>S'Ceiling</dt>
<dd>S'Ceiling denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>34_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Ceiling (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>35/5_A.5.3</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<dl>
<dd>The function yields the value &lceil;<i>X</i>&rceil;, that is, the smallest (most negative) integral value greater than or equal to <i>X</i>. When <i>X</i> is zero, the result has the sign of <i>X</i>; a zero result otherwise has a negative sign when S'Signed{"_"}Zeros is True.<br /></dd>
<MarginText>36_A.5.3</MarginText>
<dt><br/>S'Rounding</dt>
<dd>S'Rounding denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>37_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Rounding (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>38_A.5.3</MarginText>
<dl>
<dd>The function yields the integral value nearest to <i>X</i>, rounding away from zero if <i>X</i> lies exactly halfway between two integers. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True.<br /></dd>
<MarginText>39_A.5.3</MarginText>
<dt><br/>S'Unbiased{"_"}Rounding</dt>
<dd>S'Unbiased{"_"}Rounding denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>40_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Unbiased{"_"}Rounding (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>41_A.5.3</MarginText>
<dl>
<dd>The function yields the integral value nearest to <i>X</i>, rounding toward the even integer if <i>X</i> lies exactly halfway between two integers. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True.<br /></dd>
<MarginText>41.1/2_A.5.3</MarginText>
<dt><br/>S'Machine{"_"}Rounding</dt>
<MarginInfo items={["AI95-00267-01"]} />
<dd>S'Machine{"_"}Rounding denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>41.2/2_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Machine{"_"}Rounding (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>41.3/2_A.5.3</MarginText>
<dl>
<dd>The function yields the integral value nearest to <i>X</i>. If <i>X</i> lies exactly halfway between two integers, one of those integers is returned, but which of them is returned is unspecified. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True. This function provides access to the rounding behavior which is most efficient on the target processor.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>41.a.1/2_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>We leave the rounding unspecified, so that users cannot depend on a particular rounding. This attribute is intended for use in cases where the particular rounding chosen is irrelevant. If there is a need to know which way values halfway between two integers are rounded, one of the other rounding attributes should be used. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>42_A.5.3</MarginText>
<dt><br/>S'Truncation</dt>
<dl>
<dd>S'Truncation denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>43_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Truncation (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>44_A.5.3</MarginText>
<dl>
<dd>The function yields the value &lceil;<i>X</i>&rceil; when <i>X</i> is negative, and &lfloor;<i>X</i>&rfloor; otherwise. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True.<br /></dd>
<MarginText>45_A.5.3</MarginText>
<dt><br/>S'Remainder</dt>
<dd>S'Remainder denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>46_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Remainder (X, Y : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>47_A.5.3</MarginText>
<dl>
<dd>For nonzero <i>Y</i>, let <i>v</i> be the value <i>X</i> &ndash; <i>n</i> · <i>Y</i>, where <i>n</i> is the integer nearest to the exact value of <i>X</i>/<i>Y</i>; if |<i>n</i> &ndash; <i>X</i>/<i>Y</i>| = 1/2, then <i>n</i> is chosen to be even. If <i>v</i> is a machine number of the type <i>T</i>, the function yields <i>v</i>; otherwise, it yields zero. Constraint{"_"}Error is raised if <i>Y</i> is zero. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>47.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The magnitude of the result is less than or equal to one-half the magnitude of <i>Y</i>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>47.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Given machine numbers <i>X</i> and <i>Y</i> of the type <i>T</i>, <i>v</i> is necessarily a machine number of the type <i>T</i>, except when <i>Y</i> is in the neighborhood of zero, <i>X</i> is sufficiently close to a multiple of <i>Y</i>, and <i>T</i>'Denorm is False. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>48_A.5.3</MarginText>
<dt><br/>S'Adjacent</dt>
<dl>
<dd>S'Adjacent denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>49_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Adjacent (X, Towards : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>50_A.5.3</MarginText>
<dl>
<dd>If <i>Towards</i> = <i>X</i>, the function yields <i>X</i>; otherwise, it yields the machine number of the type <i>T</i> adjacent to <i>X</i> in the direction of <i>Towards</i>, if that machine number exists. If the result would be outside the base range of S, Constraint{"_"}Error is raised. When <i>T</i>'Signed{"_"}Zeros is True, a zero result has the sign of <i>X</i>. When <i>Towards</i> is zero, its sign has no bearing on the result. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>50.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The value of S'Adjacent(0.0, 1.0) is the smallest normalized positive number of the type <i>T</i> when <i>T</i>'Denorm is False and the smallest denormalized positive number of the type <i>T</i> when <i>T</i>'Denorm is True. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>51_A.5.3</MarginText>
<dt><br/>S'Copy{"_"}Sign</dt>
<dl>
<dd>S'Copy{"_"}Sign denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>52_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Copy{"_"}Sign (Value, Sign : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>53_A.5.3</MarginText>
<dl>
<dd>If the value of <i>Value</i> is nonzero, the function yields a result whose magnitude is that of <i>Value</i> and whose sign is that of <i>Sign</i>; otherwise, it yields the value zero. Constraint{"_"}Error is optionally raised if the result is outside the base range of S. A zero result has the sign of <i>Sign</i> when S'Signed{"_"}Zeros is True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>53.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>S'Copy{"_"}Sign is provided for convenience in restoring the sign to a quantity from which it has been temporarily removed, or to a related quantity. When S'Signed{"_"}Zeros is True, it is also instrumental in determining the sign of a zero quantity, when required. (Because negative and positive zeros compare equal in systems conforming to IEC 559:1989, a negative zero does <i>not</i> appear to be negative when compared to zero.) The sign determination is accomplished by transferring the sign of the zero quantity to a nonzero quantity and then testing for a negative result. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>54_A.5.3</MarginText>
<dt><br/>S'Leading{"_"}Part</dt>
<dl>
<dd>S'Leading{"_"}Part denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>55_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Leading{"_"}Part (X : T;{"\n"}                         Radix{"_"}Digits : universal{"_"}integer){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>56_A.5.3</MarginText>
<dl>
<dd>Let <i>v</i> be the value <i>T</i>'Machine{"_"}Radix<i>k</i>&ndash;<i>Radix{"_"}Digits</i>, where <i>k</i> is the normalized exponent of <i>X</i>. The function yields the value <br /></dd>
</dl>
<MarginText>57_A.5.3</MarginText>
<ul>
<li>&lfloor;<i>X</i>/<i>v</i>&rfloor; · <i>v</i>, when <i>X</i> is nonnegative and <i>Radix{"_"}Digits</i> is positive;<br /></li>
<MarginText>58_A.5.3</MarginText>
<li>&lceil;<i>X</i>/<i>v</i>&rceil; · <i>v</i>, when <i>X</i> is negative and <i>Radix{"_"}Digits</i> is positive. <br /></li>
</ul>
<MarginText>59_A.5.3</MarginText>
<dl>
<dd>Constraint{"_"}Error is raised when <i>Radix{"_"}Digits</i> is zero or negative. A zero result[, which can only occur when <i>X</i> is zero,] has the sign of <i>X</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>59.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Informally, if <i>X</i> is nonzero, the result is the value obtained by retaining only the specified number of (leading) significant digits of <i>X</i> (in the machine radix), setting all other digits to zero. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>59.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>The result can be obtained by first scaling <i>X</i> up, if necessary to normalize it, then masking the mantissa so as to retain only the specified number of leading digits, then scaling the result back down if <i>X</i> was scaled up. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>60_A.5.3</MarginText>
<dt><br/>S'Machine</dt>
<dl>
<dd>S'Machine denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>61_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Machine (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>62_A.5.3</MarginText>
<dl>
<dd>If <i>X</i> is a machine number of the type <i>T</i>, the function yields <i>X</i>; otherwise, it yields the value obtained by rounding or truncating <i>X</i> to either one of the adjacent machine numbers of the type <i>T</i>. Constraint{"_"}Error is raised if rounding or truncating <i>X</i> to the precision of the machine numbers results in a value outside the base range of S. A zero result has the sign of <i>X</i> when S'Signed{"_"}Zeros is True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>62.a/3_A.5.3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>All of the primitive function attributes except Rounding and Machine correspond to subprograms in the Generic{"_"}Primitive{"_"}Functions generic package that was proposed as a separate ISO standard (ISO/IEC DIS 11729) for Ada 83. The Scaling, Unbiased{"_"}Rounding, and Truncation attributes correspond to the Scale, Round, and Truncate functions, respectively, in Generic{"_"}Primitive{"_"}Functions. The Rounding attribute rounds away from zero; this functionality was not provided in Generic{"_"}Primitive{"_"}Functions. The name Round was not available for either of the primitive function attributes that perform rounding, since an attribute of that name is used for a different purpose for decimal fixed point types. Likewise, the name Scale was not available, since an attribute of that name is also used for a different purpose for decimal fixed point types. The functionality of the Machine attribute was also not provided in Generic{"_"}Primitive{"_"}Functions. The functionality of the Decompose procedure of Generic{"_"}Primitive{"_"}Functions is only provided in the form of the separate attributes Exponent and Fraction. The functionality of the Successor and Predecessor functions of Generic{"_"}Primitive{"_"}Functions is provided by the extension of the existing Succ and Pred attributes. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>62.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>The primitive function attributes may be implemented either with appropriate floating point arithmetic operations or with integer and logical operations that act on parts of the representation directly. The latter is strongly encouraged when it is more efficient than the former; it is mandatory when the former cannot deliver the required accuracy due to limitations of the implementation's arithmetic operations. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>63_A.5.3</MarginText>
<p>The following <i>model-oriented attributes</i> are defined for any subtype S of a floating point type <i>T</i>. <br /></p>

<MarginText>64_A.5.3</MarginText>
<dt><br/>S'Model{"_"}Mantissa</dt>
<dl>
<dd>If the Numerics Annex is not supported, this attribute yields an implementation defined value that is greater than or equal to &lceil;<i>d</i> · log(10) / log(<i>T</i>'Machine{"_"}Radix)&rceil; + 1, where <i>d</i> is the requested decimal precision of <i>T</i>, and less than or equal to the value of <i>T</i>'Machine{"_"}Mantissa. See <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a> for further requirements that apply to implementations supporting the Numerics Annex. The value of this attribute is of the type <i>universal{"_"}integer</i>.<br /></dd>
<MarginText>65_A.5.3</MarginText>
<dt><br/>S'Model{"_"}Emin</dt>
<dd>If the Numerics Annex is not supported, this attribute yields an implementation defined value that is greater than or equal to the value of <i>T</i>'Machine{"_"}Emin. See <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a> for further requirements that apply to implementations supporting the Numerics Annex. The value of this attribute is of the type <i>universal{"_"}integer</i>.<br /></dd>
<MarginText>66_A.5.3</MarginText>
<dt><br/>S'Model{"_"}Epsilon</dt>
<dd>Yields the value <i>T</i>'Machine{"_"}Radix1 &ndash; <i>T</i>'Model{"_"}Mantissa. The value of this attribute is of the type <i>universal{"_"}real</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>66.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>In most implementations, this attribute yields the absolute value of the difference between one and the smallest machine number of the type <i>T</i> above one which, when added to one, yields a machine number different from one. Further discussion can be found in <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>67_A.5.3</MarginText>
<dt><br/>S'Model{"_"}Small</dt>
<dl>
<dd>Yields the value <i>T</i>'Machine{"_"}Radix<i>T</i>'Model{"_"}Emin &ndash; 1. The value of this attribute is of the type <i>universal{"_"}real</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>67.a/5_A.5.3</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>In most implementations, this attribute yields the smallest positive normalized number of the type <i>T</i>, that is, the number corresponding to the positive underflow threshold. In some implementations employing a radix-complement representation for the type <i>T</i>, the positive underflow threshold is closer to zero than is the negative underflow threshold, with the consequence that the smallest positive normalized number does not coincide with the positive underflow threshold that is, it exceeds the latter). Further discussion can be found in <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>68_A.5.3</MarginText>
<dt><br/>S'Model</dt>
<dl>
<dd>S'Model denotes a function with the following specification: <br /></dd>
</dl>
<MarginText>69_A.5.3</MarginText>
<CodeBlock language="ada">
function S'Model (X : T){"\n"}  return T{"\n"}

</CodeBlock>
<MarginText>70_A.5.3</MarginText>
<dl>
<dd>If the Numerics Annex is not supported, the meaning of this attribute is implementation defined; see <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a> for the definition that applies to implementations supporting the Numerics Annex.<br /></dd>
<MarginText>71_A.5.3</MarginText>
<dt><br/>S'Safe{"_"}First</dt>
<dd>Yields the lower bound of the safe range (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>. If the Numerics Annex is not supported, the value of this attribute is implementation defined; see <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a> for the definition that applies to implementations supporting the Numerics Annex. The value of this attribute is of the type <i>universal{"_"}real</i>.<br /></dd>
<MarginText>72_A.5.3</MarginText>
<dt><br/>S'Safe{"_"}Last</dt>
<dd>Yields the upper bound of the safe range (see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>) of the type <i>T</i>. If the Numerics Annex is not supported, the value of this attribute is implementation defined; see <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.2">G.2.2</a> for the definition that applies to implementations supporting the Numerics Annex. The value of this attribute is of the type <i>universal{"_"}real</i>. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>72.a_A.5.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>A predefined floating point arithmetic operation that yields a value in the safe range of its result type is guaranteed not to overflow. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72.b_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>An exception is made for exponentiation by a negative exponent in <a href="/docs/arm/AA-4/AA-4.5#Subclause_4.5.6">4.5.6</a>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72.c_A.5.3</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The values of the Model{"_"}Mantissa, Model{"_"}Emin, Model{"_"}Epsilon, Model, Safe{"_"}First, and Safe{"_"}Last attributes, if the Numerics Annex is not supported.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>72.d_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
The Epsilon and Mantissa attributes of floating point types are removed from the language and replaced by Model{"_"}Epsilon and Model{"_"}Mantissa, which may have different values (as a result of changes in the definition of model numbers); the replacement of one set of attributes by another is intended to convert what would be an inconsistent change into an incompatible change.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72.e_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
The Emax, Small, Large, Safe{"_"}Emax, Safe{"_"}Small, and Safe{"_"}Large attributes of floating point types are removed from the language. Small and Safe{"_"}Small are collectively replaced by Model{"_"}Small, which is functionally equivalent to Safe{"_"}Small, though it may have a slightly different value. The others are collectively replaced by Safe{"_"}First and Safe{"_"}Last. Safe{"_"}Last is functionally equivalent to Safe{"_"}Large, though it may have a different value; Safe{"_"}First is comparable to the negation of Safe{"_"}Large but may differ slightly from it as well as from the negation of Safe{"_"}Last. Emax and Safe{"_"}Emax had relatively few uses in Ada 83; T'Safe{"_"}Emax can be computed in the revised language as Integer'Min(T'Exponent(T'Safe{"_"}First), T'Exponent(T'Safe{"_"}Last)).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72.f_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
Implementations are encouraged to eliminate the incompatibilities discussed here by retaining the old attributes, during a transition period, in the form of implementation-defined attributes with their former values. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>72.g_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
The Model{"_"}Emin attribute is new. It is conceptually similar to the negation of Safe{"_"}Emax attribute of Ada 83, adjusted for the fact that the model numbers now have the hardware radix. It is a fundamental determinant, along with Model{"_"}Mantissa, of the set of model numbers of a type (see <a href="/docs/arm/AA-G/AA-G.2#Subclause_G.2.1">G.2.1</a>).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72.h_A.5.3</MarginText>
<Admonition type="aarm" aarm="note">
The Denorm and Signed{"_"}Zeros attributes are new, as are all of the primitive function attributes. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>72.i/2_A.5.3</MarginText>
<MarginInfo items={["AI95-00388-01"]} />
<Admonition type="aarm" aarm="note">
The Machine{"_"}Rounding attribute is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.4"></a>

## A.5.4  Attributes of Fixed Point Types


#### Static Semantics

<MarginText>1_A.5.4</MarginText>
<p>The following <i>representation-oriented</i> attributes are defined for every subtype S of a fixed point type <i>T</i>. <br /></p>

<MarginText>2_A.5.4</MarginText>
<dt><br/>S'Machine{"_"}Radix</dt>
<dl>
<dd>Yields the radix of the hardware representation of the type <i>T</i>. The value of this attribute is of the type <i>universal{"_"}integer</i>.<br /></dd>
<MarginText>3_A.5.4</MarginText>
<dt><br/>S'Machine{"_"}Rounds</dt>
<dd>Yields the value True if rounding is performed on inexact results of every predefined operation that yields a result of the type <i>T</i>; yields the value False otherwise. The value of this attribute is of the predefined type Boolean.<br /></dd>
<MarginText>4_A.5.4</MarginText>
<dt><br/>S'Machine{"_"}Overflows</dt>
<dd>Yields the value True if overflow and divide-by-zero are detected and reported by raising Constraint{"_"}Error for every predefined operation that yields a result of the type <i>T</i>; yields the value False otherwise. The value of this attribute is of the predefined type Boolean. <br /></dd>
</dl>
<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.a_A.5.4</MarginText>
<Admonition type="aarm" aarm="note">
The Mantissa, Large, Safe{"_"}Small, and Safe{"_"}Large attributes of fixed point types are removed from the language.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b_A.5.4</MarginText>
<Admonition type="aarm" aarm="note">
Implementations are encouraged to eliminate the resulting incompatibility by retaining these attributes, during a transition period, in the form of implementation-defined attributes with their former values. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.c_A.5.4</MarginText>
<Admonition type="aarm" aarm="note">
The Machine{"_"}Radix attribute is now allowed for fixed point types. It is also specifiable in an attribute definition clause (see <a href="/docs/arm/AA-F/AA-F.1">F.1</a>). <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.5"></a>

## A.5.5  Big Numbers

<MarginText>1/5_A.5.5</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<p>Support is provided for integer arithmetic involving values larger than those supported by the target machine, and for arbitrary-precision real numbers. <br /></p>


#### Static Semantics

<MarginText>2/5_A.5.5</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<p>The library package Numerics.Big{"_"}Numbers has the following declaration:<br /></p>

<MarginText>3/5_A.5.5</MarginText>
<CodeBlock language="ada">
package Ada.Numerics.Big{"_"}Numbers{"\n"}   with Pure, Nonblocking, Global ={">"} null is{"\n"}   subtype Field is Integer range 0 .. implementation-defined;{"\n"}   subtype Number{"_"}Base is Integer range 2 .. 16;{"\n"}end Ada.Numerics.Big{"_"}Numbers;{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>3.a/5_A.5.5</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<Admonition type="aarm" aarm="note">
The package Numerics.Big{"_"}Numbers is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.6"></a>

## A.5.6  Big Integers


#### Static Semantics

<MarginText>1/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>The library package Numerics.Big{"_"}Numbers.Big{"_"}Integers has the following declaration:<br /></p>

<MarginText>2/5_A.5.6</MarginText>
<CodeBlock language="ada">
with Ada.Strings.Text{"_"}Buffers;{"\n"}package Ada.Numerics.Big{"_"}Numbers.Big{"_"}Integers{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
<MarginText>3/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1", "AI12-0407-1"]} />
   type Big{"_"}Integer is private{"\n"}     with Integer{"_"}Literal ={">"} From{"_"}Universal{"_"}Image,{"\n"}          Put{"_"}Image ={">"} Put{"_"}Image;{"\n"}
<MarginText>4/5_A.5.6</MarginText>
   function Is{"_"}Valid (Arg : Big{"_"}Integer) return Boolean{"\n"}      with Convention ={">"} Intrinsic;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>4.a/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The result of Is{"_"}Valid on a default-initialized object of type Big{"_"}Integer is unspecified, analogous to the value of a Valid <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> applied to a default-initialized object of an integer type (see <a href="/docs/arm/AA-13/AA-13.9#Subclause_13.9.2">13.9.2</a>). The language-provided functions in the Big{"_"}Integers package only return values for which Is{"_"}Valid is certain to be True. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>5/5_A.5.6</MarginText>
<CodeBlock language="ada">
   subtype Valid{"_"}Big{"_"}Integer is Big{"_"}Integer{"\n"}      with Dynamic{"_"}Predicate ={">"} Is{"_"}Valid (Valid{"_"}Big{"_"}Integer),{"\n"}           Predicate{"_"}Failure ={">"} (raise Program{"_"}Error);{"\n"}
<MarginText>6/5_A.5.6</MarginText>
   function "=" (L, R : Valid{"_"}Big{"_"}Integer) return Boolean;{"\n"}   function "{"<"}" (L, R : Valid{"_"}Big{"_"}Integer) return Boolean;{"\n"}   function "{"<"}=" (L, R : Valid{"_"}Big{"_"}Integer) return Boolean;{"\n"}   function "{">"}" (L, R : Valid{"_"}Big{"_"}Integer) return Boolean;{"\n"}   function "{">"}=" (L, R : Valid{"_"}Big{"_"}Integer) return Boolean;{"\n"}
<MarginText>7/5_A.5.6</MarginText>
   function To{"_"}Big{"_"}Integer (Arg : Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}
<MarginText>8/5_A.5.6</MarginText>
   subtype Big{"_"}Positive is Big{"_"}Integer{"\n"}      with Dynamic{"_"}Predicate ={">"} (if Is{"_"}Valid (Big{"_"}Positive){"\n"}                                 then Big{"_"}Positive {">"} 0),{"\n"}           Predicate{"_"}Failure ={">"} (raise Constraint{"_"}Error);{"\n"}
<MarginText>9/5_A.5.6</MarginText>
   subtype Big{"_"}Natural is Big{"_"}Integer{"\n"}      with Dynamic{"_"}Predicate ={">"} (if Is{"_"}Valid (Big{"_"}Natural){"\n"}                                 then Big{"_"}Natural {">"}= 0),{"\n"}           Predicate{"_"}Failure ={">"} (raise Constraint{"_"}Error);{"\n"}
<MarginText>10/5_A.5.6</MarginText>
   function In{"_"}Range (Arg, Low, High : Valid{"_"}Big{"_"}Integer) return Boolean is{"\n"}     (Low {"<"}= Arg and Arg {"<"}= High);{"\n"}
<MarginText>11/5_A.5.6</MarginText>
   function To{"_"}Integer (Arg : Valid{"_"}Big{"_"}Integer) return Integer{"\n"}      with Pre ={">"} In{"_"}Range (Arg,{"\n"}                            Low  ={">"} To{"_"}Big{"_"}Integer (Integer'First),{"\n"}                            High ={">"} To{"_"}Big{"_"}Integer (Integer'Last)){"\n"}                   or else raise Constraint{"_"}Error;{"\n"}
<MarginText>12/5_A.5.6</MarginText>
   generic{"\n"}      type Int is range {"<"}{">"};{"\n"}   package Signed{"_"}Conversions is{"\n"}      function To{"_"}Big{"_"}Integer (Arg : Int) return Valid{"_"}Big{"_"}Integer;{"\n"}      function From{"_"}Big{"_"}Integer (Arg : Valid{"_"}Big{"_"}Integer) return Int{"\n"}         with Pre ={">"} In{"_"}Range (Arg,{"\n"}                               Low  ={">"} To{"_"}Big{"_"}Integer (Int'First),{"\n"}                               High ={">"} To{"_"}Big{"_"}Integer (Int'Last)){"\n"}                      or else raise Constraint{"_"}Error;{"\n"}   end Signed{"_"}Conversions;{"\n"}
<MarginText>13/5_A.5.6</MarginText>
   generic{"\n"}      type Int is mod {"<"}{">"};{"\n"}   package Unsigned{"_"}Conversions is{"\n"}      function To{"_"}Big{"_"}Integer (Arg : Int) return Valid{"_"}Big{"_"}Integer;{"\n"}      function From{"_"}Big{"_"}Integer (Arg : Valid{"_"}Big{"_"}Integer) return Int{"\n"}         with Pre ={">"} In{"_"}Range (Arg,{"\n"}                               Low  ={">"} To{"_"}Big{"_"}Integer (Int'First),{"\n"}                               High ={">"} To{"_"}Big{"_"}Integer (Int'Last)){"\n"}                      or else raise Constraint{"_"}Error;{"\n"}   end Unsigned{"_"}Conversions;{"\n"}
<MarginText>14/5_A.5.6</MarginText>
   function To{"_"}String (Arg : Valid{"_"}Big{"_"}Integer;{"\n"}                       Width : Field := 0;{"\n"}                       Base  : Number{"_"}Base := 10) return String{"\n"}      with Post ={">"} To{"_"}String'Result'First = 1;{"\n"}
<MarginText>15/5_A.5.6</MarginText>
   function From{"_"}String (Arg : String) return Valid{"_"}Big{"_"}Integer;{"\n"}
<MarginText>16/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
   function From{"_"}Universal{"_"}Image (Arg : String) return Valid{"_"}Big{"_"}Integer{"\n"}      renames From{"_"}String;{"\n"}
<MarginText>17/5_A.5.6</MarginText>
   procedure Put{"_"}Image{"\n"}     (Buffer : in out Ada.Strings.Text{"_"}Buffers.Root{"_"}Buffer{"_"}Type'Class;{"\n"}      Arg    : in Valid{"_"}Big{"_"}Integer);{"\n"}
<MarginText>18/5_A.5.6</MarginText>
   function "+" (L : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "-" (L : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "abs" (L : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "+" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "-" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "{"*"}" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "/" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "mod" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "rem" (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function "{"*"}{"*"}" (L : Valid{"_"}Big{"_"}Integer; R : Natural){"\n"}      return Valid{"_"}Big{"_"}Integer;{"\n"}   function Min (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}   function Max (L, R : Valid{"_"}Big{"_"}Integer) return Valid{"_"}Big{"_"}Integer;{"\n"}
<MarginText>19/5_A.5.6</MarginText>
   function Greatest{"_"}Common{"_"}Divisor{"\n"}     (L, R : Valid{"_"}Big{"_"}Integer) return Big{"_"}Positive{"\n"}     with Pre ={">"} (L /= 0 and R /= 0) or else raise Constraint{"_"}Error;{"\n"}
<MarginText>20/5_A.5.6</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Numerics.Big{"_"}Numbers.Big{"_"}Integers;{"\n"}

</CodeBlock>
<MarginText>21/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>To{"_"}String and From{"_"}String behave analogously to the Put and Get procedures defined in Text{"_"}IO.Integer{"_"}IO (in particular, with respect to the interpretation of the Width and Base parameters) except that Constraint{"_"}Error, not Data{"_"}Error, is propagated in error cases and the result of a call to To{"_"}String with a Width parameter of 0 and a nonnegative Arg parameter does not include a leading blank. Put{"_"}Image calls To{"_"}String (passing in the default values for the Width and Base parameters), prepends a leading blank if the argument is nonnegative, and writes the resulting value to the buffer using Text{"_"}Buffers.Put.<br /></p>

<MarginText>22/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<p>The other functions have their usual mathematical meanings.<br /></p>

<MarginText>23/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>The type Big{"_"}Integer needs finalization (see <a href="/docs/arm/AA-7/AA-7.6">7.6</a>). <br /></p>


#### Dynamic Semantics

<MarginText>24/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>For purposes of determining whether predicate checks are performed as part of default initialization, the type Big{"_"}Integer is considered to have a subcomponent that has a <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>24.a/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0005-1", "AI12-0208-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>This means that the elaboration of <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b/5_A.5.6</MarginText>
<CodeBlock language="ada">
Default{"_"}Initialized{"_"}Object : Valid{"_"}Big{"_"}Integer;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.c/5_A.5.6</MarginText>
<Admonition type="aarm" aarm="note">
either produces a value for which Is{"_"}Valid is True. or it propagates Program{"_"}Error. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>25/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>No storage associated with a Big{"_"}Integer object shall be lost upon assignment or scope exit.<br /></p>

<AnnotatedOnly>
<MarginText>25.a/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<b></b>The &ldquo;No storage ... shall be lost&rdquo; requirement does not preclude implementation techniques such as caching or unique number tables. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>25.b/5_A.5.6</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<Admonition type="aarm" aarm="note">
The package Numerics.Big{"_"}Numbers.Big{"_"}Integers is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.5.7"></a>

## A.5.7  Big Reals


#### Static Semantics

<MarginText>1/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>The library package Numerics.Big{"_"}Numbers.Big{"_"}Reals has the following declaration:<br /></p>

<MarginText>2/5_A.5.7</MarginText>
<CodeBlock language="ada">
with Ada.Numerics.Big{"_"}Numbers.Big{"_"}Integers;{"\n"}   use all type Big{"_"}Integers.Big{"_"}Integer;{"\n"}with Ada.Strings.Text{"_"}Buffers;{"\n"}package Ada.Numerics.Big{"_"}Numbers.Big{"_"}Reals{"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
<MarginText>3/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1", "AI12-0407-1"]} />
   type Big{"_"}Real is private{"\n"}      with Real{"_"}Literal ={">"} From{"_"}Universal{"_"}Image,{"\n"}           Put{"_"}Image ={">"} Put{"_"}Image;{"\n"}
<MarginText>4/5_A.5.7</MarginText>
   function Is{"_"}Valid (Arg : Big{"_"}Real) return Boolean{"\n"}      with Convention ={">"} Intrinsic;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>4.a/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The result of Is{"_"}Valid on a default-initialized object of type Big{"_"}Real is unspecified, analogous to the value of a Valid <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> applied to a default-initialized object of a real type (see <a href="/docs/arm/AA-13/AA-13.9#Subclause_13.9.2">13.9.2</a>). The language-provided functions in the Big{"_"}Reals package only return values for which Is{"_"}Valid is certain to be True. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>5/5_A.5.7</MarginText>
<CodeBlock language="ada">
   subtype Valid{"_"}Big{"_"}Real is Big{"_"}Real{"\n"}      with Dynamic{"_"}Predicate ={">"} Is{"_"}Valid (Valid{"_"}Big{"_"}Real),{"\n"}           Predicate{"_"}Failure ={">"} raise Program{"_"}Error;{"\n"}
<MarginText>6/5_A.5.7</MarginText>
   function "/" (Num, Den : Big{"_"}Integers.Valid{"_"}Big{"_"}Integer){"\n"}      return Valid{"_"}Big{"_"}Real{"\n"}      with Pre ={">"} Den /= 0{"\n"}                   or else raise Constraint{"_"}Error;{"\n"}
<MarginText>7/5_A.5.7</MarginText>
   function Numerator{"\n"}      (Arg : Valid{"_"}Big{"_"}Real) return Big{"_"}Integers.Valid{"_"}Big{"_"}Integer{"\n"}     with Post ={">"} (if Arg = 0.0 then Numerator'Result = 0);{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>7.a/5_A.5.7</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>The postcondition of Numerator cannot be complete as it cannot mention Denominator. Since the postcondition of Denominator uses Numerator, we would get an infinite mutual recursion if both postconditions are enabled. The postcondition of Denominator serves as the postcondition for Numerator as well unless Arg = 0.0. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>8/5_A.5.7</MarginText>
<CodeBlock language="ada">
   function Denominator (Arg : Valid{"_"}Big{"_"}Real){"\n"}      return Big{"_"}Integers.Big{"_"}Positive{"\n"}      with Post ={">"}{"\n"}        (if Arg = 0.0 then Denominator'Result = 1{"\n"}         else Big{"_"}Integers.Greatest{"_"}Common{"_"}Divisor{"\n"}                (Numerator (Arg), Denominator'Result) = 1);{"\n"}
<MarginText>9/5_A.5.7</MarginText>
   function To{"_"}Big{"_"}Real (Arg : Big{"_"}Integers.Valid{"_"}Big{"_"}Integer){"\n"}      return Valid{"_"}Big{"_"}Real is (Arg / 1);{"\n"}
<MarginText>10/5_A.5.7</MarginText>
   function To{"_"}Real (Arg : Integer) return Valid{"_"}Big{"_"}Real is{"\n"}      (Big{"_"}Integers.To{"_"}Big{"_"}Integer (Arg) / 1);{"\n"}
<MarginText>11/5_A.5.7</MarginText>
   function "=" (L, R : Valid{"_"}Big{"_"}Real) return Boolean;{"\n"}   function "{"<"}" (L, R : Valid{"_"}Big{"_"}Real) return Boolean;{"\n"}   function "{"<"}=" (L, R : Valid{"_"}Big{"_"}Real) return Boolean;{"\n"}   function "{">"}" (L, R : Valid{"_"}Big{"_"}Real) return Boolean;{"\n"}   function "{">"}=" (L, R : Valid{"_"}Big{"_"}Real) return Boolean;{"\n"}
<MarginText>12/5_A.5.7</MarginText>
   function In{"_"}Range (Arg, Low, High : Valid{"_"}Big{"_"}Real) return Boolean is{"\n"}      (Low {"<"}= Arg and Arg {"<"}= High);{"\n"}
<MarginText>13/5_A.5.7</MarginText>
   generic{"\n"}      type Num is digits {"<"}{">"};{"\n"}   package Float{"_"}Conversions is{"\n"}      function To{"_"}Big{"_"}Real (Arg : Num) return Valid{"_"}Big{"_"}Real;{"\n"}      function From{"_"}Big{"_"}Real (Arg : Valid{"_"}Big{"_"}Real) return Num{"\n"}         with Pre ={">"} In{"_"}Range (Arg,{"\n"}                               Low  ={">"} To{"_"}Big{"_"}Real (Num'First),{"\n"}                               High ={">"} To{"_"}Big{"_"}Real (Num'Last)){"\n"}                     or else (raise Constraint{"_"}Error);{"\n"}   end Float{"_"}Conversions;{"\n"}
<MarginText>14/5_A.5.7</MarginText>
   generic{"\n"}      type Num is delta {"<"}{">"};{"\n"}   package Fixed{"_"}Conversions is{"\n"}      function To{"_"}Big{"_"}Real (Arg : Num) return Valid{"_"}Big{"_"}Real;{"\n"}      function From{"_"}Big{"_"}Real (Arg : Valid{"_"}Big{"_"}Real) return Num{"\n"}         with Pre ={">"} In{"_"}Range (Arg,{"\n"}                               Low  ={">"} To{"_"}Big{"_"}Real (Num'First),{"\n"}                               High ={">"} To{"_"}Big{"_"}Real (Num'Last)){"\n"}                     or else (raise Constraint{"_"}Error);{"\n"}   end Fixed{"_"}Conversions;{"\n"}
<MarginText>15/5_A.5.7</MarginText>
   function To{"_"}String (Arg  : Valid{"_"}Big{"_"}Real;{"\n"}                       Fore : Field := 2;{"\n"}                       Aft  : Field := 3;{"\n"}                       Exp  : Field := 0) return String{"\n"}      with Post ={">"} To{"_"}String'Result'First = 1;{"\n"}
<MarginText>16/5_A.5.7</MarginText>
   function From{"_"}String (Arg   : String) return Valid{"_"}Big{"_"}Real;{"\n"}
<MarginText>17/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
   function From{"_"}Universal{"_"}Image (Arg : String) return Valid{"_"}Big{"_"}Real{"\n"}      renames From{"_"}String;{"\n"}
<MarginText>18/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
   function From{"_"}Universal{"_"}Image (Num, Den : String){"\n"}      return Valid{"_"}Big{"_"}Real is{"\n"}         (Big{"_"}Integers.From{"_"}Universal{"_"}Image (Num) /{"\n"}          Big{"_"}Integers.From{"_"}Universal{"_"}Image (Den));{"\n"}
<MarginText>19/5_A.5.7</MarginText>
   function To{"_"}Quotient{"_"}String (Arg : Valid{"_"}Big{"_"}Real) return String is{"\n"}      (To{"_"}String (Numerator (Arg)) & " / " & To{"_"}String (Denominator (Arg)));{"\n"}   function From{"_"}Quotient{"_"}String (Arg : String) return Valid{"_"}Big{"_"}Real;{"\n"}
<MarginText>20/5_A.5.7</MarginText>
   procedure Put{"_"}Image{"\n"}     (Buffer : in out Ada.Strings.Text{"_"}Buffers.Root{"_"}Buffer{"_"}Type'Class;{"\n"}      Arg    : in Valid{"_"}Big{"_"}Real);{"\n"}
<MarginText>21/5_A.5.7</MarginText>
   function "+" (L : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "-" (L : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "abs" (L : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "+" (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "-" (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "{"*"}" (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "/" (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function "{"*"}{"*"}" (L : Valid{"_"}Big{"_"}Real; R : Integer){"\n"}      return Valid{"_"}Big{"_"}Real;{"\n"}   function Min (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}   function Max (L, R : Valid{"_"}Big{"_"}Real) return Valid{"_"}Big{"_"}Real;{"\n"}
<MarginText>22/5_A.5.7</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Numerics.Big{"_"}Numbers.Big{"_"}Reals;{"\n"}

</CodeBlock>
<MarginText>23/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>To{"_"}String and From{"_"}String behave analogously to the Put and Get procedures defined in Text{"_"}IO.Float{"_"}IO (in particular, with respect to the interpretation of the Fore, Aft, and Exp parameters), except that Constraint{"_"}Error (not Data{"_"}Error) is propagated in error cases. From{"_"}Quotient{"_"}String implements the inverse function of To{"_"}Quotient{"_"}String; Constraint{"_"}Error is propagated in error cases. Put{"_"}Image calls To{"_"}String, and writes the resulting value to the buffer using Text{"_"}Buffers.Put.<br /></p>

<MarginText>24/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<p>For an instance of Float{"_"}Conversions or Fixed{"_"}Conversions, To{"_"}Big{"_"}Real is exact (that is, the result represents exactly the same mathematical value as the argument) and From{"_"}Big{"_"}Real is subject to the same precision rules as a type conversion of a value of type T to the target type Num, where T is a hypothetical floating point type whose model numbers include all of the model numbers of Num as well as the exact mathematical value of the argument.<br /></p>

<MarginText>25/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<p>The other functions have their usual mathematical meanings.<br /></p>

<MarginText>26/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>The type Big{"_"}Real needs finalization (see <a href="/docs/arm/AA-7/AA-7.6">7.6</a>).<br /></p>


#### Dynamic Semantics

<MarginText>27/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>For purposes of determining whether predicate checks are performed as part of default initialization, the type Big{"_"}Real is considered to have a subcomponent that has a <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>27.a/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0005-1", "AI12-0208-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>This means that the elaboration of <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b/5_A.5.7</MarginText>
<CodeBlock language="ada">
Default{"_"}Initialized{"_"}Object : Valid{"_"}Big{"_"}Real;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.c/5_A.5.7</MarginText>
<Admonition type="aarm" aarm="note">
either produces a value for which Is{"_"}Valid is True. or it propagates Program{"_"}Error. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>28/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<p>No storage associated with a Big{"_"}Real object shall be lost upon assignment or scope exit.<br /></p>

<AnnotatedOnly>
<MarginText>28.a/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<b></b>The &ldquo;No storage ... shall be lost&rdquo; requirement does not preclude implementation techniques such as caching or unique number tables. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.b/5_A.5.7</MarginText>
<MarginInfo items={["AI12-0208-1", "AI12-0366-1"]} />
<Admonition type="aarm" aarm="note">
The package Numerics.Big{"_"}Numbers.Big{"_"}Reals is new. <br />
</Admonition>
</AnnotatedOnly>

