---
sidebar_position:  130
---

# A.10 Text Input-Output

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";


#### Static Semantics

<MarginText>1/5</MarginText>
<MarginInfo items={["AI05-0299-1", "AI12-0449-1"]} />
<p>This subclause describes the package Text{"_"}IO, which provides facilities for input and output in human-readable form. Each file is read or written sequentially, as a sequence of characters grouped into lines, and as a sequence of lines grouped into pages. The specification of the package is given below in <a href="../AA-A/AA-A.10#Subclause_A.10.1">A.10.1</a>.<br /></p>

<MarginText>2/5</MarginText>
<MarginInfo items={["AI05-0299-1", "AI12-0449-1"]} />
<p>The facilities for file management given above, in <a href="../AA-A/AA-A.8#Subclause_A.8.2">A.8.2</a> and <a href="../AA-A/AA-A.8#Subclause_A.8.3">A.8.3</a>, are available for text input-output. In place of Read and Write, however, there are procedures Get and Put that input values of suitable types from text files, and output values to them. These values are provided to the Put procedures, and returned by the Get procedures, in a parameter Item. Several overloaded procedures of these names exist, for different types of Item. These Get procedures analyze the input sequences of characters based on lexical elements (see Clause <a href="../AA-2/">2</a>) and return the corresponding values; the Put procedures output the given values as appropriate lexical elements. Procedures Get and Put are also available that input and output individual characters treated as character values rather than as lexical elements. Related to character input are procedures to look ahead at the next character without reading it, and to read a character &ldquo;immediately&rdquo; without waiting for an end-of-line to signal availability.<br /></p>

<MarginText>3</MarginText>
<p>In addition to the procedures Get and Put for numeric and enumeration types of Item that operate on text files, analogous procedures are provided that read from and write to a parameter of type String. These procedures perform the same analysis and composition of character sequences as their counterparts which have a file parameter.<br /></p>

<MarginText>4</MarginText>
<p>For all Get and Put procedures that operate on text files, and for many other subprograms, there are forms with and without a file parameter. Each such Get procedure operates on an input file, and each such Put procedure operates on an output file. If no file is specified, a default input file or a default output file is used.<br /></p>

<MarginText>5</MarginText>
<p>At the beginning of program execution the default input and output files are the so-called standard input file and standard output file. These files are open, have respectively the current modes In{"_"}File and Out{"_"}File, and are associated with two implementation-defined external files. Procedures are provided to change the current default input file and the current default output file. <br /></p>

<AnnotatedOnly>
<MarginText>5.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The external files associated with the standard input, standard output, and standard error files.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.a.1/1</MarginText>
<MarginInfo items={["AI95-00087-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>{"{"}<em>8652/0113</em>{"}"} The default input file and default output file are not the names of distinct file objects, but rather the <em>role</em> played by one or more (other) file object(s). Thus, they generally will be implemented as accesses to another file object. An implementation that implements them by copying them is incorrect. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>6</MarginText>
<p>At the beginning of program execution a default file for program-dependent error-related text output is the so-called standard error file. This file is open, has the current mode Out{"_"}File, and is associated with an implementation-defined external file. A procedure is provided to change the current default error file.<br /></p>

<MarginText>7</MarginText>
<p>From a logical point of view, a text file is a sequence of pages, a page is a sequence of lines, and a line is a sequence of characters; the end of a line is marked by a <em>line terminator</em>; the end of a page is marked by the combination of a line terminator immediately followed by a <em>page terminator</em>; and the end of a file is marked by the combination of a line terminator immediately followed by a page terminator and then a <em>file terminator</em>. Terminators are generated during output; either by calls of procedures provided expressly for that purpose; or implicitly as part of other operations, for example, when a bounded line length, a bounded page length, or both, have been specified for a file.<br /></p>

<MarginText>8/5</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>The actual nature of terminators is not defined by the language and hence depends on the implementation. Although terminators are recognized or generated by certain of the procedures that follow, they are not necessarily implemented as characters or as sequences of characters. Whether they are characters (and if so which ones) in any particular implementation is not of concern to a user who neither explicitly outputs nor explicitly inputs control characters. The effect of input (Get) or output (Put) of control characters (other than horizontal tabulation) is not specified by the language. <br /></p>

<MarginText>9</MarginText>
<p>The characters of a line are numbered, starting from one; the number of a character is called its <em>column number</em>. For a line terminator, a column number is also defined: it is one more than the number of characters in the line. The lines of a page, and the pages of a file, are similarly numbered. The current column number is the column number of the next character or line terminator to be transferred. The current line number is the number of the current line. The current page number is the number of the current page. These numbers are values of the subtype Positive{"_"}Count of the type Count (by convention, the value zero of the type Count is used to indicate special conditions). <br /></p>

<MarginText>10</MarginText>
<CodeBlock language="ada">
type Count is range 0 .. implementation-defined;{"\n"}subtype Positive{"_"}Count is Count range 1 .. Count'Last;{"\n"}

</CodeBlock>
<MarginText>11</MarginText>
<p>For an output file or an append file, a <em>maximum line length</em> can be specified and a <em>maximum page length</em> can be specified. If a value to be output cannot fit on the current line, for a specified maximum line length, then a new line is automatically started before the value is output; if, further, this new line cannot fit on the current page, for a specified maximum page length, then a new page is automatically started before the value is output. Functions are provided to determine the maximum line length and the maximum page length. When a file is opened with mode Out{"_"}File or Append{"_"}File, both values are zero: by convention, this means that the line lengths and page lengths are unbounded. (Consequently, output consists of a single line if the subprograms for explicit control of line and page structure are not used.) The constant Unbounded is provided for this purpose. <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="note">
Append{"_"}File is new in Ada 95. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.1"></a>

## A.10.1  The Package Text_IO


#### Static Semantics

<MarginText>1_A.10.1</MarginText>
<p>The library package Text{"_"}IO has the following declaration: <br /></p>

<MarginText>2/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
with Ada.IO{"_"}Exceptions;{"\n"}package Ada.Text{"_"}IO{"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>3_A.10.1</MarginText>
   type File{"_"}Type is limited private;{"\n"}
<MarginText>4_A.10.1</MarginText>
   type File{"_"}Mode is (In{"_"}File, Out{"_"}File, Append{"_"}File);{"\n"}
<MarginText>5_A.10.1</MarginText>
   type Count is range 0 .. implementation-defined;{"\n"}   subtype Positive{"_"}Count is Count range 1 .. Count'Last;{"\n"}   Unbounded : constant Count := 0; -- line and page length{"\n"}
<MarginText>6_A.10.1</MarginText>
   subtype Field       is Integer range 0 .. implementation-defined;{"\n"}   subtype Number{"_"}Base is Integer range 2 .. 16;{"\n"}
<MarginText>7_A.10.1</MarginText>
   type Type{"_"}Set is (Lower{"_"}Case, Upper{"_"}Case);{"\n"}
<MarginText>8_A.10.1</MarginText>
   -- File Management{"\n"}
<MarginText>9_A.10.1</MarginText>
   procedure Create (File : in out File{"_"}Type;{"\n"}                     Mode : in File{"_"}Mode := Out{"_"}File;{"\n"}                     Name : in String    := "";{"\n"}                     Form : in String    := "");{"\n"}
<MarginText>10_A.10.1</MarginText>
   procedure Open   (File : in out File{"_"}Type;{"\n"}                     Mode : in File{"_"}Mode;{"\n"}                     Name : in String;{"\n"}                     Form : in String := "");{"\n"}
<MarginText>11_A.10.1</MarginText>
   procedure Close  (File : in out File{"_"}Type);{"\n"}   procedure Delete (File : in out File{"_"}Type);{"\n"}   procedure Reset  (File : in out File{"_"}Type; Mode : in File{"_"}Mode);{"\n"}   procedure Reset  (File : in out File{"_"}Type);{"\n"}
<MarginText>12_A.10.1</MarginText>
   function  Mode   (File : in File{"_"}Type) return File{"_"}Mode;{"\n"}   function  Name   (File : in File{"_"}Type) return String;{"\n"}   function  Form   (File : in File{"_"}Type) return String;{"\n"}
<MarginText>13_A.10.1</MarginText>
   function  Is{"_"}Open(File : in File{"_"}Type) return Boolean;{"\n"}
<MarginText>14_A.10.1</MarginText>
   -- Control of default input and output files{"\n"}
<MarginText>15_A.10.1</MarginText>
   procedure Set{"_"}Input (File : in File{"_"}Type);{"\n"}   procedure Set{"_"}Output(File : in File{"_"}Type);{"\n"}   procedure Set{"_"}Error (File : in File{"_"}Type);{"\n"}
<MarginText>16_A.10.1</MarginText>
   function Standard{"_"}Input  return File{"_"}Type;{"\n"}   function Standard{"_"}Output return File{"_"}Type;{"\n"}   function Standard{"_"}Error  return File{"_"}Type;{"\n"}
<MarginText>17_A.10.1</MarginText>
   function Current{"_"}Input   return File{"_"}Type;{"\n"}   function Current{"_"}Output  return File{"_"}Type;{"\n"}   function Current{"_"}Error   return File{"_"}Type;{"\n"}
<MarginText>18_A.10.1</MarginText>
   type File{"_"}Access is access constant File{"_"}Type;{"\n"}
<MarginText>19_A.10.1</MarginText>
   function Standard{"_"}Input  return File{"_"}Access;{"\n"}   function Standard{"_"}Output return File{"_"}Access;{"\n"}   function Standard{"_"}Error  return File{"_"}Access;{"\n"}
<MarginText>20_A.10.1</MarginText>
   function Current{"_"}Input   return File{"_"}Access;{"\n"}   function Current{"_"}Output  return File{"_"}Access;{"\n"}   function Current{"_"}Error   return File{"_"}Access;{"\n"}
<MarginText>21/5_A.10.1</MarginText>
<MarginInfo items={["AI95-00057-01", "AI12-0302-1"]} />
{"{"}8652/0051{"}"} --Buffer control{"\n"}   procedure Flush (File : in File{"_"}Type){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Flush{"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>22_A.10.1</MarginText>
   -- Specification of line and page lengths{"\n"}
<MarginText>23/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Set{"_"}Line{"_"}Length(File : in File{"_"}Type; To : in Count){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Set{"_"}Line{"_"}Length(To   : in Count){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>24/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Set{"_"}Page{"_"}Length(File : in File{"_"}Type; To : in Count){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Set{"_"}Page{"_"}Length(To   : in Count){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>25/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function  Line{"_"}Length(File : in File{"_"}Type) return Count;{"\n"}   function  Line{"_"}Length return Count{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>26/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function  Page{"_"}Length(File : in File{"_"}Type) return Count;{"\n"}   function  Page{"_"}Length return Count{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>27_A.10.1</MarginText>
   -- Column, Line, and Page Control{"\n"}
<MarginText>28/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure New{"_"}Line   (File    : in File{"_"}Type;{"\n"}                         Spacing : in Positive{"_"}Count := 1){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure New{"_"}Line   (Spacing : in Positive{"_"}Count := 1){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>29/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Skip{"_"}Line  (File    : in File{"_"}Type;{"\n"}                         Spacing : in Positive{"_"}Count := 1){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Skip{"_"}Line  (Spacing : in Positive{"_"}Count := 1){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>30/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function  End{"_"}Of{"_"}Line(File : in File{"_"}Type) return Boolean;{"\n"}   function  End{"_"}Of{"_"}Line return Boolean;{"\n"}
<MarginText>31/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure New{"_"}Page   (File : in File{"_"}Type){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure New{"_"}Page{"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>32/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Skip{"_"}Page  (File : in File{"_"}Type){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Skip{"_"}Page{"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>33/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function  End{"_"}Of{"_"}Page(File : in File{"_"}Type) return Boolean;{"\n"}   function  End{"_"}Of{"_"}Page return Boolean{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>34/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function  End{"_"}Of{"_"}File(File : in File{"_"}Type) return Boolean;{"\n"}   function  End{"_"}Of{"_"}File return Boolean{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>35/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Set{"_"}Col (File : in File{"_"}Type; To : in Positive{"_"}Count){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Set{"_"}Col (To   : in Positive{"_"}Count){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>36/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Set{"_"}Line(File : in File{"_"}Type; To : in Positive{"_"}Count){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Set{"_"}Line(To   : in Positive{"_"}Count){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>37/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function Col (File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}   function Col  return Positive{"_"}Count{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>38/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function Line(File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}   function Line return Positive{"_"}Count{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>39/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   function Page(File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}   function Page return Positive{"_"}Count{"\n"}      with Global ={">"} in all;{"\n"}
<MarginText>40_A.10.1</MarginText>
   -- Character Input-Output{"\n"}
<MarginText>41/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Get(File : in  File{"_"}Type; Item : out Character){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Get(Item : out Character){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>42/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Put(File : in  File{"_"}Type; Item : in Character){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Put(Item : in  Character){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>43/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Look{"_"}Ahead (File        : in  File{"_"}Type;{"\n"}                         Item        : out Character;{"\n"}                         End{"_"}Of{"_"}Line : out Boolean){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Look{"_"}Ahead (Item        : out Character;{"\n"}                         End{"_"}Of{"_"}Line : out Boolean){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>44/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Get{"_"}Immediate(File      : in  File{"_"}Type;{"\n"}                           Item      : out Character){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Get{"_"}Immediate(Item      : out Character){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>45/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Get{"_"}Immediate(File      : in  File{"_"}Type;{"\n"}                           Item      : out Character;{"\n"}                           Available : out Boolean){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Get{"_"}Immediate(Item      : out Character;{"\n"}                           Available : out Boolean){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>46_A.10.1</MarginText>
   -- String Input-Output{"\n"}
<MarginText>47/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Get(File : in  File{"_"}Type; Item : out String){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Get(Item : out String){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>48/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Put(File : in  File{"_"}Type; Item : in String){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Put(Item : in  String){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>49/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Get{"_"}Line(File : in  File{"_"}Type;{"\n"}                      Item : out String;{"\n"}                      Last : out Natural){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Get{"_"}Line(Item : out String; Last : out Natural){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>49.1/5_A.10.1</MarginText>
<MarginInfo items={["AI95-00301-01", "AI12-0302-1"]} />
   function Get{"_"}Line(File : in  File{"_"}Type) return String{"\n"}      with Global ={">"} overriding in out File;{"\n"}   function Get{"_"}Line return String{"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>50/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
   procedure Put{"_"}Line(File : in  File{"_"}Type; Item : in String){"\n"}      with Global ={">"} overriding in out File;{"\n"}   procedure Put{"_"}Line(Item : in  String){"\n"}      with Global ={">"} in out all;{"\n"}
<MarginText>51_A.10.1</MarginText>
-- Generic packages for Input-Output of Integer Types{"\n"}
<MarginText>52_A.10.1</MarginText>
   generic{"\n"}      type Num is range {"<"}{">"};{"\n"}   package Integer{"_"}IO is{"\n"}
<MarginText>53_A.10.1</MarginText>
      Default{"_"}Width : Field := Num'Width;{"\n"}      Default{"_"}Base  : Number{"_"}Base := 10;{"\n"}
<MarginText>54/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File  : in  File{"_"}Type;{"\n"}                    Item  : out Num;{"\n"}                    Width : in Field := 0){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>55/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
      procedure Put(File  : in File{"_"}Type;{"\n"}                    Item  : in Num;{"\n"}                    Width : in Field := Default{"_"}Width;{"\n"}                    Base  : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item  : in Num;{"\n"}                    Width : in Field := Default{"_"}Width;{"\n"}                    Base  : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Global ={">"} in out all;{"\n"}      procedure Get(From : in  String;{"\n"}                    Item : out Num;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in Num;{"\n"}                    Base : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Nonblocking;{"\n"}
<MarginText>56_A.10.1</MarginText>
   end Integer{"_"}IO;{"\n"}
<MarginText>57_A.10.1</MarginText>
   generic{"\n"}      type Num is mod {"<"}{">"};{"\n"}   package Modular{"_"}IO is{"\n"}
<MarginText>58_A.10.1</MarginText>
      Default{"_"}Width : Field := Num'Width;{"\n"}      Default{"_"}Base  : Number{"_"}Base := 10;{"\n"}
<MarginText>59/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File  : in  File{"_"}Type;{"\n"}                    Item  : out Num;{"\n"}                    Width : in Field := 0){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>60/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
      procedure Put(File  : in File{"_"}Type;{"\n"}                    Item  : in Num;{"\n"}                    Width : in Field := Default{"_"}Width;{"\n"}                    Base  : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item  : in Num;{"\n"}                    Width : in Field := Default{"_"}Width;{"\n"}                    Base  : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Global ={">"} in out all;{"\n"}      procedure Get(From : in  String;{"\n"}                    Item : out Num;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in Num;{"\n"}                    Base : in Number{"_"}Base := Default{"_"}Base){"\n"}         with Nonblocking;{"\n"}
<MarginText>61_A.10.1</MarginText>
   end Modular{"_"}IO;{"\n"}
<MarginText>62_A.10.1</MarginText>
   -- Generic packages for Input-Output of Real Types{"\n"}
<MarginText>63_A.10.1</MarginText>
   generic{"\n"}      type Num is digits {"<"}{">"};{"\n"}   package Float{"_"}IO is{"\n"}
<MarginText>64_A.10.1</MarginText>
      Default{"_"}Fore : Field := 2;{"\n"}      Default{"_"}Aft  : Field := Num'Digits-1;{"\n"}      Default{"_"}Exp  : Field := 3;{"\n"}
<MarginText>65/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File  : in  File{"_"}Type;{"\n"}                    Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>66/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Put(File : in File{"_"}Type;{"\n"}                    Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>67/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
      procedure Get(From : in String;{"\n"}                    Item : out Num;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in Num;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Nonblocking;{"\n"}   end Float{"_"}IO;{"\n"}
<MarginText>68_A.10.1</MarginText>
   generic{"\n"}      type Num is delta {"<"}{">"};{"\n"}   package Fixed{"_"}IO is{"\n"}
<MarginText>69_A.10.1</MarginText>
      Default{"_"}Fore : Field := Num'Fore;{"\n"}      Default{"_"}Aft  : Field := Num'Aft;{"\n"}      Default{"_"}Exp  : Field := 0;{"\n"}
<MarginText>70/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File  : in  File{"_"}Type;{"\n"}                    Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>71/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Put(File : in File{"_"}Type;{"\n"}                    Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>72/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
      procedure Get(From : in  String;{"\n"}                    Item : out Num;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in Num;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Nonblocking;{"\n"}   end Fixed{"_"}IO;{"\n"}
<MarginText>73_A.10.1</MarginText>
   generic{"\n"}      type Num is delta {"<"}{">"} digits {"<"}{">"};{"\n"}   package Decimal{"_"}IO is{"\n"}
<MarginText>74_A.10.1</MarginText>
      Default{"_"}Fore : Field := Num'Fore;{"\n"}      Default{"_"}Aft  : Field := Num'Aft;{"\n"}      Default{"_"}Exp  : Field := 0;{"\n"}
<MarginText>75/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File  : in  File{"_"}Type;{"\n"}                    Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item  : out Num;{"\n"}                    Width : in  Field := 0){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>76/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Put(File : in File{"_"}Type;{"\n"}                    Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item : in Num;{"\n"}                    Fore : in Field := Default{"_"}Fore;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>77/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
      procedure Get(From : in  String;{"\n"}                    Item : out Num;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in Num;{"\n"}                    Aft  : in Field := Default{"_"}Aft;{"\n"}                    Exp  : in Field := Default{"_"}Exp){"\n"}         with Nonblocking;{"\n"}   end Decimal{"_"}IO;{"\n"}
<MarginText>78_A.10.1</MarginText>
   -- Generic package for Input-Output of Enumeration Types{"\n"}
<MarginText>79_A.10.1</MarginText>
   generic{"\n"}      type Enum is ({"<"}{">"});{"\n"}   package Enumeration{"_"}IO is{"\n"}
<MarginText>80_A.10.1</MarginText>
      Default{"_"}Width   : Field := 0;{"\n"}      Default{"_"}Setting : Type{"_"}Set := Upper{"_"}Case;{"\n"}
<MarginText>81/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Get(File : in  File{"_"}Type;{"\n"}                    Item : out Enum){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Get(Item : out Enum){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>82/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
      procedure Put(File  : in File{"_"}Type;{"\n"}                    Item  : in Enum;{"\n"}                    Width : in Field    := Default{"_"}Width;{"\n"}                    Set   : in Type{"_"}Set := Default{"_"}Setting){"\n"}         with Global ={">"} overriding in out File;{"\n"}      procedure Put(Item  : in Enum;{"\n"}                    Width : in Field    := Default{"_"}Width;{"\n"}                    Set   : in Type{"_"}Set := Default{"_"}Setting){"\n"}         with Global ={">"} in out all;{"\n"}
<MarginText>83/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0241-1"]} />
      procedure Get(From : in  String;{"\n"}                    Item : out Enum;{"\n"}                    Last : out Positive){"\n"}         with Nonblocking;{"\n"}      procedure Put(To   : out String;{"\n"}                    Item : in  Enum;{"\n"}                    Set  : in  Type{"_"}Set := Default{"_"}Setting){"\n"}         with Nonblocking;{"\n"}   end Enumeration{"_"}IO;{"\n"}
<MarginText>84_A.10.1</MarginText>
-- Exceptions{"\n"}
<MarginText>85/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
   Status{"_"}Error : exception renames IO{"_"}Exceptions.Status{"_"}Error;{"\n"}   Mode{"_"}Error   : exception renames IO{"_"}Exceptions.Mode{"_"}Error;{"\n"}   Name{"_"}Error   : exception renames IO{"_"}Exceptions.Name{"_"}Error;{"\n"}   Use{"_"}Error    : exception renames IO{"_"}Exceptions.Use{"_"}Error;{"\n"}   Device{"_"}Error : exception renames IO{"_"}Exceptions.Device{"_"}Error;{"\n"}   End{"_"}Error    : exception renames IO{"_"}Exceptions.End{"_"}Error;{"\n"}   Data{"_"}Error   : exception renames IO{"_"}Exceptions.Data{"_"}Error;{"\n"}   Layout{"_"}Error : exception renames IO{"_"}Exceptions.Layout{"_"}Error;{"\n"}
<MarginText>85.1/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
   package Wide{"_"}File{"_"}Names is{"\n"}
<MarginText>85.2/5_A.10.1</MarginText>
      -- File management{"\n"}
<MarginText>85.3/5_A.10.1</MarginText>
      procedure Create (File : in out File{"_"}Type;{"\n"}                        Mode : in File{"_"}Mode := Out{"_"}File;{"\n"}                        Name : in Wide{"_"}String := "";{"\n"}                        Form : in Wide{"_"}String := "");{"\n"}
<MarginText>85.4/5_A.10.1</MarginText>
      procedure Open   (File : in out File{"_"}Type;{"\n"}                        Mode : in File{"_"}Mode;{"\n"}                        Name : in Wide{"_"}String;{"\n"}                        Form : in Wide{"_"}String := "");{"\n"}
<MarginText>85.5/5_A.10.1</MarginText>
      function Name    (File : in File{"_"}Type) return Wide{"_"}String;{"\n"}
<MarginText>85.6/5_A.10.1</MarginText>
      function Form    (File : in File{"_"}Type) return Wide{"_"}String;{"\n"}
<MarginText>85.7/5_A.10.1</MarginText>
   end Wide{"_"}File{"_"}Names;{"\n"}
<MarginText>85.8/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
   package Wide{"_"}Wide{"_"}File{"_"}Names is{"\n"}
<MarginText>85.9/5_A.10.1</MarginText>
      -- File management{"\n"}
<MarginText>85.10/5_A.10.1</MarginText>
      procedure Create (File : in out File{"_"}Type;{"\n"}                        Mode : in File{"_"}Mode := Out{"_"}File;{"\n"}                        Name : in Wide{"_"}Wide{"_"}String := "";{"\n"}                        Form : in Wide{"_"}Wide{"_"}String := "");{"\n"}
<MarginText>85.11/5_A.10.1</MarginText>
      procedure Open   (File : in out File{"_"}Type;{"\n"}                        Mode : in File{"_"}Mode;{"\n"}                        Name : in Wide{"_"}Wide{"_"}String;{"\n"}                        Form : in Wide{"_"}Wide{"_"}String := "");{"\n"}
<MarginText>85.12/5_A.10.1</MarginText>
      function Name    (File : in File{"_"}Type) return Wide{"_"}Wide{"_"}String;{"\n"}
<MarginText>85.13/5_A.10.1</MarginText>
      function Form    (File : in File{"_"}Type) return Wide{"_"}Wide{"_"}String;{"\n"}
<MarginText>85.14/5_A.10.1</MarginText>
   end Wide{"_"}Wide{"_"}File{"_"}Names;{"\n"}
<MarginText>85.15/5_A.10.1</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Text{"_"}IO;{"\n"}

</CodeBlock>
<MarginText>86/2_A.10.1</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<p>The type File{"_"}Type needs finalization (see <a href="../AA-7/AA-7.6">7.6</a>).<br /></p>

<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>86.a_A.10.1</MarginText>
<Admonition type="aarm" aarm="note">
Append{"_"}File is a new element of enumeration type File{"_"}Mode. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>86.b_A.10.1</MarginText>
<Admonition type="aarm" aarm="note">
Get{"_"}Immediate, Look{"_"}Ahead, the subprograms for dealing with standard error, the type File{"_"}Access and its associated subprograms, and the generic packages Modular{"_"}IO and Decimal{"_"}IO are new in Ada 95. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>86.c/2_A.10.1</MarginText>
<MarginInfo items={["AI95-00360-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Text{"_"}IO.File{"_"}Type is defined to need finalization. If the restriction No{"_"}Nested{"_"}Finalization (see <a href="../AA-D/AA-D.7">D.7</a>) applies to the partition, and File{"_"}Type does not have a controlled part, it will not be allowed in local objects in Ada 2005 whereas it would be allowed in original Ada 95. Such code is not portable, as another Ada compiler may have a controlled part in File{"_"}Type, and thus would be illegal. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>86.d/2_A.10.1</MarginText>
<MarginInfo items={["AI95-00057-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0051</em>{"}"} <strong>Corrigendum:</strong> Corrected the parameter mode of Flush; otherwise it could not be used on Standard{"_"}Output.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>86.e/2_A.10.1</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<Admonition type="aarm" aarm="note">
The Text{"_"}IO.Get{"_"}Line functions are new; they are described in <a href="../AA-A/AA-A.10#Subclause_A.10.7">A.10.7</a>, &ldquo;<a href="../AA-A/AA-A.10#Subclause_A.10.7">Input-Output of Characters and Strings</a>&rdquo;. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>86.f/5_A.10.1</MarginText>
<MarginInfo items={["AI12-0021-1"]} />
<Admonition type="aarm" aarm="note">
The Wide{"_"}File{"_"}Names and Wide{"_"}Wide{"_"}File{"_"}Names nested packages are newly added to Ada.Text{"_"}IO. Therefore, a use clause conflict is possible; see the introduction of <a href="../AA-A/">Annex A</a> for more on this topic. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.2"></a>

## A.10.2  Text File Management


#### Static Semantics

<MarginText>1/5_A.10.2</MarginText>
<MarginInfo items={["AI12-0449-1"]} />
<p>The only allowed file modes for text files are the modes In{"_"}File, Out{"_"}File, and Append{"_"}File. The subprograms given in <a href="../AA-A/AA-A.8#Subclause_A.8.2">A.8.2</a> for the control of external files, and the function End{"_"}Of{"_"}File given in <a href="../AA-A/AA-A.8#Subclause_A.8.3">A.8.3</a> for sequential input-output, are also available for text files. There is also a version of End{"_"}Of{"_"}File that refers to the current default input file. For text files, the procedures have the following additional effects: <br /></p>

<MarginText>2_A.10.2</MarginText>
<ul>
<li>For the procedures Create and Open: After a file with mode Out{"_"}File or Append{"_"}File is opened, the page length and line length are unbounded (both have the conventional value zero). After a file (of any mode) is opened, the current column, current line, and current page numbers are set to one. If the mode is Append{"_"}File, it is implementation defined whether a page terminator will separate preexisting text in the file from the new text to be written. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>2.a_A.10.2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>For a file with mode Append{"_"}File, although it may seem more sensible for Open to set the current column, line, and page number based on the number of pages in the file, the number of lines on the last page, and the number of columns in the last line, we rejected this approach because of implementation costs; it would require the implementation to scan the file before doing the append, or to do processing that would be equivalent in effect.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b_A.10.2</MarginText>
<Admonition type="aarm" aarm="note">
For similar reasons, there is no requirement to erase the last page terminator of the file, nor to insert an explicit page terminator in the case when the final page terminator of a file is represented implicitly by the implementation. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>3_A.10.2</MarginText>
<ul>
<li>For the procedure Close: If the file has the current mode Out{"_"}File or Append{"_"}File, has the effect of calling New{"_"}Page, unless the current page is already terminated; then outputs a file terminator.<br /></li>
<MarginText>4_A.10.2</MarginText>
<li>For the procedure Reset: If the file has the current mode Out{"_"}File or Append{"_"}File, has the effect of calling New{"_"}Page, unless the current page is already terminated; then outputs a file terminator. The current column, line, and page numbers are set to one, and the line and page lengths to Unbounded. If the new mode is Append{"_"}File, it is implementation defined whether a page terminator will separate preexisting text in the file from the new text to be written. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>4.a_A.10.2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The behavior of Reset should be similar to closing a file and reopening it with the given mode<br />
</Admonition>
</AnnotatedOnly>

<MarginText>5_A.10.2</MarginText>
<p>The exception Mode{"_"}Error is propagated by the procedure Reset upon an attempt to change the mode of a file that is the current default input file, the current default output file, or the current default error file. <br /></p>

<AnnotatedOnly>
<MarginText>6_A.10.2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE   An implementation can define the Form parameter of Create and Open to control effects including the following: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7_A.10.2</MarginText>
<ul>
<li>the interpretation of line and column numbers for an interactive file, and<br /></li>
<MarginText>8_A.10.2</MarginText>
<li>the interpretation of text formats in a file created by a foreign program. <br /></li>
<a id="Subclause_A.10.3"></a>
</ul>
</AnnotatedOnly>

## A.10.3  Default Input, Output, and Error Files


#### Static Semantics

<MarginText>1_A.10.3</MarginText>
<p>The following subprograms provide for the control of the particular default files that are used when a file parameter is omitted from a Get, Put, or other operation of text input-output described below, or when application-dependent error-related text is to be output. <br /></p>

<MarginText>2_A.10.3</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Input(File : in File{"_"}Type);{"\n"}

</CodeBlock>
<MarginText>3_A.10.3</MarginText>
<p class="Indented4">Operates on a file of mode In{"_"}File. Sets the current default input file to File.<br /></p>

<MarginText>4_A.10.3</MarginText>
<p class="Indented4">The exception Status{"_"}Error is propagated if the given file is not open. The exception Mode{"_"}Error is propagated if the mode of the given file is not In{"_"}File.<br /></p>

<MarginText>5_A.10.3</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Output(File : in File{"_"}Type);{"\n"}procedure Set{"_"}Error (File : in File{"_"}Type);{"\n"}

</CodeBlock>
<MarginText>6_A.10.3</MarginText>
<p class="Indented4">Each operates on a file of mode Out{"_"}File or Append{"_"}File. Set{"_"}Output sets the current default output file to File. Set{"_"}Error sets the current default error file to File. The exception Status{"_"}Error is propagated if the given file is not open. The exception Mode{"_"}Error is propagated if the mode of the given file is not Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>7_A.10.3</MarginText>
<CodeBlock language="ada">
function Standard{"_"}Input return File{"_"}Type;{"\n"}function Standard{"_"}Input return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>8_A.10.3</MarginText>
<p class="Indented4">Returns the standard input file (see <a href="../AA-A/AA-A.10">A.10</a>), or an access value designating the standard input file, respectively.<br /></p>

<MarginText>9_A.10.3</MarginText>
<CodeBlock language="ada">
function Standard{"_"}Output return File{"_"}Type;{"\n"}function Standard{"_"}Output return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>10_A.10.3</MarginText>
<p class="Indented4">Returns the standard output file (see <a href="../AA-A/AA-A.10">A.10</a>) or an access value designating the standard output file, respectively.<br /></p>

<MarginText>11_A.10.3</MarginText>
<CodeBlock language="ada">
function Standard{"_"}Error return File{"_"}Type;{"\n"}function Standard{"_"}Error return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>12/1_A.10.3</MarginText>
<MarginInfo items={["AI95-00194-01"]} />
<p class="Indented4">{"{"}<em>8652/0052</em>{"}"} Returns the standard error file (see <a href="../AA-A/AA-A.10">A.10</a>), or an access value designating the standard error file, respectively.<br /></p>

<MarginText>13_A.10.3</MarginText>
<p>The Form strings implicitly associated with the opening of Standard{"_"}Input, Standard{"_"}Output, and Standard{"_"}Error at the start of program execution are implementation defined. <br /></p>

<MarginText>14_A.10.3</MarginText>
<CodeBlock language="ada">
function Current{"_"}Input return File{"_"}Type;{"\n"}function Current{"_"}Input return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>15_A.10.3</MarginText>
<p class="Indented4">Returns the current default input file, or an access value designating the current default input file, respectively.<br /></p>

<MarginText>16_A.10.3</MarginText>
<CodeBlock language="ada">
function Current{"_"}Output return File{"_"}Type;{"\n"}function Current{"_"}Output return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>17_A.10.3</MarginText>
<p class="Indented4">Returns the current default output file, or an access value designating the current default output file, respectively.<br /></p>

<MarginText>18_A.10.3</MarginText>
<CodeBlock language="ada">
function Current{"_"}Error return File{"_"}Type;{"\n"}function Current{"_"}Error return File{"_"}Access;{"\n"}

</CodeBlock>
<MarginText>19_A.10.3</MarginText>
<p class="Indented4">Returns the current default error file, or an access value designating the current default error file, respectively.<br /></p>

<MarginText>20/1_A.10.3</MarginText>
<MarginInfo items={["AI95-00057-01"]} />
<CodeBlock language="ada">
{"{"}8652/0051{"}"} procedure Flush (File : in File{"_"}Type);{"\n"}procedure Flush;{"\n"}

</CodeBlock>
<MarginText>21/4_A.10.3</MarginText>
<MarginInfo items={["AI12-0130-1"]} />
<p class="Indented4">[The effect of Flush is the same as the corresponding subprogram in Sequential{"_"}IO (see <a href="../AA-A/AA-A.8#Subclause_A.8.2">A.8.2</a>).] If File is not explicitly specified, Current{"_"}Output is used. <br /></p>

<AnnotatedOnly>
<MarginText>21.a/4_A.10.3</MarginText>
<MarginInfo items={["AI12-0052-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For the purpose of determining whether concurrent calls on text input-output subprograms are required to perform as specified, subprograms that implicitly operate on one of the default input-output files are considered to have a parameter of Current{"_"}Input or Current{"_"}Output (as appropriate). The result of Current{"_"}Output is considered to be overlapping with the file given to the latest call of Set{"_"}Output (or Standard{"_"}Output if Set{"_"}Output hasn't been called); a corresponding consideration applies to the result of Current{"_"}Input. See the introduction of <a href="../AA-A/">Annex A</a> for details. <br />
</Admonition>
</AnnotatedOnly>


#### Erroneous Execution

<MarginText>22/1_A.10.3</MarginText>
<MarginInfo items={["AI95-00063-01"]} />
<p>{"{"}<em>8652/0053</em>{"}"} The execution of a program is erroneous if it invokes an operation on a current default input, default output, or default error file, and if the corresponding file object is closed or no longer exists. <br /></p>

<AnnotatedOnly>
<MarginText>22.a.1/1_A.10.3</MarginText>
<MarginInfo items={["AI95-00063-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>{"{"}<em>8652/0053</em>{"}"} Closing a default file, then setting the default file to another open file before accessing it is not erroneous. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>23/1_A.10.3</MarginText>
<MarginInfo items={["AI95-00063-01"]} />
<p><em>This paragraph was deleted.</em>{"{"}<em>8652/0053</em>{"}"} <br /></p>

<AnnotatedOnly>
<MarginText>24_A.10.3</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   The standard input, standard output, and standard error files cannot be opened, closed, reset, or deleted, because the parameter File of the corresponding procedures has the mode <strong>in</strong> <strong>out</strong>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25_A.10.3</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   The standard input, standard output, and standard error files are different file objects, but not necessarily different external files. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>25.a/2_A.10.3</MarginText>
<MarginInfo items={["AI95-00057-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0051</em>{"}"} <strong>Corrigendum:</strong> Corrected the parameter mode of Flush; otherwise it could not be used on Standard{"_"}Output.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.b/2_A.10.3</MarginText>
<MarginInfo items={["AI95-00194-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0052</em>{"}"} <strong>Corrigendum:</strong> Corrected Standard{"_"}Error so it refers to the correct file.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.c/2_A.10.3</MarginText>
<MarginInfo items={["AI95-00063-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0053</em>{"}"} <strong>Corrigendum:</strong> Clarified that execution is erroneous only when a closed default file is accessed. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>25.d/4_A.10.3</MarginText>
<MarginInfo items={["AI12-0130-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> Moved the definition of Flush to <a href="../AA-A/AA-A.8#Subclause_A.8.2">A.8.2</a>, as all input-output packages now have it. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.4"></a>

## A.10.4  Specification of Line and Page Lengths


#### Static Semantics

<MarginText>1/5_A.10.4</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<p>The subprograms described in this subclause are concerned with the line and page structure of a file of mode Out{"_"}File or Append{"_"}File. They operate either on the file given as the first parameter, or, in the absence of such a file parameter, on the current default output file. They provide for output of text with a specified maximum line length or page length. In these cases, line and page terminators are output implicitly and automatically when necessary. When line and page lengths are unbounded (that is, when they have the conventional value zero), as in the case of a newly opened file, new lines and new pages are only started when explicitly called for.<br /></p>

<MarginText>2_A.10.4</MarginText>
<p>In all cases, the exception Status{"_"}Error is propagated if the file to be used is not open; the exception Mode{"_"}Error is propagated if the mode of the file is not Out{"_"}File or Append{"_"}File. <br /></p>

<MarginText>3_A.10.4</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Line{"_"}Length(File : in File{"_"}Type; To : in Count);{"\n"}procedure Set{"_"}Line{"_"}Length(To   : in Count);{"\n"}

</CodeBlock>
<MarginText>4_A.10.4</MarginText>
<p class="Indented4">Sets the maximum line length of the specified output or append file to the number of characters specified by To. The value zero for To specifies an unbounded line length. <br /></p>

<AnnotatedOnly>
<MarginText>4.a_A.10.4</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The setting does not affect the lengths of lines in the existing file, rather it only influences subsequent output operations.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>5_A.10.4</MarginText>
<p class="Indented4">The exception Use{"_"}Error is propagated if the specified line length is inappropriate for the associated external file.<br /></p>

<MarginText>6_A.10.4</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Page{"_"}Length(File : in File{"_"}Type; To : in Count);{"\n"}procedure Set{"_"}Page{"_"}Length(To   : in Count);{"\n"}

</CodeBlock>
<MarginText>7_A.10.4</MarginText>
<p class="Indented4">Sets the maximum page length of the specified output or append file to the number of lines specified by To. The value zero for To specifies an unbounded page length.<br /></p>

<MarginText>8_A.10.4</MarginText>
<p class="Indented4">The exception Use{"_"}Error is propagated if the specified page length is inappropriate for the associated external file.<br /></p>

<MarginText>9_A.10.4</MarginText>
<CodeBlock language="ada">
function Line{"_"}Length(File : in File{"_"}Type) return Count;{"\n"}function Line{"_"}Length return Count;{"\n"}

</CodeBlock>
<MarginText>10_A.10.4</MarginText>
<p class="Indented4">Returns the maximum line length currently set for the specified output or append file, or zero if the line length is unbounded.<br /></p>

<MarginText>11_A.10.4</MarginText>
<CodeBlock language="ada">
function Page{"_"}Length(File : in File{"_"}Type) return Count;{"\n"}function Page{"_"}Length return Count;{"\n"}

</CodeBlock>
<MarginText>12_A.10.4</MarginText>
<p class="Indented4">Returns the maximum page length currently set for the specified output or append file, or zero if the page length is unbounded. <br /></p>

<a id="Subclause_A.10.5"></a>

## A.10.5  Operations on Columns, Lines, and Pages


#### Static Semantics

<MarginText>1_A.10.5</MarginText>
<p>The subprograms described in this subclause provide for explicit control of line and page structure; they operate either on the file given as the first parameter, or, in the absence of such a file parameter, on the appropriate (input or output) current default file. The exception Status{"_"}Error is propagated by any of these subprograms if the file to be used is not open. <br /></p>

<MarginText>2_A.10.5</MarginText>
<CodeBlock language="ada">
procedure New{"_"}Line(File : in File{"_"}Type; Spacing : in Positive{"_"}Count := 1);{"\n"}procedure New{"_"}Line(Spacing : in Positive{"_"}Count := 1);{"\n"}

</CodeBlock>
<MarginText>3_A.10.5</MarginText>
<p class="Indented4">Operates on a file of mode Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>4_A.10.5</MarginText>
<p class="Indented4">For a Spacing of one: Outputs a line terminator and sets the current column number to one. Then increments the current line number by one, except in the case that the current line number is already greater than or equal to the maximum page length, for a bounded page length; in that case a page terminator is output, the current page number is incremented by one, and the current line number is set to one.<br /></p>

<MarginText>5_A.10.5</MarginText>
<p class="Indented4">For a Spacing greater than one, the above actions are performed Spacing times.<br /></p>

<MarginText>6_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>7_A.10.5</MarginText>
<CodeBlock language="ada">
procedure Skip{"_"}Line(File  : in File{"_"}Type; Spacing : in Positive{"_"}Count := 1);{"\n"}procedure Skip{"_"}Line(Spacing : in Positive{"_"}Count := 1);{"\n"}

</CodeBlock>
<MarginText>8_A.10.5</MarginText>
<p class="Indented4">Operates on a file of mode In{"_"}File.<br /></p>

<MarginText>9_A.10.5</MarginText>
<p class="Indented4">For a Spacing of one: Reads and discards all characters until a line terminator has been read, and then sets the current column number to one. If the line terminator is not immediately followed by a page terminator, the current line number is incremented by one. Otherwise, if the line terminator is immediately followed by a page terminator, then the page terminator is skipped, the current page number is incremented by one, and the current line number is set to one.<br /></p>

<MarginText>10_A.10.5</MarginText>
<p class="Indented4">For a Spacing greater than one, the above actions are performed Spacing times.<br /></p>

<MarginText>11_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not In{"_"}File. The exception End{"_"}Error is propagated if an attempt is made to read a file terminator.<br /></p>

<MarginText>12_A.10.5</MarginText>
<CodeBlock language="ada">
function End{"_"}Of{"_"}Line(File : in File{"_"}Type) return Boolean;{"\n"}function End{"_"}Of{"_"}Line return Boolean;{"\n"}

</CodeBlock>
<MarginText>13/3_A.10.5</MarginText>
<MarginInfo items={["AI05-0264-1"]} />
<p class="Indented4">Operates on a file of mode In{"_"}File. Returns True if a line terminator or a file terminator is next; otherwise, returns False.<br /></p>

<MarginText>14_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not In{"_"}File.<br /></p>

<MarginText>15_A.10.5</MarginText>
<CodeBlock language="ada">
procedure New{"_"}Page(File : in File{"_"}Type);{"\n"}procedure New{"_"}Page;{"\n"}

</CodeBlock>
<MarginText>16_A.10.5</MarginText>
<p class="Indented4">Operates on a file of mode Out{"_"}File or Append{"_"}File. Outputs a line terminator if the current line is not terminated, or if the current page is empty (that is, if the current column and line numbers are both equal to one). Then outputs a page terminator, which terminates the current page. Adds one to the current page number and sets the current column and line numbers to one.<br /></p>

<MarginText>17_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>18_A.10.5</MarginText>
<CodeBlock language="ada">
procedure Skip{"_"}Page(File : in File{"_"}Type);{"\n"}procedure Skip{"_"}Page;{"\n"}

</CodeBlock>
<MarginText>19_A.10.5</MarginText>
<p class="Indented4">Operates on a file of mode In{"_"}File. Reads and discards all characters and line terminators until a page terminator has been read. Then adds one to the current page number, and sets the current column and line numbers to one.<br /></p>

<MarginText>20_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not In{"_"}File. The exception End{"_"}Error is propagated if an attempt is made to read a file terminator.<br /></p>

<MarginText>21_A.10.5</MarginText>
<CodeBlock language="ada">
function End{"_"}Of{"_"}Page(File : in File{"_"}Type) return Boolean;{"\n"}function End{"_"}Of{"_"}Page return Boolean;{"\n"}

</CodeBlock>
<MarginText>22/3_A.10.5</MarginText>
<MarginInfo items={["AI05-0264-1"]} />
<p class="Indented4">Operates on a file of mode In{"_"}File. Returns True if the combination of a line terminator and a page terminator is next, or if a file terminator is next; otherwise, returns False.<br /></p>

<MarginText>23_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not In{"_"}File.<br /></p>

<MarginText>24_A.10.5</MarginText>
<CodeBlock language="ada">
function End{"_"}Of{"_"}File(File : in File{"_"}Type) return Boolean;{"\n"}function End{"_"}Of{"_"}File return Boolean;{"\n"}

</CodeBlock>
<MarginText>25/3_A.10.5</MarginText>
<MarginInfo items={["AI05-0264-1"]} />
<p class="Indented4">Operates on a file of mode In{"_"}File. Returns True if a file terminator is next, or if the combination of a line, a page, and a file terminator is next; otherwise, returns False.<br /></p>

<MarginText>26_A.10.5</MarginText>
<p class="Indented4">The exception Mode{"_"}Error is propagated if the mode is not In{"_"}File.<br /></p>

<MarginText>27_A.10.5</MarginText>
<p>The following subprograms provide for the control of the current position of reading or writing in a file. In all cases, the default file is the current output file. <br /></p>

<MarginText>28_A.10.5</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Col(File : in File{"_"}Type; To : in Positive{"_"}Count);{"\n"}procedure Set{"_"}Col(To   : in Positive{"_"}Count);{"\n"}

</CodeBlock>
<MarginText>29_A.10.5</MarginText>
<p class="Indented4">If the file mode is Out{"_"}File or Append{"_"}File: <br /></p>

<MarginText>30_A.10.5</MarginText>
<ul>
<li>If the value specified by To is greater than the current column number, outputs spaces, adding one to the current column number after each space, until the current column number equals the specified value. If the value specified by To is equal to the current column number, there is no effect. If the value specified by To is less than the current column number, has the effect of calling New{"_"}Line (with a spacing of one), then outputs (To &ndash; 1) spaces, and sets the current column number to the specified value.<br /></li>
<MarginText>31_A.10.5</MarginText>
<li>The exception Layout{"_"}Error is propagated if the value specified by To exceeds Line{"_"}Length when the line length is bounded (that is, when it does not have the conventional value zero). <br /></li>
</ul>
<MarginText>32_A.10.5</MarginText>
<p class="Indented4">If the file mode is In{"_"}File: <br /></p>

<MarginText>33_A.10.5</MarginText>
<ul>
<li>Reads (and discards) individual characters, line terminators, and page terminators, until the next character to be read has a column number that equals the value specified by To; there is no effect if the current column number already equals this value. Each transfer of a character or terminator maintains the current column, line, and page numbers in the same way as a Get procedure (see <a href="../AA-A/AA-A.10#Subclause_A.10.6">A.10.6</a>). (Short lines will be skipped until a line is reached that has a character at the specified column position.)<br /></li>
<MarginText>34_A.10.5</MarginText>
<li>The exception End{"_"}Error is propagated if an attempt is made to read a file terminator. <br /></li>
</ul>
<MarginText>35_A.10.5</MarginText>
<CodeBlock language="ada">
procedure Set{"_"}Line(File : in File{"_"}Type; To : in Positive{"_"}Count);{"\n"}procedure Set{"_"}Line(To   : in Positive{"_"}Count);{"\n"}

</CodeBlock>
<MarginText>36_A.10.5</MarginText>
<p class="Indented4">If the file mode is Out{"_"}File or Append{"_"}File: <br /></p>

<MarginText>37/3_A.10.5</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<ul>
<li>If the value specified by To is greater than the current line number, has the effect of repeatedly calling New{"_"}Line (with a spacing of one), until the current line number equals the specified value. If the value specified by To is equal to the current line number, there is no effect. If the value specified by To is less than the current line number, has the effect of calling New{"_"}Page followed, if To is greater than 1, by a call of New{"_"}Line with a spacing equal to (To &ndash; 1).<br /></li>
<MarginText>38_A.10.5</MarginText>
<li>The exception Layout{"_"}Error is propagated if the value specified by To exceeds Page{"_"}Length when the page length is bounded (that is, when it does not have the conventional value zero). <br /></li>
</ul>
<MarginText>39_A.10.5</MarginText>
<p class="Indented4">If the mode is In{"_"}File: <br /></p>

<MarginText>40_A.10.5</MarginText>
<ul>
<li>Has the effect of repeatedly calling Skip{"_"}Line (with a spacing of one), until the current line number equals the value specified by To; there is no effect if the current line number already equals this value. (Short pages will be skipped until a page is reached that has a line at the specified line position.)<br /></li>
<MarginText>41_A.10.5</MarginText>
<li>The exception End{"_"}Error is propagated if an attempt is made to read a file terminator. <br /></li>
</ul>
<MarginText>42_A.10.5</MarginText>
<CodeBlock language="ada">
function Col(File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}function Col return Positive{"_"}Count;{"\n"}

</CodeBlock>
<MarginText>43_A.10.5</MarginText>
<p class="Indented4">Returns the current column number.<br /></p>

<MarginText>44_A.10.5</MarginText>
<p class="Indented4">The exception Layout{"_"}Error is propagated if this number exceeds Count'Last.<br /></p>

<MarginText>45_A.10.5</MarginText>
<CodeBlock language="ada">
function Line(File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}function Line return Positive{"_"}Count;{"\n"}

</CodeBlock>
<MarginText>46_A.10.5</MarginText>
<p class="Indented4">Returns the current line number.<br /></p>

<MarginText>47_A.10.5</MarginText>
<p class="Indented4">The exception Layout{"_"}Error is propagated if this number exceeds Count'Last.<br /></p>

<MarginText>48_A.10.5</MarginText>
<CodeBlock language="ada">
function Page(File : in File{"_"}Type) return Positive{"_"}Count;{"\n"}function Page return Positive{"_"}Count;{"\n"}

</CodeBlock>
<MarginText>49_A.10.5</MarginText>
<p class="Indented4">Returns the current page number.<br /></p>

<MarginText>50_A.10.5</MarginText>
<p class="Indented4">The exception Layout{"_"}Error is propagated if this number exceeds Count'Last.<br /></p>

<MarginText>51_A.10.5</MarginText>
<p>The column number, line number, or page number are allowed to exceed Count'Last (as a consequence of the input or output of sufficiently many characters, lines, or pages). These events do not cause any exception to be propagated. However, a call of Col, Line, or Page propagates the exception Layout{"_"}Error if the corresponding number exceeds Count'Last. <br /></p>

<AnnotatedOnly>
<MarginText>52/5_A.10.5</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   A page terminator is always skipped whenever the preceding line terminator is skipped. An implementation can represent the combination of these terminators by a single character, provided that it is properly recognized on input. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>52.a/3_A.10.5</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Fixed a glitch in Set{"_"}Line such that we could have called New{"_"}Line(0), which would have to raise Constraint{"_"}Error. It's now defined to work. The bug occurred in Ada 95 and Ada 2005. It's very unlikely that any real programs depend on this exception being raised. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.6"></a>

## A.10.6  Get and Put Procedures


#### Static Semantics

<MarginText>1_A.10.6</MarginText>
<p>The procedures Get and Put for items of the type Character, String, numeric types, and enumeration types are described in subsequent subclauses. Features of these procedures that are common to most of these types are described in this subclause. The Get and Put procedures for items of type Character and String deal with individual character values; the Get and Put procedures for numeric and enumeration types treat the items as lexical elements.<br /></p>

<MarginText>2_A.10.6</MarginText>
<p>All procedures Get and Put have forms with a file parameter, written first. Where this parameter is omitted, the appropriate (input or output) current default file is understood to be specified. Each procedure Get operates on a file of mode In{"_"}File. Each procedure Put operates on a file of mode Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>3_A.10.6</MarginText>
<p>All procedures Get and Put maintain the current column, line, and page numbers of the specified file: the effect of each of these procedures upon these numbers is the result of the effects of individual transfers of characters and of individual output or skipping of terminators. Each transfer of a character adds one to the current column number. Each output of a line terminator sets the current column number to one and adds one to the current line number. Each output of a page terminator sets the current column and line numbers to one and adds one to the current page number. For input, each skipping of a line terminator sets the current column number to one and adds one to the current line number; each skipping of a page terminator sets the current column and line numbers to one and adds one to the current page number. Similar considerations apply to the procedures Get{"_"}Line, Put{"_"}Line, and Set{"_"}Col.<br /></p>

<MarginText>4_A.10.6</MarginText>
<p>Several Get and Put procedures, for numeric and enumeration types, have <em>format</em> parameters which specify field lengths; these parameters are of the nonnegative subtype Field of the type Integer.<br /></p>

<MarginText>5/2_A.10.6</MarginText>
<MarginInfo items={["AI95-00223-01"]} />
<p>Input-output of enumeration values uses the syntax of the corresponding lexical elements. Any Get procedure for an enumeration type begins by skipping any leading blanks, or line or page terminators. A <em>blank</em> is defined as a space or a horizontal tabulation character. Next, characters are input only so long as the sequence input is an initial sequence of an identifier or of a character literal (in particular, input ceases when a line terminator is encountered). The character or line terminator that causes input to cease remains available for subsequent input.<br /></p>

<MarginText>6_A.10.6</MarginText>
<p>For a numeric type, the Get procedures have a format parameter called Width. If the value given for this parameter is zero, the Get procedure proceeds in the same manner as for enumeration types, but using the syntax of numeric literals instead of that of enumeration literals. If a nonzero value is given, then exactly Width characters are input, or the characters up to a line terminator, whichever comes first; any skipped leading blanks are included in the count. The syntax used for numeric literals is an extended syntax that allows a leading sign (but no intervening blanks, or line or page terminators) and that also allows (for real types) an integer literal as well as forms that have digits only before the point or only after the point.<br /></p>

<MarginText>7/5_A.10.6</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<p>Any Put procedure, for an item of a numeric or an enumeration type, outputs the value of the item as a numeric literal, identifier, or character literal, as appropriate. This is preceded by leading spaces if required by the format parameters Width or Fore (as described in later subclauses), and then a minus sign for a negative value; for an enumeration type, the spaces follow instead of leading. The format given for a Put procedure is overridden if it is insufficiently wide, by using the minimum necessary width.<br /></p>

<MarginText>8_A.10.6</MarginText>
<p>Two further cases arise for Put procedures for numeric and enumeration types, if the line length of the specified output file is bounded (that is, if it does not have the conventional value zero). If the number of characters to be output does not exceed the maximum line length, but is such that they cannot fit on the current line, starting from the current column, then (in effect) New{"_"}Line is called (with a spacing of one) before output of the item. Otherwise, if the number of characters exceeds the maximum line length, then the exception Layout{"_"}Error is propagated and nothing is output.<br /></p>

<MarginText>9_A.10.6</MarginText>
<p>The exception Status{"_"}Error is propagated by any of the procedures Get, Get{"_"}Line, Put, and Put{"_"}Line if the file to be used is not open. The exception Mode{"_"}Error is propagated by the procedures Get and Get{"_"}Line if the mode of the file to be used is not In{"_"}File; and by the procedures Put and Put{"_"}Line, if the mode is not Out{"_"}File or Append{"_"}File.<br /></p>

<MarginText>10_A.10.6</MarginText>
<p>The exception End{"_"}Error is propagated by a Get procedure if an attempt is made to skip a file terminator. The exception Data{"_"}Error is propagated by a Get procedure if the sequence finally input is not a lexical element corresponding to the type, in particular if no characters were input; for this test, leading blanks are ignored; for an item of a numeric type, when a sign is input, this rule applies to the succeeding numeric literal. The exception Layout{"_"}Error is propagated by a Put procedure that outputs to a parameter of type String, if the length of the actual string is insufficient for the output of the item. <br /></p>


#### Examples

<MarginText>11/5_A.10.6</MarginText>
<MarginInfo items={["AI12-0449-1"]} />
<p>In the examples, here and in <a href="../AA-A/AA-A.10#Subclause_A.10.8">A.10.8</a> and <a href="../AA-A/AA-A.10#Subclause_A.10.9">A.10.9</a>, the string quotes and the lower case letter b are not transferred: they are shown only to reveal the layout and spaces.<br /></p>

<MarginText>12_A.10.6</MarginText>
<CodeBlock language="ada">
N : Integer;{"\n"}   ...{"\n"}Get(N);{"\n"}
<MarginText>13_A.10.6</MarginText>
--  	Characters at input 	Sequence input 	Value of N{"\n"}{"\n"}--  	bb&ndash;12535b 	&ndash;12535 	&ndash;12535{"\n"}--  	bb12{"_"}535e1b 	12{"_"}535e1 	125350{"\n"}--  	bb12{"_"}535e; 	12{"_"}535e 	(none) Data{"_"}Error raised{"\n"}

</CodeBlock>
<MarginText>14_A.10.6</MarginText>
<p>Example of overridden width parameter:<br /></p>

<MarginText>15_A.10.6</MarginText>
<CodeBlock language="ada">
Put(Item ={">"} -23, Width ={">"} 2);  --  "&ndash;23"{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>15.a/2_A.10.6</MarginText>
<MarginInfo items={["AI95-00223-01"]} />
<Admonition type="aarm" aarm="note">
Removed conflicting text describing the skipping of blanks for a Get procedure. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.7"></a>

## A.10.7  Input-Output of Characters and Strings


#### Static Semantics

<MarginText>1_A.10.7</MarginText>
<p>For an item of type Character the following procedures are provided: <br /></p>

<MarginText>2_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Get(File : in File{"_"}Type; Item : out Character);{"\n"}procedure Get(Item : out Character);{"\n"}

</CodeBlock>
<MarginText>3_A.10.7</MarginText>
<p class="Indented4">After skipping any line terminators and any page terminators, reads the next character from the specified input file and returns the value of this character in the out parameter Item.<br /></p>

<MarginText>4_A.10.7</MarginText>
<p class="Indented4">The exception End{"_"}Error is propagated if an attempt is made to skip a file terminator.<br /></p>

<MarginText>5_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Put(File : in File{"_"}Type; Item : in Character);{"\n"}procedure Put(Item : in Character);{"\n"}

</CodeBlock>
<MarginText>6_A.10.7</MarginText>
<p class="Indented4">If the line length of the specified output file is bounded (that is, does not have the conventional value zero), and the current column number exceeds it, has the effect of calling New{"_"}Line with a spacing of one. Then, or otherwise, outputs the given character to the file.<br /></p>

<MarginText>7_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Look{"_"}Ahead (File        : in  File{"_"}Type;{"\n"}                      Item        : out Character;{"\n"}                      End{"_"}Of{"_"}Line : out Boolean);{"\n"}procedure Look{"_"}Ahead (Item        : out Character;{"\n"}                      End{"_"}Of{"_"}Line : out Boolean);{"\n"}

</CodeBlock>
<MarginText>8/3_A.10.7</MarginText>
<MarginInfo items={["AI05-0038-1", "AI05-0264-1"]} />
<p class="Indented4">Status{"_"}Error is propagated if the file is not open. Mode{"_"}Error is propagated if the mode of the file is not In{"_"}File. Sets End{"_"}Of{"_"}Line to True if at end of line, including if at end of page or at end of file; in each of these cases the value of Item is not specified. Otherwise, End{"_"}Of{"_"}Line is set to False and Item is set to the next character (without consuming it) from the file.<br /></p>

<MarginText>9_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Immediate(File : in  File{"_"}Type;{"\n"}                        Item : out Character);{"\n"}procedure Get{"_"}Immediate(Item : out Character);{"\n"}

</CodeBlock>
<MarginText>10/3_A.10.7</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<p class="Indented4">Reads the next character, either control or graphic, from the specified File or the default input file. Status{"_"}Error is propagated if the file is not open. Mode{"_"}Error is propagated if the mode of the file is not In{"_"}File. End{"_"}Error is propagated if at the end of the file. The current column, line and page numbers for the file are not affected.<br /></p>

<MarginText>11_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Immediate(File      : in  File{"_"}Type;{"\n"}                        Item      : out Character;{"\n"}                        Available : out Boolean);{"\n"}procedure Get{"_"}Immediate(Item      : out Character;{"\n"}                        Available : out Boolean);{"\n"}

</CodeBlock>
<MarginText>12/3_A.10.7</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<p class="Indented4">If a character, either control or graphic, is available from the specified File or the default input file, then the character is read; Available is True and Item contains the value of this character. If a character is not available, then Available is False and the value of Item is not specified. Status{"_"}Error is propagated if the file is not open. Mode{"_"}Error is propagated if the mode of the file is not In{"_"}File. End{"_"}Error is propagated if at the end of the file. The current column, line and page numbers for the file are not affected.<br /></p>

<MarginText>13/2_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p>For an item of type String the following subprograms are provided: <br /></p>

<MarginText>14_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Get(File : in File{"_"}Type; Item : out String);{"\n"}procedure Get(Item : out String);{"\n"}

</CodeBlock>
<MarginText>15_A.10.7</MarginText>
<p class="Indented4">Determines the length of the given string and attempts that number of Get operations for successive characters of the string (in particular, no operation is performed if the string is null).<br /></p>

<MarginText>16_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Put(File : in File{"_"}Type; Item : in String);{"\n"}procedure Put(Item : in String);{"\n"}

</CodeBlock>
<MarginText>17_A.10.7</MarginText>
<p class="Indented4">Determines the length of the given string and attempts that number of Put operations for successive characters of the string (in particular, no operation is performed if the string is null).<br /></p>

<MarginText>17.1/2_A.10.7</MarginText>
<CodeBlock language="ada">
function Get{"_"}Line(File : in File{"_"}Type) return String;{"\n"}function Get{"_"}Line return String;{"\n"}

</CodeBlock>
<MarginText>17.2/2_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Returns a result string constructed by reading successive characters from the specified input file, and assigning them to successive characters of the result string. The result string has a lower bound of 1 and an upper bound of the number of characters read. Reading stops when the end of the line is met; Skip{"_"}Line is then (in effect) called with a spacing of 1.<br /></p>

<MarginText>17.3/2_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Constraint{"_"}Error is raised if the length of the line exceeds Positive'Last; in this case, the line number and page number are unchanged, and the column number is unspecified but no less than it was before the call. The exception End{"_"}Error is propagated if an attempt is made to skip a file terminator.<br /></p>

<AnnotatedOnly>
<MarginText>17.a/2_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Precisely what is left in the file is unspecified if Constraint{"_"}Error is raised because the line doesn't fit in a String; it should be consistent with column number. This allows implementers to use whatever buffering scheme makes sense. But the line terminator is not skipped in this case. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>18_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Line(File : in File{"_"}Type;{"\n"}                   Item : out String;{"\n"}                   Last : out Natural);{"\n"}procedure Get{"_"}Line(Item : out String;{"\n"}                   Last : out Natural);{"\n"}

</CodeBlock>
<MarginText>19_A.10.7</MarginText>
<p class="Indented4">Reads successive characters from the specified input file and assigns them to successive characters of the specified string. Reading stops if the end of the string is met. Reading also stops if the end of the line is met before meeting the end of the string; in this case Skip{"_"}Line is (in effect) called with a spacing of 1. The values of characters not assigned are not specified.<br /></p>

<MarginText>20_A.10.7</MarginText>
<p class="Indented4">If characters are read, returns in Last the index value such that Item(Last) is the last character assigned (the index of the first character assigned is Item'First). If no characters are read, returns in Last an index value that is one less than Item'First. The exception End{"_"}Error is propagated if an attempt is made to skip a file terminator.<br /></p>

<MarginText>21_A.10.7</MarginText>
<CodeBlock language="ada">
procedure Put{"_"}Line(File : in File{"_"}Type; Item : in String);{"\n"}procedure Put{"_"}Line(Item : in String);{"\n"}

</CodeBlock>
<MarginText>22_A.10.7</MarginText>
<p class="Indented4">Calls the procedure Put for the given string, and then the procedure New{"_"}Line with a spacing of one. <br /></p>


#### Implementation Advice

<MarginText>23_A.10.7</MarginText>
<p>The Get{"_"}Immediate procedures should be implemented with unbuffered input. For a device such as a keyboard, input should be &ldquo;available&rdquo; if a key has already been typed, whereas for a disk file, input should always be available except at end of file. For a file associated with a keyboard-like device, any line-editing features of the underlying operating system should be disabled during the execution of Get{"_"}Immediate. <br /></p>

<AnnotatedOnly>
<MarginText>23.a/2_A.10.7</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Get{"_"}Immediate should be implemented with unbuffered input; input should be available immediately; line-editing should be disabled.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24_A.10.7</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   Get{"_"}Immediate can be used to read a single key from the keyboard &ldquo;immediately&rdquo;; that is, without waiting for an end of line. In a call of Get{"_"}Immediate without the parameter Available, the caller will wait until a character is available.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25_A.10.7</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   In a literal string parameter of Put, the enclosing string bracket characters are not output. Each doubled string bracket character in the enclosed string is output as a single string bracket character, as a consequence of the rule for string literals (see <a href="../AA-2/AA-2.6">2.6</a>).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26_A.10.7</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   A string read by Get or written by Put can extend over several lines. An implementation is allowed to assume that certain external files do not contain page terminators, in which case Get{"_"}Line and Skip{"_"}Line can return as soon as a line terminator is read. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.a/3_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
The Get{"_"}Line functions are added to Ada.Text{"_"}IO. If Ada.Text{"_"}IO is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and a function Get{"_"}Line is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the user-defined Get{"_"}Line may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.b/2_A.10.7</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<Admonition type="aarm" aarm="note">
The Text{"_"}IO.Get{"_"}Line functions are new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.c/3_A.10.7</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added missing wording about raising Status{"_"}Error to Look{"_"}Ahead and Get{"_"}Immediate. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.8"></a>

## A.10.8  Input-Output for Integer Types


#### Static Semantics

<MarginText>1_A.10.8</MarginText>
<p>The following procedures are defined in the generic packages Integer{"_"}IO and Modular{"_"}IO, which have to be instantiated for the appropriate signed integer or modular type respectively (indicated by Num in the specifications).<br /></p>

<MarginText>2_A.10.8</MarginText>
<p>Values are output as decimal or based literals, without low line characters or exponent, and, for Integer{"_"}IO, preceded by a minus sign if negative. The format (which includes any leading spaces and minus sign) can be specified by an optional field width parameter. Values of widths of fields in output formats are of the nonnegative integer subtype Field. Values of bases are of the integer subtype Number{"_"}Base. <br /></p>

<MarginText>3_A.10.8</MarginText>
<CodeBlock language="ada">
subtype Number{"_"}Base is Integer range 2 .. 16;{"\n"}

</CodeBlock>
<MarginText>4_A.10.8</MarginText>
<p>The default field width and base to be used by output procedures are defined by the following variables that are declared in the generic packages Integer{"_"}IO and Modular{"_"}IO:<br /></p>

<MarginText>5_A.10.8</MarginText>
<CodeBlock language="ada">
Default{"_"}Width : Field := Num'Width;{"\n"}Default{"_"}Base  : Number{"_"}Base := 10;{"\n"}

</CodeBlock>
<MarginText>6_A.10.8</MarginText>
<p>The following procedures are provided: <br /></p>

<MarginText>7_A.10.8</MarginText>
<CodeBlock language="ada">
procedure Get(File : in File{"_"}Type; Item : out Num; Width : in Field := 0);{"\n"}procedure Get(Item : out Num; Width : in Field := 0);{"\n"}

</CodeBlock>
<MarginText>8_A.10.8</MarginText>
<p class="Indented4">If the value of the parameter Width is zero, skips any leading blanks, line terminators, or page terminators, then reads a plus sign if present or (for a signed type only) a minus sign if present, then reads the longest possible sequence of characters matching the syntax of a numeric literal without a point. If a nonzero value of Width is supplied, then exactly Width characters are input, or the characters (possibly none) up to a line terminator, whichever comes first; any skipped leading blanks are included in the count.<br /></p>

<MarginText>9_A.10.8</MarginText>
<p class="Indented4">Returns, in the parameter Item, the value of type Num that corresponds to the sequence input.<br /></p>

<MarginText>10/3_A.10.8</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence of characters read does not form a legal integer literal or if the value obtained is not of the subtype Num.<br /></p>

<MarginText>11_A.10.8</MarginText>
<CodeBlock language="ada">
procedure Put(File  : in File{"_"}Type;{"\n"}              Item  : in Num;{"\n"}              Width : in Field := Default{"_"}Width;{"\n"}              Base  : in Number{"_"}Base := Default{"_"}Base);{"\n"}{"\n"}procedure Put(Item  : in Num;{"\n"}              Width : in Field := Default{"_"}Width;{"\n"}              Base  : in Number{"_"}Base := Default{"_"}Base);{"\n"}

</CodeBlock>
<MarginText>12_A.10.8</MarginText>
<p class="Indented4">Outputs the value of the parameter Item as an integer literal, with no low lines, no exponent, and no leading zeros (but a single zero for the value zero), and a preceding minus sign for a negative value.<br /></p>

<MarginText>13_A.10.8</MarginText>
<p class="Indented4">If the resulting sequence of characters to be output has fewer than Width characters, then leading spaces are first output to make up the difference.<br /></p>

<MarginText>14_A.10.8</MarginText>
<p class="Indented4">Uses the syntax for decimal literal if the parameter Base has the value ten (either explicitly or through Default{"_"}Base); otherwise, uses the syntax for based literal, with any letters in upper case.<br /></p>

<MarginText>15_A.10.8</MarginText>
<CodeBlock language="ada">
procedure Get(From : in String; Item : out Num; Last : out Positive);{"\n"}

</CodeBlock>
<MarginText>16_A.10.8</MarginText>
<p class="Indented4">Reads an integer value from the beginning of the given string, following the same rules as the Get procedure that reads an integer value from a file, but treating the end of the string as a file terminator. Returns, in the parameter Item, the value of type Num that corresponds to the sequence input. Returns in Last the index value such that From(Last) is the last character read.<br /></p>

<MarginText>17_A.10.8</MarginText>
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence input does not have the required syntax or if the value obtained is not of the subtype Num.<br /></p>

<MarginText>18_A.10.8</MarginText>
<CodeBlock language="ada">
procedure Put(To   : out String;{"\n"}              Item : in Num;{"\n"}              Base : in Number{"_"}Base := Default{"_"}Base);{"\n"}

</CodeBlock>
<MarginText>19_A.10.8</MarginText>
<p class="Indented4">Outputs the value of the parameter Item to the given string, following the same rule as for output to a file, using the length of the given string as the value for Width. <br /></p>

<MarginText>20_A.10.8</MarginText>
<p>Integer{"_"}Text{"_"}IO is a library package that is a nongeneric equivalent to Text{"_"}IO.Integer{"_"}IO for the predefined type Integer: <br /></p>

<MarginText>21_A.10.8</MarginText>
<CodeBlock language="ada">
with Ada.Text{"_"}IO;{"\n"}package Ada.Integer{"_"}Text{"_"}IO is new Ada.Text{"_"}IO.Integer{"_"}IO(Integer);{"\n"}

</CodeBlock>
<MarginText>22_A.10.8</MarginText>
<p>For each predefined signed integer type, a nongeneric equivalent to Text{"_"}IO.Integer{"_"}IO is provided, with names such as Ada.Long{"_"}Integer{"_"}Text{"_"}IO.<br /></p>


#### Implementation Permissions

<MarginText>23/5_A.10.8</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>The nongeneric equivalent packages can be actual instantiations of the generic package for the appropriate predefined type, though that is not required.<br /></p>

<AnnotatedOnly>
<MarginText>24/3_A.10.8</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginInfo items={["AI12-0429-1"]} />
<p><em>Examples of use of an instantiation of Text{"_"}IO.Integer{"_"}IO:</em><br /></p>

<MarginText>25/3_A.10.8</MarginText>
<MarginInfo items={["AI05-0298-1"]} />
<CodeBlock language="ada">
subtype Byte{"_"}Int is Integer range -127 .. 127;{"\n"}package Int{"_"}IO is new Integer{"_"}IO(Byte{"_"}Int); use Int{"_"}IO;{"\n"}-- default format used at instantiation,{"\n"}-- Default{"_"}Width = 4, Default{"_"}Base = 10{"\n"}
<MarginText>26_A.10.8</MarginText>
Put(126);                            -- "b126"{"\n"}Put(-126, 7);                        -- "bbb&ndash;126"{"\n"}Put(126, Width ={">"} 13, Base ={">"} 2);    -- "bbb2{"#"}1111110{"#"}"{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Inconsistencies With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.a/3_A.10.8</MarginText>
<MarginInfo items={["AI05-0038-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Changed wording to make Integer{"_"}IO and Modular{"_"}IO raise Data{"_"}Error in the same way when the bounds of the subtype are exceeded. There is no value to different behavior, and all surveyed compilers already treat integer and modular values the same way. This could only cause a problem if a program was compiled with some unsurveyed compiler, and the Ada 95-defined behavior is expected for Modular{"_"}IO. But note that such code is not portable anyway, as most widely used compilers behave consistently with the new wording, so it is unlikely that such code exists. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.9"></a>

## A.10.9  Input-Output for Real Types


#### Static Semantics

<MarginText>1_A.10.9</MarginText>
<p>The following procedures are defined in the generic packages Float{"_"}IO, Fixed{"_"}IO, and Decimal{"_"}IO, which have to be instantiated for the appropriate floating point, ordinary fixed point, or decimal fixed point type respectively (indicated by Num in the specifications).<br /></p>

<MarginText>2_A.10.9</MarginText>
<p>Values are output as decimal literals without low line characters. The format of each value output consists of a Fore field, a decimal point, an Aft field, and (if a nonzero Exp parameter is supplied) the letter E and an Exp field. The two possible formats thus correspond to:<br /></p>

<MarginText>3_A.10.9</MarginText>
<CodeBlock language="ada">
Fore  .  Aft{"\n"}

</CodeBlock>
<MarginText>4_A.10.9</MarginText>
<p>and to:<br /></p>

<MarginText>5_A.10.9</MarginText>
<CodeBlock language="ada">
Fore  .  Aft  E  Exp{"\n"}

</CodeBlock>
<MarginText>6_A.10.9</MarginText>
<p>without any spaces between these fields. The Fore field may include leading spaces, and a minus sign for negative values. The Aft field includes only decimal digits (possibly with trailing zeros). The Exp field includes the sign (plus or minus) and the exponent (possibly with leading zeros).<br /></p>

<MarginText>7_A.10.9</MarginText>
<p>For floating point types, the default lengths of these fields are defined by the following variables that are declared in the generic package Float{"_"}IO:<br /></p>

<MarginText>8_A.10.9</MarginText>
<CodeBlock language="ada">
Default{"_"}Fore : Field := 2;{"\n"}Default{"_"}Aft  : Field := Num'Digits-1;{"\n"}Default{"_"}Exp  : Field := 3;{"\n"}

</CodeBlock>
<MarginText>9_A.10.9</MarginText>
<p>For ordinary or decimal fixed point types, the default lengths of these fields are defined by the following variables that are declared in the generic packages Fixed{"_"}IO and Decimal{"_"}IO, respectively:<br /></p>

<MarginText>10_A.10.9</MarginText>
<CodeBlock language="ada">
Default{"_"}Fore : Field := Num'Fore;{"\n"}Default{"_"}Aft  : Field := Num'Aft;{"\n"}Default{"_"}Exp  : Field := 0;{"\n"}

</CodeBlock>
<MarginText>11_A.10.9</MarginText>
<p>The following procedures are provided: <br /></p>

<MarginText>12_A.10.9</MarginText>
<CodeBlock language="ada">
procedure Get(File : in File{"_"}Type; Item : out Num; Width : in Field := 0);{"\n"}procedure Get(Item : out Num; Width : in Field := 0);{"\n"}

</CodeBlock>
<MarginText>13_A.10.9</MarginText>
<p class="Indented4">If the value of the parameter Width is zero, skips any leading blanks, line terminators, or page terminators, then reads the longest possible sequence of characters matching the syntax of any of the following (see <a href="../AA-2/AA-2.4">2.4</a>): <br /></p>

<MarginText>14_A.10.9</MarginText>
<ul>
<li>[+|&ndash;]<code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code><br /></li>
<MarginText>15_A.10.9</MarginText>
<li>[+|&ndash;]<code><a href="../AA-2/AA-2.4#S0008">numeral</a></code>.[<code><a href="../AA-2/AA-2.4#S0009">exponent</a></code>]<br /></li>
<MarginText>16_A.10.9</MarginText>
<li>[+|&ndash;].<code><a href="../AA-2/AA-2.4#S0008">numeral</a></code>[<code><a href="../AA-2/AA-2.4#S0009">exponent</a></code>]<br /></li>
<MarginText>17_A.10.9</MarginText>
<li>[+|&ndash;]<code><a href="../AA-2/AA-2.4#S0012">base</a></code>{"#"}<code><a href="../AA-2/AA-2.4#S0013">based_numeral</a></code>.{"#"}[<code><a href="../AA-2/AA-2.4#S0009">exponent</a></code>]<br /></li>
<MarginText>18_A.10.9</MarginText>
<li>[+|&ndash;]<code><a href="../AA-2/AA-2.4#S0012">base</a></code>{"#"}.<code><a href="../AA-2/AA-2.4#S0013">based_numeral</a></code>{"#"}[<code><a href="../AA-2/AA-2.4#S0009">exponent</a></code>] <br /></li>
</ul>
<MarginText>19_A.10.9</MarginText>
<p class="Indented4">If a nonzero value of Width is supplied, then exactly Width characters are input, or the characters (possibly none) up to a line terminator, whichever comes first; any skipped leading blanks are included in the count.<br /></p>

<MarginText>20_A.10.9</MarginText>
<p class="Indented4">Returns in the parameter Item the value of type Num that corresponds to the sequence input, preserving the sign (positive if none has been specified) of a zero value if Num is a floating point type and Num'Signed{"_"}Zeros is True.<br /></p>

<MarginText>21_A.10.9</MarginText>
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence input does not have the required syntax or if the value obtained is not of the subtype Num.<br /></p>

<MarginText>22_A.10.9</MarginText>
<CodeBlock language="ada">
procedure Put(File : in File{"_"}Type;{"\n"}              Item : in Num;{"\n"}              Fore : in Field := Default{"_"}Fore;{"\n"}              Aft  : in Field := Default{"_"}Aft;{"\n"}              Exp  : in Field := Default{"_"}Exp);{"\n"}{"\n"}procedure Put(Item : in Num;{"\n"}              Fore : in Field := Default{"_"}Fore;{"\n"}              Aft  : in Field := Default{"_"}Aft;{"\n"}              Exp  : in Field := Default{"_"}Exp);{"\n"}

</CodeBlock>
<MarginText>23_A.10.9</MarginText>
<p class="Indented4">Outputs the value of the parameter Item as a decimal literal with the format defined by Fore, Aft and Exp. If the value is negative, or if Num is a floating point type where Num'Signed{"_"}Zeros is True and the value is a negatively signed zero, then a minus sign is included in the integer part. If Exp has the value zero, then the integer part to be output has as many digits as are needed to represent the integer part of the value of Item, overriding Fore if necessary, or consists of the digit zero if the value of Item has no integer part.<br /></p>

<MarginText>24_A.10.9</MarginText>
<p class="Indented4">If Exp has a value greater than zero, then the integer part to be output has a single digit, which is nonzero except for the value 0.0 of Item.<br /></p>

<MarginText>25_A.10.9</MarginText>
<p class="Indented4">In both cases, however, if the integer part to be output has fewer than Fore characters, including any minus sign, then leading spaces are first output to make up the difference. The number of digits of the fractional part is given by Aft, or is one if Aft equals zero. The value is rounded; a value of exactly one half in the last place is rounded away from zero.<br /></p>

<MarginText>26_A.10.9</MarginText>
<p class="Indented4">If Exp has the value zero, there is no exponent part. If Exp has a value greater than zero, then the exponent part to be output has as many digits as are needed to represent the exponent part of the value of Item (for which a single digit integer part is used), and includes an initial sign (plus or minus). If the exponent part to be output has fewer than Exp characters, including the sign, then leading zeros precede the digits, to make up the difference. For the value 0.0 of Item, the exponent has the value zero.<br /></p>

<MarginText>27_A.10.9</MarginText>
<CodeBlock language="ada">
procedure Get(From : in String; Item : out Num; Last : out Positive);{"\n"}

</CodeBlock>
<MarginText>28_A.10.9</MarginText>
<p class="Indented4">Reads a real value from the beginning of the given string, following the same rule as the Get procedure that reads a real value from a file, but treating the end of the string as a file terminator. Returns, in the parameter Item, the value of type Num that corresponds to the sequence input. Returns in Last the index value such that From(Last) is the last character read.<br /></p>

<MarginText>29_A.10.9</MarginText>
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence input does not have the required syntax, or if the value obtained is not of the subtype Num.<br /></p>

<MarginText>30_A.10.9</MarginText>
<CodeBlock language="ada">
procedure Put(To   : out String;{"\n"}              Item : in Num;{"\n"}              Aft  : in Field := Default{"_"}Aft;{"\n"}              Exp  : in Field := Default{"_"}Exp);{"\n"}

</CodeBlock>
<MarginText>31_A.10.9</MarginText>
<p class="Indented4">Outputs the value of the parameter Item to the given string, following the same rule as for output to a file, using a value for Fore such that the sequence of characters output exactly fills the string, including any leading spaces. <br /></p>

<MarginText>32_A.10.9</MarginText>
<p>Float{"_"}Text{"_"}IO is a library package that is a nongeneric equivalent to Text{"_"}IO.Float{"_"}IO for the predefined type Float: <br /></p>

<MarginText>33_A.10.9</MarginText>
<CodeBlock language="ada">
with Ada.Text{"_"}IO;{"\n"}package Ada.Float{"_"}Text{"_"}IO is new Ada.Text{"_"}IO.Float{"_"}IO(Float);{"\n"}

</CodeBlock>
<MarginText>34_A.10.9</MarginText>
<p>For each predefined floating point type, a nongeneric equivalent to Text{"_"}IO.Float{"_"}IO is provided, with names such as Ada.Long{"_"}Float{"_"}Text{"_"}IO.<br /></p>


#### Implementation Permissions

<MarginText>35_A.10.9</MarginText>
<p>An implementation may extend Get [and Put] for floating point types to support special values such as infinities and NaNs.<br /></p>

<AnnotatedOnly>
<MarginText>35.a/3_A.10.9</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>See also the similar permission for the Wide{"_"}Wide{"_"}Value, Wide{"_"}Value, and Value attributes in <a href="../AA-3/AA-3.5">3.5</a>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>36/5_A.10.9</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>The implementation of Put may produce an output value with no greater accuracy than that which is supported for the base subtype. The additional accuracy, if any, of the value produced by Put when the number of requested digits in the integer and fractional parts exceeds the required accuracy is implementation defined. <br /></p>

<AnnotatedOnly>
<MarginText>36.a_A.10.9</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The required accuracy is thus Num'Base'Digits digits if Num is a floating point subtype. For a fixed point subtype the required accuracy is a function of the subtype's Fore, Aft, and Delta attributes. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>36.b_A.10.9</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The accuracy of the value produced by Put.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>37/5_A.10.9</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>The nongeneric equivalent packages can be actual instantiations of the generic package for the appropriate predefined type, though that is not required.<br /></p>

<AnnotatedOnly>
<MarginText>38_A.10.9</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   For an item with a positive value, if output to a string exactly fills the string without leading spaces, then output of the corresponding negative value will propagate Layout{"_"}Error.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>39_A.10.9</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   The rules for the Value attribute (see <a href="../AA-3/AA-3.5">3.5</a>) and the rules for Get are based on the same set of formats. <br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>40/5_A.10.9</MarginText>
<MarginInfo items={["AI12-0429-1"]} />
<p><em>Examples of use of an instantiation of Text{"_"}IO.Float{"_"}IO:</em><br /></p>

<MarginText>41_A.10.9</MarginText>
<CodeBlock language="ada">
package Real{"_"}IO is new Float{"_"}IO(Real); use Real{"_"}IO;{"\n"}-- default format used at instantiation, Default{"_"}Exp = 3{"\n"}
<MarginText>42_A.10.9</MarginText>
X : Real := -123.4567;  --  digits 8      (see <a href="../AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>){"\n"}
<MarginText>43_A.10.9</MarginText>
Put(X);  -- default format 	"&ndash;1.2345670E+02"{"\n"}Put(X, Fore ={">"} 5, Aft ={">"} 3, Exp ={">"} 2); 	-- "bbb&ndash;1.235E+2"{"\n"}Put(X, 5, 3, 0);             	-- "b&ndash;123.457"{"\n"}
<a id="Subclause_A.10.10"></a>

</CodeBlock>

## A.10.10  Input-Output for Enumeration Types


#### Static Semantics

<MarginText>1_A.10.10</MarginText>
<p>The following procedures are defined in the generic package Enumeration{"_"}IO, which has to be instantiated for the appropriate enumeration type (indicated by Enum in the specification).<br /></p>

<MarginText>2_A.10.10</MarginText>
<p>Values are output using either upper or lower case letters for identifiers. This is specified by the parameter Set, which is of the enumeration type Type{"_"}Set.<br /></p>

<MarginText>3_A.10.10</MarginText>
<CodeBlock language="ada">
type Type{"_"}Set is (Lower{"_"}Case, Upper{"_"}Case);{"\n"}

</CodeBlock>
<MarginText>4_A.10.10</MarginText>
<p>The format (which includes any trailing spaces) can be specified by an optional field width parameter. The default field width and letter case are defined by the following variables that are declared in the generic package Enumeration{"_"}IO:<br /></p>

<MarginText>5_A.10.10</MarginText>
<CodeBlock language="ada">
Default{"_"}Width   : Field := 0;{"\n"}Default{"_"}Setting : Type{"_"}Set := Upper{"_"}Case;{"\n"}

</CodeBlock>
<MarginText>6_A.10.10</MarginText>
<p>The following procedures are provided: <br /></p>

<MarginText>7_A.10.10</MarginText>
<CodeBlock language="ada">
procedure Get(File : in File{"_"}Type; Item : out Enum);{"\n"}procedure Get(Item : out Enum);{"\n"}

</CodeBlock>
<MarginText>8_A.10.10</MarginText>
<p class="Indented4">After skipping any leading blanks, line terminators, or page terminators, reads an identifier according to the syntax of this lexical element (lower and upper case being considered equivalent), or a character literal according to the syntax of this lexical element (including the apostrophes). Returns, in the parameter Item, the value of type Enum that corresponds to the sequence input.<br /></p>

<MarginText>9_A.10.10</MarginText>
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence input does not have the required syntax, or if the identifier or character literal does not correspond to a value of the subtype Enum.<br /></p>

<MarginText>10_A.10.10</MarginText>
<CodeBlock language="ada">
procedure Put(File  : in File{"_"}Type;{"\n"}              Item  : in Enum;{"\n"}              Width : in Field := Default{"_"}Width;{"\n"}              Set   : in Type{"_"}Set := Default{"_"}Setting);{"\n"}{"\n"}procedure Put(Item  : in Enum;{"\n"}              Width : in Field := Default{"_"}Width;{"\n"}              Set   : in Type{"_"}Set := Default{"_"}Setting);{"\n"}

</CodeBlock>
<MarginText>11_A.10.10</MarginText>
<p class="Indented4">Outputs the value of the parameter Item as an enumeration literal (either an identifier or a character literal). The optional parameter Set indicates whether lower case or upper case is used for identifiers; it has no effect for character literals. If the sequence of characters produced has fewer than Width characters, then trailing spaces are finally output to make up the difference. If Enum is a character type, the sequence of characters produced is as for Enum'Image(Item), as modified by the Width and Set parameters. <br /></p>

<AnnotatedOnly>
<MarginText>11.a/3_A.10.10</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For a character type, the literal might be a Wide{"_"}Wide{"_"}Character, Wide{"_"}Character, or a control character. Whatever Image does for these things is appropriate here, too.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b/3_A.10.10</MarginText>
<MarginInfo items={["AI05-0036-1"]} />
<Admonition type="aarm" aarm="note">
The &ldquo;characters produced&rdquo; defines the &ldquo;characters to be output&rdquo; in the sense of <a href="../AA-A/AA-A.10#Subclause_A.10.6">A.10.6</a>, so a result that cannot fit on any bounded line will raise Layout{"_"}Error. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>12_A.10.10</MarginText>
<CodeBlock language="ada">
procedure Get(From : in String; Item : out Enum; Last : out Positive);{"\n"}

</CodeBlock>
<MarginText>13_A.10.10</MarginText>
<p class="Indented4">Reads an enumeration value from the beginning of the given string, following the same rule as the Get procedure that reads an enumeration value from a file, but treating the end of the string as a file terminator. Returns, in the parameter Item, the value of type Enum that corresponds to the sequence input. Returns in Last the index value such that From(Last) is the last character read.<br /></p>

<MarginText>14_A.10.10</MarginText>
<p class="Indented4">The exception Data{"_"}Error is propagated if the sequence input does not have the required syntax, or if the identifier or character literal does not correspond to a value of the subtype Enum. <br /></p>

<AnnotatedOnly>
<MarginText>14.a/3_A.10.10</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>For a character type, it is permissible for the implementation to make Get do the inverse of what Put does, in the case of wide and wide{"_"}wide <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>s and control characters. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>15_A.10.10</MarginText>
<CodeBlock language="ada">
procedure Put(To   : out String;{"\n"}              Item : in Enum;{"\n"}              Set  : in Type{"_"}Set := Default{"_"}Setting);{"\n"}

</CodeBlock>
<MarginText>16_A.10.10</MarginText>
<p class="Indented4">Outputs the value of the parameter Item to the given string, following the same rule as for output to a file, using the length of the given string as the value for Width. <br /></p>

<MarginText>17/1_A.10.10</MarginText>
<MarginInfo items={["AI95-00007-01"]} />
<p>{"{"}<em>8652/0054</em>{"}"} Although the specification of the generic package Enumeration{"_"}IO would allow instantiation for an integer type, this is not the intended purpose of this generic package, and the effect of such instantiations is not defined by the language. <br /></p>

<AnnotatedOnly>
<MarginText>18_A.10.10</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   There is a difference between Put defined for characters, and for enumeration values. Thus <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19_A.10.10</MarginText>
<CodeBlock language="ada">
   Ada.Text{"_"}IO.Put('A');  --  outputs the character A{"\n"}
<MarginText>20_A.10.10</MarginText>
   package Char{"_"}IO is new Ada.Text{"_"}IO.Enumeration{"_"}IO(Character);{"\n"}   Char{"_"}IO.Put('A');  --  outputs the character 'A', between apostrophes{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>21_A.10.10</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   The type Boolean is an enumeration type, hence Enumeration{"_"}IO can be instantiated for this type. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>21.a/2_A.10.10</MarginText>
<MarginInfo items={["AI95-00007-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0054</em>{"}"} <strong>Corrigendum:</strong> Corrected the wording to say Enumeration{"_"}IO can be instantiated with an integer type, not a float type. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.11"></a>

## A.10.11  Input-Output for Bounded Strings

<MarginText>1/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p>The package Text{"_"}IO.Bounded{"_"}IO provides input-output in human-readable form for Bounded{"_"}Strings. <br /></p>


#### Static Semantics

<MarginText>2/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p>The generic library package Text{"_"}IO.Bounded{"_"}IO has the following declaration:<br /></p>

<MarginText>3/5_A.10.11</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
with Ada.Strings.Bounded;{"\n"}generic{"\n"}   with package Bounded is{"\n"}                     new Ada.Strings.Bounded.Generic{"_"}Bounded{"_"}Length ({"<"}{">"});{"\n"}package Ada.Text{"_"}IO.Bounded{"_"}IO{"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>4/2_A.10.11</MarginText>
   procedure Put{"\n"}      (File : in File{"_"}Type;{"\n"}       Item : in Bounded.Bounded{"_"}String);{"\n"}
<MarginText>5/2_A.10.11</MarginText>
   procedure Put{"\n"}      (Item : in Bounded.Bounded{"_"}String);{"\n"}
<MarginText>6/2_A.10.11</MarginText>
   procedure Put{"_"}Line{"\n"}      (File : in File{"_"}Type;{"\n"}       Item : in Bounded.Bounded{"_"}String);{"\n"}
<MarginText>7/2_A.10.11</MarginText>
   procedure Put{"_"}Line{"\n"}      (Item : in Bounded.Bounded{"_"}String);{"\n"}
<MarginText>8/2_A.10.11</MarginText>
   function Get{"_"}Line{"\n"}      (File : in File{"_"}Type){"\n"}      return Bounded.Bounded{"_"}String;{"\n"}
<MarginText>9/2_A.10.11</MarginText>
   function Get{"_"}Line{"\n"}      return Bounded.Bounded{"_"}String;{"\n"}
<MarginText>10/2_A.10.11</MarginText>
   procedure Get{"_"}Line{"\n"}      (File : in File{"_"}Type; Item : out Bounded.Bounded{"_"}String);{"\n"}
<MarginText>11/2_A.10.11</MarginText>
   procedure Get{"_"}Line{"\n"}      (Item : out Bounded.Bounded{"_"}String);{"\n"}
<MarginText>12/2_A.10.11</MarginText>
end Ada.Text{"_"}IO.Bounded{"_"}IO;{"\n"}

</CodeBlock>
<MarginText>13/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p>For an item of type Bounded{"_"}String, the following subprograms are provided:<br /></p>

<MarginText>14/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Put{"\n"}   (File : in File{"_"}Type;{"\n"}    Item : in Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>15/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put (File, Bounded.To{"_"}String(Item));<br /></p>

<MarginText>16/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Put{"\n"}   (Item : in Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>17/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put (Bounded.To{"_"}String(Item));<br /></p>

<MarginText>18/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Put{"_"}Line{"\n"}   (File : in File{"_"}Type;{"\n"}    Item : in Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>19/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put{"_"}Line (File, Bounded.To{"_"}String(Item));<br /></p>

<MarginText>20/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Put{"_"}Line{"\n"}   (Item : in Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>21/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put{"_"}Line (Bounded.To{"_"}String(Item));<br /></p>

<MarginText>22/2_A.10.11</MarginText>
<CodeBlock language="ada">
function Get{"_"}Line{"\n"}   (File : in File{"_"}Type){"\n"}   return Bounded.Bounded{"_"}String;{"\n"}

</CodeBlock>
<MarginText>23/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Returns Bounded.To{"_"}Bounded{"_"}String(Text{"_"}IO.Get{"_"}Line(File));<br /></p>

<MarginText>24/2_A.10.11</MarginText>
<CodeBlock language="ada">
function Get{"_"}Line{"\n"}   return Bounded.Bounded{"_"}String;{"\n"}

</CodeBlock>
<MarginText>25/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Returns Bounded.To{"_"}Bounded{"_"}String(Text{"_"}IO.Get{"_"}Line);<br /></p>

<MarginText>26/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Line{"\n"}   (File : in File{"_"}Type; Item : out Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>27/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Item := Get{"_"}Line (File);<br /></p>

<MarginText>28/2_A.10.11</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Line{"\n"}   (Item : out Bounded.Bounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>29/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<p class="Indented4">Equivalent to Item := Get{"_"}Line; <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>29.a/2_A.10.11</MarginText>
<MarginInfo items={["AI95-00428-01"]} />
<Admonition type="aarm" aarm="note">
Package Text{"_"}IO.Bounded{"_"}IO is new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_A.10.12"></a>

## A.10.12  Input-Output for Unbounded Strings

<MarginText>1/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p>The package Text{"_"}IO.Unbounded{"_"}IO provides input-output in human-readable form for Unbounded{"_"}Strings. <br /></p>


#### Static Semantics

<MarginText>2/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p>The library package Text{"_"}IO.Unbounded{"_"}IO has the following declaration:<br /></p>

<MarginText>3/5_A.10.12</MarginText>
<MarginInfo items={["AI12-0302-1"]} />
<CodeBlock language="ada">
with Ada.Strings.Unbounded;{"\n"}package Ada.Text{"_"}IO.Unbounded{"_"}IO{"\n"}   with Global ={">"} in out synchronized is{"\n"}
<MarginText>4/2_A.10.12</MarginText>
   procedure Put{"\n"}      (File : in File{"_"}Type;{"\n"}       Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>5/2_A.10.12</MarginText>
   procedure Put{"\n"}      (Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>6/2_A.10.12</MarginText>
   procedure Put{"_"}Line{"\n"}      (File : in File{"_"}Type;{"\n"}       Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>7/2_A.10.12</MarginText>
   procedure Put{"_"}Line{"\n"}      (Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>8/2_A.10.12</MarginText>
   function Get{"_"}Line{"\n"}      (File : in File{"_"}Type){"\n"}      return Strings.Unbounded.Unbounded{"_"}String;{"\n"}
<MarginText>9/2_A.10.12</MarginText>
   function Get{"_"}Line{"\n"}      return Strings.Unbounded.Unbounded{"_"}String;{"\n"}
<MarginText>10/2_A.10.12</MarginText>
   procedure Get{"_"}Line{"\n"}      (File : in File{"_"}Type; Item : out Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>11/2_A.10.12</MarginText>
   procedure Get{"_"}Line{"\n"}      (Item : out Strings.Unbounded.Unbounded{"_"}String);{"\n"}
<MarginText>12/2_A.10.12</MarginText>
end Ada.Text{"_"}IO.Unbounded{"_"}IO;{"\n"}

</CodeBlock>
<MarginText>13/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p>For an item of type Unbounded{"_"}String, the following subprograms are provided:<br /></p>

<MarginText>14/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Put{"\n"}   (File : in File{"_"}Type;{"\n"}    Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>15/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put (File, Strings.Unbounded.To{"_"}String(Item));<br /></p>

<MarginText>16/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Put{"\n"}   (Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>17/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put (Strings.Unbounded.To{"_"}String(Item));<br /></p>

<MarginText>18/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Put{"_"}Line{"\n"}   (File : in File{"_"}Type;{"\n"}    Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>19/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put{"_"}Line (File, Strings.Unbounded.To{"_"}String(Item));<br /></p>

<MarginText>20/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Put{"_"}Line{"\n"}   (Item : in Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>21/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Text{"_"}IO.Put{"_"}Line (Strings.Unbounded.To{"_"}String(Item));<br /></p>

<MarginText>22/2_A.10.12</MarginText>
<CodeBlock language="ada">
function Get{"_"}Line{"\n"}   (File : in File{"_"}Type){"\n"}   return Strings.Unbounded.Unbounded{"_"}String;{"\n"}

</CodeBlock>
<MarginText>23/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Returns Strings.Unbounded.To{"_"}Unbounded{"_"}String(Text{"_"}IO.Get{"_"}Line(File));<br /></p>

<MarginText>24/2_A.10.12</MarginText>
<CodeBlock language="ada">
function Get{"_"}Line{"\n"}   return Strings.Unbounded.Unbounded{"_"}String;{"\n"}

</CodeBlock>
<MarginText>25/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Returns Strings.Unbounded.To{"_"}Unbounded{"_"}String(Text{"_"}IO.Get{"_"}Line);<br /></p>

<MarginText>26/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Line{"\n"}   (File : in File{"_"}Type; Item : out Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>27/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Item := Get{"_"}Line (File);<br /></p>

<MarginText>28/2_A.10.12</MarginText>
<CodeBlock language="ada">
procedure Get{"_"}Line{"\n"}   (Item : out Strings.Unbounded.Unbounded{"_"}String);{"\n"}

</CodeBlock>
<MarginText>29/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<p class="Indented4">Equivalent to Item := Get{"_"}Line; <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>29.a/2_A.10.12</MarginText>
<MarginInfo items={["AI95-00301-01"]} />
<Admonition type="aarm" aarm="note">
Package Text{"_"}IO.Unbounded{"_"}IO is new. <br />
</Admonition>
</AnnotatedOnly>

