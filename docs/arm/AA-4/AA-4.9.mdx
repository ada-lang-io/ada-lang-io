---
sidebar_position:  39
---

# 4.9 Static Expressions and Static Subtypes

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>Certain expressions of a scalar or string type are defined to be static. Similarly, certain discrete ranges are defined to be static, and certain scalar and string subtypes are defined to be static subtypes. [ <em>Static</em> means determinable at compile time, using the declared properties or values of the program entities.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>As opposed to more elaborate data flow analysis, etc. <br /></Admonition>
</AnnotatedOnly>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.b</MarginText>
<Admonition type="aarm" aarm="note">
For an expression to be static, it has to be calculable at compile time.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.c</MarginText>
<Admonition type="aarm" aarm="note">
Only scalar and string expressions are static.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.d</MarginText>
<Admonition type="aarm" aarm="note">
To be static, an expression cannot have any nonscalar, nonstring subexpressions (though it can have nonscalar constituent <code><a href="../AA-4/AA-4.1#S0091">name</a></code>s). A static scalar expression cannot have any nonscalar subexpressions. There is one exception &mdash; a membership test for a string subtype can be static, and the result is scalar, even though a subexpression is nonscalar.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.e</MarginText>
<Admonition type="aarm" aarm="note">
The rules for evaluating static expressions are designed to maximize portability of static calculations.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.f/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We support static string expressions so that, for example, the <code><a href="../AA-13/AA-13.1#S0348">aspect_definition</a></code> for a Link_Name aspect can contain a concatenation. We don't support static aggregates (even for string types) or non-string static nonscalar types; we're trying to keep it cheap and simple (from the implementer's viewpoint). <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2</MarginText>
<p>A static expression is [a scalar or string expression that is] one of the following:<br /></p>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI12-0249-1"]} />
<ul>
<li>a <code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code> of a numeric type; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>3.a/5</MarginText>
<MarginInfo items={["AI12-0249-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>A <code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code> of a numeric type is always a static expression, even if its expected type is not that of a static subtype. However, if its value is explicitly converted to, or qualified by, a nonstatic subtype, the resulting expression is nonstatic. Non-numeric types can have numeric literals if aspect Integer_Literal or Real_Literal is used; these are never static. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4</MarginText>
<ul>
<li>a <code><a href="../AA-2/AA-2.6#S0016">string_literal</a></code> of a static string subtype; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>That is, the constrained subtype defined by the index range of the string is static. Note that elementary values don't generally have subtypes, while composite values do (since the bounds or discriminants are inherent in the value). <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/5</MarginText>
<MarginInfo items={["AI12-0394-1"]} />
<ul>
<li>a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that denotes the declaration of  a static constant;<br /></li>
<MarginText>5.1/5</MarginText>
<MarginInfo items={["AI12-0394-1"]} />
<li>a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that denotes a named number, and that is interpreted as a value of a numeric type;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>5.a.1/5</MarginText>
<MarginInfo items={["AI12-0394-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This is referring the resolution of the named number and not the Static Semantics (for which all named numbers are values of a universal numeric type). The word &ldquo;interpreted&rdquo; is intended to make the distinction. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that enumeration literals are covered by the <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> case. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6</MarginText>
<ul>
<li>a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> whose <em>function_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> or <em>function_</em><code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> statically denotes a static function, and whose actual parameters, if any (whether given explicitly or by default), are all static expressions; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This includes uses of operators that are equivalent to <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7</MarginText>
<ul>
<li>an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> that denotes a scalar value, and whose <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes a static scalar subtype;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>7.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that this does not include the case of an attribute that is a function; a reference to such an attribute is not even an expression. See above for function <em>calls</em>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.b</MarginText>
<Admonition type="aarm" aarm="note">
An implementation may define the staticness and other properties of implementation-defined attributes. <br /></Admonition>
</AnnotatedOnly>

<MarginText>8/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<ul>
<li>an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> whose <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> statically names  a statically constrained array object or array subtype, and whose <code><a href="../AA-4/AA-4.1#S0101">attribute_designator</a></code> is First, Last, or Length, with an optional dimension;<br /></li>
<MarginText>8.1/5</MarginText>
<MarginInfo items={["AI12-0064-2"]} />
<li>an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> whose <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes a non-generic entity that is not declared in a generic unit, and whose <code><a href="../AA-4/AA-4.1#S0101">attribute_designator</a></code> is Nonblocking;<br /></li>
<MarginText>9/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<li>a <code><a href="../AA-4/AA-4.6#S0162">type_conversion</a></code> whose <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denotes a static [(scalar or string)]  subtype, and whose operand is a static expression;<br /></li>
<MarginText>10</MarginText>
<li>a <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code> whose <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denotes a static [(scalar or string)] subtype, and whose operand is a static expression; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This rules out the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>'<code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> case. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Adding qualification to an expression shouldn't make it nonstatic, even for strings. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11/4</MarginText>
<MarginInfo items={["AI05-0158-1", "AI05-0269-1", "AI12-0039-1"]} />
<ul>
<li>a membership test whose <em>tested_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> is a static expression, and whose <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code> consists only of <code><a href="../AA-4/AA-4.4#S0137">membership_choice</a></code>s that are either static <em>choice_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>s, static <code><a href="../AA-3/AA-3.5#S0037">range</a></code>s, or <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>s that denote a static [(scalar or string)] subtype; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Clearly, we should allow membership tests in exactly the same cases where we allow <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12</MarginText>
<ul>
<li>a short-circuit control form both of whose <code><a href="../AA-4/AA-4.4#S0135">relation</a></code>s are static expressions;<br /></li>
<MarginText>12.1/3</MarginText>
<MarginInfo items={["AI05-0147-1", "AI05-0188-1"]} />
<li>a <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code> all of whose <code><a href="../AA-4/AA-4.5#S0150">condition</a></code>s, <em>selecting_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s, and <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s are static expressions;<br /></li>
<MarginText>12.2/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<li>a <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code> whose <em>body_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> is static and each of whose declarations, if any, is either the declaration of a static constant or is an <code><a href="../AA-8/AA-8.5#S0239">object_renaming_declaration</a></code> with an <em>object_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> that statically names the renamed object;<br /></li>
<MarginText>13</MarginText>
<li>a static expression enclosed in parentheses. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>13.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Informally, we talk about a <em>static value</em>. When we do, we mean a value specified by a static expression. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.b/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The language requires a static expression in a <code><a href="../AA-3/AA-3.3#S0034">number_declaration</a></code>, a numeric type definition,  certain representation items, and a number of other contexts . <br /></Admonition>
</AnnotatedOnly>

<MarginText>14</MarginText>
<p>A <code><a href="../AA-4/AA-4.1#S0091">name</a></code> <em>statically denotes</em> an entity if it denotes the entity and: <br /></p>

<MarginText>15</MarginText>
<ul>
<li>It is a <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code>, expanded name, or <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>, and it denotes a declaration other than a <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code>; or<br /></li>
<MarginText>16</MarginText>
<li>It is an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> whose <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> statically denotes some entity; or<br /></li>
<MarginText>16.1/5</MarginText>
<MarginInfo items={["AI12-0322-1"]} />
<li>It is a <code><a href="../AA-5/AA-5.2#S0174">target_name</a></code> (see <a href="../AA-5/AA-5.2#Subclause_5.2.1">5.2.1</a>) in an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> whose <em>variable_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> statically denotes some entity; or<br /></li>
<MarginText>17</MarginText>
<li>It denotes a <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code> with a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that statically denotes the renamed entity. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong><code><a href="../AA-4/AA-4.1#S0098">Selected_component</a></code>s that are not expanded names and <code><a href="../AA-4/AA-4.1#S0096">indexed_component</a></code>s do not statically denote things. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.1/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<p>A <code><a href="../AA-4/AA-4.1#S0091">name</a></code> <em>statically names</em> an object if it: <br /></p>

<MarginText>17.2/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<ul>
<li>statically denotes the declaration of an object [(possibly through one or more renames)]; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.b/5</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>Follows from the definition of statically denotes. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.3/5</MarginText>
<MarginInfo items={["AI12-0368-1", "AI12-0373-1"]} />
<ul>
<li>is a <code><a href="../AA-4/AA-4.1#S0098">selected_component</a></code> whose prefix statically names an object, there is no implicit dereference of the prefix, and the <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> does not denote a <code><a href="../AA-3/AA-3.8#S0070">component_declaration</a></code> occurring within a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code>; or <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.c/5</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We disallow components in a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code> so that no discriminant checks are needed to evaluate the <code><a href="../AA-4/AA-4.1#S0098">selected_component</a></code>. Note that other kinds of discriminant-dependent components do not need any checks on access (only when they are changed). <br /></Admonition>
</AnnotatedOnly>

<MarginText>17.4/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<ul>
<li>is an <code><a href="../AA-4/AA-4.1#S0096">indexed_component</a></code> whose prefix statically names an object, there is no implicit dereference of the prefix, the object is statically constrained, and the index expressions of the object are static and have values that are within the range of the index constraint. <br /></li>
</ul>
<MarginText>17.5/5</MarginText>
<MarginInfo items={["AI12-0368-1"]} />
<p>For an entity other than an object, a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> statically names an entity if the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> statically denotes the entity.<br /></p>

<MarginText>18</MarginText>
<p>A <em>static function</em> is one of the following: <br /></p>

<AnnotatedOnly>
<MarginText>18.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>These are the functions whose calls can be static expressions. <br /></Admonition>
</AnnotatedOnly>

<MarginText>19</MarginText>
<ul>
<li>a predefined operator whose parameter and result types are all scalar types none of which are descendants of formal scalar types;<br /></li>
<MarginText>19.1/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<li>a predefined relational operator whose parameters are of a string type that is not a descendant of a formal array type;<br /></li>
<MarginText>20/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<li>a predefined concatenation operator whose result type is a string type that is not a descendant of a formal array type;<br /></li>
<MarginText>20.1/5</MarginText>
<MarginInfo items={["AI12-0385-1"]} />
<li>a shifting or rotating function associated with a modular type declared in package Interfaces (see <a href="../AA-B/AA-B.2">B.2</a>);<br /></li>
<MarginText>21</MarginText>
<li>an enumeration literal;<br /></li>
<MarginText>21.1/5</MarginText>
<MarginInfo items={["AI12-0075-1"]} />
<li>a static expression function (see <a href="../AA-6/AA-6.8">6.8</a>);<br /></li>
<MarginText>22</MarginText>
<li>a language-defined attribute that is a function, if the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes a static scalar subtype, and if the parameter and result types are scalar. <br /></li>
</ul>
<MarginText>23</MarginText>
<p>In any case, a generic formal subprogram is not a static function.<br /></p>

<MarginText>24/5</MarginText>
<MarginInfo items={["AI12-0201-1", "AI12-0393-1"]} />
<p>A <em>static constant</em> is a constant view declared by a full constant declaration or an <code><a href="../AA-8/AA-8.5#S0239">object_renaming_declaration</a></code> with a static nominal subtype, having a value defined by a static scalar expression or by a static string expression, and which satisfies any constraint or predicate that applies to the nominal subtype . <br /></p>

<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A deferred constant is not static; the view introduced by the corresponding full constant declaration can be static. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b/5</MarginText>
<MarginInfo items={["AI05-0229-1", "AI12-0201-1"]} />
<Admonition type="aarm" aarm="reason">
<em>This paragraph was deleted.</em><strong></strong> <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.c/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em> <br /></Admonition>
</AnnotatedOnly>

<MarginText>25</MarginText>
<p>A <em>static range</em> is a <code><a href="../AA-3/AA-3.5#S0037">range</a></code> whose bounds are static expressions, [or a <code><a href="../AA-4/AA-4.1#S0102">range_attribute_reference</a></code> that is equivalent to such a <code><a href="../AA-3/AA-3.5#S0037">range</a></code>.] A <em>static <code><a href="../AA-3/AA-3.6#S0058">discrete_range</a></code></em> is one that is a static range or is a <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code> that defines a static scalar subtype. The base range of a scalar type is a static range, unless the type is a descendant of a formal scalar type.<br /></p>

<MarginText>26/3</MarginText>
<MarginInfo items={["AI95-00263-01", "AI05-0153-3"]} />
<p>A <em>static subtype</em> is either a <em>static scalar subtype</em> or a <em>static string subtype</em>. A static scalar subtype is an unconstrained scalar subtype whose type is not a descendant of a formal type, or a constrained scalar subtype formed by imposing a compatible static constraint on a static scalar subtype. A static string subtype is an unconstrained string subtype whose index subtype and component subtype are static, or a constrained string subtype formed by imposing a compatible static constraint on a static string subtype. In any case, the subtype of a generic formal object of mode <strong>in out</strong>, and the result subtype of a generic formal function, are not static. Also, a subtype is not static if any Dynamic_Predicate specifications apply to it. <br /></p>

<AnnotatedOnly>
<MarginText>26.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>String subtypes are the only composite subtypes that can be static. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.b</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The part about generic formal objects of mode <strong>in out</strong> is necessary because the subtype of the formal is not required to have anything to do with the subtype of the actual. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.c</MarginText>
<CodeBlock language="ada">
subtype Int10 is Integer range 1..10;{"\n"}
<MarginText>26.d</MarginText>
generic{"\n"}    F : in out Int10;{"\n"}procedure G;{"\n"}
<MarginText>26.e</MarginText>
procedure G is{"\n"}begin{"\n"}    case F is{"\n"}        when 1..10 ={">"} null;{"\n"}        -- Illegal!{"\n"}    end case;{"\n"}end G;{"\n"}
<MarginText>26.f</MarginText>
X : Integer range 1..20;{"\n"}procedure I is new G(F ={">"} X); -- OK.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.g</MarginText>
<Admonition type="aarm" aarm="note">
The <code><a href="../AA-5/AA-5.4#S0176">case_statement</a></code> is illegal, because the subtype of F is not static, so the choices have to cover all values of Integer, not just those in the range 1..10. A similar issue arises for generic formal functions, now that function calls are object names. <br /></Admonition>
</AnnotatedOnly>

<MarginText>27</MarginText>
<p>The different kinds of <em>static constraint</em> are defined as follows: <br /></p>

<MarginText>28</MarginText>
<ul>
<li>A null constraint is always static;<br /></li>
<MarginText>29</MarginText>
<li>A scalar constraint is static if it has no <code><a href="../AA-3/AA-3.5#S0036">range_constraint</a></code>, or one with a static range;<br /></li>
<MarginText>30</MarginText>
<li>An index constraint is static if each <code><a href="../AA-3/AA-3.6#S0058">discrete_range</a></code> is static, and each index subtype of the corresponding array type is static;<br /></li>
<MarginText>31</MarginText>
<li>A discriminant constraint is static if each <code><a href="../AA-4/AA-4.4#S0132">expression</a></code> of the constraint is static, and the subtype of each discriminant is static. <br /></li>
</ul>
<MarginText>31.1/2</MarginText>
<MarginInfo items={["AI95-00311-01"]} />
<p>In any case, the constraint of the first subtype of a scalar formal type is neither static nor null.<br /></p>

<MarginText>32</MarginText>
<p>A subtype is <em>statically constrained</em> if it is constrained, and its constraint is static. An object is <em>statically constrained</em> if its nominal subtype is statically constrained, or if it is a static string constant. <br /></p>


#### Legality Rules

<MarginText>32.1/3</MarginText>
<MarginInfo items={["AI05-0147-1"]} />
<p>An expression is <em>statically unevaluated</em> if it is part of:<br /></p>

<MarginText>32.2/3</MarginText>
<MarginInfo items={["AI05-0147-1"]} />
<ul>
<li>the right operand of a static short-circuit control form whose value is determined by its left operand; or<br /></li>
<MarginText>32.3/3</MarginText>
<MarginInfo items={["AI05-0147-1", "AI05-0188-1"]} />
<li>a <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> of an <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code> whose associated <code><a href="../AA-4/AA-4.5#S0150">condition</a></code> is static and equals False; or<br /></li>
<MarginText>32.4/3</MarginText>
<MarginInfo items={["AI05-0147-1", "AI05-0188-1"]} />
<li>a <code><a href="../AA-4/AA-4.5#S0150">condition</a></code> or <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> of an <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code> where the <code><a href="../AA-4/AA-4.5#S0150">condition</a></code> corresponding to at least one preceding <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> of the <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code> is static and equals True; or<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>32.a/3</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We need this bullet so that only a single <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> is evaluated in a static <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code> if there is more than one <code><a href="../AA-4/AA-4.5#S0150">condition</a></code> that evaluates to True. The part about <code><a href="../AA-4/AA-4.5#S0150">condition</a></code>s makes <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.b/3</MarginText>
<CodeBlock language="ada">
(if N = 0 then Min elsif 10_000/N {">"} Min then 10_000/N else Min){"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.c/3</MarginText>
<Admonition type="aarm" aarm="note">
legal if N and Min are static and N = 0. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.d/3</MarginText>
<MarginInfo items={["AI05-0147-1", "AI05-0188-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>We need the "of the <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code>" here so there is no confusion for nested <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code>s; this rule only applies to the <code><a href="../AA-4/AA-4.5#S0150">condition</a></code>s and <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>s of a single <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code>. Similar reasoning applies to the "of a <code><a href="../AA-4/AA-4.5#S0151">case_expression</a></code>" of the last bullet. <br /></Admonition>
</AnnotatedOnly>

<MarginText>32.5/3</MarginText>
<MarginInfo items={["AI05-0188-1", "AI05-0269-1"]} />
<ul>
<li>a <em>dependent_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> of a <code><a href="../AA-4/AA-4.5#S0151">case_expression</a></code> whose <em>selecting_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code> is static and whose value is not covered by the corresponding <code><a href="../AA-3/AA-3.8#S0073">discrete_choice_list</a></code>; or<br /></li>
<MarginText>32.6/4</MarginText>
<MarginInfo items={["AI05-0158-1", "AI12-0039-1"]} />
<li>a <em>choice_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> (or a <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> of a <code><a href="../AA-3/AA-3.5#S0037">range</a></code> that occurs as a <code><a href="../AA-4/AA-4.4#S0137">membership_choice</a></code> of a <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code>) of a static membership test that is preceded in the enclosing <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code> by another item whose individual membership test (see <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>) statically yields True. <br /></li>
</ul>
<MarginText>33/3</MarginText>
<MarginInfo items={["AI05-0147-1"]} />
<p>A static expression is evaluated at compile time except when it is statically unevaluated. The compile-time evaluation of a static expression is performed exactly, without performing Overflow_Checks. For a static expression that is evaluated: <br /></p>

<MarginText>34/3</MarginText>
<MarginInfo items={["AI05-0262-1"]} />
<ul>
<li>The expression is illegal if its evaluation fails a language-defined check other than Overflow_Check. For the purposes of this evaluation, the assertion policy is assumed to be Check.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>34.a/3</MarginText>
<MarginInfo items={["AI05-0262-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>Assertion policies can control whether checks are made, but we don't want assertion policies to affect legality. For Ada 2012, subtype predicates are the only checks controlled by the assertion policy that can appear in static expressions. <br /></Admonition>
</AnnotatedOnly>

<MarginText>35/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<ul>
<li>If the expression is not part of a larger static expression and the expression is expected to be of a single specific type, then its value shall be within the base range of its expected type. Otherwise, the value may be arbitrarily large or small. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>35.a/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If the expression is expected to be of a universal type, or of &ldquo;any integer type&rdquo;, there are no limits on the value of the expression. <br /></Admonition>
</AnnotatedOnly>

<MarginText>36/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<ul>
<li>If the expression is of type <em>universal_real</em> and its expected type is a decimal fixed point type, then its value shall be a multiple of the <em>small</em> of the decimal type. This restriction does not apply if the expected type is a descendant of a formal scalar type (or a corresponding actual type in an instance). <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>36.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This means that a <code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code> for a decimal type cannot have &ldquo;extra&rdquo; significant digits. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>36.b/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The small is not known for a generic formal type, so we have to exclude formal types from this check. <br /></Admonition>
</AnnotatedOnly>

<MarginText>37/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<p>In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), the above restrictions also apply in the private part of an instance of a generic unit.<br /></p>

<AnnotatedOnly>
<MarginText>37.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Values outside the base range are not permitted when crossing from the &ldquo;static&rdquo; domain to the &ldquo;dynamic&rdquo; domain. This rule is designed to enhance portability of programs containing static expressions. Note that this rule applies to the exact value, not the value after any rounding or truncation. (See below for the rounding and truncation requirements.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.b</MarginText>
<Admonition type="aarm" aarm="note">
Short-circuit control forms are a special case: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.c</MarginText>
<CodeBlock language="ada">
N: constant := 0.0;{"\n"}X: constant Boolean := (N = 0.0) or else (1.0/N {">"} 0.5); -- Static.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>37.d</MarginText>
<Admonition type="aarm" aarm="note">
The declaration of X is legal, since the divide-by-zero part of the expression is not evaluated. X is a static constant equal to True.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.e/5</MarginText>
<MarginInfo items={["AI12-0075-1"]} />
<Admonition type="aarm" aarm="note">
The preceding &ldquo;statically unevaluated&rdquo; rule allows<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.f/5</MarginText>
<CodeBlock language="ada">
X : constant := (if True then 37 else (1 / 0));{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>37.g/5</MarginText>
<Admonition type="aarm" aarm="note">
but does not allow<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.h/5</MarginText>
<CodeBlock language="ada">
function If_Then_Else (Flag : Boolean; X, Y : Integer) return Integer is{"\n"}   (if Flag then X else Y) with Static; -- see <a href="../AA-6/AA-6.8">6.8</a>{"\n"}X : constant := If_Then_Else (True, 37, 1 / 0);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>37.i/5</MarginText>
<Admonition type="aarm" aarm="note">
because evaluation of a function call includes evaluation of all of its actual parameters. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>38/2</MarginText>
<MarginInfo items={["AI95-00268-01", "AI95-00269-01"]} />
<p>For a real static expression that is not part of a larger static expression, and whose expected type is not a descendant of a formal type, the implementation shall round or truncate the value (according to the Machine_Rounds attribute of the expected type) to the nearest machine number of the expected type; if the value is exactly half-way between two machine numbers, the rounding performed is implementation-defined. If the expected type is a descendant of a formal type, or if the static expression appears in the body of an instance of a generic unit and the corresponding expression is nonstatic in the corresponding generic body, then no special rounding or truncating is required &mdash; normal accuracy rules apply (see <a href="../AA-G/">Annex G</a>). <br /></p>

<AnnotatedOnly>
<MarginText>38.a.1/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>Rounding of real static expressions which are exactly half-way between two machine numbers.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.a/2</MarginText>
<MarginInfo items={["AI95-00268-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>Discarding extended precision enhances portability by ensuring that the value of a static constant of a real type is always a machine number of the type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.b</MarginText>
<Admonition type="aarm" aarm="note">
When the expected type is a descendant of a formal floating point type, extended precision (beyond that of the machine numbers) can be retained when evaluating a static expression, to ease code sharing for generic instantiations. For similar reasons, normal (nondeterministic) rounding or truncating rules apply for descendants of a formal fixed point type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.b.1/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<Admonition type="aarm" aarm="note">
There is no requirement for exact evaluation or special rounding in an instance body (unless the expression is static in the generic body). This eliminates a potential contract issue where the exact value of a static expression depends on the actual parameters (which could then affect the legality of other code). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.c</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Note that the implementation of static expressions has to keep track of plus and minus zero for a type whose Signed_Zeros attribute is True.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.d/2</MarginText>
<MarginInfo items={["AI95-00100-01"]} />
<Admonition type="aarm" aarm="note">
Note that the only machine numbers of a fixed point type are the multiples of the small, so a static conversion to a fixed-point type, or division by an integer, must do truncation to a multiple of small. It is not correct for the implementation to do all static calculations in infinite precision.<br /></Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>38.1/2</MarginText>
<MarginInfo items={["AI95-00268-01"]} />
<p>For a real static expression that is not part of a larger static expression, and whose expected type is not a descendant of a formal type, the rounding should be the same as the default rounding for the target system. <br /></p>

<AnnotatedOnly>
<MarginText>38.e/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>A real static expression with a nonformal type that is not part of a larger static expression should be rounded the same as the target system.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>39</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   An expression can be static even if it occurs in a context where staticness is not required. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>39.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>39.b</MarginText>
<CodeBlock language="ada">
X : Float := Float'(1.0E+400) + 1.0 - Float'(1.0E+400);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>39.c</MarginText>
<Admonition type="aarm" aarm="note">
The expression is static, which means that the value of X must be exactly 1.0, independent of the accuracy or range of the run-time floating point implementation.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>39.d</MarginText>
<Admonition type="aarm" aarm="note">
The following kinds of expressions are never static: <code><a href="../AA-4/AA-4.1#S0094">explicit_dereference</a></code>, <code><a href="../AA-4/AA-4.1#S0096">indexed_component</a></code>, <code><a href="../AA-4/AA-4.1#S0097">slice</a></code>, <strong>null</strong>, <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>, <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>40</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   A static (or run-time) <code><a href="../AA-4/AA-4.6#S0162">type_conversion</a></code> from a real type to an integer type performs rounding. If the operand value is exactly half-way between two integers, the rounding is performed away from zero. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>40.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We specify this for portability. The reason for not choosing round-to-nearest-even, for example, is that this method is easier to undo. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>40.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The attribute Truncation (see <a href="../AA-A/AA-A.5#Subclause_A.5.3">A.5.3</a>) can be used to perform a (static) truncation prior to conversion, to prevent rounding. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>40.c</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>The value of the literal 0E999999999999999999999999999999999999999999999 is zero. The implementation must take care to evaluate such literals properly.<br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>41</MarginText>
<p><em>Examples of static expressions:</em> <br /></p>

<MarginText>42</MarginText>
<CodeBlock language="ada">
1 + 1       -- 2{"\n"}abs(-10)*3  -- 30{"\n"}
<MarginText>43</MarginText>
Kilo : constant := 1000;{"\n"}Mega : constant := Kilo*Kilo;   -- 1_000_000{"\n"}Long : constant := Float'Digits*2;{"\n"}
<MarginText>44</MarginText>
Half_Pi    : constant := Pi/2;           -- see <a href="../AA-3/AA-3.3#Subclause_3.3.2">3.3.2</a>{"\n"}Deg_To_Rad : constant := Half_Pi/90;{"\n"}Rad_To_Deg : constant := 1.0/Deg_To_Rad; -- equivalent to 1.0/((3.14159_26536/2)/90){"\n"}

</CodeBlock>

#### Extensions to Ada 83

<AnnotatedOnly>
<MarginText>44.a</MarginText>
<Admonition type="aarm" aarm="note">
The rules for static expressions and static subtypes are generalized to allow more kinds of compile-time-known expressions to be used where compile-time-known values are required, as follows: <br /></Admonition>
</AnnotatedOnly>

<MarginText>44.b</MarginText>
<ul>
<li>Membership tests and short-circuit control forms may appear in a static expression.<br /></li>
<MarginText>44.c</MarginText>
<li>The bounds and length of statically constrained array objects or subtypes are static.<br /></li>
<MarginText>44.d</MarginText>
<li>The Range attribute of a statically constrained array subtype or object gives a static range.<br /></li>
<MarginText>44.e</MarginText>
<li>A <code><a href="../AA-4/AA-4.6#S0162">type_conversion</a></code> is static if the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denotes a static scalar subtype and the operand is a static expression.<br /></li>
<MarginText>44.f</MarginText>
<li>All numeric literals are now static, even if the expected type is a formal scalar type. This is useful in <code><a href="../AA-5/AA-5.4#S0176">case_statement</a></code>s and <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code>s, which both now allow a value of a formal scalar type to control the selection, to ease conversion of a package into a generic package. Similarly, named array aggregates are also permitted for array types with an index type that is a formal scalar type. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>44.g</MarginText>
<Admonition type="aarm" aarm="note">
The rules for the evaluation of static expressions are revised to require exact evaluation at compile time, and force a machine number result when crossing from the static realm to the dynamic realm, to enhance portability and predictability. Exact evaluation is not required for descendants of a formal scalar type, to simplify generic code sharing and to avoid generic contract model problems.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.h</MarginText>
<Admonition type="aarm" aarm="note">
Static expressions are legal even if an intermediate in the expression goes outside the base range of the type. Therefore, the following will succeed in Ada 95, whereas it might raise an exception in Ada 83: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.i</MarginText>
<CodeBlock language="ada">
type Short_Int is range -32_768 .. 32_767;{"\n"}I : Short_Int := -32_768;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.j</MarginText>
<Admonition type="aarm" aarm="note">
This might raise an exception in Ada 83 because "32_768" is out of range, even though "&ndash;32_768" is not. In Ada 95, this will always succeed.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.k</MarginText>
<Admonition type="aarm" aarm="note">
Certain expressions involving string operations (in particular concatenation and membership tests) are considered static in Ada 95.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.l</MarginText>
<Admonition type="aarm" aarm="note">
The reason for this change is to simplify the rule requiring compile-time-known string expressions as the link name in an interfacing pragma, and to simplify the preelaborability rules. <br /></Admonition>
</AnnotatedOnly>


#### Incompatibilities With Ada 83

<AnnotatedOnly>
<MarginText>44.m</MarginText>
<Admonition type="aarm" aarm="note">
An Ada 83 program that uses an out-of-range static value is illegal in Ada 95, unless the expression is part of a larger static expression, or the expression is not evaluated due to being on the right-hand side of a short-circuit control form. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 83

<AnnotatedOnly>
<MarginText>44.n/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
This subclause (and <a href="../AA-4/AA-4.5#Subclause_4.5.5">4.5.5</a>, &ldquo;<a href="../AA-4/AA-4.5#Subclause_4.5.5">Multiplying Operators</a>&rdquo;) subsumes the RM83 section on Universal Expressions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.o</MarginText>
<Admonition type="aarm" aarm="note">
The existence of static string expressions necessitated changing the definition of static subtype to include string subtypes. Most occurrences of "static subtype" have been changed to "static scalar subtype", in order to preserve the effect of the Ada 83 rules. This has the added benefit of clarifying the difference between "static subtype" and "statically constrained subtype", which has been a source of confusion. In cases where we allow static string subtypes, we explicitly use phrases like "static string subtype" or "static (scalar or string) subtype", in order to clarify the meaning for those who have gotten used to the Ada 83 terminology.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.p</MarginText>
<Admonition type="aarm" aarm="note">
In Ada 83, an expression was considered nonstatic if it raised an exception. Thus, for example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.q</MarginText>
<CodeBlock language="ada">
Bad: constant := 1/0; -- Illegal!{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.r</MarginText>
<Admonition type="aarm" aarm="note">
was illegal because 1/0 was not static. In Ada 95, the above example is still illegal, but for a different reason: 1/0 is static, but there's a separate rule forbidding the exception raising.<br /></Admonition>
</AnnotatedOnly>


#### Inconsistencies With Ada 95

<AnnotatedOnly>
<MarginText>44.s/2</MarginText>
<MarginInfo items={["AI95-00268-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Rounding of static real expressions is implementation-defined in Ada 2005, while it was specified as away from zero in (original) Ada 95. This could make subtle differences in programs. However, the original Ada 95 rule required rounding that (probably) differed from the target processor, thus creating anomalies where the value of a static expression was required to be different than the same expression evaluated at run time. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 95

<AnnotatedOnly>
<MarginText>44.t/2</MarginText>
<MarginInfo items={["AI95-00263-01", "AI95-00268-01"]} />
<Admonition type="aarm" aarm="note">
The Ada 95 wording that defined static subtypes unintentionally failed to exclude formal derived types that happen to be scalar (these aren't formal scalar types); and had a parenthetical remark excluding formal string types - but that was neither necessary nor parenthetical (it didn't follow from other wording). This issue also applies to the rounding rules for real static expressions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.u/2</MarginText>
<MarginInfo items={["AI95-00269-01"]} />
<Admonition type="aarm" aarm="note">
Ada 95 didn't clearly define the bounds of a value of a static expression for universal types and for &ldquo;any integer/float/fixed type&rdquo;. We also make it clear that we do not intend exact evaluation of static expressions in an instance body if the expressions aren't static in the generic body.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.v/2</MarginText>
<MarginInfo items={["AI95-00311-01"]} />
<Admonition type="aarm" aarm="note">
We clarify that the first subtype of a scalar formal type has a nonstatic, nonnull constraint. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 2005

<AnnotatedOnly>
<MarginText>44.w/3</MarginText>
<MarginInfo items={["AI05-0147-1", "AI05-0188-1"]} />
<Admonition type="aarm" aarm="note">
Added wording to define staticness and the lack of evaluation for <code><a href="../AA-4/AA-4.5#S0149">if_expression</a></code>s and <code><a href="../AA-4/AA-4.5#S0151">case_expression</a></code>s. These are new and defined elsewhere.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.x/3</MarginText>
<MarginInfo items={["AI05-0153-3"]} />
<Admonition type="aarm" aarm="note">
Added wording to prevent subtypes that have dynamic predicates (see <a href="../AA-3/AA-3.2#Subclause_3.2.4">3.2.4</a>) from being static.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.y/3</MarginText>
<MarginInfo items={["AI05-0158-1"]} />
<Admonition type="aarm" aarm="note">
Revised wording for membership tests to allow for the new possibilities allowed by the <code><a href="../AA-4/AA-4.4#S0136">membership_choice_list</a></code>. <br /></Admonition>
</AnnotatedOnly>


#### Incompatibilities With Ada 2012

<AnnotatedOnly>
<MarginText>44.z/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<Admonition type="aarm" aarm="note">
Added a missing exclusion for concatenations of a string type descended from a formal array type. This could potentially make some expression non-static; but as that could only matter in a context where a static string is required (such as the Link_Name aspect), it is quite unlikely.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.aa/5</MarginText>
<MarginInfo items={["AI12-0385-1"]} />
<Admonition type="aarm" aarm="note">
Shifting and rotating functions declared in package Interfaces are now static. This could potentially make some expression illegal that is legal if nonstatic (as in Ada 2012). While this can happen especially in conditional code that is not in use, it is quite unlikely given typical uses of shifting or rotating functions. <br /></Admonition>
</AnnotatedOnly>


#### Extensions to Ada 2012

<AnnotatedOnly>
<MarginText>44.bb/5</MarginText>
<MarginInfo items={["AI12-0201-1"]} />
<Admonition type="aarm" aarm="note">
Expressions involving string relational operators or string type conversions now can be static. Additionally, the length limit on static string constants was removed as being a hazard without much help to implementations. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 2012

<AnnotatedOnly>
<MarginText>44.cc/5</MarginText>
<MarginInfo items={["AI12-0064-2"]} />
<Admonition type="aarm" aarm="note">
Defined the staticness of the Nonblocking attribute (see <a href="../AA-9/AA-9.5">9.5</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.dd/5</MarginText>
<MarginInfo items={["AI12-0075-1"]} />
<Admonition type="aarm" aarm="note">
Expression functions can be static if declared correctly; this is documented as an extension in <a href="../AA-6/AA-6.8">6.8</a>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.ee/5</MarginText>
<MarginInfo items={["AI12-0249-1", "AI12-0394-1"]} />
<Admonition type="aarm" aarm="note">
A <code><a href="../AA-2/AA-2.4#S0006">numeric_literal</a></code> or named number can be non-static if they interpreted using an Integer_Literal or Real_Literal aspect (see <a href="../AA-4/AA-4.2#Subclause_4.2.1">4.2.1</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.ff/5</MarginText>
<MarginInfo items={["AI12-0322-1"]} />
<Admonition type="aarm" aarm="note">
Clarified that a target name symbol can statically denote an entity if the associated <em>variable_</em><code><a href="../AA-4/AA-4.1#S0091">name</a></code> statically denotes an entity. This is necessary so that target names participate in the anti-order-dependence checks of <a href="../AA-6/AA-6.4#Subclause_6.4.1">6.4.1</a>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.gg/3</MarginText>
<MarginInfo items={["AI12-0368-1", "AI12-0373-1"]} />
<Admonition type="aarm" aarm="note">
Added wording to define staticness for <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code>s. Also moved &ldquo;statically names&rdquo; definition here and used it in array attribute prefix wording.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.hh/5</MarginText>
<MarginInfo items={["AI12-0393-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified that constants whose values do not belong to their nominal subtype are not static. This change potentially would be incompatible, but this case is considered pathological and will not be checked by the ACATS. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_4.9.1"></a>

## 4.9.1  Statically Matching Constraints and Subtypes


#### Static Semantics

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00311-01"]} />
<p>A constraint <em>statically matches</em> another constraint if: <br /></p>

<MarginText>1.1/2</MarginText>
<ul>
<li>both are null constraints;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>1.a/5</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>A null constraint has nothing to do with null exclusions! Unconstrained array subtypes, subtypes with unknown discriminants, and subtypes with no explicit constraint have null constraints (see <a href="../AA-3/AA-3.2">3.2</a>). This terminology became confusing when null exclusions were introduced in the 2007 Amendment. <br /></Admonition>
</AnnotatedOnly>

<MarginText>1.2/2</MarginText>
<ul>
<li>both are static and have equal corresponding bounds or discriminant values;<br /></li>
<MarginText>1.3/2</MarginText>
<li>both are nonstatic and result from the same elaboration of a <code><a href="../AA-3/AA-3.2#S0029">constraint</a></code> of a <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code> or the same evaluation of a <code><a href="../AA-3/AA-3.5#S0037">range</a></code> of a <code><a href="../AA-3/AA-3.6#S0055">discrete_subtype_definition</a></code>; or<br /></li>
<MarginText>1.4/2</MarginText>
<MarginInfo items={["AI95-00311-01"]} />
<li>both are nonstatic and come from the same <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code>. <br /></li>
</ul>
<MarginText>1.5/5</MarginText>
<MarginInfo items={["AI12-0374-2", "AI12-0427-1"]} />
<p>The Global or Global'Class aspects (see <a href="../AA-6/AA-6.1#Subclause_6.1.2">6.1.2</a>) of two entities <em>statically match</em> if both consist of a single <code><a href="../AA-6/AA-6.1#S0209">global_aspect_definition</a></code> where each is the reserved word <strong>null</strong>, or each is of the form &ldquo;<code><a href="../AA-6/AA-6.1#S0211">global_mode</a></code> <code><a href="../AA-6/AA-6.1#S0214">global_designator</a></code>&rdquo; with each <code><a href="../AA-6/AA-6.1#S0211">global_mode</a></code> being the same sequence of reserved words and each <code><a href="../AA-6/AA-6.1#S0214">global_designator</a></code> being the same reserved word, or each being a <code><a href="../AA-6/AA-6.1#S0215">global_name</a></code> that statically names the same entity.<br /></p>

<MarginText>2/5</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00254-01", "AI05-0153-3", "AI12-0059-1", "AI12-0374-2"]} />
<p>A subtype <em>statically matches</em> another subtype of the same type if they have statically matching constraints, all predicate specifications that apply to them come from the same declarations, Nonblocking aspects have the same value, global aspects statically match, Object_Size (see <a href="../AA-13/AA-13.3">13.3</a>) has been specified to have a nonconfirming value for either both or neither, and the nonconfirming values, if any, are the same, and, for access subtypes, either both or neither exclude null. Two anonymous access-to-object subtypes statically match if their designated subtypes statically match, and either both or neither exclude null, and either both or neither are access-to-constant. Two anonymous access-to-subprogram subtypes statically match if their designated profiles are subtype conformant, and either both or neither exclude null. <br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Statically matching constraints and subtypes are the basis for subtype conformance of profiles (see <a href="../AA-6/AA-6.3#Subclause_6.3.1">6.3.1</a>). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Even though anonymous access types always represent different types, they can statically match. That's important so that they can be used widely. For instance, if this wasn't true, access parameters and access discriminants could never conform, so they couldn't be used in separate specifications. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.c/5</MarginText>
<MarginInfo items={["AI12-0059-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If one of the subtypes is not yet frozen, an implementation may have to repeat the check when the subtypes are both frozen (as it is impossible to check the Object_Size part before the subtypes are frozen). This recheck can only make a previously statically matching subtype fail to match; it cannot make a match legal. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.d/5</MarginText>
<MarginInfo items={["AI12-0059-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>We exclude the case where both Object_Sizes are confirming so that we don't introduce an incompatibility for existing Ada code. But practically the implementation can simply check that the Object_Size values are the same, as we have a rule in <a href="../AA-13/AA-13.1">13.1</a> that the subtype-specific aspects (such as Object_Size) are always the same for statically matching subtypes. We wrote the rules this way to avoid having wording that appeared to require predicting the future ("would statically match if ..."). <br /></Admonition>
</AnnotatedOnly>

<MarginText>3</MarginText>
<p>Two ranges of the same type <em>statically match</em> if both result from the same evaluation of a <code><a href="../AA-3/AA-3.5#S0037">range</a></code>, or if both are static and have equal corresponding bounds. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The notion of static matching of ranges is used in <a href="../AA-12/AA-12.5#Subclause_12.5.3">12.5.3</a>, &ldquo;<a href="../AA-12/AA-12.5#Subclause_12.5.3">Formal Array Types</a>&rdquo;; the index ranges of formal and actual constrained array subtypes have to statically match. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4/3</MarginText>
<MarginInfo items={["AI05-0086-1", "AI05-0153-3"]} />
<p>A constraint is <em>statically compatible</em> with a scalar subtype if it statically matches the constraint of the subtype, or if both are static and the constraint is compatible with the subtype. A constraint is <em>statically compatible</em> with an access or composite subtype if it statically matches the constraint of the subtype, or if the subtype is unconstrained. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Static compatibility is required when constraining a parent subtype with a discriminant from a new <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>. See <a href="../AA-3/AA-3.7">3.7</a>. Static compatibility is also used in matching generic formal derived types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that statically compatible with a subtype does not imply compatible with a type. It is OK since the terms are used in different contexts. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/3</MarginText>
<MarginInfo items={["AI05-0153-3"]} />
<p>Two statically matching subtypes are statically compatible with each other. In addition, a subtype <em>S1</em> is statically compatible with a subtype <em>S2</em> if: <br /></p>

<MarginText>6/3</MarginText>
<ul>
<li>the constraint of <em>S1</em> is statically compatible with <em>S2</em>, and<br /></li>
<MarginText>7/3</MarginText>
<MarginInfo items={["AI05-0086-1"]} />
<li>if <em>S2</em> excludes null, so does <em>S1</em>, and<br /></li>
<MarginText>8/3</MarginText>
<li>either: <br /></li>
</ul>
<MarginText>9/3</MarginText>
<ul>
<li>all predicate specifications that apply to <em>S2</em> apply also to <em>S1</em>, or<br /></li>
<MarginText>10/4</MarginText>
<MarginInfo items={["AI05-0290-1", "AI12-0071-1"]} />
<li>both subtypes are static, every value that satisfies the predicates of <em>S1</em> also satisfies the predicates of <em>S2</em>, and it is not the case that both types each have at least one applicable predicate specification, predicate checks are enabled (see <a href="../AA-11/AA-11.4#Subclause_11.4.2">11.4.2</a>) for <em>S2</em>, and predicate checks are not enabled for <em>S1</em>. <br /></li>
</ul>

#### Wording Changes from Ada 83

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="note">
This subclause is new to Ada 95. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 95

<AnnotatedOnly>
<MarginText>10.b/2</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00254-01"]} />
<Admonition type="aarm" aarm="note">
Added static matching rules for null exclusions and anonymous access-to-subprogram types; both of these are new.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.c/2</MarginText>
<MarginInfo items={["AI95-00311-01"]} />
<Admonition type="aarm" aarm="note">
We clarify that the constraint of the first subtype of a scalar formal type statically matches itself. <br /></Admonition>
</AnnotatedOnly>


#### Incompatibilities With Ada 2005

<AnnotatedOnly>
<MarginText>10.d/3</MarginText>
<MarginInfo items={["AI05-0086-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Updated the statically compatible rules to take null exclusions into account. This is technically incompatible, as it could cause a legal Ada 2005 program to be rejected; however, such a program violates the intent of the rules (for instance, <a href="../AA-3/AA-3.7">3.7</a>(15)) and this probably will simply detect bugs. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 2005

<AnnotatedOnly>
<MarginText>10.e/3</MarginText>
<MarginInfo items={["AI05-0153-3", "AI05-0290-1"]} />
<Admonition type="aarm" aarm="note">
Modified static matching and static compatibility to take predicate aspects (see <a href="../AA-3/AA-3.2#Subclause_3.2.4">3.2.4</a>) into account. <br /></Admonition>
</AnnotatedOnly>


#### Wording Changes from Ada 2012

<AnnotatedOnly>
<MarginText>10.f/4</MarginText>
<MarginInfo items={["AI12-0071-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> Updated wording of static compatibility to use the new term "satisfies the predicates" (see <a href="../AA-3/AA-3.2#Subclause_3.2.4">3.2.4</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.g/5</MarginText>
<MarginInfo items={["AI12-0059-1"]} />
<Admonition type="aarm" aarm="note">
Updated wording to take nonconfirming values of Object_Size into account.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.h/5</MarginText>
<MarginInfo items={["AI12-0374-2"]} />
<Admonition type="aarm" aarm="note">
Static matching now includes the effects of Global aspects and the Nonblocking aspect. <br /></Admonition>
</AnnotatedOnly>

