---
sidebar_position:  51
---

# 6.1. Subprogram Declarations

:::danger
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[A <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> declares a procedure or function.] <br /></p>


#### Syntax

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00218-03", "AI05-0183-1"]} />

<CodeBlock>
<code>subprogram{"_"}declaration</code><a id="S0195"></a><code> ::= </code><br />    [<code><a href="/docs/arm/AA-8/AA-8.3#S0234">overriding_indicator</a></code>]<br />    <code><a href="/docs/arm/AA-6/AA-6.1#S0196">subprogram_specification</a></code><br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<p class="Indented2"><i>This paragraph was deleted.</i><br /></p>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />

<CodeBlock>
<code>subprogram{"_"}specification</code><a id="S0196"></a><code> ::= </code><br />    <code><a href="/docs/arm/AA-6/AA-6.1#S0197">procedure_specification</a></code><br />  | <code><a href="/docs/arm/AA-6/AA-6.1#S0198">function_specification</a></code><br />

</CodeBlock>
<MarginText>4.1/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />

<CodeBlock>
<code>procedure{"_"}specification</code><a id="S0197"></a><code> ::= </code><br />    <b>procedure</b> <code><a href="/docs/arm/AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> <code><a href="/docs/arm/AA-6/AA-6.1#S0204">parameter_profile</a></code><br />

</CodeBlock>
<MarginText>4.2/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />

<CodeBlock>
<code>function{"_"}specification</code><a id="S0198"></a><code> ::= </code><br />    <b>function</b> <code><a href="/docs/arm/AA-6/AA-6.1#S0200">defining_designator</a></code> <code><a href="/docs/arm/AA-6/AA-6.1#S0205">parameter_and_result_profile</a></code><br />

</CodeBlock>
<MarginText>5</MarginText>

<CodeBlock>
<code>designator</code><a id="S0199"></a><code> ::= </code>[<code><a href="/docs/arm/AA-10/AA-10.1#S0291">parent_unit_name</a></code> . ]<code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code> | <code><a href="/docs/arm/AA-6/AA-6.1#S0202">operator_symbol</a></code><br />

</CodeBlock>
<MarginText>6</MarginText>

<CodeBlock>
<code>defining{"_"}designator</code><a id="S0200"></a><code> ::= </code><br />    <code><a href="/docs/arm/AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> | <code><a href="/docs/arm/AA-6/AA-6.1#S0203">defining_operator_symbol</a></code><br />

</CodeBlock>
<MarginText>7</MarginText>

<CodeBlock>
<code>defining{"_"}program{"_"}unit{"_"}name</code><a id="S0201"></a><code> ::= </code>[<code><a href="/docs/arm/AA-10/AA-10.1#S0291">parent_unit_name</a></code> . ]<code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code><br />

</CodeBlock>
<MarginText>8</MarginText>
<p class="Indented2">[The optional <code><a href="/docs/arm/AA-10/AA-10.1#S0291">parent_unit_name</a></code> is only allowed for library units (see <a href="/docs/arm/AA-10/AA-10.1#Subclause_10.1.1">10.1.1</a>).] <br /></p>

<MarginText>9</MarginText>

<CodeBlock>
<code>operator{"_"}symbol</code><a id="S0202"></a><code> ::= </code><code><a href="/docs/arm/AA-2/AA-2.6#S0016">string_literal</a></code><br />

</CodeBlock>
<MarginText>10/5</MarginText>
<MarginInfo items={["AI95-00395-01", "AI05-0299-1", "AI12-0449-1"]} />
<p class="Indented2">The sequence of characters in an <code><a href="/docs/arm/AA-6/AA-6.1#S0202">operator_symbol</a></code> shall form a reserved word, a delimiter, or compound delimiter that corresponds to an operator belonging to one of the six categories of operators defined in <a href="/docs/arm/AA-4/AA-4.5">4.5</a>.<br /></p>

<AnnotatedOnly>
<MarginText>10.a/3</MarginText>
<MarginInfo items={["AI95-00395-01", "AI05-0090-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>The &ldquo;sequence of characters&rdquo; of the string literal of the operator is a technical term (see <a href="/docs/arm/AA-2/AA-2.6">2.6</a>), and does not include the surrounding quote characters. As defined in <a href="/docs/arm/AA-2/AA-2.2">2.2</a>, lexical elements are &ldquo;formed&rdquo; from a sequence of characters. Spaces are not allowed, and upper and lower case is not significant. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>

<CodeBlock>
<code>defining{"_"}operator{"_"}symbol</code><a id="S0203"></a><code> ::= </code><code><a href="/docs/arm/AA-6/AA-6.1#S0202">operator_symbol</a></code><br />

</CodeBlock>
<MarginText>12</MarginText>

<CodeBlock>
<code>parameter{"_"}profile</code><a id="S0204"></a><code> ::= </code>[<code><a href="/docs/arm/AA-6/AA-6.1#S0206">formal_part</a></code>]<br />

</CodeBlock>
<MarginText>13/2</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00318-02"]} />

<CodeBlock>
<code>parameter{"_"}and{"_"}result{"_"}profile</code><a id="S0205"></a><code> ::= </code><br />    [<code><a href="/docs/arm/AA-6/AA-6.1#S0206">formal_part</a></code>] <b>return</b> [<code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code>] <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code><br />  | [<code><a href="/docs/arm/AA-6/AA-6.1#S0206">formal_part</a></code>] <b>return</b> <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code><br />

</CodeBlock>
<MarginText>14</MarginText>

<CodeBlock>
<code>formal{"_"}part</code><a id="S0206"></a><code> ::= </code><br />   (<code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code> {"{"}; <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code>{"}"})<br />

</CodeBlock>
<MarginText>15/5</MarginText>
<MarginInfo items={["AI95-00231-01", "AI05-0142-4", "AI12-0395-1"]} />

<CodeBlock>
<code>parameter{"_"}specification</code><a id="S0207"></a><code> ::= </code><br />    <code><a href="/docs/arm/AA-3/AA-3.3#S0033">defining_identifier_list</a></code> : [<b>aliased</b>] <code><a href="/docs/arm/AA-6/AA-6.1#S0208">mode</a></code> [<code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code>] <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code> [:= <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>]<br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>]<br />  | <code><a href="/docs/arm/AA-3/AA-3.3#S0033">defining_identifier_list</a></code> : <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code> [:= <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>]<br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>]<br />

</CodeBlock>
<AnnotatedOnly>
<MarginText>15.a/5</MarginText>
<MarginInfo items={["AI12-0395-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>Only implementation-defined aspects are allowed on formal parameters in Ada 2022. Implementers are cautioned that any aspect allowed on a formal parameter will need conformance rules. If, for instance, an aspect changed the representation of a parameter, rules would be needed to ensure that the representation is the same for the specification and body. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>16</MarginText>

<CodeBlock>
<code>mode</code><a id="S0208"></a><code> ::= </code>[<b>in</b>] | <b>in</b> <b>out</b> | <b>out</b><br />

</CodeBlock>

#### Name Resolution Rules

<MarginText>17</MarginText>
<p>A <i>formal parameter</i> is an object [directly visible within a <code><a href="/docs/arm/AA-6/AA-6.3#S0216">subprogram_body</a></code>] that represents the actual parameter passed to the subprogram in a call; it is declared by a <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code>. For a formal parameter, the expected type for its <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>, if any, is that of the formal parameter. <br /></p>


#### Legality Rules

<MarginText>18/3</MarginText>
<MarginInfo items={["AI05-0143-1"]} />
<p>The <i>parameter mode</i> of a formal parameter conveys the direction of information transfer with the actual parameter: <b>in</b>, <b>in out</b>, or <b>out</b>. Mode <b>in</b> is the default, and is the mode of a parameter defined by an <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>18.a/3</MarginText>
<MarginInfo items={["AI05-0143-1"]} />
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<MarginText>19</MarginText>
<p>A <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code> is only allowed in a <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code> for a formal parameter of mode <b>in</b>.<br /></p>

<MarginText>20/3</MarginText>
<MarginInfo items={["AI95-00348-01", "AI05-0177-1", "AI05-0229-1"]} />
<p>A <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> or a <code><a href="/docs/arm/AA-12/AA-12.1#S0311">generic_subprogram_declaration</a></code> requires a completion [unless the Import aspect (see <a href="/docs/arm/AA-B/AA-B.1">B.1</a>) is True for the declaration; the completion shall be a body or a <code><a href="/docs/arm/AA-8/AA-8.5#S0238">renaming_declaration</a></code> (see <a href="/docs/arm/AA-8/AA-8.5">8.5</a>)]. [A completion is not allowed for an <code><a href="/docs/arm/AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> (see <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>), a <code><a href="/docs/arm/AA-6/AA-6.7#S0227">null_procedure_declaration</a></code> (see <a href="/docs/arm/AA-6/AA-6.7">6.7</a>), or an <code><a href="/docs/arm/AA-6/AA-6.8#S0228">expression_function_declaration</a></code> (see <a href="/docs/arm/AA-6/AA-6.8">6.8</a>).] <br /></p>

<AnnotatedOnly>
<MarginText>20.a/3</MarginText>
<MarginInfo items={["AI95-00348-01", "AI05-0177-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>Abstract subprograms , null procedures, and expression functions are not declared by <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code>s, and so do not require completion (although the latter two can <i>be</i> completions). Protected subprograms are declared by <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code>s, and so require completion. Note that an abstract subprogram is a subprogram, a null procedure is a subprogram, an expression function is a subprogram, and a protected subprogram is a subprogram, but a generic subprogram is not a subprogram. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="proof">
<b></b>When the Import aspect is True for any entity, no completion is allowed (see <a href="/docs/arm/AA-B/AA-B.1">B.1</a>). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>21</MarginText>
<p>A <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> that denotes a formal parameter is not allowed within the <code><a href="/docs/arm/AA-6/AA-6.1#S0206">formal_part</a></code> in which it is declared, nor within the <code><a href="/docs/arm/AA-6/AA-6.1#S0206">formal_part</a></code> of a corresponding body or <code><a href="/docs/arm/AA-9/AA-9.5#S0258">accept_statement</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>By contrast, <code><a href="/docs/arm/AA-12/AA-12.1#S0314">generic_formal_parameter_declaration</a></code>s are visible to subsequent declarations in the same <code><a href="/docs/arm/AA-12/AA-12.1#S0313">generic_formal_part</a></code>. <br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>22</MarginText>
<p>The <i>profile</i> of (a view of) a callable entity is either a <code><a href="/docs/arm/AA-6/AA-6.1#S0204">parameter_profile</a></code> or <code><a href="/docs/arm/AA-6/AA-6.1#S0205">parameter_and_result_profile</a></code>[; it embodies information about the interface to that entity &mdash; for example, the profile includes information about parameters passed to the callable entity. All callable entities have a profile &mdash; enumeration literals, other subprograms, and entries. An access-to-subprogram type has a designated profile.] Associated with a profile is a calling convention. A <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> declares a procedure or a function, as indicated by the initial reserved word, with name and profile as given by its specification.<br /></p>

<MarginText>23/2</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00318-02"]} />
<p>The nominal subtype of a formal parameter is the subtype determined by the optional <code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code> and the <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code>, or defined by the <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>, in the <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code>. The nominal subtype of a function result is the subtype determined by the optional <code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code> and the <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code>, or defined by the <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>, in the <code><a href="/docs/arm/AA-6/AA-6.1#S0205">parameter_and_result_profile</a></code>. <br /></p>

<MarginText>23.1/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<p>An <i>explicitly aliased parameter</i> is a formal parameter whose <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code> includes the reserved word <b>aliased</b>.<br /></p>

<MarginText>24/2</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00254-01", "AI95-00318-02"]} />
<p>An <i>access parameter</i> is a formal <b>in</b> parameter specified by an <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>. An <i>access result type</i> is a function result type specified by an <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>. An access parameter or result type is of an anonymous access type (see <a href="/docs/arm/AA-3/AA-3.10">3.10</a>). [Access parameters of an access-to-object type allow dispatching calls to be controlled by access values. Access parameters of an access-to-subprogram type permit calls to subprograms passed as parameters irrespective of their accessibility level.]<br /></p>

<AnnotatedOnly>
<MarginText>24.a/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>Access result types have normal accessibility and thus don't have any special properties worth noting here. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>25</MarginText>
<p>The <i>subtypes of a profile</i> are: <br /></p>

<MarginText>26</MarginText>
<ul>
<li>For any non-access parameters, the nominal subtype of the parameter.<br /></li>
<MarginText>27/2</MarginText>
<MarginInfo items={["AI95-00254-01"]} />
<li>For any access parameters of an access-to-object type, the designated subtype of the parameter type.<br /></li>
<MarginText>27.1/3</MarginText>
<MarginInfo items={["AI95-00254-01", "AI05-0164-1"]} />
<li>For any access parameters of an access-to-subprogram type, the subtypes of the designated profile of the parameter type.<br /></li>
<MarginText>28/2</MarginText>
<MarginInfo items={["AI95-00231-01", "AI95-00318-02"]} />
<li>For any non-access result, the nominal subtype of the function result.<br /></li>
<MarginText>28.1/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<li>For any access result type of an access-to-object type, the designated subtype of the result type.<br /></li>
<MarginText>28.2/3</MarginText>
<MarginInfo items={["AI95-00318-02", "AI05-0164-1"]} />
<li>For any access result type of an access-to-subprogram type, the subtypes of the designated profile of the result type.<br /></li>
</ul>
<MarginText>29</MarginText>
<p>[ The <i>types of a profile</i> are the types of those subtypes.]<br /></p>

<MarginText>30/3</MarginText>
<MarginInfo items={["AI95-00348-01", "AI05-0177-1"]} />
<p>[A subprogram declared by an <code><a href="/docs/arm/AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> is abstract; a subprogram declared by a <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> is not. See <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>, &ldquo;<a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">Abstract Types and Subprograms</a>&rdquo;. Similarly, a procedure declared by a <code><a href="/docs/arm/AA-6/AA-6.7#S0227">null_procedure_declaration</a></code> is a null procedure; a procedure declared by a <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> is not. See <a href="/docs/arm/AA-6/AA-6.7">6.7</a>, &ldquo;<a href="/docs/arm/AA-6/AA-6.7">Null Procedures</a>&rdquo;. Finally, a function declared by an <code><a href="/docs/arm/AA-6/AA-6.8#S0228">expression_function_declaration</a></code> is an expression function; a function declared by a <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> is not. See <a href="/docs/arm/AA-6/AA-6.8">6.8</a>, &ldquo;<a href="/docs/arm/AA-6/AA-6.8">Expression Functions</a>&rdquo;.]<br /></p>

<MarginText>30.1/2</MarginText>
<MarginInfo items={["AI95-00218-03"]} />
<p>[An <code><a href="/docs/arm/AA-8/AA-8.3#S0234">overriding_indicator</a></code> is used to indicate whether overriding is intended. See <a href="/docs/arm/AA-8/AA-8.3#Subclause_8.3.1">8.3.1</a>, &ldquo;<a href="/docs/arm/AA-8/AA-8.3#Subclause_8.3.1">Overriding Indicators</a>&rdquo;.] <br /></p>


#### Dynamic Semantics

<MarginText>31/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<p>The elaboration of a <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code> has no effect. <br /></p>

<AnnotatedOnly>
<MarginText>32</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   A <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code> with several identifiers is equivalent to a sequence of single <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code>s, as explained in <a href="/docs/arm/AA-3/AA-3.3">3.3</a>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>33</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   Abstract subprograms do not have bodies, and cannot be used in a nondispatching call (see <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>, &ldquo;<a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">Abstract Types and Subprograms</a>&rdquo;).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>34</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   The evaluation of <code><a href="/docs/arm/AA-3/AA-3.7#S0063">default_expression</a></code>s is caused by certain calls, as described in <a href="/docs/arm/AA-6/AA-6.4#Subclause_6.4.1">6.4.1</a>. They are not evaluated during the elaboration of the subprogram declaration.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>35</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 4   Subprograms can be called recursively and can be called concurrently from multiple tasks. <br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>36</MarginText>
<p><i>Examples of subprogram declarations:</i> <br /></p>

<MarginText>37</MarginText>
<CodeBlock language="ada">
procedure Traverse{"_"}Tree;{"\n"}procedure Increment(X : in out Integer);{"\n"}procedure Right{"_"}Indent(Margin : out Line{"_"}Size);          -- see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.4">3.5.4</a>{"\n"}procedure Switch(From, To : in out Link);                -- see <a href="/docs/arm/AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a>{"\n"}
<MarginText>38</MarginText>
function Random return Probability;                      -- see <a href="/docs/arm/AA-3/AA-3.5#Subclause_3.5.7">3.5.7</a>{"\n"}
<MarginText>39/4</MarginText>
<MarginInfo items={["AI12-0056-1"]} />
function Min{"_"}Cell(X : Link) return Cell;                 -- see <a href="/docs/arm/AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a>{"\n"}function Next{"_"}Frame(K : Positive) return Frame;          -- see <a href="/docs/arm/AA-3/AA-3.10">3.10</a>{"\n"}function Dot{"_"}Product(Left, Right : Vector) return Real;  -- see <a href="/docs/arm/AA-3/AA-3.6">3.6</a>{"\n"}function Find(B : aliased in out Barrel; Key : String) return Real;{"\n"}                                                         -- see <a href="/docs/arm/AA-4/AA-4.1#Subclause_4.1.5">4.1.5</a>{"\n"}
<MarginText>40</MarginText>
function "{"*"}"(Left, Right : Matrix) return Matrix;        -- see <a href="/docs/arm/AA-3/AA-3.6">3.6</a>{"\n"}

</CodeBlock>
<MarginText>41</MarginText>
<p><i>Examples of <b>in</b> parameters with default expressions:</i> <br /></p>

<MarginText>42</MarginText>
<CodeBlock language="ada">
procedure Print{"_"}Header(Pages  : in Natural;{"\n"}            Header : in Line    :=  (1 .. Line'Last ={">"} ' '); -- see <a href="/docs/arm/AA-3/AA-3.6">3.6</a>{"\n"}            Center : in Boolean := True);{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.a</MarginText>
<Admonition type="aarm" aarm="note">
The syntax for <code><a href="/docs/arm/AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> is added. The syntax for <code><a href="/docs/arm/AA-6/AA-6.1#S0207">parameter_specification</a></code> is revised to allow for access parameters (see <a href="/docs/arm/AA-3/AA-3.10">3.10</a>)<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.b/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
Program units that are library units may have a <code><a href="/docs/arm/AA-10/AA-10.1#S0291">parent_unit_name</a></code> to indicate the parent of a child (see <a href="/docs/arm/AA-10/AA-10.1#Subclause_10.1.1">10.1.1</a>). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.c</MarginText>
<Admonition type="aarm" aarm="note">
We have incorporated the rules from RM83-6.5, &ldquo;Function Subprograms&rdquo; here and in <a href="/docs/arm/AA-6/AA-6.3">6.3</a>, &ldquo;<a href="/docs/arm/AA-6/AA-6.3">Subprogram Bodies</a>&rdquo;<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.d</MarginText>
<Admonition type="aarm" aarm="note">
We have incorporated the definitions of RM83-6.6, &ldquo;Parameter and Result Type Profile - Overloading of Subprograms&rdquo; here.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.e</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="/docs/arm/AA-6/AA-6.1#S0203">defining_operator_symbol</a></code> is new. It is used for the defining occurrence of an <code><a href="/docs/arm/AA-6/AA-6.1#S0202">operator_symbol</a></code>, analogously to <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code>. Usage occurrences use the <code><a href="/docs/arm/AA-4/AA-4.1#S0092">direct_name</a></code> or <code><a href="/docs/arm/AA-4/AA-4.1#S0099">selector_name</a></code> syntactic categories. The syntax rules for <code><a href="/docs/arm/AA-6/AA-6.1#S0200">defining_designator</a></code> and <code><a href="/docs/arm/AA-6/AA-6.1#S0201">defining_program_unit_name</a></code> are new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.f/2</MarginText>
<MarginInfo items={["AI95-00218-03"]} />
<Admonition type="aarm" aarm="note">
Subprograms now allow <code><a href="/docs/arm/AA-8/AA-8.3#S0234">overriding_indicator</a></code>s for better error checking of overriding.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.g/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code> can be used in a formal parameter declaration. Similarly, an optional <code><a href="/docs/arm/AA-3/AA-3.10#S0083">null_exclusion</a></code> can be used in a function result.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.h/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="note">
The return type of a function can be an anonymous access type. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.i/2</MarginText>
<MarginInfo items={["AI95-00254-01"]} />
<Admonition type="aarm" aarm="note">
A description of the purpose of anonymous access-to-subprogram parameters and the definition of the profile of subprograms containing them was added.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.j/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<Admonition type="aarm" aarm="note">
Split the production for <code><a href="/docs/arm/AA-6/AA-6.1#S0196">subprogram_specification</a></code> in order to make the declaration of null procedures (see <a href="/docs/arm/AA-6/AA-6.7">6.7</a>) easier.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.k/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<Admonition type="aarm" aarm="note">
Moved the Syntax and Dynamic Semantics for <code><a href="/docs/arm/AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> to <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>, so that the syntax and semantics are together. This also keeps abstract and null subprograms similar.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.l/2</MarginText>
<MarginInfo items={["AI95-00395-01"]} />
<Admonition type="aarm" aarm="note">
Revised to allow <code>other{"_"}format</code> characters in <code><a href="/docs/arm/AA-6/AA-6.1#S0202">operator_symbol</a></code>s in the same way as the underlying constructs. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.m/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="note">
Parameters can now be explicitly aliased, allowing parts of function results to designate parameters and forcing by-reference parameter passing.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.n/3</MarginText>
<MarginInfo items={["AI05-0143-1"]} />
<Admonition type="aarm" aarm="note">
The parameters of a function can now have any mode.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.o/3</MarginText>
<MarginInfo items={["AI05-0183-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in a <code><a href="/docs/arm/AA-6/AA-6.1#S0195">subprogram_declaration</a></code>. This is described in <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.p/3</MarginText>
<MarginInfo items={["AI05-0177-1"]} />
<Admonition type="aarm" aarm="note">
Added expression functions (see <a href="/docs/arm/AA-6/AA-6.8">6.8</a>) to the wording. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>42.q/5</MarginText>
<MarginInfo items={["AI12-0395-1"]} />
<Admonition type="aarm" aarm="note">
Parameters now can have an <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>, allowing the specification of (implementation-defined) aspects for individual parameters. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_6.1.1"></a>

## 6.1.1  Preconditions and Postconditions

<MarginText>1/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI12-0045-1", "AI12-0220-1", "AI12-0272-1", "AI12-0396-1"]} />
<p>For a noninstance subprogram [(including a generic formal subprogram)], a generic subprogram, an entry, or an access-to-subprogram type, the following language-defined assertion aspects may be specified with an <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code> (see <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>):<br /></p>

<AnnotatedOnly>
<MarginText>1.a/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0045-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>&ldquo;Noninstance subprogram&rdquo; excludes a subprogram that is an instance of a generic subprogram. In that case, the aspects should be specified on the generic subprogram. If preconditions or postconditions need to be added to an instance of a generic subprogram, it can be accomplished by creating a separate subprogram specification and then completing that specification with a renames-as-body of the instance. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0272-1"]} />
<Admonition type="aarm" aarm="proof">
<b></b>A generic formal subprogram is a subprogram, and there are no rules to prevent using these attributes on it. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>2/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1"]} />
<dt><br/>Pre</dt>
<dl>
<dd>This aspect specifies a specific precondition for a callable entity or an access-to-subprogram type; it shall be specified by an <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>, called a <i>specific precondition expression</i>. If not specified for an entity, the specific precondition expression for the entity is the enumeration literal True.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>2.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>In this and the following rules, we are talking about the enumeration literal True declared in package Standard (see <a href="/docs/arm/AA-A/AA-A.1">A.1</a>), and not some other value or identifier True. That matters as some rules depend on full conformance of these expressions, which depends on the specific declarations involved. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Pre: </b>Precondition; a condition that is expected to hold true before a call.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>3/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0254-1", "AI05-0262-1", "AI12-0418-1"]} />
<dt><br/>Pre'Class</dt>
<dl>
<dd>This aspect specifies a class-wide precondition for a dispatching operation of a tagged type and its descendants; it shall be specified by an <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>, called a <i>class-wide precondition expression</i>. If not specified for an entity, then if no other class-wide precondition applies to the entity, the class-wide precondition expression for the entity is the enumeration literal True.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>3.a/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0254-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>If other class-wide preconditions apply to the entity and no class-wide precondition is specified, no class-wide precondition is defined for the entity; of course, the class-wide preconditions (of ancestors) that apply are still going to be checked. We need subprograms that don't have ancestors and don't specify a class-wide precondition to have a class-wide precondition of True, so that adding such a precondition to a descendant has no effect (necessary as a dispatching call through the root routine would not check any precondition).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1"]} />
<Admonition type="aarm" aarm="note">
Pre'Class cannot be specified on an access-to-subprogram type because of a Legality Rule found in <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a> that limits 'Class aspects to tagged types and primitive subprograms of tagged types. The same is true for Post'Class (below). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.c/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Pre'Class: </b>Precondition that applies to corresponding subprograms of descendant types.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>4/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1"]} />
<dt><br/>Post</dt>
<dl>
<dd>This aspect specifies a specific postcondition for a callable entity or an access-to-subprogram type; it shall be specified by an <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>, called a <i>specific postcondition expression</i>. If not specified for an entity, the specific postcondition expression for the entity is the enumeration literal True.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>4.a/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Post: </b>Postcondition; a condition that will hold true after a call.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>5/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0262-1", "AI12-0418-1"]} />
<dt><br/>Post'Class</dt>
<dl>
<dd>This aspect specifies a class-wide postcondition for a dispatching operation of a tagged type and its descendants; it shall be specified by an <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>, called a <i>class-wide postcondition expression</i>. If not specified for an entity, the class-wide postcondition expression for the entity is the enumeration literal True. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>5.a/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Post'Class: </b>Postcondition that applies to corresponding subprograms of descendant types.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>In the AARM notes below, we use the terms &ldquo;inherited&rdquo; and &ldquo;inheritance&rdquo; informally with respect to class-wide pre/post-conditions, to mean that the aspect applies to corresponding subprograms in descendant types. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.c/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Term entry: </b><b>precondition</b> &mdash; assertion that is expected to be True when a given subprogram is called<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.d/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Term entry: </b><b>postcondition</b> &mdash; assertion that is expected to be True when a given subprogram returns normally<br />
</Admonition>
</AnnotatedOnly>


#### Name Resolution Rules

<MarginText>6/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2"]} />
<p>The expected type for a precondition or postcondition expression is any boolean type.<br /></p>

<MarginText>7/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI12-0113-1", "AI12-0159-1", "AI12-0170-1", "AI12-0418-1"]} />
<p>Within the expression for a Pre'Class or Post'Class aspect for a primitive subprogram <i>S</i> of a tagged type <i>T</i>, a <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> that denotes a formal parameter (or <i>S</i>'Result) of type <i>T</i> is interpreted as though it had a (notional) nonabstract type <i>NT</i> that is a formal derived type whose ancestor type is <i>T</i>, with directly visible primitive operations. Similarly, a <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> that denotes a formal access parameter (or <i>S</i>'Result for an access result) of type access-to-<i>T</i> is interpreted as having type access-to-<i>NT</i>. [The result of this interpretation is that the only operations that can be applied to such <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code>s are those defined for such a formal derived type.]<br /></p>

<AnnotatedOnly>
<MarginText>7.a/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0159-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>This ensures that the expression is well-defined for any primitive subprogram of a type descended from <i>T</i>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0170-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>The operations of <i>NT</i> are also nonabstract, so the rule against a call of an abstract subprogram does not trigger for a class-wide precondition or postcondition. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>8/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0264-1", "AI12-0418-1"]} />
<p>For an <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> with <code><a href="/docs/arm/AA-4/AA-4.1#S0101">attribute_designator</a></code> Old, if the attribute reference has an expected type (or class of types) or shall resolve to a given type, the same applies to the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code>; otherwise, the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> shall be resolved independently of context.<br /></p>


#### Legality Rules

<MarginText>9/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0230-1"]} />
<p>The Pre or Post aspect shall not be specified for an abstract subprogram or a null procedure. [Only the Pre'Class and Post'Class aspects may be specified for such a subprogram.]<br /></p>

<AnnotatedOnly>
<MarginText>9.a/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0183-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>Pre'Class and Post'Class can only be specified on primitive routines of tagged types, by a blanket rule found in <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>10/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0247-1", "AI05-0254-1"]} />
<p>If a type <i>T</i> has an implicitly declared subprogram <i>P</i> inherited from a parent type <i>T1</i> and a homograph (see <a href="/docs/arm/AA-8/AA-8.3">8.3</a>) of <i>P</i> from a progenitor type <i>T2</i>, and<br /></p>

<MarginText>11/3_6.1.1</MarginText>
<ul>
<li>the corresponding primitive subprogram <i>P1</i> of type <i>T1</i> is neither null nor abstract; and<br /></li>
<MarginText>12/3_6.1.1</MarginText>
<li>the class-wide precondition expression True does not apply to <i>P1</i> (implicitly or explicitly); and<br /></li>
<MarginText>13/3_6.1.1</MarginText>
<li>there is a class-wide precondition expression that applies to the corresponding primitive subprogram <i>P2</i> of <i>T2</i> that does not fully conform to any class-wide precondition expression that applies to <i>P1</i>, <br /></li>
</ul>
<MarginText>14/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0247-1", "AI05-0254-1"]} />
<p>then:<br /></p>

<MarginText>15/3_6.1.1</MarginText>
<ul>
<li>If the type <i>T</i> is abstract, the implicitly declared subprogram <i>P</i> is <i>abstract</i>.<br /></li>
<MarginText>16/3_6.1.1</MarginText>
<li>Otherwise, the subprogram <i>P</i> <i>requires overriding</i> and shall be overridden with a nonabstract subprogram.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>16.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>We use the term "requires overriding" here so that this rule is taken into account when calculating visibility in <a href="/docs/arm/AA-8/AA-8.3">8.3</a>; otherwise we would have a mess when this routine is overridden. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Such an inherited subprogram would necessarily violate the Liskov Substitutability Principle (LSP) if called via a dispatching call from an ancestor other than the one that provides the called body. In such a case, the class-wide precondition of the actual body is stronger than the class-wide precondition of the ancestor. If we did not enforce that precondition for the body, the body could be called when the precondition it knows about is False &mdash; such "counterfeiting" of preconditions has to be avoided. But enforcing the precondition violates LSP. We do not want the language to be implicitly creating bodies that violate LSP; the programmer can still write an explicit body that calls the appropriate parent subprogram. In that case, the violation of LSP is explicitly in the code and obvious to code reviewers (both human and automated).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.c/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
We have to say that the subprogram is abstract for an abstract type in this case, so that the next concrete type has to override it for the reasons above. Otherwise, inserting an extra level of abstract types would eliminate the requirement to override (as there is only one declared operation for the concrete type), and that would be bad for the reasons given above. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.d/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>This requires the set of class-wide preconditions that apply to the interface routine to be strictly stronger than those that apply to the concrete routine. Since full conformance requires each name to denote the same declaration, it is unlikely that independently declared preconditions would conform. This rule does allow "diamond inheritance" of preconditions, and of course no preconditions at all match.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.e/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
We considered adopting a rule that would allow examples where the expressions would conform after all inheritance has been applied, but this is complex and is not likely to be common in practice. Since the penalty here is just that an explicit overriding is required, the complexity is too much. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>17/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0247-1"]} />
<p>If a renaming of a subprogram or entry <i>S1</i> overrides an inherited subprogram <i>S2</i>, then the overriding is illegal unless each class-wide precondition expression that applies to <i>S1</i> fully conforms to some class-wide precondition expression that applies to <i>S2</i> and each class-wide precondition expression that applies to <i>S2</i> fully conforms to some class-wide precondition expression that applies to <i>S1</i>.<br /></p>

<AnnotatedOnly>
<MarginText>17.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Such an overriding subprogram would violate LSP, as the precondition of <i>S1</i> would usually be different (and thus stronger) than the one known to a dispatching call through an ancestor routine of <i>S2</i>. This is always OK if the preconditions match, so we always allow that. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>This only applies to primitives of tagged types; other routines cannot have class-wide preconditions. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>17.1/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0131-1"]} />
<p>Pre'Class shall not be specified for an overriding primitive subprogram of a tagged type <i>T</i> unless the Pre'Class aspect is specified for the corresponding primitive subprogram of some ancestor of <i>T</i>.<br /></p>

<AnnotatedOnly>
<MarginText>17.c/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Any such Pre'Class will have no effect, as it will be <b>or</b>ed with True. As such, it is highly misleading for readers, especially for those who are determining the assumptions that can be made in the body of the primitive subprogram. Note that in this case there is nothing explicit that might indicate that the class-wide precondition is ineffective. This rule does not prevent explicitly writing an ineffective class-wide precondition (for instance, if the parent subprogram has explicitly specified a precondition of True). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>17.2/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0131-1"]} />
<p>In addition to the places where Legality Rules normally apply (see <a href="/docs/arm/AA-12/AA-12.3">12.3</a>), these rules also apply in the private part of an instance of a generic unit. <br /></p>


#### Static Semantics

<MarginText>18/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI12-0113-1", "AI12-0131-1", "AI12-0170-1"]} />
<p>If a Pre'Class or Post'Class aspect is specified for a primitive subprogram <i>S</i> of a tagged type <i>T</i>, or such an aspect defaults to True, then a corresponding expression also applies to the corresponding primitive subprogram <i>S</i> of each descendant of <i>T</i> [(including <i>T</i> itself)]. The <i>corresponding expression</i> is constructed from the associated expression as follows: <br /></p>

<AnnotatedOnly>
<MarginText>18.a/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>A Pre'Class defaults to True only if no class-wide preconditions are inherited for the subprogram. The same is true for Post'Class. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>We have to inherit precondition expressions that default to True, so that later overridings don't strengthen the precondition (a violation of LSP). We do the same for postconditions for consistency. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>18.1/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0113-1"]} />
<ul>
<li>References to formal parameters of <i>S</i> (or to <i>S</i> itself) are replaced with references to the corresponding formal parameters of the corresponding inherited or overriding subprogram <i>S</i> (or to the corresponding subprogram <i>S</i> itself).<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>18.c/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>We have to define the corresponding expression this way as overriding routines are only required to be subtype conformant; in particular, the parameter names can be different. So we have to talk about corresponding parameters without mentioning any names. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>18.2/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0113-1", "AI12-0412-1"]} />
<p>If the primitive subprogram <i>S</i> is not abstract, but the given descendant of <i>T</i> is abstract, then a nondispatching call on <i>S</i> is illegal if any Pre'Class or Post'Class aspect that applies to <i>S</i> is other than a static boolean expression. Similarly, a primitive subprogram of an abstract type <i>T</i>, to which a non-static Pre'Class or Post'Class aspect applies, shall neither be the prefix of an Access attribute{"_"}reference, nor shall it be a generic actual subprogram for a formal subprogram declared by a <code><a href="/docs/arm/AA-12/AA-12.6#S0336">formal_concrete_subprogram_declaration</a></code>.<br /></p>

<AnnotatedOnly>
<MarginText>18.d/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.e/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0412-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>The above rules mean that a concrete primitive of an abstract type is effectively treated as abstract, if any nontrivial Pre'Class or Post'Class aspects apply to it. This makes sense because we are using a notional formal derived type model for such aspects, and an abstract type is not permitted as an actual type for such a formal type. If we didn't do this, the evaluation of the precondition or postcondition of a concrete subprogram of an abstract type could possibly call abstract functions.. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.f/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0412-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>As this Reference Manual was frozen, a significant incompatibility has come to light with the above rule. The wording makes some calls to non-abstract primitives of a tagged abstract type illegal even if no abstract routines are involved in the Pre'Class or Post'Class. It is likely that the above rule will be adjusted; check with ARG work at <a href="http://www.ada-auth.org/arg.html">www.ada-auth.org/arg.html</a> to find the adjusted rules. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>19/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI05-0290-1", "AI12-0220-1"]} />
<p>If performing checks is required by the Pre, Pre'Class, Post, or Post'Class assertion policies (see <a href="/docs/arm/AA-11/AA-11.4#Subclause_11.4.2">11.4.2</a>) in effect at the point of a corresponding aspect specification applicable to a given subprogram, entry, or access-to-subprogram type, then the respective precondition or postcondition expressions are considered <i>enabled</i>.<br /></p>

<AnnotatedOnly>
<MarginText>19.a/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0290-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>If a class-wide precondition or postcondition expression is enabled, it remains enabled when inherited by an overriding subprogram, even if the policy in effect is Ignore for the inheriting subprogram. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>20/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0273-1", "AI12-0280-2"]} />
<p>A subexpression of a postcondition expression is <i>known on entry</i> if it is any of:<br /></p>

<MarginText>21/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>a static subexpression (see <a href="/docs/arm/AA-4/AA-4.9">4.9</a>);<br /></li>
<MarginText>22/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>a literal whose type does not have any Integer{"_"}Literal, Real{"_"}Literal, or String{"_"}Literal aspect specified, or the function specified by such an attribute has aspect Global specified to be <b>null</b>;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.a/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<Admonition type="aarm" aarm="reason">
<b></b>We mention literals explicitly in case they are not static (as when their subtype is not static, they are the literal <b>null</b>, and so on). We exclude literals of types with the aspects that are not Global ={">"} <b>null</b> as those cause a user-written subprogram with possible side effects to be called. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22.1/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1", "AI12-0280-2", "AI12-0422-1"]} />
<ul>
<li>a name statically denoting a full constant declaration which is known to have no variable views (see <a href="/docs/arm/AA-3/AA-3.3">3.3</a>);<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.b/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Constants of types with immutably limited or controlled parts are not allowed by this rule. Generic formal in objects are allowed by this rule (as they are defined to be full constant declarations). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>22.c/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>We only want things that cannot be changed. We can't just say &ldquo;constant&rdquo; since that includes views of variables in some cases (for instance, a dereference of an access to constant object can be a view of a variable). There are other things we could have allowed (like a loop parameter), but having a subprogram declaration where those could be used (like inside of a loop) seems unusual enough to not be worth defining. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22.2/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>a name statically denoting a nonaliased <b>in</b> parameter of an elementary type;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.d/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>All such parameters are by-copy, so the value won't change during the execution of the subprogram. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22.3/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code>;<br /></li>
<MarginText>22.4/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>an invocation of a predefined operator where all of the operands are known on entry;<br /></li>
<MarginText>22.5/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>a function call where the function has aspect Global ={">"} <b>null</b> where all of the actual parameters are known on entry;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.e/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Such a function can only depend on the values of its parameters. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22.6/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>a <code><a href="/docs/arm/AA-4/AA-4.1#S0098">selected_component</a></code> of a known-on-entry <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code>;<br /></li>
<MarginText>22.7/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>an <code><a href="/docs/arm/AA-4/AA-4.1#S0096">indexed_component</a></code> of a known-on-entry <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> where all index <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>s are known on entry;<br /></li>
<MarginText>22.8/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>a parenthesized known-on-entry <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>;<br /></li>
<MarginText>22.9/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>a <code><a href="/docs/arm/AA-4/AA-4.7#S0163">qualified_expression</a></code> or <code><a href="/docs/arm/AA-4/AA-4.6#S0162">type_conversion</a></code> whose operand is a known-on-entry expression;<br /></li>
<MarginText>22.10/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>a <code><a href="/docs/arm/AA-4/AA-4.5#S0148">conditional_expression</a></code> where all of the <code><a href="/docs/arm/AA-4/AA-4.5#S0150">condition</a></code>s, <i>selecting{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>s, and <i>dependent{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>s are known on entry.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.f/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>It's OK if such an expression raises an exception, so long as every evaluation of the expression raises the same exception. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22.11/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0198-1", "AI12-0280-2"]} />
<p>A subexpression of a postcondition expression is <i>unconditionally evaluated</i>, <i>conditionally evaluated</i>, or <i>repeatedly evaluated</i>. A subexpression is considered unconditionally evaluated unless it is conditionally evaluated or repeatedly evaluated.<br /></p>

<MarginText>22.12/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<p>The following subexpressions are repeatedly evaluated:<br /></p>

<MarginText>22.13/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>A subexpression of a predicate of a <code><a href="/docs/arm/AA-4/AA-4.5#S0153">quantified_expression</a></code>;<br /></li>
<MarginText>22.14/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>A subexpression of the expression of an <code><a href="/docs/arm/AA-4/AA-4.3#S0118">array_component_association</a></code>;<br /></li>
<MarginText>22.15/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>A subexpression of the expression of a <code><a href="/docs/arm/AA-4/AA-4.3#S0128">container_element_association</a></code>. <br /></li>
</ul>
<MarginText>22.16/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<p>For a subexpression that is conditionally evaluated, there is a set of <i>determining expressions</i> that determine whether the subexpression is actually evaluated at run time. Subexpressions that are conditionally evaluated and their determining expressions are as follows:<br /></p>

<MarginText>22.17/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<ul>
<li>For an <code><a href="/docs/arm/AA-4/AA-4.5#S0149">if_expression</a></code> that is not repeatedly evaluated, a subexpression of any part other than the first condition is conditionally evaluated, and its determining expressions include all <code><a href="/docs/arm/AA-4/AA-4.5#S0150">condition</a></code>s of the <code><a href="/docs/arm/AA-4/AA-4.5#S0149">if_expression</a></code> that precede the subexpression textually;<br /></li>
<MarginText>22.18/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>For a <code><a href="/docs/arm/AA-4/AA-4.5#S0151">case_expression</a></code> that is not repeatedly evaluated, a subexpression of any <i>dependent{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> is conditionally evaluated, and its determining expressions include the <i>selecting{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> of the <code><a href="/docs/arm/AA-4/AA-4.5#S0151">case_expression</a></code>;<br /></li>
<MarginText>23/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>For a short-circuit control form that is not repeatedly evaluated, a subexpression of the right-hand operand is conditionally evaluated, and its determining expressions include the left-hand operand of the short-circuit control form;<br /></li>
<MarginText>24/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<li>For a membership test that is not repeatedly evaluated, a subexpression of a <code><a href="/docs/arm/AA-4/AA-4.4#S0137">membership_choice</a></code> other than the first is conditionally evaluated, and its determining expressions include the <i>tested{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0138">simple_expression</a></code> and the preceding <code><a href="/docs/arm/AA-4/AA-4.4#S0137">membership_choice</a></code>s of the membership test. <br /></li>
</ul>
<MarginText>24.1/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<p>A conditionally evaluated subexpression is <i>determined to be unevaluated</i> at run time if its set of determining expressions are all known on entry, and when evaluated on entry their values are such that the given subexpression is not evaluated. <br /></p>

<AnnotatedOnly>
<MarginText>24.a/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>To be precise, a conditionally evaluated expression is determined to be unevaluated (including all of its subexpressions) under the following circumstances: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b/5_6.1.1</MarginText>
<ul>
<li>Within an <code><a href="/docs/arm/AA-4/AA-4.5#S0149">if_expression</a></code>, a <i>dependent{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> with an associated <code><a href="/docs/arm/AA-4/AA-4.5#S0150">condition</a></code> that evaluates to False, or a <code><a href="/docs/arm/AA-4/AA-4.5#S0150">condition</a></code> or <i>dependent{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> where a condition of a preceding part of the <code><a href="/docs/arm/AA-4/AA-4.5#S0149">if_expression</a></code> evaluates to True;<br /></li>
<MarginText>24.c_6.1.1</MarginText>
<li>Within a <code><a href="/docs/arm/AA-4/AA-4.5#S0151">case_expression</a></code>, a <i>dependent{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> with an <code><a href="/docs/arm/AA-3/AA-3.8#S0073">discrete_choice_list</a></code> that is not covered by the value of the <i>selecting{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code>;<br /></li>
<MarginText>24.d/5_6.1.1</MarginText>
<li>The right-hand operand of a short-circuit control form where the left-hand operand evaluates to False for <b>and then</b> or True for <b>or else</b>;<br /></li>
<MarginText>24.e/5_6.1.1</MarginText>
<li>A <code><a href="/docs/arm/AA-4/AA-4.4#S0137">membership_choice</a></code> of a membership test where the individual membership test defined by any prior <code><a href="/docs/arm/AA-4/AA-4.4#S0137">membership_choice</a></code> evaluates to True. <br /></li>
</ul>
</AnnotatedOnly>
<MarginText>25/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2"]} />
<p>For a <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> X that denotes an object of a nonlimited type, the following attribute is defined: <br /></p>

<MarginText>26/5_6.1.1</MarginText>
<dt><br/>X'Old</dt>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI05-0273-1", "AI12-0032-1", "AI12-0280-2"]} />
<dl>
<dd>Each X'Old in a postcondition expression that is enabled, other than those that occur in subexpressions that are determined to be unevaluated, denotes a constant that is implicitly declared at the beginning of the subprogram body, entry body, or accept statement.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>26.a/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>If X'Old occurs in a subexpression that is determined to be unevaluated, then there is no associated constant, and no evaluation of the prefix takes place. In general, this will require evaluating one or more known-on-entry subexpressions before creating and initializing any X'Old constants. Note that any 'Old in a known-on-entry subexpression evaluated this way represents the current value of the prefix (the 'Old itself can be ignored).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0193-1"]} />
<Admonition type="aarm" aarm="note">
In the case of an accept statement, the constant is declared inside of the rendezvous. It is considered part of the initialization of the postcondition check, which is part of the rendezvous by definition (see <a href="/docs/arm/AA-9/AA-9.5#Subclause_9.5.2">9.5.2</a>). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>26.1/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1", "AI12-0159-1"]} />
<dl>
<dd>The implicitly declared entity denoted by each occurrence of X'Old is declared as follows:<br /></dd>
</dl>
<MarginText>26.2/4_6.1.1</MarginText>
<ul>
<li>If X is of an anonymous access type defined by an <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code> <i>A</i> then <br /></li>
</ul>
<MarginText>26.3/4_6.1.1</MarginText>
<CodeBlock language="ada">
X'Old : constant A := X;{"\n"}

</CodeBlock>
<MarginText>26.4/4_6.1.1</MarginText>
<ul>
<li>If X is of a specific tagged type <i>T</i> then <br /></li>
</ul>
<MarginText>26.5/4_6.1.1</MarginText>
<CodeBlock language="ada">
anonymous : constant T'Class := T'Class(X);{"\n"}X'Old : T renames T(anonymous);{"\n"}

</CodeBlock>
<MarginText>26.6/4_6.1.1</MarginText>
<ul>
<li>where the name X'Old denotes the object renaming. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>26.c/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>This means that the underlying tag associated with X'Old is that of X and not that of the nominal type of X. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>26.7/4_6.1.1</MarginText>
<ul>
<li>Otherwise <br /></li>
</ul>
<MarginText>26.8/4_6.1.1</MarginText>
<CodeBlock language="ada">
X'Old : constant S := X;{"\n"}

</CodeBlock>
<MarginText>26.9/4_6.1.1</MarginText>
<ul>
<li>where <i>S</i> is the nominal subtype of X. This includes the case where the type of <i>S</i> is an anonymous array type or a universal type. <br /></li>
</ul>
<MarginText>26.10/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1", "AI12-0185-1", "AI12-0388-1"]} />
<dl>
<dd>The type and nominal subtype of X'Old are as implied by the above definitions.<br /></dd>
<MarginText>27/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI05-0273-1", "AI12-0217-1", "AI12-0280-2"]} />
<dd>Reference to this attribute is only allowed within a postcondition expression. The <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> shall not contain a Result <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code>, nor an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code>, nor a use of an entity declared within the postcondition expression but not within <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> itself (for example, the loop parameter of an enclosing <code><a href="/docs/arm/AA-4/AA-4.5#S0153">quantified_expression</a></code>). The <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> shall statically name (see <a href="/docs/arm/AA-4/AA-4.9">4.9</a>) an entity, unless the <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> is unconditionally evaluated, or is conditionally evaluated where all of the determining expressions are known on entry.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>27.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> X can be any nonlimited object that obeys the syntax for prefix other than the few exceptions given above (discussed below). Useful cases are: the <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> of a formal parameter of mode [<b>in</b>] <b>out</b>, the <code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> of a global variable updated by the subprogram, a function call passing those as parameters, a subcomponent of those things, etc.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
A qualified expression can be used to make an arbitrary expression into a valid prefix, so T'(X + Y)'Old is legal, even though (X + Y)'Old is not. The value being saved here is the sum of X and Y (a function result is an object). Of course, in this case "+"(X, Y)'Old is also legal, but the qualified expression is arguably more readable.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.c/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
Note that F(X)'Old and F(X'Old) are not necessarily equal. The former calls F(X) and saves that value for later use during the postcondition. The latter saves the value of X, and during the postcondition, passes that saved value to F. In most cases, the former is what one wants (but it is not always legal, see below).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.d/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="note">
If X has controlled parts, adjustment and finalization are implied by the implicit constant declaration. Similarly, the implicit constant declaration defines the accessibility level of X'Old.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.e/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
If postconditions are disabled, we want the compiler to avoid any overhead associated with saving 'Old values.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.f/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
'Old makes no sense for limited types, because its implementation involves copying. It might make semantic sense to allow build-in-place, but it's not worth the trouble. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.g/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0273-1", "AI12-0005-1", "AI12-0280-2"]} />
<Admonition type="aarm" aarm="reason">
<b></b>Since the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> is evaluated when the subprogram is called (if it is evaluated at all), we cannot allow it to include values that do not exist at that time (like 'Result and loop parameters of <code><a href="/docs/arm/AA-4/AA-4.5#S0153">quantified_expression</a></code>s). We also do not allow the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> itself to include 'Old references, as those would be redundant (because the evaluation of the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code>, if it occurs, already happens on entry to the subprogram ), and allowing them would require some sort of order to the implicit constant declarations (because in A(I'Old)'Old, we surely would want the value of I'Old evaluated before the A(I'Old) is evaluated).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.h/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0273-1", "AI12-0280-2"]} />
<Admonition type="aarm" aarm="note">
An additional rule applies when it cannot be determined on entry to the subprogram whether the Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> will or will not be evaluated when the overall postcondition expression is evaluated. In such cases, we require that the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of the Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> to statically name some object. This is necessary because the Old <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code>es have to be evaluated when the subprogram is called if there is any possibility that they might be needed; the compiler cannot in general know whether they will be needed in the postcondition expression. To see the problem, consider:<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.i/3_6.1.1</MarginText>
<CodeBlock language="ada">
Table : array (1..10) of Integer := ...{"\n"}procedure Bar (I : in out Natural){"\n"}   with Post ={">"} I {">"} 0 and then Table(I)'Old = 1; -- Illegal{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.j/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
In this example, the compiler cannot know on entry what will be the value of I when the subprogram returns (since the subprogram execution can change it), and thus it does not know whether Table(I)'Old will be needed then. Thus it has to always create an implicit constant and evaluate Table(I) when Bar is called (because not having the value when it is needed is not acceptable). But if I = 0 when the subprogram is called, that evaluation will raise Constraint{"_"}Error, and that will happen even if I is unchanged by the subprogram and the value of Table(I)'Old is not ultimately needed. It's easy to see how a similar problem could occur for a dereference of an access type. This would be mystifying (since the point of the short circuit is to eliminate this possibility, but it cannot do so). Therefore, we require the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of any Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> in such a context to statically name an object, which eliminates anything that could change during execution.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.k/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
It is easy to work around most errors that occur because of this rule. Just move the 'Old to the outer object, before any indexing, dereferences, or components. (That does not work for function calls, however, nor does it work for array indexing if the index can change during the execution of the subprogram.) <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.l/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>An accept statement for a task entry with enabled postconditions such as <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.m/4_6.1.1</MarginText>
<CodeBlock language="ada">
accept E do{"\n"}   statements{"\n"}exception{"\n"}   handlers{"\n"}end;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.n/4_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
behaves (at runtime) as follows: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.o/4_6.1.1</MarginText>
<CodeBlock language="ada">
accept E do{"\n"}   declare{"\n"}      declarations, if any, of 'Old constants{"\n"}   begin{"\n"}      begin{"\n"}         statements{"\n"}      exception{"\n"}         handlers{"\n"}      end;{"\n"}      postcondition checks{"\n"}   end;{"\n"}end;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27.p/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="note">
Preconditions are checked by the caller before the rendezvous begins. Postcondition expressions might, of course, reference 'Old constants.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.q/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="note">
In the case of a protected operation with enabled postconditions, 'Old constant declarations (if any) are elaborated after the start of the protected action. Postcondition checks (which might reference these constants) are performed before the end of the protected action as described below.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.r/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<Admonition type="aarm" aarm="note">
The <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> has to statically name an entity if it appears within a repeatedly evaluated expression. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>28/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0220-1"]} />
<p>For a <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> F that denotes a function declaration or an access-to-function type, the following attribute is defined: <br /></p>

<MarginText>29/5_6.1.1</MarginText>
<dt><br/>F'Result</dt>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI12-0185-1", "AI12-0220-1", "AI12-0388-1"]} />
<dl>
<dd>Within a postcondition expression for F, denotes the return object of the function call for which the postcondition expression is evaluated. The type of this attribute is that of the result subtype of the function or access-to-function type except within a Post'Class postcondition expression for a function with a controlling result or with a controlling access result; in those cases the type of the attribute is described above as part of the Name Resolution Rules for Post'Class.<br /></dd>
<MarginText>30/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0262-1"]} />
<dd>Use of this attribute is allowed only within a postcondition expression for F. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>30.a/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0220-1"]} />
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>An &ldquo;access-to-function type&rdquo; is an access-to-subprogram type whose designated profile is a function profile. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>30.1/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0143-1"]} />
<p>For a <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> E that denotes an entry declaration of an entry family (see <a href="/docs/arm/AA-9/AA-9.5#Subclause_9.5.2">9.5.2</a>), the following attribute is defined: <br /></p>

<MarginText>30.2/5_6.1.1</MarginText>
<dt><br/>E'Index</dt>
<MarginInfo items={["AI12-0143-1"]} />
<dl>
<dd>Within a precondition or postcondition expression for entry family E, denotes the value of the entry index for the call of E. The nominal subtype of this attribute is the entry index subtype.<br /></dd>
<MarginText>30.3/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0143-1"]} />
<dd>Use of this attribute is allowed only within a precondition or postcondition expression for E. <br /></dd>
</dl>

#### Dynamic Semantics

<MarginText>31/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0290-1"]} />
<p>Upon a call of the subprogram or entry, after evaluating any actual parameters, precondition checks are performed as follows:<br /></p>

<MarginText>32/3_6.1.1</MarginText>
<ul>
<li>The specific precondition check begins with the evaluation of the specific precondition expression that applies to the subprogram or entry, if it is enabled; if the expression evaluates to False, Assertions.Assertion{"_"}Error is raised; if the expression is not enabled, the check succeeds.<br /></li>
<MarginText>33/3_6.1.1</MarginText>
<li>The class-wide precondition check begins with the evaluation of any enabled class-wide precondition expressions that apply to the subprogram or entry. If and only if all the class-wide precondition expressions evaluate to False, Assertions.Assertion{"_"}Error is raised.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>33.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The class-wide precondition expressions of the entity itself as well as those of any parent or progenitor operations are evaluated, as these expressions apply to the corresponding operations of all descendants.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>33.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
Class-wide precondition checks are performed for all appropriate calls, but only enabled precondition expressions are evaluated. Thus, the check would be trivial if no precondition expressions are enabled. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>34/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0254-1", "AI05-0269-1", "AI12-0166-1"]} />
<p>The precondition checks are performed in an arbitrary order, and if any of the class-wide precondition expressions evaluate to True, it is not specified whether the other class-wide precondition expressions are evaluated. The precondition checks and any check for elaboration of the subprogram body are performed in an arbitrary order. In a call on a protected operation, the checks are performed before starting the protected action. For an entry call, the checks are performed prior to checking whether the entry is open.<br /></p>

<AnnotatedOnly>
<MarginText>34.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>We need to explicitly allow short-circuiting of the evaluation of the class-wide precondition check if any expression fails, as it consists of multiple expressions; we don't need a similar permission for the specific precondition check as it consists only of a single expression. Nothing is evaluated for the call after a check fails, as the failed check propagates an exception. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>35/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0254-1", "AI05-0262-1", "AI05-0290-1"]} />
<p>Upon successful return from a call of the subprogram or entry, prior to copying back any by-copy <b>in out</b> or <b>out</b> parameters, the postcondition check is performed. This consists of the evaluation of any enabled specific and class-wide postcondition expressions that apply to the subprogram or entry. If any of the postcondition expressions evaluate to False, then Assertions.Assertion{"_"}Error is raised. The postcondition expressions are evaluated in an arbitrary order, and if any postcondition expression evaluates to False, it is not specified whether any other postcondition expressions are evaluated. The postcondition check, and any constraint or predicate checks associated with <b>in out</b> or <b>out</b> parameters are performed in an arbitrary order.<br /></p>

<AnnotatedOnly>
<MarginText>35.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The class-wide postcondition expressions of the entity itself as well as those of any parent or progenitor operations are evaluated, as these apply to all descendants; in contrast, only the specific postcondition of the entity applies. Postconditions can always be evaluated inside the invoked body. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>35.1/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<p>For a call to a task entry, the postcondition check is performed before the end of the rendezvous; for a call to a protected operation, the postcondition check is performed before the end of the protected action of the call. The postcondition check for any call is performed before the finalization of any implicitly-declared constants associated (as described above) with Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code>s but after the finalization of any other entities whose accessibility level is that of the execution of the callable construct. <br /></p>

<AnnotatedOnly>
<MarginText>35.a.1/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>If a postcondition references the implicitly-declared constant associated with an Old attribute, the postcondition must be evaluated before the constant is finalized. One way to think of this is to imagine declaring a controlled object between any implicit "'Old" constant declarations and any explicit declarations, then performing postcondition checks during the finalization of this object. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>36/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1"]} />
<p>If a precondition or postcondition check fails, the exception is raised at the point of the call[; the exception cannot be handled inside the called subprogram or entry]. Similarly, any exception raised by the evaluation of a precondition or postcondition expression is raised at the point of call.<br /></p>

<MarginText>37/4_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0254-1", "AI05-0262-1", "AI12-0113-1", "AI12-0159-1"]} />
<p>For any call to a subprogram or entry <i>S</i> (including dispatching calls), the checks that are performed to verify specific precondition expressions and specific and class-wide postcondition expressions are determined by those for the subprogram or entry actually invoked. Note that the class-wide postcondition expressions verified by the postcondition check that is part of a call on a primitive subprogram of type <i>T</i> includes all class-wide postcondition expressions originating in any progenitor of <i>T</i>[, even if the primitive subprogram called is inherited from a type <i>T1</i> and some of the postcondition expressions do not apply to the corresponding primitive subprogram of <i>T1</i>]. Any operations within a class-wide postcondition expression that were resolved as primitive operations of the (notional) formal derived type <i>NT</i>, are in the evaluation of the postcondition bound to the corresponding operations of the type identified by the controlling tag of the call on <i>S</i>.[ This applies to both dispatching and non-dispatching calls on <i>S</i>.]<br /></p>

<AnnotatedOnly>
<MarginText>37.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>This applies to access-to-subprogram calls, dispatching calls, and to statically bound calls. We need this rule to cover statically bound calls as well, as specific pre- and postconditions are not inherited, but the subprogram might be.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
For concrete subprograms, we require the original specific postcondition to be evaluated as well as the inherited class-wide postconditions in order that the semantics of an explicitly defined wrapper that does nothing but call the original subprogram is the same as that of an inherited subprogram.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>37.c/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
Note that this rule does not apply to class-wide preconditions; they have their own rules mentioned below. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>38/4_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0254-1", "AI12-0113-1", "AI12-0159-1"]} />
<p>The class-wide precondition check for a call to a subprogram or entry <i>S</i> consists solely of checking the class-wide precondition expressions that apply to the denoted callable entity (not necessarily to the one that is invoked). Any operations within such an expression that were resolved as primitive operations of the (notional) formal derived type <i>NT</i> are in the evaluation of the precondition bound to the corresponding operations of the type identified by the controlling tag of the call on <i>S</i>.[ This applies to both dispatching and non-dispatching calls on <i>S</i>.]<br /></p>

<AnnotatedOnly>
<MarginText>38.a/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>For a dispatching call, we are talking about the Pre'Class(es) that apply to the subprogram that the dispatching call is resolving to, not the Pre'Class(es) for the subprogram that is ultimately dispatched to. The class-wide precondition of the resolved call is necessarily the same or stronger than that of the invoked call. For a statically bound call, these are the same; for an access-to-subprogram, (which has no class-wide preconditions of its own), we check the class-wide preconditions of the invoked routine.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.a.1/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0233-1"]} />
<Admonition type="aarm" aarm="note">
Since this check is based on the &ldquo;callable entity&rdquo;, it does not depend on the view of the entity. This matters any time the ancestor type (if any) of the partial view differs from the parent type of the full view. In such a case, the view of the callable entity associated with the full view might inherit a Pre'Class while the view of the same callable entity associated with the partial view does not. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.b/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>These rules imply that logically, class-wide preconditions of routines must be checked at the point of call (other than for access-to-subprogram calls, which must be checked in the body, probably using a wrapper). Specific preconditions that might be called with a dispatching call or via an access-to-subprogram value must be checked inside of the subprogram body. In contrast, the postcondition checks always need to be checked inside the body of the routine. Of course, an implementation can evaluate all of these at the point of call for statically bound calls if the implementation uses wrappers for dispatching bodies and for 'Access values.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>38.c/3_6.1.1</MarginText>
<Admonition type="aarm" aarm="note">
There is no requirement for an implementation to generate special code for routines that are imported from outside of the Ada program. That's because there is a requirement on the programmer that the use of interfacing aspects do not violate Ada semantics (see <a href="/docs/arm/AA-B/AA-B.1">B.1</a>). That includes making pre- and postcondition checks. For instance, if the implementation expects routines to make their own postcondition checks in the body before returning, C code can be assumed to do this (even though that is highly unlikely). That's even though the formal definition of those checks is that they are evaluated at the call site. Note that pre- and postconditions can be very useful for verification tools (even if they aren't checked), because they tell the tool about the expectations on the foreign code that it most likely cannot analyze. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>39/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0195-1"]} />
<p>For the purposes of the above rules, a call on an inherited subprogram is considered to involve a call on a subprogram <i>S</i>' whose body consists only of a call (with appropriate conversions) on the non-inherited subprogram <i>S</i> from which the inherited subprogram was derived. It is not specified whether class-wide precondition or postcondition expressions that are equivalent (with respect to which non-inherited function bodies are executed) for <i>S</i> and <i>S</i>' are evaluated once or twice. If evaluated only once, the value returned is used for both associated checks.<br /></p>

<AnnotatedOnly>
<MarginText>39.a/5_6.1.1</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<b></b>If the class-wide pre- and postcondition expressions are equivalent for <i>S</i> and <i>S</i>' because none of the primitive subprograms called in those expressions were overridden, no wrapper is needed. Otherwise, a wrapper is presumably needed to provide the correct logic. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>40/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0247-1", "AI05-0254-1", "AI12-0220-1"]} />
<p>For a call via an access-to-subprogram value, precondition and postcondition checks performed are as determined by the subprogram or entry denoted by the prefix of the Access attribute reference that produced the value. In addition, a precondition check of any precondition expression associated with the access-to-subprogram type is performed. Similarly, a postcondition check of any postcondition expression associated with the access-to-subprogram type is performed.<br /></p>

<AnnotatedOnly>
<MarginText>40.a/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<b></b>A call via an access-to-subprogram value can be considered equivalent (with respect to dynamic semantics) to a call to a notional "wrapper" subprogram which has the Pre and Post aspects and the profile of the access-to-subprogram type and whose body contains (and returns, in the case of a function) only a call to the designated subprogram. However, other evaluation orders for the checks are allowed beyond those allowed by strictly following this model. This equivalence can be used to determine the appropriate point at which the constant associated with an Old attribute reference in the Post aspect for an access-to-subprogram type is elaborated and finalized. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>40.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1"]} />
<Admonition type="aarm" aarm="ramification">
<b></b>In the case of type conversion between two access-to-subprogram types, the Pre and Post aspects of the source type of the conversion play no role in any subsequent call via the conversion result; only the Pre and Post aspects of the target type of the conversion are relevant in that case. The same applies in the case of a &ldquo;conversion&rdquo; (using the term loosely) which is accomplished by combining a dereference and an Access attribute reference, as in Some{"_"}Pointer.<b>all</b>'Access. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>41/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0272-1"]} />
<p>[For a call on a generic formal subprogram, precondition and postcondition checks performed are as determined by the subprogram or entry denoted by the actual subprogram, along with any specific precondition and specific postcondition of the formal subprogram itself.]<br /></p>

<AnnotatedOnly>
<MarginText>41.a/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0272-1"]} />
<Admonition type="aarm" aarm="proof">
<b></b>This follows from the general Dynamic Semantics rules given above, but we mention it explicitly so that there can be no doubt that it is intended. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>41.b/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0371-1"]} />
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>The specific precondition and postcondition that apply to a generic formal subprogram also apply to any renaming of that subprogram, even if that renaming is visible in the instance and called from outside of the generic instance. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>42/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2", "AI12-0373-1"]} />
<p>An implementation may evaluate a known-on-entry subexpression of a postcondition expression of an entity at the place where X'Old constants are created for the entity, with the normal evaluation of the postcondition expression, or both.<br /></p>

<AnnotatedOnly>
<MarginText>42.a/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<Admonition type="aarm" aarm="reason">
<b></b>We allow the evaluation of known-on-entry subexpressions when they might be needed to determine whether to create a particular 'Old constant. We allow them to be evaluated later as well, or for the results to be saved somehow. This permission shouldn't matter, as the results ought to be same wherever they are evaluated and there should not be any side effects. The main effect of the permission is to determine when any exceptions caused by such subexpressions may be raised. We never require waiting to determine the value of such subexpressions, even if they aren't used to determine the creation of a constant for 'Old. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>43/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0262-1", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   A precondition is checked just before the call. If another task can change any value that the precondition expression depends on, the precondition can evaluate to False within the subprogram or entry body.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   For an example of the use of these aspects and attributes, see the Streams Subsystem definitions in <a href="/docs/arm/AA-13/AA-13.13#Subclause_13.13.1">13.13.1</a>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.a/3_6.1.1</MarginText>
<MarginInfo items={["AI05-0145-2", "AI05-0230-1", "AI05-0247-1", "AI05-0254-1", "AI05-0262-1", "AI05-0273-1", "AI05-0274-1"]} />
<Admonition type="aarm" aarm="note">
Pre and Post aspects are new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.b/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0032-1"]} />
<Admonition type="aarm" aarm="note">
<b>Corrigendum:</b> The Old attribute is defined more carefully. This changes the nominal subtype and place of declaration of the attribute compared to the published Ada 2012 Reference Manual. In extreme cases, this could change the runtime behavior of the attribute (for instance, the tag might be different). The changes are most likely going to prevent bugs by being more intuitive, but it is possible that a program that previously worked might fail.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.c/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0113-1", "AI12-0159-1"]} />
<Admonition type="aarm" aarm="note">
<b>Corrigendum:</b> Eliminated unintentional redispatching from class-wide preconditions and postconditions. This means that a different body might be evaluated for a statically bound call to a routine that has a class-wide precondition or postcondition. The change means that the behavior of Pre and Pre'Class will be the same for a particular subprogram, and that the known behavior of the operations can be assumed within the body of that subprogram for Pre'Class. We expect that this change will primarily fix bugs, as it will make Pre'Class and Post'Class work more like expected. In the case where redispatching is desired, an explicit conversion to a class-wide type can be used.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.d/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0166-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Specified that precondition checks always take place before starting a protected action. Original Ada 2012 left this unspecified, so if an implementation made the checks after starting the protected action, and a program depended upon that, the program might fail in a different compiler. But such a program was depending on unspecified behavior anyway, and thus was never portable; as such, such programs should be rare.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.d.1/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0195-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Specified that an inherited subprogram check both the original and new versions of a class-wide precondition. If a call on an inherited subprogram fails the original class-wide precondition when it passes the new class-wide precondition, then the call will fail the precondition check whereas it would have passed in original Ada 2012. (A similar possibility exists for class-wide postconditions.) This can only happen if the overriding subprograms somehow fail to follow the guidelines of LSP, so this should be rare (the entire point of class-wide preconditions and postconditions is to use them in cases where LSP is followed). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.e/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0005-1", "AI12-0045-1"]} />
<Admonition type="aarm" aarm="note">
<b>Corrigendum:</b> Precondition and postcondition aspects cannot be specified on instances of generic subprograms (they should be specified on the generic subprogram instead). This was (unintentionally) allowed by the Ada 2012 standard. These are not allowed on instances as there is no corresponding way to add preconditions and postconditions to subprograms declared within the instance of a generic package. Therefore, allowing specification on a subprogram instance could present a maintenance problem in the future if the entity needs to be converted to a generic package (a common conversion).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.f/4_6.1.1</MarginText>
<MarginInfo items={["AI12-0131-1"]} />
<Admonition type="aarm" aarm="note">
<b>Corrigendum:</b> Pre'Class is no longer allowed to be specified for an overriding primitive subprogram unless there are also inherited class-wide precondittions. This incompatibility prevents cases where the explicit Pre'Class is counterfeited by an implicit class-wide precondition of True. This rule should catch more bugs than it creates; the programmer should have written Pre rather than Pre'Class in this case (or written Pre'Class on the original subprogram, not an overriding). Note that this incompatibility eliminates what otherwise would be an inconsistency with original Ada 2012, where precondition checks that would have previously been made for a statically bound call would no longer be made. That dynamic change was necessary to eliminate cases where the evaluated class-wide precondition on a dispatching call would have been weaker than the class-wide precondition of a statically bound call. (The original Ada 2012 violated the LSP semantics that class-wide preconditions were intended to model.)<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.g/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0198-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> A component <code><a href="/docs/arm/AA-4/AA-4.4#S0132">expression</a></code> in an array aggregate can now be potentially unevaluated, requiring the prefix to be statically determined. Existing code that uses the Old attribute with a dynamic prefix in such contexts will now be illegal. However, in many cases, the existing code will not do what the programmer is expecting (as Old is evaluated textually, once per occurrence, while array aggregate components are evaluated once per component). In addition, Old is a new Ada 2012 feature, so most Ada legacy code will not contain it. The problem is usually easily fixed by moving Old to an outer object (such as the entire aggregate). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.h/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0143-1"]} />
<Admonition type="aarm" aarm="note">
The Index attribute is new.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.i/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0217-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> The <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of a statically unevaluated Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> can be a <code><a href="/docs/arm/AA-4/AA-4.1#S0098">selected_component</a></code> or <code><a href="/docs/arm/AA-4/AA-4.1#S0096">indexed_component</a></code>. This is considered a correction as the old rule is unintentionally too fierce, rejecting safe cases.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.j/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0280-2"]} />
<Admonition type="aarm" aarm="note">
We make no restriction on the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Old <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> if we can determine when the subprogram is entered (which is the point when Old prefixes are evaluated) whether it will be needed in the evaluation of the postcondition.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.k/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0220-1", "AI12-0272-1"]} />
<Admonition type="aarm" aarm="note">
Pre and Post can be given on an access-to-subprogram type and on a generic formal subprogram.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.l/5_6.1.1</MarginText>
<MarginInfo items={["AI12-0412-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> We now allow the definition of a concrete subprogram <i>S</i> that has applicable Pre'Class or Post'Class expressions that is primitive for an abstract type <i>T</i> even when a Pre'Class or Post'Class may call an abstract subprogram. Rather, <i>S</i> is treated as if it is abstract (meaning that uses that might require evaluating a statically bound Pre'Class or Post'Class expression are not allowed). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.m/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0170-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Clarified the wording about the meaning of the notional type <i>NT</i> and the corresponding expression. Both changes follow from other rules but are nonobvious.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44.n/5_6.1.1</MarginText>
<MarginInfo items={["AI05-0185-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Removed redundant (and sometimes incorrect) wording about the resolution of the Old and Result attributes. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_6.1.2"></a>

## 6.1.2  The Global and Global'Class Aspects

<MarginText>1/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0425-1", "AI12-0439-1"]} />
<p>The Global and Global'Class aspects of a program unit are used to identify the objects global to the unit that can be read or written during its execution. <br /></p>


#### Syntax

<MarginText>2/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0380-1", "AI12-0425-1"]} />

<CodeBlock>
<code>global{"_"}aspect{"_"}definition</code><a id="S0209"></a><code> ::= </code><br />    <b>null</b><br />  | Unspecified<br />  | <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> <code><a href="/docs/arm/AA-6/AA-6.1#S0214">global_designator</a></code><br />  | (<code><a href="/docs/arm/AA-6/AA-6.1#S0210">global_aspect_element</a></code>{"{"}; <code><a href="/docs/arm/AA-6/AA-6.1#S0210">global_aspect_element</a></code>{"}"})<br />

</CodeBlock>
<MarginText>3/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0380-1"]} />

<CodeBlock>
<code>global{"_"}aspect{"_"}element</code><a id="S0210"></a><code> ::= </code><br />    <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> <code><a href="/docs/arm/AA-6/AA-6.1#S0213">global_set</a></code><br />  | <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> <b>all</b><br />  | <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> <b>synchronized</b><br />

</CodeBlock>
<MarginText>4/5_6.1.2</MarginText>

<CodeBlock>
<code>global{"_"}mode</code><a id="S0211"></a><code> ::= </code><br />    <code><a href="/docs/arm/AA-6/AA-6.1#S0212">basic_global_mode</a></code><br />  | <code><a href="/docs/arm/AA-H/AA-H.7#S0361">extended_global_mode</a></code><br />

</CodeBlock>
<MarginText>5/5_6.1.2</MarginText>

<CodeBlock>
<code>basic{"_"}global{"_"}mode</code><a id="S0212"></a><code> ::= </code><b>in</b> | <b>in out</b> | <b>out</b><br />

</CodeBlock>
<MarginText>6/5_6.1.2</MarginText>

<CodeBlock>
<code>global{"_"}set</code><a id="S0213"></a><code> ::= </code><code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code> {"{"}, <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>{"}"}<br />

</CodeBlock>
<MarginText>7/5_6.1.2</MarginText>

<CodeBlock>
<code>global{"_"}designator</code><a id="S0214"></a><code> ::= </code><b>all</b> | <b>synchronized</b> | <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code><br />

</CodeBlock>
<MarginText>8/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-1", "AI12-0310-1"]} />

<CodeBlock>
<code>global{"_"}name</code><a id="S0215"></a><code> ::= </code><i>object{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> | <i>package{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code><br />

</CodeBlock>

#### Name Resolution Rules

<MarginText>9/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0425-1", "AI12-0427-1"]} />
<p>A <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code> shall resolve to statically name an object or a package (including a limited view of a package). <br /></p>


#### Static Semantics

<MarginText>10/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>For a subprogram, an entry, an access-to-subprogram type, a task unit, a protected unit, or a library package or generic library package, the following language-defined aspect may be specified with an <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code> (see <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>):<br /></p>

<MarginText>11/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0425-1"]} />
<dt><br/>Global</dt>
<dl>
<dd>The Global aspect shall be specified with a <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code>.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>11.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Global: </b>Global object usage contract.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>12/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0422-1"]} />
<dl>
<dd>The Global aspect identifies the set of variables (which, for the purposes of this clause, includes all constants except those which are known to have no variable views (see <a href="/docs/arm/AA-3/AA-3.3">3.3</a>)) that are global to a callable entity or task body, and that are read or updated as part of the execution of the callable entity or task body. If specified for a protected unit, it refers to all of the protected operations of the protected unit. Constants of any type may also be mentioned in a Global aspect.<br /></dd>
<MarginText>13/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<dd>If not specified or otherwise defined below, the aspect defaults to the Global aspect for the enclosing library unit if the entity is declared at library level, and to Unspecified otherwise. If not specified for a library unit, the aspect defaults to Global ={">"} <b>null</b> for a library unit that is declared Pure, and to Global ={">"} Unspecified otherwise. <br /></dd>
</dl>
<MarginText>14/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>For a dispatching subprogram, the following language-defined aspect may be specified with an <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code> (see <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>):<br /></p>

<MarginText>15/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0425-1"]} />
<dt><br/>Global'Class</dt>
<dl>
<dd>The Global'Class aspect shall be specified with a <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code>. This aspect identifies an upper bound on the set of variables global to a dispatching operation that can be read or updated as a result of a dispatching call on the operation. If not specified, the aspect defaults to the Global aspect for the dispatching subprogram.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>15.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>Global'Class: </b>Global object usage contract inherited on derivation.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>16/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0380-1"]} />
<p>Together, we refer to the Global and Global'Class aspects as <i>global</i> aspects.<br /></p>

<MarginText>17/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>A <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code> defines the Global or Global'Class aspect of some entity. The Global aspect identifies the sets of global variables that can be read, written, or modified as a side effect of executing the operation(s) associated with the entity. The Global'Class aspect associated with a dispatching operation of type <i>T</i> represents a restriction on the Global aspect on a corresponding operation of any descendant of type <i>T</i>.<br /></p>

<MarginText>18/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0416-1", "AI12-0442-1"]} />
<p>The Global aspect for a callable entity defines the global variables that can be referenced as part of a call on the entity, including any assertion expressions that apply to the call (even if not enabled), such as preconditions, postconditions, predicates, and type invariants.<br /></p>

<MarginText>19/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0439-1"]} />
<p>The Global aspect for an access-to-subprogram object (or subtype) identifies the global variables that can be referenced when calling via the object (or any object of that subtype) including assertion expressions that apply.<br /></p>

<MarginText>20/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0405-1"]} />
<p>For a predefined operator of an elementary type, the function representing an enumeration literal, or any other static function (see <a href="/docs/arm/AA-4/AA-4.9">4.9</a>), the Global aspect is <b>null</b>. For a predefined operator of a composite type, the Global aspect of the operator defaults to that of the enclosing library unit (unless a Global aspect is specified for the type &mdash; see <a href="/docs/arm/AA-H/AA-H.7">H.7</a>).<br /></p>

<MarginText>21/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0380-1"]} />
<p>The following is defined in terms of operations that are performed by or on behalf of an entity. The rules on operations apply to the entity(s) associated with those operations.<br /></p>

<AnnotatedOnly>
<MarginText>21.a/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0380-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The operations performed by a callable entity are those associated with the body of the entity. For other kinds of entities (such as subtypes, see <a href="/docs/arm/AA-H/AA-H.7">H.7</a>), we explicitly list the associated operations. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>The global variables associated with any <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> can be read as a side effect of an operation. The <b>in out</b> and <b>out</b> <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code>s together identify the set of global variables that can be updated as a side effect of an operation. Creating an access-to-variable value that designates an object is considered an update of the designated object, and creating an access-to-constant value that designates an object is considered a read of the designated object.<br /></p>

<MarginText>23/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>The overall set of objects associated with each <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> includes all objects identified for the mode in the <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code>.<br /></p>

<MarginText>24/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>A <code><a href="/docs/arm/AA-6/AA-6.1#S0213">global_set</a></code> identifies a <i>global variable set</i> as follows:<br /></p>

<MarginText>25/5_6.1.2</MarginText>
<ul>
<li><b>all</b> identifies the set of all global variables;<br /></li>
<MarginText>26/5_6.1.2</MarginText>
<li><b>synchronized</b> identifies the set of all synchronized variables (see <a href="/docs/arm/AA-9/AA-9.10">9.10</a>), as well as variables of a composite type all of whose non-discriminant subcomponents are synchronized;<br /></li>
<MarginText>27/5_6.1.2</MarginText>
<li><code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>{"{"}, <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>{"}"} identifies the union of the sets of variables identified by the <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>s in the list, for the following forms of <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>:<br /></li>
<MarginText>28/5_6.1.2</MarginText>
<li><i>object{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> identifies the specified global variable (or constant);<br /></li>
<MarginText>29/5_6.1.2</MarginText>
<li><i>package{"_"}</i><code><a href="/docs/arm/AA-4/AA-4.1#S0091">name</a></code> identifies the set of all variables declared in the private part or body of the package, or anywhere within a private descendant of the package. <br /></li>
</ul>

#### Legality Rules

<MarginText>30/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-1"]} />
<p>Within a <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code>, a given <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> shall be specified at most once. Similarly, within a <code><a href="/docs/arm/AA-6/AA-6.1#S0209">global_aspect_definition</a></code>, a given entity shall be named at most once by a <code><a href="/docs/arm/AA-6/AA-6.1#S0215">global_name</a></code>.<br /></p>

<MarginText>31/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>If an entity (other than a library package or generic library package) has a Global aspect other than Unspecified or <b>in out all</b>, then the associated operation(s) shall read only those variables global to the entity that are within the global variable set associated with the <b>in</b>, <b>in out</b>, or <b>out</b> <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code>s, and the operation(s) shall update only those variables global to the entity that are within the global variable set associated with either the <b>in out</b> or <b>out</b> <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code>s. In the absence of the No{"_"}Hidden{"_"}Indirect{"_"}Globals restriction (see <a href="/docs/arm/AA-H/AA-H.4">H.4</a>), this ignores objects reached via a dereference of an access value. The above rule includes any possible Global effects of calls occurring during the execution of the operation, except for the following excluded calls:<br /></p>

<MarginText>32/5_6.1.2</MarginText>
<ul>
<li>calls to formal subprograms;<br /></li>
<MarginText>33/5_6.1.2</MarginText>
<li>calls associated with operations on formal subtypes;<br /></li>
<MarginText>34/5_6.1.2</MarginText>
<li>calls through formal objects of an access-to-subprogram type;<br /></li>
<MarginText>35/5_6.1.2</MarginText>
<li>calls through access-to-subprogram parameters;<br /></li>
<MarginText>36/5_6.1.2</MarginText>
<li>calls on operations with Global aspect Unspecified.<br /></li>
</ul>
<MarginText>37/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>The possible Global effects of these excluded calls (other than those that are Unspecified) are taken into account by the caller of the original operation, by presuming they occur at least once during its execution. For calls that are not excluded, the possible Global effects of the call are those permitted by the Global aspect of the associated entity, or by its Global'Class aspect if a dispatching call.<br /></p>

<AnnotatedOnly>
<MarginText>37.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>For a predefined equality operator of a composite type, the possible Global effects includes those of the equality operations invoked as part of the evaluation of the operator (which might not be predefined and thus might have a different Global specification than the component types). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>38/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>If a Global aspect other than Unspecified or <b>in out all</b> applies to an access-to-subprogram type, then the <code><a href="/docs/arm/AA-4/AA-4.1#S0093">prefix</a></code> of an Access <code><a href="/docs/arm/AA-4/AA-4.1#S0100">attribute_reference</a></code> producing a value of such a type shall denote a subprogram whose Global aspect is not Unspecified and is <i>covered</i> by that of the result type, where a global aspect <i>G1</i> is <i>covered</i> by a global aspect <i>G2</i> if the set of variables that <i>G1</i> identifies as readable or updatable is a subset of the corresponding set for <i>G2</i>. Similarly on a conversion to such a type, the operand shall be of a named access-to-subprogram type whose Global aspect is covered by that of the target type.<br /></p>

<MarginText>39/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>If an implementation-defined <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code> applies to a given set of variables, an implementation-defined rule determines what sort of references to them are permitted.<br /></p>

<MarginText>40/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-1"]} />
<p>For a subprogram that is a dispatching operation of a tagged type <i>T</i>, each mode of its Global aspect shall identify a subset of the variables identified by the corresponding mode, or by the <b>in out</b> mode, of the Global'Class aspect of a corresponding dispatching subprogram of any ancestor of <i>T</i>, unless the aspect of that ancestor is Unspecified.<br /></p>


#### Implementation Permissions

<MarginText>41/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0444-1"]} />
<p>An implementation can allow some references to a constant object which are not accounted for by the Global or Global'Class aspect when it is considered a variable in the above rules, if the implementation can determine that the object is in fact immutable.<br /></p>

<AnnotatedOnly>
<MarginText>41.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>In particular, this allows the implementation to violate privacy in order to determine whether a constant needs to be covered by a Global aspect. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>42/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>Implementations may perform additional checks on calls to operations with an Unspecified Global aspect to ensure that they do not violate any limitations associated with the point of call.<br /></p>

<AnnotatedOnly>
<MarginText>42.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>In this sense, Global ={">"} Unspecified is not permission to violate the caller's Global restrictions. It is rather that the implementor of the subprogram is presuming other means are being used to ensure safety. Note the No{"_"}Unspecified{"_"}Globals Restriction (<a href="/docs/arm/AA-H/AA-H.4">H.4</a>), which prevents the use of Unspecified with the Global aspect in a given partition. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>43/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<p>Implementations may extend the syntax or semantics of the Global aspect in an implementation-defined manner[; for example, supporting additional <code><a href="/docs/arm/AA-6/AA-6.1#S0211">global_mode</a></code>s].<br /></p>

<AnnotatedOnly>
<MarginText>43.a/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>Any extensions of the Global aspect.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>43.b/5_6.1.2</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>This is intended to allow preexisting usages from SPARK 2014 to remain acceptable in conforming implementations, as well as to provide flexibility for future enhancements. Note the word &ldquo;extend&rdquo; in this permission; we expect that any aspect usage that conforms with the (other) rules of this subclause will be accepted by any Ada implementation, regardless of any implementation-defined extensions. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   For an example of the use of these aspects, see the Vector container definition in <a href="/docs/arm/AA-A/AA-A.18#Subclause_A.18.2">A.18.2</a>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>44.a/5_6.1.2</MarginText>
<MarginInfo items={["AI12-0079-1", "AI12-0240-6", "AI12-0310-1"]} />
<Admonition type="aarm" aarm="note">
The Global and Global'Class aspects are new. <br />
</Admonition>
</AnnotatedOnly>

