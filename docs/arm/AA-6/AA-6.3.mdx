---
sidebar_position:  53
---

# 6.3 Subprogram Bodies

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[A <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> specifies the execution of a subprogram.] <br /></p>


#### Syntax

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00218-03", "AI05-0183-1"]} />

<CodeBlock>
<code>subprogram_body</code><a id="S0216"></a><code> ::= </code><br />    [<code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code>]<br />    <code><a href="../AA-6/AA-6.1#S0196">subprogram_specification</a></code><br />       [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>] <strong>is</strong><br />       <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code><br />    <strong>begin</strong><br />        <code><a href="../AA-11/AA-11.2#S0304">handled_sequence_of_statements</a></code><br />    <strong>end</strong> [<code><a href="../AA-6/AA-6.1#S0199">designator</a></code>];<br />

</CodeBlock>
<MarginText>3</MarginText>
<p class="Indented2">If a <code><a href="../AA-6/AA-6.1#S0199">designator</a></code> appears at the end of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>, it shall repeat the <code><a href="../AA-6/AA-6.1#S0200">defining_designator</a></code> of the <code><a href="../AA-6/AA-6.1#S0196">subprogram_specification</a></code>. <br /></p>


#### Legality Rules

<MarginText>4/5</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>[In contrast to other bodies,] a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is allowed to be defined without it being  the completion of a previous declaration[, in which case the body declares the subprogram]. If the body is a completion, it shall be the completion of a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code> or <code><a href="../AA-12/AA-12.1#S0311">generic_subprogram_declaration</a></code>. The profile of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> that completes a declaration shall conform fully to that of the declaration. <br /></p>


#### Static Semantics

<MarginText>5</MarginText>
<p>A <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is considered a declaration. It can either complete a previous declaration, or itself be the initial declaration of the subprogram. <br /></p>


#### Dynamic Semantics

<MarginText>6</MarginText>
<p>The elaboration of a nongeneric <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> has no other effect than to establish that the subprogram can from then on be called without failing the Elaboration_Check. <br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>See <a href="../AA-12/AA-12.2">12.2</a> for elaboration of a generic body. Note that protected <code>subprogram_bodies</code> never get elaborated; the elaboration of the containing <code><a href="../AA-9/AA-9.4#S0254">protected_body</a></code> allows them to be called without failing the Elaboration_Check. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7</MarginText>
<p>[The execution of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is invoked by a subprogram call.] For this execution the <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> is elaborated, and the <code><a href="../AA-11/AA-11.2#S0304">handled_sequence_of_statements</a></code> is then executed. <br /></p>


#### Examples

<MarginText>8</MarginText>
<p><em>Example of procedure body:</em> <br /></p>

<MarginText>9</MarginText>
<CodeBlock language="ada">
procedure Push(E : in Element_Type; S : in out Stack) is{"\n"}begin{"\n"}   if S.Index = S.Size then{"\n"}      raise Stack_Overflow;{"\n"}   else{"\n"}      S.Index := S.Index + 1;{"\n"}      S.Space(S.Index) := E;{"\n"}   end if;{"\n"}end Push;{"\n"}

</CodeBlock>
<MarginText>10</MarginText>
<p><em>Example of a function body:</em> <br /></p>

<MarginText>11</MarginText>
<CodeBlock language="ada">
function Dot_Product(Left, Right : Vector) return Real is{"\n"}   Sum : Real := 0.0;{"\n"}begin{"\n"}   Check(Left'First = Right'First and Left'Last = Right'Last);{"\n"}   for J in Left'Range loop{"\n"}      Sum := Sum + Left(J)*Right(J);{"\n"}   end loop;{"\n"}   return Sum;{"\n"}end Dot_Product;{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="note">
A <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code> may be used instead of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.b</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> now uses the syntactic category <code><a href="../AA-11/AA-11.2#S0304">handled_sequence_of_statements</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.c</MarginText>
<Admonition type="aarm" aarm="note">
The <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is now required; that doesn't make any real difference, because a <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code> can be empty.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.d</MarginText>
<Admonition type="aarm" aarm="note">
We have incorporated some rules from RM83-6.5 here.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.e</MarginText>
<Admonition type="aarm" aarm="note">
RM83 forgot to restrict the definition of elaboration of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> to nongenerics. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.f/2</MarginText>
<MarginInfo items={["AI95-00218-03"]} />
<Admonition type="aarm" aarm="note">
<code><a href="../AA-8/AA-8.3#S0234">Overriding_indicator</a></code> is added to <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>11.g/3</MarginText>
<MarginInfo items={["AI05-0183-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>. This is described in <a href="../AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_6.3.1"></a>

## 6.3.1  Conformance Rules

<MarginText>1</MarginText>
<p>[When subprogram profiles are given in more than one place, they are required to conform in one of four ways: type conformance, mode conformance, subtype conformance, or full conformance.] <br /></p>


#### Static Semantics

<MarginText>2/1</MarginText>
<MarginInfo items={["AI95-00117-01"]} />
<p>{"{"}<em>8652/0011</em>{"}"} [As explained in <a href="../AA-B/AA-B.1">B.1</a>, &ldquo;<a href="../AA-B/AA-B.1">Interfacing Aspects</a>&rdquo;, a <em>convention</em> can be specified for an entity.] Unless this document states otherwise, the default convention of an entity is Ada. [For a callable entity or access-to-subprogram type, the convention is called the <em>calling convention</em>.] The following conventions are defined by the language: <br /></p>

<MarginText>3/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<ul>
<li>The default calling convention for any subprogram not listed below is <em>Ada</em>. [The Convention aspect may be specified to override the default calling convention (see <a href="../AA-B/AA-B.1">B.1</a>)]. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>See also the rule about renamings-as-body in <a href="../AA-8/AA-8.5#Subclause_8.5.4">8.5.4</a>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4</MarginText>
<ul>
<li>The <em>Intrinsic</em> calling convention represents subprograms that are &ldquo;built in&rdquo; to the compiler. The default calling convention is Intrinsic for the following: <br /></li>
</ul>
<MarginText>5</MarginText>
<ul>
<li>an enumeration literal;<br /></li>
<MarginText>6</MarginText>
<li>a "/=" operator declared implicitly due to the declaration of "=" (see <a href="../AA-6/AA-6.6">6.6</a>);<br /></li>
<MarginText>7</MarginText>
<li>any other implicitly declared subprogram unless it is a dispatching operation of a tagged type;<br /></li>
<MarginText>8</MarginText>
<li>an inherited subprogram of a generic formal tagged type with unknown discriminants; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>8.a.1/1</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Consider: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.a.2/1</MarginText>
<CodeBlock language="ada">
package P is{"\n"}    type Root is tagged null record;{"\n"}    procedure Proc(X: Root);{"\n"}end P;{"\n"}
<MarginText>8.a.3/1</MarginText>
generic{"\n"}    type Formal({"<"}{">"}) is new Root with private;{"\n"}package G is{"\n"}    ...{"\n"}end G;{"\n"}
<MarginText>8.a.4/1</MarginText>
package body G is{"\n"}    ...{"\n"}    X: Formal := ...;{"\n"}    ...{"\n"}    Proc(X); -- This is a dispatching call in Instance, because{"\n"}             -- the actual type for Formal is class-wide.{"\n"}    ...{"\n"}    -- Proc'Access would be illegal here, because it is of{"\n"}    -- convention Intrinsic, by the above rule.{"\n"}end G;{"\n"}
<MarginText>8.a.5/1</MarginText>
type Actual is new Root with ...;{"\n"}procedure Proc(X: Actual);{"\n"}package Instance is new G(Formal ={">"} Actual'Class);{"\n"}    -- It is legal to pass in a class-wide actual, because Formal{"\n"}    -- has unknown discriminants.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>8.a.6/1</MarginText>
<Admonition type="aarm" aarm="note">
Within Instance, all calls to Proc will be dispatching calls, so Proc doesn't really exist in machine code, so we wish to avoid taking 'Access of it. This rule applies to those cases where the actual type might be class-wide, and makes these Intrinsic, thus forbidding 'Access. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9</MarginText>
<ul>
<li>an attribute that is a subprogram;<br /></li>
<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00252-01"]} />
<li>a subprogram declared immediately within a <code><a href="../AA-9/AA-9.4#S0254">protected_body</a></code>;<br /></li>
<MarginText>10.1/4</MarginText>
<MarginInfo items={["AI95-00252-01", "AI95-00407-01", "AI12-0107-1"]} />
<li>any prefixed view of a subprogram (see <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>) without synchronization kind (see <a href="../AA-9/AA-9.5">9.5</a>) By_Entry or By_Protected_Procedure. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>10.a/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The profile of a prefixed view is different from  the &ldquo;real&rdquo; profile of the subprogram (it doesn't have the first parameter), so we don't want to be able to take 'Access of it, as that would require generating a wrapper of some sort.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b/4</MarginText>
<MarginInfo items={["AI12-0107-1"]} />
<Admonition type="aarm" aarm="note">
We except prefixed views that have synchronization kind By_Protected_Procedure so that they can be used with an access-to-protected-procedure type. These don't require special wrappers (this is the normal form for a protected subprogram call). The By_Entry part is just for consistency (there is no access-to-entry type in Ada). <br /></Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>
<ul>
<li>[The Access attribute is not allowed for Intrinsic subprograms.] <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The Intrinsic calling convention really represents any number of calling conventions at the machine code level; the compiler might have a different instruction sequence for each intrinsic. That's why the Access attribute is disallowed. We do not wish to require the implementation to generate an out of line body for an intrinsic.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
Whenever we wish to disallow the Access attribute in order to ease implementation, we make the subprogram Intrinsic. Several language-defined subprograms have &ldquo;<strong>with</strong> Convention ={">"} Intrinsic;&rdquo;. An implementation might actually implement this as &ldquo;<strong>with</strong> Import ={">"} True, Convention ={">"} Intrinsic;&rdquo;, if there is really no body, and the implementation of the subprogram is built into the code generator.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.c</MarginText>
<Admonition type="aarm" aarm="note">
Subprograms declared in <code>protected_bodies</code> will generally have a special calling convention so as to pass along the identification of the current instance of the protected type. The convention is not <em>protected</em> since such local subprograms need not contain any &ldquo;locking&rdquo; logic since they are not callable via &ldquo;external&rdquo; calls; this rule prevents an access value designating such a subprogram from being passed outside the protected unit.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.d</MarginText>
<Admonition type="aarm" aarm="note">
The &ldquo;implicitly declared subprogram&rdquo; above refers to predefined operators (other than the "=" of a tagged type) and the inherited subprograms of untagged types. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12/4</MarginText>
<MarginInfo items={["AI12-0107-1", "AI12-0159-1"]} />
<ul>
<li>The default calling convention is <em>protected</em> for a protected subprogram, for a prefixed view of a subprogram with a synchronization kind of By_Protected_Procedure, and for an access-to-subprogram type with the reserved word <strong>protected</strong> in its definition.<br /></li>
<MarginText>13/4</MarginText>
<MarginInfo items={["AI12-0107-1", "AI12-0159-1"]} />
<li>The default calling convention is <em>entry</em> for an entry and for a prefixed view of a subprogram with a synchronization kind of By_Entry.<br /></li>
<MarginText>13.1/5</MarginText>
<MarginInfo items={["AI95-00254-01", "AI95-00409-01", "AI05-0264-1", "AI12-0207-1"]} />
<li>The calling convention for an anonymous access-to-subprogram parameter or anonymous access-to-subprogram result is <em>protected</em> if the reserved word <strong>protected</strong> appears in its definition; otherwise, it is the convention of the entity  that has  the parameter or result, unless that entity has convention <em>protected</em>, <em>entry</em>, or Intrinsic, in which case the convention is Ada. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>13.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The calling convention for other anonymous access-to-subprogram types is Ada. <br /></Admonition>
</AnnotatedOnly>

<MarginText>13.2/1</MarginText>
<MarginInfo items={["AI95-00117-01"]} />
<ul>
<li>{"{"}<em>8652/0011</em>{"}"} [If not specified above as Intrinsic, the calling convention for any inherited or overriding dispatching operation of a tagged type is that of the corresponding subprogram of the parent type.] The default calling convention for a new dispatching operation of a tagged type is the convention of the type. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>13.a.1/1</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The first rule is officially stated in <a href="../AA-3/AA-3.9#Subclause_3.9.2">3.9.2</a>. The second is intended to make interfacing to foreign OOP languages easier, by making the default be that the type and operations all have the same convention. <br /></Admonition>
</AnnotatedOnly>

<MarginText>14/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>Of these four conventions, only Ada and Intrinsic are allowed as a <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> in the specification of a Convention aspect. <br /></p>

<AnnotatedOnly>
<MarginText>14.a/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>The names of the <em>protected</em> and <em>entry</em> calling conventions cannot be used in the specification of Convention. Note that <strong>protected</strong> and <strong>entry</strong> are reserved words. <br /></Admonition>
</AnnotatedOnly>

<MarginText>15/2</MarginText>
<MarginInfo items={["AI95-00409-01"]} />
<p>Two profiles are <em>type conformant</em> if they have the same number of parameters, and both have a result if either does, and corresponding parameter and result types are the same, or, for access parameters or access results, corresponding designated types are the same, or corresponding designated profiles are type conformant. <br /></p>

<AnnotatedOnly>
<MarginText>15.a/2</MarginText>
<MarginInfo items={["AI95-00409-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For anonymous access-to-object parameters, the designated types have to be the same for type conformance, not the access types, since in general each access parameter has its own anonymous access type, created when the subprogram is called. Of course, corresponding parameters have to be either both access parameters or both not access parameters.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>15.b/2</MarginText>
<MarginInfo items={["AI95-00409-01"]} />
<Admonition type="aarm" aarm="note">
Similarly, for anonymous access-to-subprogram parameters, the designated profiles of the types, not the types themselves, have to be conformant. <br /></Admonition>
</AnnotatedOnly>

<MarginText>16/3</MarginText>
<MarginInfo items={["AI95-00318-02", "AI95-00409-01", "AI05-0142-4"]} />
<p>Two profiles are <em>mode conformant</em> if:<br /></p>

<MarginText>16.1/3</MarginText>
<MarginInfo items={["AI05-0142-4", "AI05-0262-1"]} />
<ul>
<li>they are type conformant; and<br /></li>
<MarginText>16.2/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<li>corresponding parameters have identical modes and both or neither are explicitly aliased parameters; and<br /></li>
<MarginText>16.3/3</MarginText>
<MarginInfo items={["AI05-0207-1"]} />
<li>for corresponding access parameters and any access result type, the designated subtypes statically match and either both or neither are access-to-constant, or the designated profiles are subtype conformant. <br /></li>
</ul>
<MarginText>17/3</MarginText>
<MarginInfo items={["AI05-0239-1"]} />
<p>Two profiles are <em>subtype conformant</em> if they are mode conformant, corresponding subtypes of the profile statically match, and the associated calling conventions are the same. The profile of a generic formal subprogram is not subtype conformant with any other profile. <br /></p>

<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong><br /></Admonition>
</AnnotatedOnly>

<MarginText>18/3</MarginText>
<MarginInfo items={["AI05-0134-1", "AI05-0262-1"]} />
<p>Two profiles are <em>fully conformant</em> if they are subtype conformant, if they have access-to-subprogram results whose designated profiles are fully conformant, and for corresponding parameters: <br /></p>

<MarginText>18.1/3</MarginText>
<MarginInfo items={["AI05-0262-1"]} />
<ul>
<li>they have the same names; and<br /></li>
<MarginText>18.2/3</MarginText>
<MarginInfo items={["AI05-0046-1"]} />
<li>both or neither have <code><a href="../AA-3/AA-3.10#S0083">null_exclusion</a></code>s; and<br /></li>
<MarginText>18.3/3</MarginText>
<li>neither have <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s, or they both have <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s that are fully conformant with one another; and<br /></li>
<MarginText>18.4/3</MarginText>
<MarginInfo items={["AI05-0134-1"]} />
<li>for access-to-subprogram parameters, the designated profiles are fully conformant. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>18.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Full conformance requires subtype conformance, which requires the same calling conventions. However, the calling convention of the declaration and body of a subprogram or entry are always the same by definition. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b/3</MarginText>
<MarginInfo items={["AI05-0046-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The part about <code><a href="../AA-3/AA-3.10#S0083">null_exclusion</a></code>s is necessary to prevent controlling parameters from having different exclusions, as such a parameter is defined to exclude null whether or not an exclusion is given.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.c/3</MarginText>
<MarginInfo items={["AI05-0134-1"]} />
<Admonition type="aarm" aarm="note">
The parts about access-to-subprogram parameters and results is necessary to prevent such types from having different <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s in the specification and body of a subprogram. If that was allowed, it would be undefined which <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code> was used in a call of an access-to-subprogram parameter. <br /></Admonition>
</AnnotatedOnly>

<MarginText>19</MarginText>
<p>Two expressions are <em>fully conformant</em> if, [after replacing each use of an operator with the equivalent <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code>:] <br /></p>

<MarginText>20</MarginText>
<ul>
<li>each constituent construct of one corresponds to an instance of the same syntactic category in the other, except that an expanded name may correspond to a <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code> (or <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>) or to a different expanded name in the other; and<br /></li>
<MarginText>20.1/4</MarginText>
<MarginInfo items={["AI12-0050-1"]} />
<li>corresponding <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>s occurring within the two expressions are the same; and<br /></li>
<MarginText>21/4</MarginText>
<MarginInfo items={["AI12-0050-1"]} />
<li>each <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code>, <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>, and <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> that is not part of the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> of an expanded name in one denotes the same declaration as the corresponding <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code>, <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>, or <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> in the other, or they denote corresponding declarations occurring within the two expressions; and <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>21.a/5</MarginText>
<MarginInfo items={["AI12-0300-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that it doesn't say &ldquo;respectively&rdquo; because a <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code> can correspond to a <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code>, and vice  versa, by the previous bullet. This rule allows the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> of an expanded name to be removed, or replaced with a different <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> that denotes a renaming of the same entity. However, it does not allow a <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code> or <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> to be replaced with one denoting a distinct renaming (except for <code><a href="../AA-4/AA-4.1#S0092">direct_name</a></code>s and <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code>s in <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code>es of expanded names). Note that calls using operator notation are equivalent to calls using prefix notation.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b</MarginText>
<Admonition type="aarm" aarm="note">
Given the following declarations: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.c</MarginText>
<CodeBlock language="ada">
package A is{"\n"}    function F(X : Integer := 1) return Boolean;{"\n"}end A;{"\n"}
<MarginText>21.c.1/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
with A;{"\n"}package B is{"\n"}    package A_View renames A;{"\n"}    function F_View(X : Integer := 9999) return Boolean renames A.F;{"\n"}end B;{"\n"}
<MarginText>21.d</MarginText>
with A, B; use A, B;{"\n"}procedure Main is ...{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>21.e</MarginText>
<Admonition type="aarm" aarm="note">
Within Main, the expressions &ldquo;F&rdquo;, &ldquo;A.F&rdquo;, &ldquo;B.A_View.F&rdquo;, and &ldquo;A_View.F&rdquo; are all fully conformant with one another. However, &ldquo;F&rdquo; and &ldquo;F_View&rdquo; are not fully conformant. If they were, it would be bad news, since the two denoted views have different <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.f/4</MarginText>
<MarginInfo items={["AI12-0050-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>We talk about <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>s and "corresponding declarations" because of the possibility of <code><a href="../AA-5/AA-5.5#S0183">iterator_specification</a></code>s occurring within the expressions; each <code><a href="../AA-5/AA-5.5#S0183">iterator_specification</a></code> is a separate declaration, which we need to allow, but we do want to require that the <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>s are the same. <br /></Admonition>
</AnnotatedOnly>

<MarginText>21.1/3</MarginText>
<MarginInfo items={["AI95-00175-01", "AI05-0092-1"]} />
<ul>
<li>{"{"}<em>8652/0018</em>{"}"} each <code><a href="../AA-4/AA-4.1#S0101">attribute_designator</a></code> in one is the same as the corresponding <code><a href="../AA-4/AA-4.1#S0101">attribute_designator</a></code> in the other; and<br /></li>
<MarginText>22/5</MarginText>
<MarginInfo items={["AI12-0342-1"]} />
<li>each <code><a href="../AA-4/AA-4.4#S0141">primary</a></code> that is a literal in one is a user-defined literal if and only if the corresponding literal in the other is also a user-defined literal. Furthermore, if neither are user-defined literals then they shall have the same values[, but they may have differing textual representations]; if both are user-defined literals then they shall have the same textual representation .<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.a/5</MarginText>
<MarginInfo items={["AI12-0342-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This rule applies to <code><a href="../AA-2/AA-2.5#S0015">character_literal</a></code>s, so even though other rules would allow a rename of a character literal to conform to the literal, this rule prevents that . <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>22.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that the above definition makes full conformance a transitive relation. <br /></Admonition>
</AnnotatedOnly>

<MarginText>23</MarginText>
<p>Two <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>s are <em>fully conformant</em> if they have the same number of discriminants, and discriminants in the same positions have the same names, statically matching subtypes, and <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s that are fully conformant with one another. <br /></p>

<MarginText>24</MarginText>
<p>Two <code><a href="../AA-3/AA-3.6#S0055">discrete_subtype_definition</a></code>s are <em>fully conformant</em> if they are both <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code>s or are both <code><a href="../AA-3/AA-3.5#S0037">range</a></code>s, the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>s (if any) denote the same subtype, and the corresponding <code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>s of the <code><a href="../AA-3/AA-3.5#S0037">range</a></code>s (if any) fully conform. <br /></p>

<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>In the <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code> case, any ranges have to <em>be</em> corresponding; that is, two <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code>s cannot conform unless both or neither has a <code><a href="../AA-3/AA-3.5#S0037">range</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This definition is used in <a href="../AA-9/AA-9.5#Subclause_9.5.2">9.5.2</a>, &ldquo;<a href="../AA-9/AA-9.5#Subclause_9.5.2">Entries and Accept Statements</a>&rdquo; for the conformance required between the <code><a href="../AA-3/AA-3.6#S0055">discrete_subtype_definition</a></code>s of an <code><a href="../AA-9/AA-9.5#S0257">entry_declaration</a></code> for a family of entries and the corresponding <code><a href="../AA-9/AA-9.5#S0263">entry_index_specification</a></code> of the <code><a href="../AA-9/AA-9.5#S0260">entry_body</a></code>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>24.1/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00397-01"]} />
<p>The <em>prefixed view profile</em> of a subprogram is the profile obtained by omitting the first parameter of that subprogram. There is no prefixed view profile for a parameterless subprogram. For the purposes of defining subtype and mode conformance, the convention of a prefixed view profile is considered to match that of either an entry or a protected operation.<br /></p>

<AnnotatedOnly>
<MarginText>24.c/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This definition is used to define how primitive subprograms of interfaces match operations in task and protected type definitions (see <a href="../AA-9/AA-9.1">9.1</a> and <a href="../AA-9/AA-9.4">9.4</a>). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.d/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The weird rule about conventions is pretty much required for synchronized interfaces to make any sense. There will be wrappers all over the place for interfaces anyway. Of course, this doesn't imply that entries have the same convention as protected operations. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>25</MarginText>
<p>An implementation may declare an operator declared in a language-defined library unit to be intrinsic. <br /></p>

<AnnotatedOnly>
<MarginText>26/5</MarginText>
<MarginInfo items={["AI12-0398-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   Any conformance requirements between <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>s that are part of a profile or <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> are defined by the semantics of each particular aspect. In particular, there is no general requirement for <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>s to match in conforming profiles or discriminant parts. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.a</MarginText>
<Admonition type="aarm" aarm="note">
The rules for full conformance are relaxed &mdash; they are now based on the structure of constructs, rather than the sequence of lexical elements. This implies, for example, that "(X, Y: T)" conforms fully with "(X: T; Y: T)", and "(X: T)" conforms fully with "(X: <strong>in</strong> T)". <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.b/2</MarginText>
<MarginInfo items={["AI95-00117-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0011</em>{"}"} <strong>Corrigendum:</strong> Clarified that the default convention is Ada. Also clarified that the convention of a primitive operation of a tagged type is the same as that of the type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.c/2</MarginText>
<MarginInfo items={["AI95-00175-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0018</em>{"}"} <strong>Corrigendum:</strong> Added wording to ensure that two attributes conform only if they have the same <code><a href="../AA-4/AA-4.1#S0101">attribute_designator</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.d/2</MarginText>
<MarginInfo items={["AI95-00252-01", "AI95-00254-01", "AI95-00407-01"]} />
<Admonition type="aarm" aarm="note">
Defined the calling convention for anonymous access-to-subprogram types and for prefixed views of subprograms (see <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.e/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="note">
Defined the conformance of access result types (see <a href="../AA-6/AA-6.1">6.1</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.f/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00397-01"]} />
<Admonition type="aarm" aarm="note">
Defined the prefixed view profile of subprograms for later use.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.g/2</MarginText>
<MarginInfo items={["AI95-00409-01"]} />
<Admonition type="aarm" aarm="note">
Defined the conformance of anonymous access-to-subprogram parameters. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.h/3</MarginText>
<MarginInfo items={["AI05-0046-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Now require <code><a href="../AA-3/AA-3.10#S0083">null_exclusion</a></code>s to match for full conformance. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage of the ability to write mismatching exclusions. In any case, it is easy to fix: add a <code><a href="../AA-3/AA-3.10#S0083">null_exclusion</a></code> where needed for conformance.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.i/3</MarginText>
<MarginInfo items={["AI05-0134-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Now require full conformance of anonymous access-to-subprogram parameters and results for full conformance. This is necessary so that there is no confusion about the default expression that is used for a call. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage and writing different default expressions. In any case, it is easy to fix: change any default expressions that don't conform so that they do conform.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.j/3</MarginText>
<MarginInfo items={["AI05-0207-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Now include the presence or absence of <strong>constant</strong> in access parameters to be considered when checking mode conformance. This is necessary to prevent modification of constants. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage and writing mismatching access types. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.k/3</MarginText>
<MarginInfo items={["AI05-0142-4"]} />
<Admonition type="aarm" aarm="note">
Explicitly aliased parameters are included as part of mode conformance (since it affects the parameter passing mechanism). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.l/5</MarginText>
<MarginInfo items={["AI12-0207-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> The convention of an anonymous access-to-subprogram parameter of a protected entry or subprogram is Ada; if one wants it to be <em>protected</em> it can be declared with the keyword <strong>protected</strong>. This is incompatible, but only in a very rare case; usually the intent is to pass a normal subprogram to a protected subprogram (and this was impossible in Ada 2012). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.m/4</MarginText>
<MarginInfo items={["AI12-0107-1", "AI12-0159-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> We now define that a prefixed view of a subprogram with synchronization kind By_Protected_Procedure can be used as the prefix of 'Access for an access-to-protected type. We consider this a correction as it certainly appears that it ought to work, but in original Ada 2012 it would have had a convention mismatch. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>26.n/4</MarginText>
<MarginInfo items={["AI12-0050-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> We now define how two expressions containing quantified expressions can fully conform. This isn't incompatible, as the original Ada 2012 never allowed such expressions to conform (the declarations in each formally being different). Neither is it an extension as one would expect these to conform.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.o/5</MarginText>
<MarginInfo items={["AI12-0342-1"]} />
<Admonition type="aarm" aarm="note">
The conformance of literals is tightened up to not assume anything about the value of a user-defined literal. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_6.3.2"></a>

## 6.3.2  Inline Expansion of Subprograms

<MarginText>1</MarginText>
<p>[Subprograms may be expanded in line at the call site.] <br /></p>

<p><em>Paragraphs 2 through 4 were moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo;.</em> <br /></p>


#### Static Semantics

<MarginText>5/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>For a callable entity or a generic subprogram, the following language-defined representation aspect may be specified:<br /></p>

<MarginText>5.1/3</MarginText>
<dt><br/>Inline</dt>
<dl>
<dd>The type of aspect Inline is Boolean. When aspect Inline is True for a callable entity, inline expansion is desired for all calls to that entity. When aspect Inline is True for a generic subprogram, inline expansion is desired for all calls to all instances of that generic subprogram.<br /></dd>
<MarginText>5.2/3</MarginText>
<dd>If directly specified, the <code><a href="../AA-13/AA-13.1#S0348">aspect_definition</a></code> shall be a static expression. [This aspect is never inherited;] if not directly specified, the aspect is False.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>5.a/3</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Aspect Description for </strong><strong>Inline: </strong>For efficiency, Inline calls are requested for a subprogram.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.c/3</MarginText>
<CodeBlock language="ada">
This paragraph was deleted.{"\n"}
<MarginText>5.d/3</MarginText>
This paragraph was deleted.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>5.e/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The meaning of a subprogram can be changed by inline expansion as requested by aspect Inline only in the presence of failing checks (see <a href="../AA-11/AA-11.6">11.6</a>). <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>6/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>For each call, an implementation is free to follow or to ignore the recommendation determined by the Inline aspect. <br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note, in particular, that the recommendation cannot always be followed for a recursive call, and is often infeasible for entries. Note also that the implementation can inline calls even when no such desire was expressed via the Inline aspect, so long as the semantics of the program remains unchanged. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>7.a/3</MarginText>
<MarginInfo items={["AI95-00309-01", "AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>7.b/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>7.c/3</MarginText>
<MarginInfo items={["AI95-00309-01", "AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>7.d/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
Aspect Inline is new; <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Inline is now obsolescent. <br /></Admonition>
</AnnotatedOnly>

