---
sidebar_position:  100
---

# 12.5 Formal Types

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>[A generic formal subtype can be used to pass to a generic unit a subtype whose type is in a certain category of types.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We considered having intermediate syntactic categories <code>formal_integer_type_definition</code>, <code>formal_real_type_definition</code>, and <code>formal_fixed_point_definition</code>, to be more uniform with the syntax rules for non-generic-formal types. However, that would make the rules for formal types slightly more complicated, and it would cause confusion, since <code><a href="../AA-12/AA-12.5#S0326">formal_discrete_type_definition</a></code> would not fit into the scheme very well. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />

<CodeBlock>
<code>formal_type_declaration</code><a id="S0320"></a><code> ::= </code><br />      <code><a href="../AA-12/AA-12.5#S0321">formal_complete_type_declaration</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0322">formal_incomplete_type_declaration</a></code><br />

</CodeBlock>
<MarginText>2.1/5</MarginText>
<MarginInfo items={["AI05-0183-1", "AI05-0213-1", "AI12-0205-1"]} />

<CodeBlock>
<code>formal_complete_type_declaration</code><a id="S0321"></a><code> ::= </code><br />    <strong>type</strong> <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>[<code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>] <strong>is</strong> <code><a href="../AA-12/AA-12.5#S0323">formal_type_definition</a></code><br />        [<strong>or use</strong> <em>default_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>] [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>
<MarginText>2.2/5</MarginText>
<MarginInfo items={["AI05-0213-1", "AI12-0205-1"]} />

<CodeBlock>
<code>formal_incomplete_type_declaration</code><a id="S0322"></a><code> ::= </code><br />    <strong>type</strong> <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code>[<code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>] [<strong>is tagged</strong>]<br />        [<strong>or use</strong> <em>default_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>];<br />

</CodeBlock>
<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />

<CodeBlock>
<code>formal_type_definition</code><a id="S0323"></a><code> ::= </code><br />      <code><a href="../AA-12/AA-12.5#S0324">formal_private_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0325">formal_derived_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0326">formal_discrete_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0327">formal_signed_integer_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0328">formal_modular_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0329">formal_floating_point_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0330">formal_ordinary_fixed_point_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0331">formal_decimal_fixed_point_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0332">formal_array_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0333">formal_access_type_definition</a></code><br />    | <code><a href="../AA-12/AA-12.5#S0334">formal_interface_type_definition</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>4</MarginText>
<p>For a generic formal subtype, the actual shall be a <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>; it denotes the <em>(generic) actual subtype</em>. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>When we say simply &ldquo;formal&rdquo; or &ldquo;actual&rdquo; (for a generic formal that denotes a subtype) we're talking about the subtype, not the type, since a name that denotes a <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code> denotes a subtype, and the corresponding actual also denotes a subtype. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>5</MarginText>
<p>A <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code> declares a <em>(generic) formal type</em>, and its first subtype, the <em>(generic) formal subtype</em>. <br /></p>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A subtype (other than the first subtype) of a generic formal type is not a generic formal subtype. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/3</MarginText>
<MarginInfo items={["AI95-00442-01", "AI05-0213-1"]} />
<p>The form of a <code><a href="../AA-12/AA-12.5#S0323">formal_type_definition</a></code> <em>determines a category (of types)</em> to which the formal type belongs. For a <code><a href="../AA-12/AA-12.5#S0324">formal_private_type_definition</a></code> the reserved words <strong>tagged</strong> and <strong>limited</strong> indicate the category of types (see <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>). The reserved word <strong>tagged</strong> also plays this role in the case of a <code><a href="../AA-12/AA-12.5#S0322">formal_incomplete_type_declaration</a></code>. For a <code><a href="../AA-12/AA-12.5#S0325">formal_derived_type_definition</a></code> the category of types is the derivation class rooted at the ancestor type. For other formal types, the name of the syntactic category indicates the category of types; a <code><a href="../AA-12/AA-12.5#S0326">formal_discrete_type_definition</a></code> defines a discrete type, and so on. <br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule is clearer with the flat syntax rule for <code><a href="../AA-12/AA-12.5#S0323">formal_type_definition</a></code> given above. Adding <code>formal_integer_type_definition</code> and others would make this rule harder to state clearly.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.b/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We use &ldquo;category&rsquo; rather than &ldquo;class&rdquo; above, because the requirement that classes are closed under derivation is not important here. Moreover, there are interesting categories that are not closed under derivation. For instance, limited and interface are categories that do not form classes. <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>The actual type shall be in the category determined for the formal. <br /></p>

<AnnotatedOnly>
<MarginText>7.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>For example, if the category determined for the formal is the category of all discrete types, then the actual has to be discrete.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.b/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
Note that this rule does not require the actual to belong to every category to which the formal belongs. For example, formal private types are in the category of composite types, but the actual need not be composite. Furthermore, one can imagine an infinite number of categories that are just arbitrary sets of types (even though we don't give them names, since they are uninteresting). We don't want this rule to apply to <em>those</em> categories.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.c/2</MarginText>
<MarginInfo items={["AI95-00114-01", "AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
&ldquo;Limited&rdquo; is not an &ldquo;interesting&rdquo; category, but &ldquo;nonlimited&rdquo; is; it is legal to pass a nonlimited type to a limited formal type, but not the other way around. The reserved word <strong>limited</strong> really represents a category containing both limited and nonlimited types. &ldquo;Private&rdquo; is not a category for this purpose; a generic formal private type accepts both private and nonprivate actual types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.d/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
It is legal to pass a class-wide subtype as the actual if it is in the right category, so long as the formal has unknown discriminants. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7.1/5</MarginText>
<MarginInfo items={["AI12-0205-1"]} />
<p>The <em>default_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>, if any, shall denote a subtype which is allowed as an actual subtype for the formal type.<br /></p>

<AnnotatedOnly>
<MarginText>7.e/5</MarginText>
<MarginInfo items={["AI12-0205-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This rule is observed at compile time of the <code><a href="../AA-12/AA-12.1#S0310">generic_declaration</a></code>, and is consistent with the handling of the <code><a href="../AA-12/AA-12.6#S0339">default_name</a></code> of a formal subprogram. This means that a type declared outside of the <code><a href="../AA-12/AA-12.1#S0310">generic_declaration</a></code> cannot be used as the <em>default_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> for a formal type that depends on any other formal type. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>8/5</MarginText>
<MarginInfo items={["AI95-00043-01", "AI95-00233-01", "AI95-00442-01", "AI05-0029-1", "AI12-0413-1"]} />
<p>{"{"}<em>8652/0037</em>{"}"} [The formal type also belongs to each category that contains the determined category.] The primitive subprograms of the type are as for any type in the determined category. For a formal type other than a formal derived type, these are the predefined operators of the type. For an elementary formal type, the predefined operators are implicitly declared immediately after the declaration of the formal type. For a composite formal type, the predefined operators are implicitly declared either immediately after the declaration of the formal type, or later immediately within the declarative region in which the type is declared according to the rules of <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>. In an instance, the copy of such an implicit declaration declares a view of the predefined operator of the actual type, even if this operator has been overridden for the actual type and even if it is never declared for the actual type, unless the actual type is an untagged record type, in which case it declares a view of the primitive (equality) operator. [The rules specific to formal derived types are given in <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>.] <br /></p>

<AnnotatedOnly>
<MarginText>8.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>All properties of the type are as for any type in the category. Some examples: The primitive operations available are as defined by the language for each category. The form of <code><a href="../AA-3/AA-3.2#S0029">constraint</a></code> applicable to a formal type in a <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code> depends on the category of the type as for a nonformal type. The formal type is tagged if and only if it is declared as a tagged private type, or as a type derived from a (visibly) tagged type. (Note that the actual type might be tagged even if the formal type is not.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.a.1/5</MarginText>
<MarginInfo items={["AI12-0413-1"]} />
<Admonition type="aarm" aarm="note">
If the primitive equality operator of the (actual) untagged record type is declared abstract, then Program_Error will be raised if the equality operator of the formal type is in fact invoked within an instance of a generic body (see <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>). If the operator is invoked within an instance of the generic spec, the instance is illegal. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.b/3</MarginText>
<MarginInfo items={["AI05-0029-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The somewhat cryptic phrase &ldquo;even if it is never declared&rdquo; is intended to deal with the following oddity: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.c/3</MarginText>
<CodeBlock language="ada">
package Q is{"\n"}    type T is limited private;{"\n"}private{"\n"}    type T is range 1 .. 10;{"\n"}end Q;{"\n"}
<MarginText>8.d/3</MarginText>
generic{"\n"}    type A is array (Positive range {"<"}{">"}) of T;{"\n"}package Q.G is{"\n"}    A1, A2 : A (1 .. 1);{"\n"}private{"\n"}    B : Boolean := A1 = A2;{"\n"}end Q.G;{"\n"}
<MarginText>8.e/3</MarginText>
with Q.G;{"\n"}package R is{"\n"}   type C is array (Positive range {"<"}{">"}) of Q.T;{"\n"}
<MarginText>8.f/3</MarginText>
   package I is new Q.G (C); -- Where is the predefined "=" for C?{"\n"}end R;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>8.g/3</MarginText>
<Admonition type="aarm" aarm="note">
An "=" is available for the formal type A in the private part of Q.G. However, no "=" operator is ever declared for type C, because its component type Q.T is limited. Still, in the instance I the name "=" declares a view of the "=" for C which exists-but-is-never-declared. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   Generic formal types, like all types, are not named. Instead, a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> can denote a generic formal subtype. Within a generic unit, a generic formal type is considered as being distinct from all other (formal or nonformal) types. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>This follows from the fact that each <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code> declares a type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   A <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code> is allowed only for certain kinds of types, and therefore only for certain kinds of generic formal types. See <a href="../AA-3/AA-3.7">3.7</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.a/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The term &ldquo;formal floating point type&rdquo; refers to a type defined by a <code><a href="../AA-12/AA-12.5#S0329">formal_floating_point_definition</a></code>. It does not include a formal derived type whose ancestor is a floating point type. Similar terminology applies to the other kinds of <code><a href="../AA-12/AA-12.5#S0323">formal_type_definition</a></code>. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>11</MarginText>
<p><em>Examples of generic formal types:</em> <br /></p>

<MarginText>12</MarginText>
<CodeBlock language="ada">
type Item is private;{"\n"}type Buffer(Length : Natural) is limited private;{"\n"}
<MarginText>13</MarginText>
type Enum  is ({"<"}{">"});{"\n"}type Int   is range {"<"}{">"};{"\n"}type Angle is delta {"<"}{">"};{"\n"}type Mass  is digits {"<"}{">"};{"\n"}
<MarginText>14</MarginText>
type Table is array (Enum) of Item;{"\n"}

</CodeBlock>
<MarginText>15</MarginText>
<p><em>Example of a generic formal part declaring a formal integer type:</em> <br /></p>

<MarginText>16</MarginText>
<CodeBlock language="ada">
generic{"\n"}   type Rank is range {"<"}{">"};{"\n"}   First  : Rank := Rank'First;{"\n"}   Second : Rank := First + 1;  --  the operator "+" of the type Rank  {"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="note">
RM83 has separate sections &ldquo;Generic Formal Xs&rdquo; and &ldquo;Matching Rules for Formal Xs&rdquo; (for various X's) with most of the text redundant between the two. We have combined the two in order to reduce the redundancy. In RM83, there is no &ldquo;Matching Rules for Formal Types&rdquo; section; nor is there a &ldquo;Generic Formal Y Types&rdquo; section (for Y = Private, Scalar, Array, and Access). This causes, for example, the duplication across all the &ldquo;Matching Rules for Y Types&rdquo; sections of the rule that the actual passed to a formal type shall be a subtype; the new organization avoids that problem.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.b</MarginText>
<Admonition type="aarm" aarm="note">
The matching rules are stated more concisely.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.c</MarginText>
<Admonition type="aarm" aarm="note">
We no longer consider the multiplying operators that deliver a result of type <em>universal_fixed</em> to be predefined for the various types; there is only one of each in package Standard. Therefore, we need not mention them here as RM83 had to. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.d/2</MarginText>
<MarginInfo items={["AI95-00043-01", "AI95-00233-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0037</em>{"}"} Corrigendum 1 corrected the wording to properly define the location where operators are defined for formal array types. The wording here was inconsistent with that in <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>, &ldquo;<a href="../AA-7/AA-7.3#Subclause_7.3.1">Private Operations</a>&rdquo;. For the Amendment, this wording was corrected again, because it didn't reflect the Corrigendum 1 revisions in <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.e/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
Formal interface types are defined; see <a href="../AA-12/AA-12.5#Subclause_12.5.5">12.5.5</a>, &ldquo;<a href="../AA-12/AA-12.5#Subclause_12.5.5">Formal Interface Types</a>&rdquo;.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.f/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We use &ldquo;determines a category&rdquo; rather than class, since not all interesting properties form a class. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.g/3</MarginText>
<MarginInfo items={["AI05-0183-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in a <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code>. This is described in <a href="../AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.h/3</MarginText>
<MarginInfo items={["AI05-0029-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Correction</strong>: Updated the wording to acknowledge the possibility of operations that are never declared for an actual type but still can be used inside of a generic unit.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>16.i/3</MarginText>
<MarginInfo items={["AI05-0213-1", "AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
Formal incomplete types are added; these are documented as an extension in the next subclause. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.j/5</MarginText>
<MarginInfo items={["AI12-0413-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Updated the wording to clarify that predefined record equality never reemerges in a generic instantiation. This model was presumed by <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>, but the wording wasn't right for untagged record types with user-defined equality. Therefore, an implementation that strictly implemented the Ada 2012 wording would call the predefined equality for an actual type that is an untagged record type with a user-defined equality, while Ada 2022 implementations would call the primitive (user-defined) equality. This could change the runtime behavior in rare cases. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.k/5</MarginText>
<MarginInfo items={["AI12-0205-1"]} />
<Admonition type="aarm" aarm="note">
Generic formal types now can include an optional default <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_12.5.1"></a>

## 12.5.1  Formal Private and Derived Types

<MarginText>1/5</MarginText>
<MarginInfo items={["AI95-00442-01", "AI05-0213-1", "AI12-0445-1"]} />
<p>[In its most general form, the category determined for a formal private type is all types, but the category can be restricted to only nonlimited types or to only tagged types. Similarly, the category for a formal incomplete type is all types but the category can be restricted to only tagged types; unlike other formal types, the actual type can be incompletely defined, and not ready  to be frozen (see <a href="../AA-13/AA-13.14">13.14</a>). The category determined for a formal derived type is the derivation class rooted at the ancestor type.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/3</MarginText>
<MarginInfo items={["AI95-00442-01", "AI05-0213-1"]} />
<Admonition type="aarm" aarm="proof">
<strong></strong>The first two rules are given normatively below, and the third rule is given normatively in <a href="../AA-12/AA-12.5">12.5</a>; they are repeated here to give a capsule summary of what this subclause is about. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Since the actual of a formal incomplete type does not need to be able to be frozen, the actual can be an incomplete type or a partial view before its completion. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>formal_private_type_definition</code><a id="S0324"></a><code> ::= </code>[[<strong>abstract</strong>] <strong>tagged</strong>] [<strong>limited</strong>] <strong>private</strong><br />

</CodeBlock>
<MarginText>3/5</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00419-01", "AI95-00443-01", "AI12-0446-1"]} />

<CodeBlock>
<code>formal_derived_type_definition</code><a id="S0325"></a><code> ::= </code><br />     [<strong>abstract</strong>] [<strong>limited</strong> | <strong>synchronized</strong>] <strong>new</strong> <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> [[<strong>and</strong> <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code>] <strong>with</strong> <strong>private</strong>]<br />

</CodeBlock>

#### Legality Rules

<MarginText>4</MarginText>
<p>If a generic formal type declaration has a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>, then it shall not include a <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code> for a discriminant. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Consequently, a generic formal subtype with a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> is an indefinite subtype, so the declaration of a stand-alone variable has to provide a constraint on such a subtype, either explicitly, or by its initial value. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/3</MarginText>
<MarginInfo items={["AI95-00401-01", "AI95-00419-01", "AI95-00443-01", "AI05-0237-1"]} />
<p>The <em>ancestor subtype</em> of a formal derived type is the subtype denoted by the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> of the <code><a href="../AA-12/AA-12.5#S0325">formal_derived_type_definition</a></code>. For a formal derived type declaration, the reserved words <strong>with private</strong> shall appear if and only if the ancestor type is a tagged type; in this case the formal derived type is a private extension of the ancestor type and the ancestor shall not be a class-wide type. [Similarly, an <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code> or the optional reserved words <strong>abstract</strong> or <strong>synchronized</strong> shall appear only if the ancestor type is a tagged type]. The reserved word <strong>limited</strong> or <strong>synchronized</strong> shall appear only if the ancestor type [and any progenitor types] are limited types. The reserved word <strong>synchronized</strong> shall appear (rather than <strong>limited</strong>) if the ancestor type or any of the progenitor types are synchronized interfaces. The ancestor type shall be a limited interface if the reserved word <strong>synchronized</strong> appears.<br /></p>

<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We use the term &ldquo;ancestor&rdquo; here instead of &ldquo;parent&rdquo; because the actual can be any descendant of the ancestor, not necessarily a direct descendant.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b/3</MarginText>
<MarginInfo items={["AI95-00419-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
We require the ancestor type to be limited when <strong>limited</strong> appears so that we avoid oddities like limited integer types. Normally, <strong>limited</strong> means &ldquo;match anything&rdquo; for a generic formal, but it was felt that allowing limited elementary types to be declared was just too weird. Integer still matches a formal limited private type; it is only a problem when the type is known to be elementary. Note that the progenitors are required to be limited by rules in <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>, thus that part of the rule is redundant.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.c/2</MarginText>
<MarginInfo items={["AI95-00443-01"]} />
<Admonition type="aarm" aarm="note">
We require that <strong>synchronized</strong> appear if the ancestor or any of the progenitors are synchronized, so that property is explicitly given in the program text &ndash; it is not automatically inherited from the ancestors. However, it can be given even if neither the ancestor nor the progenitors are synchronized. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5.1/5</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00401-01", "AI95-00443-01", "AI05-0087-1", "AI12-0036-1", "AI12-0442-1"]} />
<p>The actual type for a formal derived type shall be a descendant of [the ancestor type and] every progenitor of the formal type.  The actual type for a formal derived type shall be tagged if and only if the formal derived type is a private extension. If the reserved word <strong>synchronized</strong> appears in the declaration of the formal derived type, the actual type shall be a synchronized tagged type. <br /></p>

<AnnotatedOnly>
<MarginText>5.d/2</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>The actual type has to be a descendant of the ancestor type, in order that it be in the correct class. Thus, that part of the rule is redundant. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.e/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For a nonformal private extension, we require the partial view to be synchronized if the full view is synchronized tagged. This does not apply to a formal private extension &mdash; it is OK if the formal is not synchronized. Any attempt to extend the formal type will be rechecked in the instance, where the rule disallowing extending a synchronized noninterface type will be enforced. This is consistent with the &ldquo;no hidden interfaces&rdquo; rule also applying only to nonformal private extensions, as well as the rule that a limited nonformal private extension implies a limited full type. Formal private extensions are exempted from all these rules to enable the construction of generics that can be used with the widest possible range of types. In particular, an indefinite tagged limited formal private type can match any &ldquo;concrete&rdquo; actual tagged type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.f/3</MarginText>
<MarginInfo items={["AI05-0087-1"]} />
<Admonition type="aarm" aarm="note">
A type (including formal types) derived from a limited interface could be nonlimited; we do not want a limited type derived from such an interface to match a nonlimited formal derived type. Otherwise, we could assign limited objects. Thus, we have to explicitly ban this case.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.g/5</MarginText>
<MarginInfo items={["AI12-0005-1", "AI12-0036-1"]} />
<Admonition type="aarm" aarm="note">
If we allowed actual types whose kind differs from that  of the formal derived type, we could allow type conversions that would not be allowed outside of the generic. That would be particularly problematical if the actual is a tagged type with extension components; we could have created an object of the type that is missing those components by converting from the ancestor type to a formal derived type that is not an extension. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/5</MarginText>
<MarginInfo items={["AI05-0213-1", "AI12-0442-1"]} />
<p>If a formal private or derived subtype is definite, then the actual subtype shall also be definite. If the formal type is nonlimited, the actual type shall be nonlimited. <br /></p>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>On the other hand, for an indefinite formal subtype, the actual can be either definite or indefinite. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.b/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>The rule about nonlimited formals applies to both private and derived formal types. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6.1/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />
<p>A <code><a href="../AA-12/AA-12.5#S0322">formal_incomplete_type_declaration</a></code> declares a formal incomplete type. The only view of a formal incomplete type is an incomplete view. [Thus, a formal incomplete type is subject to the same usage restrictions as any other incomplete type &mdash; see <a href="../AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a>.]<br /></p>

<MarginText>7/5</MarginText>
<MarginInfo items={["AI12-0351-1"]} />
<p>For a generic formal derived type with no <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>, the actual subtype shall be statically compatible with the ancestor subtype. Furthermore: <br /></p>

<MarginText>8/5</MarginText>
<MarginInfo items={["AI12-0351-1"]} />
<ul>
<li>If the ancestor subtype is constrained, the actual subtype shall be constrained ; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>8.a/5</MarginText>
<MarginInfo items={["AI12-0351-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>In other words, any constraint on the ancestor subtype is considered part of the &ldquo;contract&rdquo;. Predicates are also considered part of the contract for <em>any</em> subtype, via the static compatibility requirement. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9</MarginText>
<ul>
<li>If the ancestor subtype is an unconstrained access or composite subtype, the actual subtype shall be unconstrained. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule ensures that if a composite constraint is allowed on the formal, one is also allowed on the actual. If the ancestor subtype is an unconstrained scalar subtype, the actual is allowed to be constrained, since a scalar constraint does not cause further constraints to be illegal. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10</MarginText>
<ul>
<li>If the ancestor subtype is an unconstrained discriminated subtype, then the actual shall have the same number of discriminants, and each discriminant of the actual shall correspond to a discriminant of the ancestor, in the sense of <a href="../AA-3/AA-3.7">3.7</a>.<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This ensures that if a discriminant constraint is given on the formal subtype, the corresponding constraint in the instance will make sense, without additional runtime checks. This is not necessary for arrays, since the bounds cannot be overridden in a type extension. An <code><a href="../AA-3/AA-3.7#S0060">unknown_discriminant_part</a></code> may be used to relax these matching requirements. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10.1/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<ul>
<li>If the ancestor subtype is an access subtype, the actual subtype shall exclude null if and only if the ancestor subtype excludes null. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>10.b/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We require that the &ldquo;excludes null&rdquo; property match, because it would be difficult to write a correct generic for a formal access type without knowing this property. Many typical algorithms and techniques will not work for a subtype that excludes null (setting an unused component to <strong>null</strong>, default-initialized objects, and so on). We want this sort of requirement to be reflected in the contract of the generic.<br /></Admonition>
</AnnotatedOnly>

<MarginText>11/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />
<p>The declaration of a formal derived type shall not have a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>. For a generic formal private or incomplete type with a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>: <br /></p>

<MarginText>12</MarginText>
<ul>
<li>The actual type shall be a type with the same number of discriminants.<br /></li>
<MarginText>13</MarginText>
<li>The actual subtype shall be unconstrained.<br /></li>
<MarginText>14</MarginText>
<li>The subtype of each discriminant of the actual type shall statically match the subtype of the corresponding discriminant of the formal type. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>14.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We considered defining the first and third rule to be called &ldquo;subtype conformance&rdquo; for <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>s. We rejected that idea, because it would require implicit (inherited) <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>s, which seemed like too much mechanism. <br /></Admonition>
</AnnotatedOnly>

<MarginText>15/5</MarginText>
<MarginInfo items={["AI12-0444-1"]} />
<p>[For a generic formal type with an <code><a href="../AA-3/AA-3.7#S0060">unknown_discriminant_part</a></code>, the actual may  have discriminants, though that is not required, and may be definite or indefinite.]<br /></p>

<MarginText>15.1/4</MarginText>
<MarginInfo items={["AI12-0095-1"]} />
<p>When enforcing Legality Rules, for the purposes of determining within a generic body whether a type is unconstrained in any partial view, a discriminated subtype is considered to have a constrained partial view if it is a descendant of an untagged generic formal private or derived type.<br /></p>


#### Static Semantics

<MarginText>16/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>The category determined for a formal private type is as follows: <br /></p>

<MarginText>17/2</MarginText>
<p class="Indented2"><em>Type Definition</em> 	<em>Determined Category</em><br /><br /><strong>limited private</strong> 	the category of all types<br /><strong>private</strong> 	the category of all nonlimited types<br /><strong>tagged limited private</strong> 	the category of all tagged types<br /><strong>tagged private</strong> 	the category of all nonlimited tagged types<br /></p>

<MarginText>18</MarginText>
<p>[The presence of the reserved word <strong>abstract</strong> determines whether the actual type may be abstract.]<br /></p>

<MarginText>18.1/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />
<p>The category determined for a formal incomplete type is the category of all types, unless the <code><a href="../AA-12/AA-12.5#S0320">formal_type_declaration</a></code> includes the reserved word <strong>tagged</strong>; in this case, it is the category of all tagged types.<br /></p>

<MarginText>19</MarginText>
<p>A formal private or derived type is a private or derived type, respectively. A formal derived tagged type is a private extension. [A formal private or derived type is abstract if the reserved word <strong>abstract</strong> appears in its declaration.]<br /></p>

<MarginText>20/3</MarginText>
<MarginInfo items={["AI95-00233-01", "AI05-0110-1"]} />
<p>For a formal derived type, the characteristics (including components, but excluding discriminants if there is a new <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>), predefined operators, and inherited user-defined primitive subprograms are determined by its ancestor type and its progenitor types (if any), in the same way that those of a derived type are determined by those of its parent type and its progenitor types (see <a href="../AA-3/AA-3.4">3.4</a> and <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>).<br /></p>

<MarginText>21/3</MarginText>
<MarginInfo items={["AI95-00202", "AI95-00233-01", "AI95-00401-01", "AI05-0029-1", "AI05-0110-1"]} />
<p>{"{"}<em>8652/0038</em>{"}"} In an instance, the copy of an implicit declaration of a primitive subprogram of a formal derived type declares a view of the corresponding primitive subprogram of the ancestor or progenitor of the formal derived type, even if this primitive has been overridden for the actual type and even if it is never declared for the actual type. When the ancestor or progenitor of the formal derived type is itself a formal type, the copy of the implicit declaration declares a view of the corresponding copied operation of the ancestor or progenitor. [In the case of a formal private extension, however, the tag of the formal type is that of the actual type, so if the tag in a call is statically determined to be that of the formal type, the body executed will be that corresponding to the actual type.] <br /></p>

<AnnotatedOnly>
<MarginText>21.a/3</MarginText>
<MarginInfo items={["AI95-00401-01", "AI05-0239-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The above rule defining the properties of primitive subprograms in an instance applies even if the subprogram has been overridden or hidden for the actual type. This rule is necessary for untagged types, because their primitive subprograms might have been overridden by operations that are not subtype conformant with the operations defined for the class. For tagged types, the rule still applies, but the primitive subprograms will dispatch to the appropriate implementation based on the type and tag of the operands. Even for tagged types, the formal parameter names and <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code>s are determined by those of the primitive subprograms of the specified ancestor type (or progenitor type, for subprograms inherited from an interface type). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b/4</MarginText>
<MarginInfo items={["AI12-0030-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>The availability of stream attributes is not formally a characteristic of a type, but it is still determined by the ancestor type for a formal derived type in the same way as the characteristics are. Availability is rechecked in the instance specification. <br /></Admonition>
</AnnotatedOnly>

<MarginText>21.1/5</MarginText>
<MarginInfo items={["AI12-0419-1"]} />
<p>In an instance, the implicitly composed and additive aspects (see <a href="../AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>) of a formal type are those of the actual; for a nonoverridable aspect, a formal derived type inherits the aspect if the ancestor or any progenitor has the aspect, according to the rules given in <a href="../AA-13/AA-13.1">13.1</a>.<br /></p>

<MarginText>22/1</MarginText>
<p>For a <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> S that denotes a formal indefinite subtype, the following attribute is defined: <br /></p>

<MarginText>23/3</MarginText>
<dt><br/>S'Definite</dt>
<MarginInfo items={["AI05-0264-1"]} />
<dl>
<dd>S'Definite yields True if the actual subtype corresponding to S is definite; otherwise, it yields False. The value of this attribute is of the predefined type Boolean. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>23.a/5</MarginText>
<MarginInfo items={["AI95-00114-01", "AI12-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>Whether an actual subtype is definite or indefinite may have a major effect on the algorithm used in a generic. For example, in a generic I/O package, whether to use fixed-length or variable-length records could depend on whether the actual is definite or indefinite. This attribute is essentially a replacement for the Constrained attribute, which is now obsolescent . <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>23.1/3</MarginText>
<MarginInfo items={["AI95-00158-01", "AI05-0071-1"]} />
<p>In the case where a formal type has unknown discriminants, and the actual type is a class-wide type <em>T</em>'Class:<br /></p>

<MarginText>23.2/2</MarginText>
<MarginInfo items={["AI95-00158-01"]} />
<ul>
<li>For the purposes of defining the primitive operations of the formal type, each of the primitive operations of the actual type is considered to be a subprogram (with an intrinsic calling convention &mdash; see <a href="../AA-6/AA-6.3#Subclause_6.3.1">6.3.1</a>) whose body consists of a dispatching call upon the corresponding operation of <em>T</em>, with its formal parameters as the actual parameters. If it is a function, the result of the dispatching call is returned.<br /></li>
<MarginText>23.3/2</MarginText>
<MarginInfo items={["AI95-00158-01"]} />
<li>If the corresponding operation of <em>T</em> has no controlling formal parameters, then the controlling tag value is determined by the context of the call, according to the rules for tag-indeterminate calls (see <a href="../AA-3/AA-3.9#Subclause_3.9.2">3.9.2</a> and <a href="../AA-5/AA-5.2">5.2</a>). In the case where the tag would be statically determined to be that of the formal type, the call raises Program_Error. If such a function is renamed, any call on the renaming raises Program_Error. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>23.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>As it states in <a href="../AA-6/AA-6.3#Subclause_6.3.1">6.3.1</a>, the convention of an inherited subprogram of a generic formal tagged type with unknown discriminants is intrinsic.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.c/2</MarginText>
<Admonition type="aarm" aarm="note">
In the case of a corresponding primitive of T with no controlling formal parameters, the context of the call provides the controlling tag value for the dispatch. If no tag is provided by context, Program_Error is raised rather than resorting to a nondispatching call. For example:<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.d/2</MarginText>
<CodeBlock language="ada">
generic{"\n"}   type NT({"<"}{">"}) is new T with private;{"\n"}    -- Assume T has operation "function Empty return T;"{"\n"}package G is{"\n"}   procedure Test(X : in out NT);{"\n"}end G;{"\n"}
<MarginText>23.e/2</MarginText>
package body G is{"\n"}   procedure Test(X : in out NT) is{"\n"}   begin{"\n"}      X := Empty;  -- Dispatching based on X'Tag takes{"\n"}                   -- place if actual is class-wide.{"\n"}      declare{"\n"}          Y : NT := Empty;{"\n"}                   -- If actual is class-wide, this raises Program_Error{"\n"}                   -- as there is no tag provided by context.{"\n"}      begin{"\n"}          X := Y;  -- We never get this far.{"\n"}      end;{"\n"}   end Test;{"\n"}end G;{"\n"}
<MarginText>23.f/2</MarginText>
type T1 is new T with null record;{"\n"}package I is new G(T1'Class);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24/5</MarginText>
<MarginInfo items={["AI95-00442-01", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
 <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<ul>
<li> <br /></li>
<MarginText>26/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<li> <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>27</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   The actual type can be abstract only if the formal type is abstract (see <a href="../AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This is necessary to avoid contract model problems, since one or more of its primitive subprograms are abstract; it is forbidden to create objects of the type, or to declare functions returning the type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>On the other hand, it is OK to pass a nonabstract actual to an abstract formal &mdash; <strong>abstract</strong> on the formal indicates that the actual might be abstract. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28/5</MarginText>
<MarginInfo items={["AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   If the formal has a <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>, the actual can be either definite or indefinite. Otherwise, the actual can only  be definite. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.a</MarginText>
<Admonition type="aarm" aarm="note">
Ada 83 does not have <code><a href="../AA-3/AA-3.7#S0060">unknown_discriminant_part</a></code>s, so it allows indefinite subtypes to be passed to definite formals, and applies a legality rule to the instance body. This is a contract model violation. Ada 95 disallows such cases at the point of the instantiation. The workaround is to add ({"<"}{">"}) as the <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code> of any formal subtype if it is intended to be used with indefinite actuals. If that's the intent, then there can't be anything in the generic body that would require a definite subtype.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.b</MarginText>
<Admonition type="aarm" aarm="note">
The check for discriminant subtype matching is changed from a runtime check to a compile-time check. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.c/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00401-01", "AI95-00419-01", "AI95-00443-01"]} />
<Admonition type="aarm" aarm="note">
A generic formal derived type can include progenitors (interfaces) as well as a primary ancestor. It also may include <strong>limited</strong> to indicate that it is a limited type, and <strong>synchronized</strong> to indicate that it is a synchronized type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.d/2</MarginText>
<MarginInfo items={["AI95-00202-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0038</em>{"}"} <strong>Corrigendum:</strong> Corrected wording to define the operations that are inherited when the ancestor of a formal type is itself a formal type to avoid anomalies.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.e/2</MarginText>
<MarginInfo items={["AI95-00158-01"]} />
<Admonition type="aarm" aarm="note">
Added a semantic description of the meaning of operations of an actual class-wide type, as such a type does not have primitive operations of its own.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.f/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<Admonition type="aarm" aarm="note">
Added a matching rule for access subtypes that exclude null.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.g/2</MarginText>
<MarginInfo items={["AI95-00233-01"]} />
<Admonition type="aarm" aarm="note">
The wording for the declaration of implicit operations is corrected to be consistent with <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a> as modified by Corrigendum 1.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.h/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We change to &ldquo;determines a category&rdquo; as that is the new terminology (it avoids confusion, since not all interesting properties form a class). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.i/3</MarginText>
<MarginInfo items={["AI05-0087-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added wording to prevent a limited type from being passed to a nonlimited formal derived type. While this was allowed, it would break the contract for the limited type, so hopefully no programs actually depend on that. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.j/3</MarginText>
<MarginInfo items={["AI05-0213-1"]} />
<Admonition type="aarm" aarm="note">
Formal incomplete types are a new kind of generic formal; these can be instantiated with incomplete types and unfrozen private types. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.k/3</MarginText>
<MarginInfo items={["AI05-0029-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Updated the wording to acknowledge the possibility of operations that are never declared for an actual type but still can be used inside of a generic unit.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.l/3</MarginText>
<MarginInfo items={["AI05-0071-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Fixed hole that failed to define what happened for "=" for an untagged private type whose actual is class-wide.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.m/3</MarginText>
<MarginInfo items={["AI05-0110-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Revised the wording for inheritance of characteristics and operations of formal derived types to be reuse the rules as defined for derived types; this should eliminate holes in the wording which have plagued us since Ada 95 was defined (it has been "corrected" four previous times).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.n/3</MarginText>
<MarginInfo items={["AI05-0237-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added missing rule for the ancestors of formal derived types. The added rule would formally be incompatible, but since it would be impossible to instantiate any such generic, this cannot happen outside of test suites and thus is not documented as an incompatibility. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.o/4</MarginText>
<MarginInfo items={["AI12-0036-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> Added a requirement that a tagged type only match a formal derived type that is a private extension. This is necessary to prevent type conversions that would not be allowed outside of the generic. We expect that this will be rare, as it only can happen if the formal derived type does not accurately describe the actual type; in most such cases, extension will be desired and a private extension used so that is allowed.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.p/5</MarginText>
<MarginInfo items={["AI12-0351-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> The predicates of an ancestor subtype are considered part of the contract for a formal derived type, even if the ancestor subtype is unconstrained. This means, for instance, if the ancestor subtype is a subtype of Float with a predicate, then an actual subtype with a different predicate is illegal in Ada 2022 while it would have been allowed in Ada 2012. Cases like this are quite unlikely and will be detected at compile-time if they occur. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.q/4</MarginText>
<MarginInfo items={["AI12-0095-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> The assume the worst rule for determining within a generic body whether a type is unconstrained in any partial view was moved here. While AI05-0041-1 added it to <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>, it's also needed (at least) in <a href="../AA-4/AA-4.6">4.6</a> and <a href="../AA-6/AA-6.4#Subclause_6.4.1">6.4.1</a>. Thus, it was moved here so that it applies generally. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_12.5.2"></a>

## 12.5.2  Formal Scalar Types

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>A <em>formal scalar type</em> is one defined by any of the <code><a href="../AA-12/AA-12.5#S0323">formal_type_definition</a></code>s in this subclause. [The category determined for a formal scalar type is the category of all discrete, signed integer, modular, floating point, ordinary fixed point, or decimal types.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="proof">
<strong></strong>The second rule follows from the rule in <a href="../AA-12/AA-12.5">12.5</a> that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The &ldquo;category of a type&rdquo; includes any classes that the type belongs to. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>formal_discrete_type_definition</code><a id="S0326"></a><code> ::= </code>({"<"}{">"})<br />

</CodeBlock>
<MarginText>3</MarginText>

<CodeBlock>
<code>formal_signed_integer_type_definition</code><a id="S0327"></a><code> ::= </code><strong>range</strong> {"<"}{">"}<br />

</CodeBlock>
<MarginText>4</MarginText>

<CodeBlock>
<code>formal_modular_type_definition</code><a id="S0328"></a><code> ::= </code><strong>mod</strong> {"<"}{">"}<br />

</CodeBlock>
<MarginText>5</MarginText>

<CodeBlock>
<code>formal_floating_point_definition</code><a id="S0329"></a><code> ::= </code><strong>digits</strong> {"<"}{">"}<br />

</CodeBlock>
<MarginText>6</MarginText>

<CodeBlock>
<code>formal_ordinary_fixed_point_definition</code><a id="S0330"></a><code> ::= </code><strong>delta</strong> {"<"}{">"}<br />

</CodeBlock>
<MarginText>7</MarginText>

<CodeBlock>
<code>formal_decimal_fixed_point_definition</code><a id="S0331"></a><code> ::= </code><strong>delta</strong> {"<"}{">"} <strong>digits</strong> {"<"}{">"}<br />

</CodeBlock>

#### Legality Rules

<MarginText>8</MarginText>
<p>The actual type for a formal scalar type shall not be a nonstandard numeric type. <br /></p>

<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This restriction is necessary because nonstandard numeric types have some number of restrictions on their use, which could cause contract model problems in a generic body. Note that nonstandard numeric types can be passed to formal derived and formal private subtypes, assuming they obey all the other rules, and assuming the implementation allows it (being nonstandard means the implementation might disallow anything). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
 <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>9.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We change to &ldquo;determines a category&rdquo; as that is the new terminology (it avoids confusion, since not all interesting properties form a class). <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_12.5.3"></a>

## 12.5.3  Formal Array Types

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>[The category determined for a formal array type is the category of all array types.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="proof">
<strong></strong>This rule follows from the rule in <a href="../AA-12/AA-12.5">12.5</a> that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>formal_array_type_definition</code><a id="S0332"></a><code> ::= </code><code><a href="../AA-3/AA-3.6#S0051">array_type_definition</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>3</MarginText>
<p>The only form of <code><a href="../AA-3/AA-3.6#S0055">discrete_subtype_definition</a></code> that is allowed within the declaration of a generic formal (constrained) array subtype is a <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The reason is the same as for forbidding <code><a href="../AA-3/AA-3.2#S0029">constraint</a></code>s in <code><a href="../AA-3/AA-3.2#S0027">subtype_indication</a></code>s (see <a href="../AA-12/AA-12.1">12.1</a>). <br /></Admonition>
</AnnotatedOnly>

<MarginText>4</MarginText>
<p>For a formal array subtype, the actual subtype shall satisfy the following conditions: <br /></p>

<MarginText>5</MarginText>
<ul>
<li>The formal array type and the actual array type shall have the same dimensionality; the formal subtype and the actual subtype shall be either both constrained or both unconstrained.<br /></li>
<MarginText>6</MarginText>
<li>For each index position, the index types shall be the same, and the index subtypes (if unconstrained), or the index ranges (if constrained), shall statically match (see <a href="../AA-4/AA-4.9#Subclause_4.9.1">4.9.1</a>). <br /></li>
<MarginText>7</MarginText>
<li>The component subtypes of the formal and actual array types shall statically match. <br /></li>
<MarginText>8</MarginText>
<li>If the formal type has aliased components, then so shall the actual. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>On the other hand, if the formal's components are not aliased, then the actual's components can be either aliased or not. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>9</MarginText>
<p><em>Example of formal array types:</em> <br /></p>

<MarginText>10</MarginText>
<CodeBlock language="ada">
--  given the generic package {"\n"}
<MarginText>11</MarginText>
generic{"\n"}   type Item   is private;{"\n"}   type Index  is ({"<"}{">"});{"\n"}   type Vector is array (Index range {"<"}{">"}) of Item;{"\n"}   type Table  is array (Index) of Item;{"\n"}package P is{"\n"}   ...{"\n"}end P;{"\n"}
<MarginText>12</MarginText>
--  and the types {"\n"}
<MarginText>13</MarginText>
type Mix    is array (Color range {"<"}{">"}) of Boolean;{"\n"}type Option is array (Color) of Boolean;{"\n"}
<MarginText>14</MarginText>
--  then Mix can match Vector and Option can match Table {"\n"}
<MarginText>15</MarginText>
package R is new P(Item   ={">"} Boolean, Index ={">"} Color,{"\n"}                   Vector ={">"} Mix,     Table ={">"} Option);{"\n"}
<MarginText>16</MarginText>
--  Note that Mix cannot match Table and Option cannot match Vector{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="note">
The check for matching of component subtypes and index subtypes or index ranges is changed from a runtime check to a compile-time check. The Ada 83 rule that &ldquo;If the component type is not a scalar type, then the component subtypes shall be either both constrained or both unconstrained&rdquo; is removed, since it is subsumed by static matching. Likewise, the rules requiring that component types be the same is subsumed. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>16.b/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We change to &ldquo;determines a category&rdquo; as that is the new terminology (it avoids confusion, since not all interesting properties form a class). <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_12.5.4"></a>

## 12.5.4  Formal Access Types

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<p>[The category determined for a formal access type is the category of all access types.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="proof">
<strong></strong>This rule follows from the rule in <a href="../AA-12/AA-12.5">12.5</a> that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>formal_access_type_definition</code><a id="S0333"></a><code> ::= </code><code><a href="../AA-3/AA-3.10#S0079">access_type_definition</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>3</MarginText>
<p>For a formal access-to-object type, the designated subtypes of the formal and actual types shall statically match. <br /></p>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<p>If and only if the <code><a href="../AA-3/AA-3.10#S0081">general_access_modifier</a></code> <strong>constant</strong> applies to the formal, the actual shall be an access-to-constant type. If the <code><a href="../AA-3/AA-3.10#S0081">general_access_modifier</a></code> <strong>all</strong> applies to the formal, then the actual shall be a general access-to-variable type (see <a href="../AA-3/AA-3.10">3.10</a>). If and only if the formal subtype excludes null, the actual subtype shall exclude null. <br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>If no <code>_modifier</code> applies to the formal, then the actual type may be either a pool-specific or a general access-to-variable type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.a.1/1</MarginText>
<MarginInfo items={["AI95-00025-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>{"{"}<em>8652/0109</em>{"}"} Matching an access-to-variable to a formal access-to-constant type cannot be allowed. If it were allowed, it would be possible to create an access-to-variable value designating a constant.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<Admonition type="aarm" aarm="note">
We require that the &ldquo;excludes null&rdquo; property match, because it would be difficult to write a correct generic for a formal access type without knowing this property. Many typical algorithms and techniques will not work for a subtype that excludes null (setting an unused component to <strong>null</strong>, default-initialized objects, and so on). Even Ada.Unchecked_Deallocation would fail for a subtype that excludes null. Most generics would end up with comments saying that they are not intended to work for subtypes that exclude null. We would rather that this sort of requirement be reflected in the contract of the generic. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/3</MarginText>
<MarginInfo items={["AI05-0239-1", "AI05-0288-1"]} />
<p>For a formal access-to-subprogram subtype, the designated profiles of the formal and the actual shall be subtype conformant. <br /></p>


#### Examples

<MarginText>6</MarginText>
<p><em>Example of formal access types:</em> <br /></p>

<MarginText>7</MarginText>
<CodeBlock language="ada">
--  the formal types of the generic package {"\n"}
<MarginText>8</MarginText>
generic{"\n"}   type Node is private;{"\n"}   type Link is access Node;{"\n"}package P is{"\n"}   ...{"\n"}end P;{"\n"}
<MarginText>9</MarginText>
--  can be matched by the actual types {"\n"}
<MarginText>10</MarginText>
type Car;{"\n"}type Car_Name is access Car;{"\n"}
<MarginText>11</MarginText>
type Car is{"\n"}   record{"\n"}      Pred, Succ : Car_Name;{"\n"}      Number     : License_Number;{"\n"}      Owner      : Person;{"\n"}   end record;{"\n"}
<MarginText>12</MarginText>
--  in the following generic instantiation {"\n"}
<MarginText>13</MarginText>
package R is new P(Node ={">"} Car, Link ={">"} Car_Name);{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Incompatibilities With Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>13.a</MarginText>
<Admonition type="aarm" aarm="note">
The check for matching of designated subtypes is changed from a runtime check to a compile-time check. The Ada 83 rule that &ldquo;If the designated type is other than a scalar type, then the designated subtypes shall be either both constrained or both unconstrained&rdquo; is removed, since it is subsumed by static matching. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>13.b</MarginText>
<Admonition type="aarm" aarm="note">
Formal access-to-subprogram subtypes and formal general access types are new concepts. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>13.c/2</MarginText>
<MarginInfo items={["AI95-00231-01"]} />
<Admonition type="aarm" aarm="note">
Added a matching rule for subtypes that exclude null.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.d/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
We change to &ldquo;determines a category&rdquo; as that is the new terminology (it avoids confusion, since not all interesting properties form a class). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>13.e/3</MarginText>
<MarginInfo items={["AI05-0288-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Matching of formal access-to-subprogram types now uses subtype conformance rather than mode conformance, which is needed to plug a hole. This could cause some instantiations legal in Ada 95 and Ada 2005 to be rejected in Ada 2012. We believe that formal access-to-subprogram types occur rarely, and actuals that are not subtype conformant are rarer still, so this should not happen often. (In addition, one popular compiler has a bug that causes such instances to be rejected, so no code compiled with that compiler could have an incompatibility.) <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_12.5.5"></a>

## 12.5.5  Formal Interface Types

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00442-01"]} />
<p>[The category determined for a formal interface type is the category of all interface types.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/2</MarginText>
<MarginInfo items={["AI95-00442-01"]} />
<Admonition type="aarm" aarm="proof">
<strong></strong>This rule follows from the rule in <a href="../AA-12/AA-12.5">12.5</a> that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Here we're taking advantage of our switch in terminology from &ldquo;determined class&rdquo; to &ldquo;determined category&rdquo;; by saying &ldquo;category&rdquo; rather than &ldquo;class&rdquo;, we require that any actual type be an interface type, not just some type derived from an interface type. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />

<CodeBlock>
<code>formal_interface_type_definition</code><a id="S0334"></a><code> ::= </code><code><a href="../AA-3/AA-3.9#S0077">interface_type_definition</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00251", "AI95-00401"]} />
<p>The actual type shall be a descendant of every progenitor of the formal type.<br /></p>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00345"]} />
<p>The actual type shall be a limited, task, protected, or synchronized interface if and only if the formal type is also, respectively, a limited, task, protected, or synchronized interface. <br /></p>

<AnnotatedOnly>
<MarginText>4.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We require the kind of interface type to match exactly because without that it is almost impossible to properly implement the interface. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>5/5</MarginText>
<MarginInfo items={["AI12-0429-1", "AI12-0442-1"]} />
<p><em>Example of the use of a generic with a formal interface type, to establish a standard interface that all tasks will implement so they can be managed appropriately by an application-specific scheduler:</em> <br /></p>

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
<CodeBlock language="ada">
type Root_Work_Item is tagged private;{"\n"}
<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
generic{"\n"}   type Managed_Task is task interface;{"\n"}   type Work_Item({"<"}{">"}) is new Root_Work_Item with private;{"\n"}package Server_Manager is{"\n"}   task type Server is new Managed_Task with{"\n"}      entry Start(Data : in out Work_Item);{"\n"}   end Server;{"\n"}end Server_Manager;{"\n"}

</CodeBlock>
<MarginText>8/5</MarginText>
<MarginInfo items={["AI95-00433-01", "AI12-0429-1"]} />
<p> <br /></p>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>8.a/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01", "AI95-00401-01", "AI95-00442-01"]} />
<Admonition type="aarm" aarm="note">
The formal interface type is new. <br /></Admonition>
</AnnotatedOnly>

