---
sidebar_position:  74
---

# 9.1. Task Units and Task Objects

:::danger
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>A task unit is declared by a <i>task declaration</i>, which has a corresponding <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code>. A task declaration may be a <code><a href="/docs/arm/AA-9/AA-9.1#S0244">task_type_declaration</a></code>, in which case it declares a named task type; alternatively, it may be a <code><a href="/docs/arm/AA-9/AA-9.1#S0245">single_task_declaration</a></code>, in which case it defines an anonymous task type, as well as declaring a named task object of that type. <br /></p>


#### Syntax

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00345-01", "AI05-0183-1"]} />

<CodeBlock>
<code>task{"_"}type{"_"}declaration</code><a id="S0244"></a><code> ::= </code><br />   <b>task</b> <b>type</b> <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code> [<code><a href="/docs/arm/AA-3/AA-3.7#S0061">known_discriminant_part</a></code>]<br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>] [<b>is</b><br />     [<b>new</b> <code><a href="/docs/arm/AA-3/AA-3.9#S0078">interface_list</a></code> <b>with</b>]<br />     <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code>];<br />

</CodeBlock>
<MarginText>3/5</MarginText>
<MarginInfo items={["AI95-00399-01", "AI05-0183-1", "AI12-0446-1"]} />

<CodeBlock>
<code>single{"_"}task{"_"}declaration</code><a id="S0245"></a><code> ::= </code><br />   <b>task</b> <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code> <br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>] [<b>is</b><br />     [<b>new</b> <code><a href="/docs/arm/AA-3/AA-3.9#S0078">interface_list</a></code> <b>with</b>]<br />     <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code>];<br />

</CodeBlock>
<MarginText>4</MarginText>

<CodeBlock>
<code>task{"_"}definition</code><a id="S0246"></a><code> ::= </code><br />     {"{"}<code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code>{"}"}<br />  [ <b>private</b><br />     {"{"}<code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code>{"}"}]<br />  <b>end</b> [<i>task{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code>]<br />

</CodeBlock>
<MarginText>5/1</MarginText>
<MarginInfo items={["AI95-00137-01"]} />

<CodeBlock>
{"{"}<i>8652/0009</i>{"}"} <code>task{"_"}item</code><a id="S0247"></a><code> ::= </code><code><a href="/docs/arm/AA-9/AA-9.5#S0257">entry_declaration</a></code> | <code><a href="/docs/arm/AA-13/AA-13.1#S0343">aspect_clause</a></code><br />

</CodeBlock>
<MarginText>6/3</MarginText>
<MarginInfo items={["AI05-0267-1"]} />

<CodeBlock>
<code>task{"_"}body</code><a id="S0248"></a><code> ::= </code><br />   <b>task</b> <b>body</b> <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code><br />        [<code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code>] <b>is</b><br />     <code><a href="/docs/arm/AA-3/AA-3.11#S0086">declarative_part</a></code><br />   <b>begin</b><br />     <code><a href="/docs/arm/AA-11/AA-11.2#S0304">handled_sequence_of_statements</a></code><br />   <b>end</b> [<i>task{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code>];<br />

</CodeBlock>
<MarginText>7</MarginText>
<p class="Indented2">If a <i>task{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code> appears at the end of a <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> or <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code>, it shall repeat the <code><a href="/docs/arm/AA-3/AA-3.1#S0022">defining_identifier</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>8.a/2</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<p><i>Paragraph 8 was deleted.</i> <br /></p>


#### Static Semantics

<MarginText>9</MarginText>
<p>A <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> defines a task type and its first subtype. The first list of <code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code>s of a <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task{"_"}definition</a></code>, together with the <code><a href="/docs/arm/AA-3/AA-3.7#S0061">known{"_"}discriminant{"_"}part</a></code>, if any, is called the visible part of the task unit. [ The optional list of <code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code>s after the reserved word <b>private</b> is called the private part of the task unit.] <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="proof">
<b></b>Private part is defined in Clause <a href="/docs/arm/AA-8/">8</a>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>9.1/1</MarginText>
<MarginInfo items={["AI95-00116-01"]} />
<p>{"{"}<i>8652/0029</i>{"}"} For a task declaration without a <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code>, a <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> without <code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code>s is assumed.<br /></p>

<MarginText>9.2/3</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00397-01", "AI95-00399-01", "AI95-00419-01", "AI05-0042-1"]} />
<p>For a task declaration with an <code><a href="/docs/arm/AA-3/AA-3.9#S0078">interface_list</a></code>, the task type inherits user-defined primitive subprograms from each progenitor type (see <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>), in the same way that a derived type inherits user-defined primitive subprograms from its progenitor types (see <a href="/docs/arm/AA-3/AA-3.4">3.4</a>). If the first parameter of a primitive inherited subprogram is of the task type or an access parameter designating the task type, and there is an <code><a href="/docs/arm/AA-9/AA-9.5#S0257">entry_declaration</a></code> for a single entry with the same identifier within the task declaration, whose profile is type conformant with the prefixed view profile of the inherited subprogram, the inherited subprogram is said to be <i>implemented</i> by the conforming task entry using an implicitly declared nonabstract subprogram which has the same profile as the inherited subprogram and which overrides it. <br /></p>

<AnnotatedOnly>
<MarginText>9.b/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The inherited subprograms can only come from an interface given as part of the task declaration. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b.1/3</MarginText>
<MarginInfo items={["AI05-0042-1"]} />
<Admonition type="aarm" aarm="reason">
<b></b>The part about the implicitly declared subprogram is needed so that a subprogram implemented by an entry is considered to be overridden for the purpose of the other rules of the language. Without it, it would for instance be illegal for an abstract subprogram to be implemented by an entry, because the abstract subprogram would not be overridden. The Legality Rules below ensure that there is no conflict between the implicit overriding subprogram and a user-defined overriding subprogram. <br />
</Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>9.3/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>A task declaration requires a completion[, which shall be a <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code>,] and every <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> shall be the completion of some task declaration. <br /></p>

<AnnotatedOnly>
<MarginText>9.c/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>If the implementation supports it, the task body can be imported (using aspect Import, see <a href="/docs/arm/AA-B/AA-B.1">B.1</a>), in which case no explicit <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> is allowed. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>9.4/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00399-01"]} />
<p>[Each <i>interface{"_"}</i><code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code> of an <code><a href="/docs/arm/AA-3/AA-3.9#S0078">interface_list</a></code> appearing within a task declaration shall denote a limited interface type that is not a protected interface.] <br /></p>

<AnnotatedOnly>
<MarginText>9.d/2</MarginText>
<Admonition type="aarm" aarm="proof">
<b></b><a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a> requires that an <code><a href="/docs/arm/AA-3/AA-3.9#S0078">interface_list</a></code> only name interface types, and limits the descendants of the various kinds of interface types. Only a limited, task, or synchronized interface can have a task type descendant. Nonlimited or protected interfaces are not allowed, as they offer operations that a task does not have. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>9.5/3</MarginText>
<MarginInfo items={["AI95-00397-01", "AI05-0090-1"]} />
<p>The prefixed view profile of an explicitly declared primitive subprogram of a tagged task type shall not be type conformant with any entry of the task type, if the subprogram has the same defining name as the entry and the first parameter of the subprogram is of the task type or is an access parameter designating the task type. <br /></p>

<AnnotatedOnly>
<MarginText>9.e/2</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>This prevents the existence of two operations with the same name and profile which could be called with a prefixed view. If the operation was inherited, this would be illegal by the following rules; this rule puts inherited and noninherited routines on the same footing. Note that this only applies to tagged task types (that is, those with an interface in their declaration); we do that as there is no problem with prefixed view calls of primitive operations for &ldquo;normal&rdquo; task types, and having this rule apply to all tasks would be incompatible with Ada 95. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>9.6/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00399-01"]} />
<p>For each primitive subprogram inherited by the type declared by a task declaration, at most one of the following shall apply:<br /></p>

<MarginText>9.7/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<ul>
<li>the inherited subprogram is overridden with a primitive subprogram of the task type, in which case the overriding subprogram shall be subtype conformant with the inherited subprogram and not abstract; or<br /></li>
<MarginText>9.8/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00397-01"]} />
<li>the inherited subprogram is implemented by a single entry of the task type; in which case its prefixed view profile shall be subtype conformant with that of the task entry. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>9.f/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>An entry may implement two subprograms from the ancestors, one whose first parameter is of type <i>T</i> and one whose first parameter is of type <b>access</b> <i>T</i>. That doesn't cause implementation problems because &ldquo;implemented by&rdquo; (unlike &ldquo;overridden&rsquo;) probably entails the creation of wrappers. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>9.9/2</MarginText>
<p>If neither applies, the inherited subprogram shall be a null procedure. In addition to the places where Legality Rules normally apply (see <a href="/docs/arm/AA-12/AA-12.3">12.3</a>), these rules also apply in the private part of an instance of a generic unit. <br /></p>

<AnnotatedOnly>
<MarginText>9.g/2</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Each inherited subprogram can only have a single implementation (either from overriding a subprogram or implementing an entry), and must have an implementation unless the subprogram is a null procedure. <br />
</Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>10</MarginText>
<p>[ The elaboration of a task declaration elaborates the <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code>. The elaboration of a <code><a href="/docs/arm/AA-9/AA-9.1#S0245">single{"_"}task{"_"}declaration</a></code> also creates an object of an (anonymous) task type.] <br /></p>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="proof">
<b></b>This is redundant with the general rules for the elaboration of a <code><a href="/docs/arm/AA-3/AA-3.2#S0024">full_type_declaration</a></code> and an <code><a href="/docs/arm/AA-3/AA-3.3#S0032">object_declaration</a></code>. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>
<p>[The elaboration of a <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> creates the task type and its first subtype;] it also includes the elaboration of the <code><a href="/docs/arm/AA-9/AA-9.5#S0257">entry_declaration</a></code>s in the given order.<br /></p>

<MarginText>12/1</MarginText>
<MarginInfo items={["AI95-00137-01"]} />
<p>{"{"}<i>8652/0009</i>{"}"} As part of the initialization of a task object, any <code><a href="/docs/arm/AA-13/AA-13.1#S0343">aspect_clause</a></code>s and any per-object constraints associated with <code><a href="/docs/arm/AA-9/AA-9.5#S0257">entry{"_"}declaration</a></code>s of the corresponding <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task{"_"}definition</a></code> are elaborated in the given order. <br /></p>

<AnnotatedOnly>
<MarginText>12.a/1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>The only <code><a href="/docs/arm/AA-13/AA-13.1#S0343">aspect_clause</a></code>s defined for task entries are ones that specify the Address of an entry, as part of defining an interrupt entry. These clearly need to be elaborated per-object, not per-type. Normally the address will be a function of a discriminant, if such an Address clause is in a task type rather than a single task declaration, though it could rely on a parameterless function that allocates sequential interrupt vectors.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.b</MarginText>
<Admonition type="aarm" aarm="note">
We do not mention representation pragmas, since each pragma may have its own elaboration rules. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>13</MarginText>
<p>The elaboration of a <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> has no effect other than to establish that tasks of the type can from then on be activated without failing the Elaboration{"_"}Check.<br /></p>

<MarginText>14</MarginText>
<p>[The execution of a <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> is invoked by the activation of a task of the corresponding type (see <a href="/docs/arm/AA-9/AA-9.2">9.2</a>).]<br /></p>

<MarginText>15</MarginText>
<p>The content of a task object of a given task type includes: <br /></p>

<MarginText>16</MarginText>
<ul>
<li>The values of the discriminants of the task object, if any;<br /></li>
<MarginText>17</MarginText>
<li>An entry queue for each entry of the task object; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>"For each entry" implies one queue for each single entry, plus one for each entry of each entry family. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>18</MarginText>
<ul>
<li>A representation of the state of the associated task. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19/2</MarginText>
<MarginInfo items={["AI95-00382-01"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   Other than in an <code><a href="/docs/arm/AA-3/AA-3.10#S0084">access_definition</a></code>, the name of a task unit within the declaration or body of the task unit denotes the current instance of the unit (see <a href="/docs/arm/AA-8/AA-8.6">8.6</a>), rather than the first subtype of the corresponding task type (and thus the name cannot be used as a <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code>). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19.a/2</MarginText>
<MarginInfo items={["AI95-00382-01"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>It can be used as a <code><a href="/docs/arm/AA-3/AA-3.2#S0028">subtype_mark</a></code> in an anonymous access type. In addition, it is possible to refer to some other subtype of the task type within its body, presuming such a subtype has been declared between the <code><a href="/docs/arm/AA-9/AA-9.1#S0244">task_type_declaration</a></code> and the <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   The notation of a <code><a href="/docs/arm/AA-4/AA-4.1#S0098">selected_component</a></code> can be used to denote a discriminant of a task (see <a href="/docs/arm/AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>). Within a task unit, the name of a discriminant of the task type denotes the corresponding discriminant of the current instance of the unit.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21/5</MarginText>
<MarginInfo items={["AI95-00287-01", "AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   A task type is a limited type (see <a href="/docs/arm/AA-7/AA-7.5">7.5</a>), and hence precludes use of <code><a href="/docs/arm/AA-5/AA-5.2#S0173">assignment_statement</a></code>s and predefined equality operators. If a programmer wants to write an application that stores and exchanges task identities, they can do so by defining an access type designating the corresponding task objects and by using access values for identification purposes. Assignment is available for such an access type as for any access type. Alternatively, if the implementation supports the Systems Programming Annex, the Identity attribute can be used for task identification (see <a href="/docs/arm/AA-C/AA-C.7#Subclause_C.7.1">C.7.1</a>). <br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>22</MarginText>
<p><i>Examples of declarations of task types:</i> <br /></p>

<MarginText>23</MarginText>
<CodeBlock language="ada">
task type Server is{"\n"}   entry Next{"_"}Work{"_"}Item(WI : in Work{"_"}Item);{"\n"}   entry Shut{"_"}Down;{"\n"}end Server;{"\n"}
<MarginText>24/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
task type Keyboard{"_"}Driver(ID : Keyboard{"_"}ID := New{"_"}ID) is{"\n"}      new Serial{"_"}Device with  -- see <a href="/docs/arm/AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>{"\n"}   entry Read (C : out Character);{"\n"}   entry Write(C : in  Character);{"\n"}end Keyboard{"_"}Driver;{"\n"}

</CodeBlock>
<MarginText>25</MarginText>
<p><i>Examples of declarations of single tasks:</i> <br /></p>

<MarginText>26</MarginText>
<CodeBlock language="ada">
task Controller is{"\n"}   entry Request(Level)(D : Item);  --  a family of entries{"\n"}end Controller;{"\n"}
<MarginText>27</MarginText>
task Parser is{"\n"}   entry Next{"_"}Lexeme(L : in  Lexical{"_"}Element);{"\n"}   entry Next{"_"}Action(A : out Parser{"_"}Action);{"\n"}end;{"\n"}
<MarginText>28</MarginText>
task User;  --  has no entries{"\n"}

</CodeBlock>
<MarginText>29</MarginText>
<p><i>Examples of task objects:</i> <br /></p>

<MarginText>30</MarginText>
<CodeBlock language="ada">
Agent    : Server;{"\n"}Teletype : Keyboard{"_"}Driver(TTY{"_"}ID);{"\n"}Pool     : array(1 .. 10) of Keyboard{"_"}Driver;{"\n"}

</CodeBlock>
<MarginText>31</MarginText>
<p><i>Example of access type designating task objects:</i> <br /></p>

<MarginText>32</MarginText>
<CodeBlock language="ada">
type Keyboard is access Keyboard{"_"}Driver;{"\n"}Terminal : Keyboard := new Keyboard{"_"}Driver(Term{"_"}ID);{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.a/1</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rules for task declarations are modified to allow a <code><a href="/docs/arm/AA-3/AA-3.7#S0061">known_discriminant_part</a></code>, and to allow a private part. They are also modified to allow <code><a href="/docs/arm/AA-9/AA-9.5#S0257">entry_declaration</a></code>s and <code><a href="/docs/arm/AA-13/AA-13.1#S0343">aspect_clause</a></code>s to be mixed. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.b</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rules for tasks have been split up according to task types and single tasks. In particular: The syntax rules for <code>task{"_"}declaration</code> and <code>task{"_"}specification</code> are removed. The syntax rules for <code><a href="/docs/arm/AA-9/AA-9.1#S0244">task_type_declaration</a></code>, <code><a href="/docs/arm/AA-9/AA-9.1#S0245">single_task_declaration</a></code>, <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> and <code><a href="/docs/arm/AA-9/AA-9.1#S0247">task_item</a></code> are new.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.c</MarginText>
<Admonition type="aarm" aarm="note">
The syntax rule for <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> now uses the nonterminal <code><a href="/docs/arm/AA-11/AA-11.2#S0304">handled_sequence_of_statements</a></code>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.d</MarginText>
<Admonition type="aarm" aarm="note">
The <code><a href="/docs/arm/AA-3/AA-3.11#S0086">declarative_part</a></code> of a <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code> is now required; that doesn't make any real difference, because a <code><a href="/docs/arm/AA-3/AA-3.11#S0086">declarative_part</a></code> can be empty. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.e/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00397-01", "AI95-00399-01", "AI95-00419-01"]} />
<Admonition type="aarm" aarm="note">
Task types and single tasks can be derived from one or more interfaces. Entries of the task type can implement the primitive operations of an interface. <code><a href="/docs/arm/AA-8/AA-8.3#S0234">Overriding_indicator</a></code>s can be used to specify whether or not an entry implements a primitive operation. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.f/2</MarginText>
<MarginInfo items={["AI95-00116-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0029</i>{"}"} <b>Corrigendum:</b> Clarified that a task type has an implicit empty <code><a href="/docs/arm/AA-9/AA-9.1#S0246">task_definition</a></code> if none is given.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.g/2</MarginText>
<MarginInfo items={["AI95-00137-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0009</i>{"}"} <b>Corrigendum:</b> Changed representation clauses to aspect clauses to reflect that they are used for more than just representation.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.h/2</MarginText>
<MarginInfo items={["AI95-00287-01"]} />
<Admonition type="aarm" aarm="note">
Revised the note on operations of task types to reflect that limited types do have an assignment operation, but not copying (<code><a href="/docs/arm/AA-5/AA-5.2#S0173">assignment_statement</a></code>s).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.i/2</MarginText>
<MarginInfo items={["AI95-00382-01"]} />
<Admonition type="aarm" aarm="note">
Revised the note on use of the name of a task type within itself to reflect the exception for anonymous access types. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.j/3</MarginText>
<MarginInfo items={["AI05-0183-1", "AI05-0267-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="/docs/arm/AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in a <code><a href="/docs/arm/AA-9/AA-9.1#S0244">task_type_declaration</a></code>, a <code><a href="/docs/arm/AA-9/AA-9.1#S0245">single_task_declaration</a></code>, and a <code><a href="/docs/arm/AA-9/AA-9.1#S0248">task_body</a></code>. This is described in <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.k/3</MarginText>
<MarginInfo items={["AI05-0042-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Clarified that an inherited procedure of a progenitor is overridden when it is implemented by an entry.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.l/3</MarginText>
<MarginInfo items={["AI05-0090-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Added the missing defining name in the no conflicting primitive operation rule. <br />
</Admonition>
</AnnotatedOnly>

