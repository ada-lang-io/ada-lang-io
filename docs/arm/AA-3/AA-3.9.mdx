---
sidebar_position:  27
---

# 3.9 Tagged Types and Type Extensions

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1</MarginText>
<p>[ Tagged types and type extensions support object-oriented programming, based on inheritance with extension and run-time polymorphism via <em>dispatching operations</em>. ]<br /></p>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.a/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
The intended implementation model is for the static portion of a tag to be represented as a pointer to a statically allocated and link-time initialized type descriptor. The type descriptor contains the address of the code for each primitive operation of the type. It probably also contains other information, such as might make membership tests convenient and efficient. Tags for nested type extensions must also have a dynamic part that identifies the particular elaboration of the type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b</MarginText>
<Admonition type="aarm" aarm="note">
The primitive operations of a tagged type are known at its first freezing point; the type descriptor is laid out at that point. It contains linker symbols for each primitive operation; the linker fills in the actual addresses.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b.1/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
Primitive operations of type extensions that are declared at a level deeper than the level of the ultimate ancestor from which they are derived can be represented by wrappers that use the dynamic part of the tag to call the actual primitive operation. The dynamic part would generally be some way to represent the static link or display necessary for making a nested call. One implementation strategy would be to store that information in the extension part of such nested type extensions, and use the dynamic part of the tag to point at it. (That way, the &ldquo;dynamic&rdquo; part of the tag could be static, at the cost of indirect access.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b.2/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
If the tagged type is descended from any interface types, it also will need to include &ldquo;subtags&rdquo; (one for each interface) that describe the mapping of the primitive operations of the interface to the primitives of the type. These subtags could directly reference the primitive operations (for faster performance), or simply provide the tag &ldquo;slot&rdquo; numbers for the primitive operations (for easier derivation). In either case, the subtags would be used for calls that dispatch through a class-wide type of the interface.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.c</MarginText>
<Admonition type="aarm" aarm="note">
Other implementation models are possible.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.d</MarginText>
<Admonition type="aarm" aarm="note">
The rules ensure that &ldquo;dangling dispatching&rdquo; is impossible; that is, when a dispatching call is made, there is always a body to execute. This is different from some other object-oriented languages, such as Smalltalk, where it is possible to get a run-time error from a missing method.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.e/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="note">
Dispatching calls should be efficient, and should have a bounded worst-case execution time. This is important in a language intended for real-time applications. In the intended implementation model, a dispatching call involves calling indirect through the appropriate slot in the dispatch table. No complicated "method lookup" is involved although a call which is dispatching on an interface may require a lookup of the appropriate interface subtag.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.f</MarginText>
<Admonition type="aarm" aarm="note">
The programmer should have the choice at each call site of a dispatching operation whether to do a dispatching call or a statically determined call (i.e. whether the body executed should be determined at run time or at compile time).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.g</MarginText>
<Admonition type="aarm" aarm="note">
The same body should be executed for a call where the tag is statically determined to be T'Tag as for a dispatching call where the tag is found at run time to be T'Tag. This allows one to test a given tagged type with statically determined calls, with some confidence that run-time dispatching will produce the same behavior.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.h</MarginText>
<Admonition type="aarm" aarm="note">
All views of a type should share the same type descriptor and the same tag.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.i</MarginText>
<Admonition type="aarm" aarm="note">
The visibility rules determine what is legal at compile time; they have nothing to do with what bodies can be executed at run time. Thus, it is possible to dispatch to a subprogram whose declaration is not visible at the call site. In fact, this is one of the primary facts that gives object-oriented programming its power. The subprogram that ends up being dispatched to by a given call might even be designed long after the call site has been coded and compiled.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.j</MarginText>
<Admonition type="aarm" aarm="note">
Given that Ada has overloading, determining whether a given subprogram overrides another is based both on the names and the type profiles of the operations.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.k/2</MarginText>
<MarginInfo items={["AI95-00401-01"]} />
<Admonition type="aarm" aarm="note">
When a type extension is declared, if there is any place within its immediate scope where a certain subprogram of the parent or progenitor is visible, then a matching subprogram should override. If there is no such place, then a matching subprogram should be totally unrelated, and occupy a different slot in the type descriptor. This is important to preserve the privacy of private parts; when an operation declared in a private part is inherited, the inherited version can be overridden only in that private part, in the package body, and in any children of the package.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.l</MarginText>
<Admonition type="aarm" aarm="note">
If an implementation shares code for instances of generic bodies, it should be allowed to share type descriptors of tagged types declared in the generic body, so long as they are not extensions of types declared in the specification of the generic unit. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>A record type or private type that has the reserved word <strong>tagged</strong> in its declaration is called a <em>tagged</em> type. In addition, an interface type is a tagged type, as is a task or protected type derived from an interface (see <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>). [When deriving from a tagged type, as for any derived type, additional primitive subprograms may be defined, and inherited primitive subprograms may be overridden.] The derived type is called an <em>extension</em> of its ancestor types, or simply a <em>type extension</em>.<br /></p>

<MarginText>2.1/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>Every type extension is also a tagged type, and is a <em>record extension</em> or a <em>private extension</em> of some other tagged type, or a noninterface synchronized tagged type (see <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>). A record extension is defined by a <code><a href="../AA-3/AA-3.4#S0035">derived_type_definition</a></code> with a <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> (see <a href="../AA-3/AA-3.9#Subclause_3.9.1">3.9.1</a>)[, which may include the definition of additional components]. A private extension, which is a partial view of a record extension or of a synchronized tagged type, can be declared in the visible part of a package (see <a href="../AA-7/AA-7.3">7.3</a>) or in a generic formal part (see <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>). <br /></p>

<AnnotatedOnly>
<MarginText>2.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>tagged type</strong> &mdash; type whose objects each have a run-time type tag, which indicates the specific type for which the object was originally created<br /><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b/2</MarginText>
<MarginInfo items={["AI95-00218-03"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If a tagged type is declared other than in a <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code>, it is impossible to add new primitive subprograms for that type, although it can inherit primitive subprograms, and those can be overridden. If the user incorrectly thinks a certain subprogram is primitive when it is not, and tries to call it with a dispatching call, an error message will be given at the call site. Similarly, by using an <code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code> (see <a href="../AA-6/AA-6.1">6.1</a>), the user can declare that a subprogram is intended to be overriding, and get an error message when they made a mistake. The use of <code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code>s is highly recommended in new code that does not need to be compatible with Ada 95.<br /></Admonition>
</AnnotatedOnly>

<MarginText>3</MarginText>
<p>An object of a tagged type has an associated (run-time) <em>tag</em> that identifies the specific tagged type used to create the object originally. [ The tag of an operand of a class-wide tagged type <em>T</em>'Class controls which subprogram body is to be executed when a primitive subprogram of type <em>T</em> is applied to the operand (see <a href="../AA-3/AA-3.9#Subclause_3.9.2">3.9.2</a>); using a tag to control which body to execute is called <em>dispatching</em>.] <br /></p>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<p>The tag of a specific tagged type identifies the <code><a href="../AA-3/AA-3.2#S0024">full_type_declaration</a></code> of the type, and for a type extension, is sufficient to uniquely identify the type among all descendants of the same ancestor. If a declaration for a tagged type occurs within a <code><a href="../AA-12/AA-12.1#S0312">generic_package_declaration</a></code>, then the corresponding type declarations in distinct instances of the generic package are associated with distinct tags. For a tagged type that is local to a generic package body and with all of its ancestors (if any) also local to the generic body, the language does not specify whether repeated instantiations of the generic body result in distinct tags. <br /></p>

<AnnotatedOnly>
<MarginText>4.a/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.a.1/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>In most cases, a tag need only identify a particular tagged type declaration, and can therefore be a simple link-time-known address. However, for tag checks (see <a href="../AA-3/AA-3.9#Subclause_3.9.2">3.9.2</a>) it is essential that each descendant (that currently exists) of a given type have a unique tag. Hence, for types declared in shared generic bodies where an ancestor comes from outside the generic, or for types declared at a deeper level than an ancestor, the tag needs to be augmented with some kind of dynamic descriptor (which may be a static link, global display, instance descriptor pointer, or combination). This implies that type Tag may need to be two words, the second of which is normally null, but in these identified special cases needs to include a static link or equivalent. Within an object of one of these types with a two-word tag, the two parts of the tag would typically be separated, one part as the first word of the object, the second placed in the first extension part that corresponds to a type declared more nested than its parent or declared in a shared generic body when the parent is declared outside. Alternatively, by using an extra level of indirection, the type Tag could remain a single-word.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
For types that are not type extensions (even for ones declared in nested scopes), we do not require that repeated elaborations of the same <code><a href="../AA-3/AA-3.2#S0024">full_type_declaration</a></code> correspond to distinct tags. This was done so that Ada 2005 implementations of tagged types could maintain representation compatibility with Ada 95 implementations. Only type extensions that were not allowed in Ada 95 require additional information with the tag. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.c/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>The wording &ldquo;is sufficient to uniquely identify the type among all descendants of the same ancestor&rdquo; only applies to types that currently exist. It is not necessary to distinguish between descendants that currently exist, and descendants of the same type that no longer exist. For instance, the address of the stack frame of the subprogram that created the tag is sufficient to meet the requirements of this rule, even though it is possible, after the subprogram returns, that a later call of the subprogram could have the same stack frame and thus have an identical tag. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5</MarginText>
<p>The following language-defined library package exists: <br /></p>

<MarginText>6/5</MarginText>
<MarginInfo items={["AI95-00362-01", "AI12-0241-1", "AI12-0302-1", "AI12-0399-1"]} />
<CodeBlock language="ada">
package Ada.Tags  {"\n"}    with  Preelaborate, Nonblocking, Global ={">"} in out synchronized is {"\n"}    type Tag is private {"\n"}       with  Preelaborable_Initialization ;{"\n"}
<MarginText>6.1/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
    No_Tag : constant Tag;{"\n"}
<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00400-01"]} />
    function Expanded_Name(T : Tag) return String;{"\n"}    function Wide_Expanded_Name(T : Tag) return Wide_String;{"\n"}    function Wide_Wide_Expanded_Name(T : Tag) return Wide_Wide_String;{"\n"}    function External_Tag(T : Tag) return String;{"\n"}    function Internal_Tag(External : String) return Tag;{"\n"}
<MarginText>7.1/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
    function Descendant_Tag(External : String;{"\n"}                            Ancestor : Tag) return Tag;{"\n"}    function Is_Descendant_At_Same_Level(Descendant, Ancestor : Tag){"\n"}        return Boolean;{"\n"}
<MarginText>7.2/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
    function Parent_Tag (T : Tag) return Tag;{"\n"}
<MarginText>7.3/2</MarginText>
<MarginInfo items={["AI95-00405-01"]} />
    type Tag_Array is array (Positive range {"<"}{">"}) of Tag;{"\n"}
<MarginText>7.4/2</MarginText>
<MarginInfo items={["AI95-00405-01"]} />
    function Interface_Ancestor_Tags (T : Tag) return Tag_Array;{"\n"}
<MarginText>7.5/3</MarginText>
<MarginInfo items={["AI05-0173-1"]} />
    function Is_Abstract (T : Tag) return Boolean;{"\n"}
<MarginText>8</MarginText>
    Tag_Error : exception;{"\n"}
<MarginText>9</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Ada.Tags;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Tag is a nonlimited, definite subtype, because it needs the equality operators, so that tag checking makes sense. Also, equality, assignment, and object declaration are all useful capabilities for this subtype.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b</MarginText>
<Admonition type="aarm" aarm="note">
For an object X and a type T, &ldquo;X'Tag = T'Tag&rdquo; is not needed, because a membership test can be used. However, comparing the tags of two objects cannot be done via membership. This is one reason to allow equality for type Tag. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9.1/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<p>No_Tag is the default initial value of type Tag. <br /></p>

<AnnotatedOnly>
<MarginText>9.c/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This is similar to the requirement that all access values be initialized to <strong>null</strong>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00400-01"]} />
<p>The function Wide_Wide_Expanded_Name returns the full expanded name of the first subtype of the specific type identified by the tag, in upper case, starting with a root library unit. The result is implementation defined if the type is declared within an unnamed <code><a href="../AA-5/AA-5.6#S0191">block_statement</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This name, as well as each <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> of it, does not denote a <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The result of Tags.Wide_Wide_Expanded_Name for types declared within an unnamed <code><a href="../AA-5/AA-5.6#S0191">block_statement</a></code>.<br /></Admonition>
</AnnotatedOnly>

<MarginText>10.1/2</MarginText>
<MarginInfo items={["AI95-00400-01"]} />
<p>The function Expanded_Name (respectively, Wide_Expanded_Name) returns the same sequence of graphic characters as that defined for Wide_Wide_Expanded_Name, if all the graphic characters are defined in Character (respectively, Wide_Character); otherwise, the sequence of characters is implementation defined, but no shorter than that returned by Wide_Wide_Expanded_Name for the same value of the argument. <br /></p>

<AnnotatedOnly>
<MarginText>10.c/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The sequence of characters of the value returned by Tags.Expanded_Name (respectively, Tags.Wide_Expanded_Name) when some of the graphic characters of Tags.Wide_Wide_Expanded_Name are not defined in Character (respectively, Wide_Character).<br /></Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>
<p>The function External_Tag returns a string to be used in an external representation for the given tag. The call External_Tag(S'Tag) is equivalent to the <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> S'External_Tag (see <a href="../AA-13/AA-13.3">13.3</a>). <br /></p>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>It might seem redundant to provide both the function External_Tag and the attribute External_Tag. The function is needed because the attribute can't be applied to values of type Tag. The attribute is needed so that it can be specified via an <code><a href="../AA-13/AA-13.3#S0349">attribute_definition_clause</a></code>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11.1/2</MarginText>
<MarginInfo items={["AI95-00417-01"]} />
<p>The string returned by the functions Expanded_Name, Wide_Expanded_Name, Wide_Wide_Expanded_Name, and External_Tag has lower bound 1.<br /></p>

<MarginText>12/2</MarginText>
<MarginInfo items={["AI95-00279-01"]} />
<p>The function Internal_Tag returns a tag that corresponds to the given external tag, or raises Tag_Error if the given string is not the external tag for any specific type of the partition. Tag_Error is also raised if the specific type identified is a library-level type whose tag has not yet been created (see <a href="../AA-13/AA-13.14">13.14</a>).<br /></p>

<AnnotatedOnly>
<MarginText>12.a/3</MarginText>
<MarginInfo items={["AI95-00279-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The check for uncreated library-level types prevents a reference to the type before execution reaches the freezing point of the type. This is important so that T'Class'Input or an instance of Tags.Generic_Dispatching_Constructor do not try to create an object of a type that hasn't been frozen (which might not have yet elaborated its constraints). We don't require this behavior for non-library-level types as the tag can be created multiple times and possibly multiple copies can exist at the same time, making the check complex. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.1/3</MarginText>
<MarginInfo items={["AI95-00344-01", "AI05-0113-1"]} />
<p>The function Descendant_Tag returns the (internal) tag for the type that corresponds to the given external tag and is both a descendant of the type identified by the Ancestor tag and has the same accessibility level as the identified ancestor. Tag_Error is raised if External is not the external tag for such a type. Tag_Error is also raised if the specific type identified is a library-level type whose tag has not yet been created, or if the given external tag identifies more than one type that has the appropriate Ancestor and accessibility level.<br /></p>

<AnnotatedOnly>
<MarginText>12.b/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Descendant_Tag is used by T'Class'Input to identify the type identified by an external tag. Because there can be multiple elaborations of a given type declaration, Internal_Tag does not have enough information to choose a unique such type. Descendant_Tag does not return the tag for types declared at deeper accessibility levels than the ancestor because there could be ambiguity in the presence of recursion or multiple tasks. Descendant_Tag can be used in constructing a user-defined replacement for T'Class'Input.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.b.1/3</MarginText>
<MarginInfo items={["AI05-0113-1"]} />
<Admonition type="aarm" aarm="note">
Rules for specifying external tags will usually prevent an external tag from identifying more than one type. However, an external tag can identify multiple types if a generic body contains a derivation of a tagged type declared outside of the generic, and there are multiple instances at the same accessibility level as the type. (The Reference Manual allows default external tags to not be unique in this case.) <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.2/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<p>The function Is_Descendant_At_Same_Level returns True if the Descendant tag identifies a type that is both a descendant of the type identified by Ancestor and at the same accessibility level. If not, it returns False.<br /></p>

<AnnotatedOnly>
<MarginText>12.c/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Is_Descendant_At_Same_Level (or something similar to it) is used by T'Class'Output to determine whether the item being written is at the same accessibility level as T. It may be used to determine prior to using T'Class'Output whether Tag_Error will be raised, and also can be used in constructing a user-defined replacement for T'Class'Output. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.3/3</MarginText>
<MarginInfo items={["AI05-0115-1"]} />
<p>For the purposes of the dynamic semantics of functions Descendant_Tag and Is_Descendant_At_Same_Level, a tagged type T2 is a <em>descendant</em> of a type T1 if it is the same as T1, or if its parent type or one of its progenitor types is a descendant of type T1 by this rule[, even if at the point of the declaration of T2, one of the derivations in the chain is not visible].<br /></p>

<AnnotatedOnly>
<MarginText>12.c.1/3</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>In other contexts, &ldquo;descendant&rdquo; is dependent on visibility, and the particular view a derived type has of its parent type. See <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.4/4</MarginText>
<MarginInfo items={["AI95-00260-02", "AI12-0056-1"]} />
<p>The function Parent_Tag returns the tag of the parent type of the type whose tag is T. If the type does not have a parent type (that is, it was not defined by a <code><a href="../AA-3/AA-3.4#S0035">derived_type_definition</a></code>), then No_Tag is returned.<br /></p>

<AnnotatedOnly>
<MarginText>12.d/4</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>The parent type is always the parent of the full type; a private extension appears to define a parent type, but it does not (only the various forms of derivation do that). As this is a run-time operation, ignoring privacy is OK. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.5/3</MarginText>
<MarginInfo items={["AI95-00405-01"]} />
<p>The function Interface_Ancestor_Tags returns an array containing the tag of each interface ancestor type of the type whose tag is T, other than T itself. The lower bound of the returned array is 1, and the order of the returned tags is unspecified. Each tag appears in the result exactly once.[ If the type whose tag is T has no interface ancestors, a null array is returned.]<br /></p>

<AnnotatedOnly>
<MarginText>12.e/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The result of Interface_Ancestor_Tags includes the tag of the parent type, if the parent is an interface.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.f/2</MarginText>
<Admonition type="aarm" aarm="note">
Indirect interface ancestors are included in the result of Interface_Ancestor_Tags. That's because where an interface appears in the derivation tree has no effect on the semantics of the type; the only interesting property is whether the type has an interface as an ancestor. <br /></Admonition>
</AnnotatedOnly>

<MarginText>12.6/3</MarginText>
<MarginInfo items={["AI05-0173-1"]} />
<p>The function Is_Abstract returns True if the type whose tag is T is abstract, and False otherwise.<br /></p>

<MarginText>13</MarginText>
<p>For every subtype S of a tagged type <em>T</em> (specific or class-wide), the following attributes are defined: <br /></p>

<MarginText>14</MarginText>
<dt><br/>S'Class</dt>
<dl>
<dd>S'Class denotes a subtype of the class-wide type (called <em>T</em>'Class in this document) for the class rooted at <em>T</em> (or if S already denotes a class-wide subtype, then S'Class is the same as S).<br /></dd>
<MarginText>15</MarginText>
<dd>S'Class is unconstrained. However, if S is constrained, then the values of S'Class are only those that when converted to the type <em>T</em> belong to S. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>15.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This attribute is defined for both specific and class-wide subtypes. The definition is such that S'Class'Class is the same as S'Class.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>15.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that if S is constrained, S'Class is only partially constrained, since there might be additional discriminants added in descendants of <em>T</em> which are not constrained. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>15.c/2</MarginText>
<MarginInfo items={["AI95-00326-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The Class attribute is not defined for untagged subtypes (except for incomplete types and private types whose full view is tagged &mdash; see <a href="../AA-J/AA-J.11">J.11</a> and <a href="../AA-7/AA-7.3#Subclause_7.3.1">7.3.1</a>) so as to preclude implicit conversion in the absence of run-time type information. If it were defined for untagged subtypes, it would correspond to the concept of universal types provided for the predefined numeric classes. <br /></Admonition>
</AnnotatedOnly>

<MarginText>16</MarginText>
<dt><br/>S'Tag</dt>
<dl>
<dd>S'Tag denotes the tag of the type <em>T</em> (or if <em>T</em> is class-wide, the tag of the root type of the corresponding class). The value of this attribute is of type Tag. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>S'Class'Tag equals S'Tag, to avoid generic contract model problems when S'Class is the actual type associated with a generic formal derived type.<br /></Admonition>
</AnnotatedOnly>

<MarginText>17</MarginText>
<p>Given a <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> X that is of a class-wide tagged type [(after any implicit dereference)], the following attribute is defined: <br /></p>

<MarginText>18</MarginText>
<dt><br/>X'Tag</dt>
<dl>
<dd>X'Tag denotes the tag of X. The value of this attribute is of type Tag. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>18.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>X'Tag is not defined if X is of a specific type. This is primarily to avoid confusion that might result about whether the Tag attribute should reflect the tag of the type of X, or the tag of X. No such confusion is possible if X is of a class-wide type. <br /></Admonition>
</AnnotatedOnly>

<MarginText>18.1/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00441-01"]} />
<p>The following language-defined generic function exists:<br /></p>

<MarginText>18.2/5</MarginText>
<MarginInfo items={["AI05-0229-1", "AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
generic{"\n"}    type T ({"<"}{">"}) is abstract tagged limited private;{"\n"}    type Parameters ({"<"}{">"}) is limited private;{"\n"}    with function Constructor (Params : not null access Parameters){"\n"}        return T is abstract;{"\n"}function Ada.Tags.Generic_Dispatching_Constructor{"\n"}   (The_Tag : Tag;{"\n"}    Params  : not null access Parameters) return T'Class{"\n"}   with Preelaborate, Convention ={">"} Intrinsic,{"\n"}        Nonblocking, Global ={">"} in out synchronized; {"\n"}

</CodeBlock>
<MarginText>18.3/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<p>Tags.Generic_Dispatching_Constructor provides a mechanism to create an object of an appropriate type from just a tag value. The function Constructor is expected to create the object given a reference to an object of type Parameters.<br /></p>

<AnnotatedOnly>
<MarginText>18.b/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>This specification is designed to make it easy to create dispatching constructors for streams; in particular, this can be used to construct overridings for T'Class'Input.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.c/5</MarginText>
<MarginInfo items={["AI12-0005-1"]} />
<Admonition type="aarm" aarm="note">
Note that almost any tagged type can be used in an instance of Generic_Dispatching_Constructor. Using a tagged incomplete view or a tagged partial view before the completion of the type in such an instance would be illegal; all other tagged types can be used in an instance of Generic_Dispatching_Constructor . <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>19</MarginText>
<p>The tag associated with an object of a tagged type is determined as follows: <br /></p>

<MarginText>20</MarginText>
<ul>
<li>The tag of a stand-alone object, a component, or an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> of a specific tagged type <em>T</em> identifies <em>T</em>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>20.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The tag of a formal parameter of type <em>T</em> is not necessarily the tag of <em>T</em>, if, for example, the actual was a type conversion. <br /></Admonition>
</AnnotatedOnly>

<MarginText>21/5</MarginText>
<MarginInfo items={["AI12-0437-1"]} />
<ul>
<li>The tag of an object created by an allocator for an access type with a specific designated tagged type <em>T</em>  identifies <em>T</em>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The tag of an object designated by a value of such an access type might not be <em>T</em>, if, for example, the access value is the result of a type conversion.<br /></Admonition>
</AnnotatedOnly>

<MarginText>22</MarginText>
<ul>
<li>The tag of an object of a class-wide tagged type is that of its initialization expression. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>22.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The tag of an object (even a class-wide one) cannot be changed after it is initialized, since a &ldquo;class-wide&rdquo; <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> raises Constraint_Error if the tags don't match, and a &ldquo;specific&rdquo; <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> does not affect the tag. <br /></Admonition>
</AnnotatedOnly>

<MarginText>23</MarginText>
<ul>
<li>The tag of the result returned by a function whose result type is a specific tagged type <em>T</em> identifies <em>T</em>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>23.a/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>For a limited tagged type, the return object is &ldquo;built in place&rdquo; in the ultimate result object with the appropriate tag. For a nonlimited type, a new anonymous object with the appropriate tag is created as part of the function return. See <a href="../AA-6/AA-6.5">6.5</a>, &ldquo;<a href="../AA-6/AA-6.5">Return Statements</a>&rdquo;. <br /></Admonition>
</AnnotatedOnly>

<MarginText>24/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<ul>
<li>The tag of the result returned by a function with a class-wide result type is that of the return object. <br /></li>
</ul>
<MarginText>25</MarginText>
<p>The tag is preserved by type conversion and by parameter passing. The tag of a value is the tag of the associated object (see <a href="../AA-6/AA-6.2">6.2</a>).<br /></p>

<MarginText>25.1/3</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00344-01", "AI95-00405-01", "AI05-0092-1", "AI05-0262-1"]} />
<p>Tag_Error is raised by a call of Descendant_Tag, Expanded_Name, External_Tag, Interface_Ancestor_Tags, Is_Abstract, Is_Descendant_At_Same_Level, Parent_Tag, Wide_Expanded_Name, or Wide_Wide_Expanded_Name if any tag passed is No_Tag.<br /></p>

<MarginText>25.2/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<p>An instance of Tags.Generic_Dispatching_Constructor raises Tag_Error if The_Tag does not represent a concrete descendant of T or if the innermost master (see <a href="../AA-7/AA-7.6#Subclause_7.6.1">7.6.1</a>) of this descendant is not also a master of the instance. Otherwise, it dispatches to the primitive function denoted by the formal Constructor for the type identified by The_Tag, passing Params, and returns the result. Any exception raised by the function is propagated.<br /></p>

<AnnotatedOnly>
<MarginText>25.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The tag check checks both that The_Tag is in T'Class, and that it is not abstract. These checks are similar to the ones required by streams for T'Class'Input (see <a href="../AA-13/AA-13.13#Subclause_13.13.2">13.13.2</a>). In addition, there is a check that the tag identifies a type declared on the current dynamic call chain, and not a more nested type or a type declared by another task. This check is not necessary for streams, because the stream attributes are declared at the same dynamic level as the type used. <br /></Admonition>
</AnnotatedOnly>


#### Erroneous Execution

<MarginText>25.3/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<p>If an internal tag provided to an instance of Tags.Generic_Dispatching_Constructor or to any subprogram declared in package Tags identifies either a type that is not library-level and whose tag has not been created (see <a href="../AA-13/AA-13.14">13.14</a>), or a type that does not exist in the partition at the time of the call, then execution is erroneous.<br /></p>

<AnnotatedOnly>
<MarginText>25.b/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>One reason that a type might not exist in the partition is that the tag refers to a type whose declaration was elaborated as part of an execution of a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> which has been left (see <a href="../AA-7/AA-7.6#Subclause_7.6.1">7.6.1</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.c/2</MarginText>
<Admonition type="aarm" aarm="note">
We exclude tags of library-level types from the current execution of the partition, because misuse of such tags should always be detected. T'Tag freezes the type (and thus creates the tag), and Internal_Tag and Descendant_Tag cannot return the tag of a library-level type that has not been created. All ancestors of a tagged type must be frozen no later than the (full) declaration of a type that uses them, so Parent_Tag and Interface_Ancestor_Tags cannot return a tag that has not been created. Finally, library-level types never cease to exist while the partition is executing. Thus, if the tag comes from a library-level type, there cannot be erroneous execution (the use of Descendant_Tag rather than Internal_Tag can help ensure that the tag is of a library-level type). This is also similar to the rules for T'Class'Input (see <a href="../AA-13/AA-13.13#Subclause_13.13.2">13.13.2</a>). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.d/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>Ada 95 allowed Tag_Error in this case, or expected the functions to work. This worked because most implementations used tags constructed at link-time, and each elaboration of the same <code><a href="../AA-3/AA-3.2#S0023">type_declaration</a></code> produced the same tag. However, Ada 2005 requires at least part of the tags to be dynamically constructed for a type derived from a type at a shallower level. For dynamically constructed tags, detecting the error can be expensive and unreliable. To see this, consider a program containing two tasks. Task A creates a nested tagged type, passes the tag to task B (which saves it), and then terminates. The nested tag (if dynamic) probably will need to refer in some way to the stack frame for task A. If task B later tries to use the tag created by task A, the tag's reference to the stack frame of A probably is a dangling pointer. Avoiding this would require some sort of protected tag manager, which would be a bottleneck in a program's performance. Moreover, we'd still have a race condition; if task A terminated after the tag check, but before the tag was used, we'd still have a problem. That means that all of these operations would have to be serialized. That could be a significant performance drain, whether or not nested tagged types are ever used. Therefore, we allow execution to become erroneous as we do for other dangling pointers. If the implementation can detect the error, we recommend that Tag_Error be raised. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Permissions

<MarginText>26/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00279-01"]} />
<p>The implementation of Internal_Tag and Descendant_Tag may raise Tag_Error if no specific type corresponding to the string External passed as a parameter exists in the partition at the time the function is called, or if there is no such type whose innermost master is a master of the point of the function call. <br /></p>

<AnnotatedOnly>
<MarginText>26.a/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00279-01", "AI95-00344-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>Locking would be required to ensure that the mapping of strings to tags never returned tags of types which no longer exist, because types can cease to exist (because they belong to another task, as described above) during the execution of these operations. Moreover, even if these functions did use locking, that would not prevent the type from ceasing to exist at the instant that the function returned. Thus, we do not require the overhead of locking; hence the word &ldquo;may&rdquo; in this rule. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>26.1/3</MarginText>
<MarginInfo items={["AI95-00260-02", "AI05-0113-1"]} />
<p>Internal_Tag should return the tag of a type, if one exists, whose innermost master is a master of the point of the function call. <br /></p>

<AnnotatedOnly>
<MarginText>26.b/3</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>Tags.Internal_Tag should return the tag of a type, if one exists, whose innermost master is a master of the point of the function call.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.c/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00344-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>It's not helpful if Internal_Tag returns the tag of some type in another task when one is available in the task that made the call. We don't require this behavior (because it requires the same implementation techniques we decided not to insist on previously), but encourage it. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>26.d/3</MarginText>
<MarginInfo items={["AI05-0113-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>There is no Advice for the result of Internal_Tag if no such type exists. In most cases, the Implementation Permission can be used to raise Tag_Error, but some other tag can be returned as well. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   A type declared with the reserved word <strong>tagged</strong> is  normally  declared in a <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code>, so that new primitive subprograms can be declared for it.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   Once an object has been created, its tag never changes.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>29/5</MarginText>
<MarginInfo items={["AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   Class-wide types are defined to have unknown discriminants (see <a href="../AA-3/AA-3.7">3.7</a>). This means that, by the rules in <a href="../AA-3/AA-3.7">3.7</a> for objects with unknown discriminants, objects of a class-wide type are illegal unless they are  explicitly initialized (whether created by an <code><a href="../AA-3/AA-3.3#S0032">object_declaration</a></code> or an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>), and that <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>s are illegal unless they are  explicitly qualified with a specific type when their expected type is class-wide.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>30/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00326-01"]} />
<Admonition type="aarm" aarm="note">
NOTE 4   The capability provided by Tags.Generic_Dispatching_Constructor is sometimes known as a <em>factory</em>. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>31</MarginText>
<p><em>Examples of tagged record types:</em> <br /></p>

<MarginText>32</MarginText>
<CodeBlock language="ada">
type Point is tagged{"\n"}  record{"\n"}    X, Y : Real := 0.0;{"\n"}  end record;{"\n"}
<MarginText>33</MarginText>
type Expression is tagged null record;{"\n"}  -- Components will be added by each extension{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.a</MarginText>
<Admonition type="aarm" aarm="note">
Tagged types are a new concept. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.b/2</MarginText>
<MarginInfo items={["AI95-00279-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Added wording specifying that Internal_Tag must raise Tag_Error if the tag of a library-level type has not yet been created. Ada 95 gave an Implementation Permission to do this; we require it to avoid erroneous execution when streaming in an object of a library-level type that has not yet been elaborated. This is technically inconsistent; a program that used Internal_Tag outside of streaming and used a compiler that didn't take advantage of the Implementation Permission would not have raised Tag_Error, and may have returned a useful tag. (If the tag was used in streaming, the program would have been erroneous.) Since such a program would not have been portable to a compiler that did take advantage of the Implementation Permission, this is not a significant inconsistency.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>33.c/2</MarginText>
<MarginInfo items={["AI95-00417-01"]} />
<Admonition type="aarm" aarm="note">
We now define the lower bound of the string returned from [[Wide_]Wide_]Expanded_Name and External_Name. This makes working with the returned string easier, and is consistent with many other string-returning functions in Ada. This is technically an inconsistency; if a program depended on some other lower bound for the string returned from one of these functions, it could fail when compiled with Ada 2005. Such code is not portable even between Ada 95 implementations, so it should be very rare. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.d/3</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00344-01", "AI95-00400-01", "AI95-00405-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
Constant No_Tag, and functions Parent_Tag, Interface_Ancestor_Tags, Descendant_Tag, Is_Descendant_At_Same_Level, Wide_Expanded_Name, and Wide_Wide_Expanded_Name are added to Ada.Tags. If Ada.Tags is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity in Ada.Tags is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.e/2</MarginText>
<MarginInfo items={["AI95-00362-01"]} />
<Admonition type="aarm" aarm="note">
Ada.Tags is now defined to be preelaborated.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>33.f/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="note">
Generic function Tags.Generic_Dispatching_Constructor is new. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.g/2</MarginText>
<MarginInfo items={["AI95-00318-02"]} />
<Admonition type="aarm" aarm="note">
We talk about return objects rather than return expressions, as functions can return using an <code><a href="../AA-6/AA-6.5#S0225">extended_return_statement</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>33.h/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
Added wording to define that tags for all descendants of a tagged type must be distinct. This is needed to ensure that more nested type extensions will work properly. The wording does not require implementation changes for types that were allowed in Ada 95. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Inconsistencies With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.i/3</MarginText>
<MarginInfo items={["AI05-0113-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added wording specifying that Dependent_Tag must raise Tag_Error if there is more than one type which matches the requirements. If an implementation had returned a random tag of the matching types, a program may have worked properly. However, such a program would not be portable (another implementation may return a different tag) and the conditions that would cause the problem are unlikely (most likely, a tagged type extension declared in a generic body with multiple instances in the same scope). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.j/3</MarginText>
<MarginInfo items={["AI05-0173-1"]} />
<Admonition type="aarm" aarm="note">
Function Is_Abstract is added to Ada.Tags. If Ada.Tags is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> Is_Abstract is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>33.k/3</MarginText>
<MarginInfo items={["AI05-0115-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> We explicitly define the meaning of "descendant" at runtime, so that it does not depend on visibility as does the usual meaning. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_3.9.1"></a>

## 3.9.1  Type Extensions

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>[ Every type extension is a tagged type, and is a <em>record extension</em> or a <em>private extension</em> of some other tagged type, or a noninterface synchronized tagged type.] <br /></p>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="note">
We want to make sure that we can extend a generic formal tagged type, without knowing its discriminants.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.b</MarginText>
<Admonition type="aarm" aarm="note">
We don't want to allow components in an extension aggregate to depend on discriminants inherited from the parent value, since such dependence requires staticness in aggregates, at least for variants. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2</MarginText>

<CodeBlock>
<code>record_extension_part</code><a id="S0075"></a><code> ::= </code><strong>with</strong> <code><a href="../AA-3/AA-3.8#S0067">record_definition</a></code><br />

</CodeBlock>

#### Legality Rules

<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00344-01", "AI95-00345-01", "AI95-00419-01"]} />
<p>The parent type of a record extension shall not be a class-wide type nor shall it be a synchronized tagged type (see <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>). If the parent type or any progenitor is nonlimited, then each of the components of the <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> shall be nonlimited. In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), these rules apply also in the private part of an instance of a generic unit. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>If the parent is a limited formal type, then the actual might be nonlimited.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
Ada 95 required the record extensions to be the same level as the parent type. Now we use accessibility checks on class-wide <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s and return statements to prevent objects from living longer than their type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.c/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
Synchronized tagged types cannot be extended. We have this limitation so that all of the data of a task or protected type is defined within the type. Data defined outside of the type wouldn't be subject to the mutual exclusion properties of a protected type, and couldn't be used by a task, and thus doesn't seem to be worth the potential impact on implementations. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<p>Within the body of a generic unit, or the body of any of its descendant library units, a tagged type shall not be declared as a descendant of a formal type declared within the formal part of the generic unit.<br /></p>

<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This paragraph ensures that a dispatching call will never attempt to execute an inaccessible subprogram body.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.a.1/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
The convoluted wording (&ldquo;formal type declared within the formal part&rdquo;) is necessary to include tagged types that are formal parameters of formal packages of the generic unit, as well as formal tagged and tagged formal derived types of the generic unit.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
This rule is necessary in order to preserve the contract model.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.c/2</MarginText>
<MarginInfo items={["AI95-00344-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
If an ancestor is a formal of the generic unit , we have a problem because it might have an unknown number of subprograms that require overriding, as in the following example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.d/2</MarginText>
<CodeBlock language="ada">
package P is{"\n"}    type T is tagged null record;{"\n"}    function F return T; -- Inherited versions will require overriding.{"\n"}end P;{"\n"}
<MarginText>4.e</MarginText>
generic{"\n"}    type TT is tagged private;{"\n"}package Gp is{"\n"}    type NT is abstract new TT with null record;{"\n"}    procedure Q(X : in NT) is abstract;{"\n"}end Gp;{"\n"}
<MarginText>4.f/2</MarginText>
package body Gp is{"\n"}    type NT2 is new NT with null record; -- Illegal!{"\n"}    procedure Q(X : in NT2) is begin null; end Q;{"\n"}    -- Is this legal or not? Can't decide because{"\n"}    -- we don't know whether TT had any functions that require{"\n"}    -- overriding on extension.{"\n"}end Gp;{"\n"}
<MarginText>4.g</MarginText>
package I is new Gp(TT ={">"} P.T);{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.h/2</MarginText>
<Admonition type="aarm" aarm="note">
I.NT is an abstract type with two abstract subprograms: F (inherited as abstract) and Q (explicitly declared as abstract). But the generic body doesn't know about F, so we don't know that it needs to be overridden to make a nonabstract extension of NT. Hence, we have to disallow this case.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.h.1/2</MarginText>
<Admonition type="aarm" aarm="note">
Similarly, since the actual type for a formal tagged limited private type can be a nonlimited type, we would have a problem if a type extension of a limited private formal type could be declared in a generic body. Such an extension could have a task component, for example, and an object of that type could be passed to a dispatching operation of a nonlimited ancestor type. That operation could try to copy the object with the task component. That would be bad. So we disallow this as well.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.i</MarginText>
<Admonition type="aarm" aarm="note">
If TT were declared as abstract, then we could have the same problem with abstract procedures.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.j</MarginText>
<Admonition type="aarm" aarm="note">
We considered disallowing all tagged types in a generic body, for simplicity. We decided not to go that far, in order to avoid unnecessary restrictions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.k</MarginText>
<Admonition type="aarm" aarm="note">
We also considered trying make the accessibility level part of the contract; i.e. invent some way of saying (in the <code><a href="../AA-12/AA-12.1#S0310">generic_declaration</a></code>) &ldquo;all instances of this generic unit will have the same accessibility level as the <code><a href="../AA-12/AA-12.1#S0310">generic_declaration</a></code>&rdquo;. Unfortunately, that doesn't solve the part of the problem having to do with abstract types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.l/2</MarginText>
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.m/2</MarginText>
<MarginInfo items={["AI95-00344"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This rule applies to types with ancestors (directly or indirectly) of formal interface types (see <a href="../AA-12/AA-12.5#Subclause_12.5.5">12.5.5</a>), formal tagged private types (see <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>), and formal derived private types whose ancestor type is tagged (see <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>). <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>4.1/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<p>A record extension is a <em>null extension</em> if its declaration has no <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> and its <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> includes no <code><a href="../AA-3/AA-3.8#S0070">component_declaration</a></code>s.<br /></p>

<MarginText>4.2/5</MarginText>
<MarginInfo items={["AI12-0191-1"]} />
<p>In the case where the (compile-time) view of an object <em>X</em> is of a tagged type T1 or T1'Class and the (run-time) tag of <em>X</em> is T2'Tag, only the components (if any) of <em>X</em> that are components of T1 (or that are discriminants which correspond to a discriminant of T1) are said to be <em>components of the nominal type</em> of <em>X</em>. Similarly, only parts (respectively, subcomponents) of T1 are parts (respectively, subcomponents) of the nominal type of <em>X</em>.<br /></p>

<AnnotatedOnly>
<MarginText>4.n/5</MarginText>
<MarginInfo items={["AI12-0191-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>For example, if T2 is an undiscriminated extension of T1 which declares a component named Comp, then <em>X</em>.Comp is not a component of the nominal type of <em>X</em>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.o/5</MarginText>
<MarginInfo items={["AI12-0191-1"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For example, there is a Dynamic Semantics rule that finalization of an object includes finalization of its components (see <a href="../AA-7/AA-7.6#Subclause_7.6.1">7.6.1</a>). In the following case: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.p/5</MarginText>
<CodeBlock language="ada">
type T1 is tagged null record;{"\n"}type T2 is new T1 with record{"\n"}   Comp : Some_Controlled_Type;{"\n"}end record;{"\n"}function Func return T1'Class is (T2'(others ={">"} {"<"}{">"}));{"\n"}X : T1'Class := Func;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.q/5</MarginText>
<Admonition type="aarm" aarm="note">
the rule that &ldquo;every component of the object is finalized&rdquo; (as opposed to something like &ldquo;every component of the nominal type of the object is finalized&rdquo;) means that the finalization of X will include finalization of X.Comp. For another example, see the rule about accessibility checking of access discriminants of parts of function results in <a href="../AA-6/AA-6.5">6.5</a>. In contrast, the rules in <a href="../AA-7/AA-7.3#Subclause_7.3.2">7.3.2</a> explicitly state that type invariant checks are only performed for parts which are of the type-invariant bearing type and which are parts of the nominal type of the object (as opposed to for all parts, whether part of the nominal type or not, which are of the invariant-bearing type). Similarly, the rule in <a href="../AA-13/AA-13.13#Subclause_13.13.2">13.13.2</a> governing which components of a composite value are read and written by the default implementations of Read and Write for a composite type states that only the components of the object which are components of the nominal type of the object are read or written.<br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>5</MarginText>
<p>The elaboration of a <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> consists of the elaboration of the <code><a href="../AA-3/AA-3.8#S0067">record_definition</a></code>. <br /></p>

<AnnotatedOnly>
<MarginText>6</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   The term &ldquo;type extension&rdquo; refers to a type as a whole. The term &ldquo;extension part&rdquo; refers to the piece of text that defines the additional components (if any) the type extension has relative to its specified ancestor type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>We considered other terminology, such as &ldquo;extended type&rdquo;. However, the terms &ldquo;private extended type&rdquo; and &ldquo;record extended type&rdquo; did not convey the proper meaning. Hence, we have chosen to uniformly use the term &ldquo;extension&rdquo; as the type resulting from extending a type, with &ldquo;private extension&rdquo; being one produced by privately extending the type, and &ldquo;record extension&rdquo; being one produced by extending the type with an additional record-like set of components. Note also that the term &ldquo;type extension&rdquo; refers to the result of extending a type in the language Oberon as well (though there the term &ldquo;extended type&rdquo; is also used, interchangeably, perhaps because Oberon doesn't have the concept of a &ldquo;private extension&rdquo;). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   When an extension is declared immediately within a body, primitive subprograms are inherited and are overridable, but new primitive subprograms cannot be added.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8/5</MarginText>
<MarginInfo items={["AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   By the rules given in <a href="../AA-3/AA-3.8">3.8</a>, a  <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that denotes a component (including a discriminant) of the parent type is illegal  within the <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code>. Similarly, a <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that denotes a component defined within the <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> is illegal  within the <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code>. A  <code><a href="../AA-4/AA-4.1#S0091">name</a></code> that denotes a discriminant of the record extension is legal, providing that it refers to a discriminant defined in  a new <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> in the enclosing type declaration.  <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The restriction against depending on discriminants of the parent is to simplify the definition of extension aggregates. The restriction against using parent components in other ways is methodological; it presumably simplifies implementation as well. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9/5</MarginText>
<MarginInfo items={["AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 4   By the rules given in <a href="../AA-8/AA-8.3">8.3</a>, each  visible component of a record extension will  have a unique name, whether the component is (visibly) inherited from the parent type or declared in the <code><a href="../AA-3/AA-3.9#S0075">record_extension_part</a></code> . <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>10</MarginText>
<p><em>Examples of record extensions (of types defined above in <a href="../AA-3/AA-3.9">3.9</a>):</em> <br /></p>

<MarginText>11</MarginText>
<CodeBlock language="ada">
type Painted_Point is new Point with{"\n"}  record{"\n"}    Paint : Color := White;{"\n"}  end record;{"\n"}    -- Components X and Y are inherited{"\n"}
<MarginText>12</MarginText>
Origin : constant Painted_Point := (X | Y ={">"} 0.0, Paint ={">"} Black);{"\n"}
<MarginText>13</MarginText>
type Literal is new Expression with{"\n"}  record               -- a leaf in an Expression tree{"\n"}    Value : Real;{"\n"}  end record;{"\n"}
<MarginText>14/5</MarginText>
<MarginInfo items={["AI12-0404-1"]} />
type Expr_Ptr is access all Expression'Class;{"\n"}                             -- see <a href="../AA-3/AA-3.9">3.9</a> {"\n"}
<MarginText>15</MarginText>
type Binary_Operation is new Expression with{"\n"}  record               -- an internal node in an Expression tree{"\n"}    Left, Right : Expr_Ptr;{"\n"}  end record;{"\n"}
<MarginText>16</MarginText>
type Addition is new Binary_Operation with null record;{"\n"}type Subtraction is new Binary_Operation with null record;{"\n"}  -- No additional components needed for these extensions{"\n"}
<MarginText>17</MarginText>
Tree : Expr_Ptr :=     -- A tree representation of &ldquo;5.0 + (13.0&ndash;7.0)&rdquo;{"\n"}   new Addition'({"\n"}      Left  ={">"} new Literal'(Value ={">"} 5.0),{"\n"}      Right ={">"} new Subtraction'({"\n"}         Left  ={">"} new Literal'(Value ={">"} 13.0),{"\n"}         Right ={">"} new Literal'(Value ={">"} 7.0)));{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="note">
Type extension is a new concept. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.b/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="note">
Type extensions now can be declared in more nested scopes than their parent types. Additional accessibility checks on <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>s and return statements prevent objects from outliving their type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.c/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
Added wording to prevent extending synchronized tagged types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.d/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<Admonition type="aarm" aarm="note">
Defined null extension for use elsewhere. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.e/5</MarginText>
<MarginInfo items={["AI12-0191-1"]} />
<Admonition type="aarm" aarm="note">
Defined the term &ldquo;components of the nominal type&rdquo; to remove a confusion as to how components are described in Dynamic Semantics rules. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_3.9.2"></a>

## 3.9.2  Dispatching Operations of Tagged Types

<MarginText>1/5</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00335-01", "AI12-0342-1", "AI12-0419-1"]} />
<p>The primitive subprograms of a tagged type, the subprograms declared by <code><a href="../AA-12/AA-12.6#S0337">formal_abstract_subprogram_declaration</a></code>s, the Put_Image attribute (see <a href="../AA-4/AA-4.10">4.10</a>) of a specific tagged type, and the stream attributes of a specific tagged type that are available (see <a href="../AA-13/AA-13.13#Subclause_13.13.2">13.13.2</a>) at the end of the declaration list where the type is declared are called <em>dispatching operations</em>. [A dispatching operation can be called using a statically determined <em>controlling</em> tag, in which case the body to be executed is determined at compile time. Alternatively, the controlling tag can be dynamically determined, in which case the call <em>dispatches</em> to a body that is determined at run time;] such a call is termed a <em>dispatching call</em>. [As explained below, the properties of the operands and the context of a particular call on a dispatching operation determine how the controlling tag is determined, and hence whether or not the call is a dispatching call. Run-time polymorphism is achieved when a dispatching operation is called by a dispatching call.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a.1/2</MarginText>
<MarginInfo items={["AI95-00335-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>For the stream attributes of a type declared immediately within a <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code> that has a partial view, the declaration list to consider is the visible part of the package. Stream attributes that are not available in the same declaration list are not dispatching as there is no guarantee that descendants of the type have available attributes (there is such a guarantee for visibly available attributes). If we allowed dispatching for any available attribute, then for attributes defined in the private part we could end up executing a nonexistent body. <br /></Admonition>
</AnnotatedOnly>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.a</MarginText>
<Admonition type="aarm" aarm="note">
The controlling tag determination rules are analogous to the overload resolution rules, except they deal with run-time type identification (tags) rather than compile-time type resolution. As with overload resolution, controlling tag determination may depend on operands or result context. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00416-01", "AI05-0076-1"]} />
<p>A <em>call on a dispatching operation</em> is a call whose <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes the declaration of a dispatching operation. A <em>controlling operand</em> in a call on a dispatching operation of a tagged type <em>T</em> is one whose corresponding formal parameter is of type <em>T</em> or is of an anonymous access type with designated type <em>T</em>; the corresponding formal parameter is called a <em>controlling formal parameter</em>. If the controlling formal parameter is an access parameter, the controlling operand is the object designated by the actual parameter, rather than the actual parameter itself. If the call is to a (primitive) function with result type <em>T</em> (a <em>function with a controlling result</em>), then the call has a <em>controlling result</em> &mdash; the context of the call can control the dispatching. Similarly, if the call is to a function with an access result type designating <em>T</em> (a <em>function with a controlling access result</em>), then the call has a <em>controlling access result</em>, and the context can similarly control dispatching. <br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This definition implies that a call through the dereference of an access-to-subprogram value is never considered a call on a dispatching operation. Note also that if the <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes a <code><a href="../AA-8/AA-8.5#S0238">renaming_declaration</a></code>, the place where the renaming occurs determines whether it is primitive; the thing being renamed is irrelevant. <br /></Admonition>
</AnnotatedOnly>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI12-0236-1"]} />
<p>A <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or expression of a tagged type is either <em>statically</em> tagged, <em>dynamically</em> tagged, or <em>tag indeterminate</em>, according to whether, when used as a controlling operand, the tag that controls dispatching is determined statically by the operand's (specific) type, dynamically by its tag at run time, or from context. A <code><a href="../AA-4/AA-4.7#S0163">qualified_expression</a></code> or parenthesized expression is statically, dynamically, or indeterminately tagged according to its operand. A <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code> is statically, dynamically, or indeterminately tagged according to rules given in <a href="../AA-4/AA-4.5#Subclause_4.5.7">4.5.7</a>. A <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code> is statically, dynamically, or indeterminately tagged according to its <em>body_</em><code><a href="../AA-4/AA-4.4#S0132">expression</a></code>. For other kinds of <code><a href="../AA-4/AA-4.1#S0091">name</a></code>s and expressions, this is determined as follows: <br /></p>

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<ul>
<li>The <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or expression is <em>statically tagged</em> if it is of a specific tagged type and, if it is a call with a controlling result or controlling access result, it has at least one statically tagged controlling operand; <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>4.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>It is illegal to have both statically tagged and dynamically tagged controlling operands in the same call -- see below. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<ul>
<li>The <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or expression is <em>dynamically tagged</em> if it is of a class-wide type, or it is a call with a controlling result or controlling access result and at least one dynamically tagged controlling operand;<br /></li>
<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<li>The <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or expression is <em>tag indeterminate</em> if it is a call with a controlling result or controlling access result, all of whose controlling operands (if any) are tag indeterminate. <br /></li>
</ul>
<MarginText>7/1</MarginText>
<MarginInfo items={["AI95-00127-01"]} />
<p>{"{"}<em>8652/0010</em>{"}"} [A <code><a href="../AA-4/AA-4.6#S0162">type_conversion</a></code> is statically or dynamically tagged according to whether the type determined by the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> is specific or class-wide, respectively.] For an object that is designated by an expression whose expected type is an anonymous access-to-specific tagged type, the object is dynamically tagged if the expression, ignoring enclosing parentheses, is of the form X'Access, where X is of a class-wide type, or is of the form <strong>new</strong> T'(...), where T denotes a class-wide subtype. Otherwise, the object is statically or dynamically tagged according to whether the designated type of the type of the expression is specific or class-wide, respectively. <br /></p>

<AnnotatedOnly>
<MarginText>7.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A <code><a href="../AA-4/AA-4.6#S0162">type_conversion</a></code> is never tag indeterminate, even if its operand is. A designated object is never tag indeterminate.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.a.1/1</MarginText>
<MarginInfo items={["AI95-00127-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0010</em>{"}"} Allocators and access attributes of class-wide types can be used as the controlling parameters of dispatching calls. <br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>8</MarginText>
<p>A call on a dispatching operation shall not have both dynamically tagged and statically tagged controlling operands. <br /></p>

<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This restriction is intended to minimize confusion between whether the dynamically tagged operands are implicitly converted to, or tag checked against the specific type of the statically tagged operand(s). <br /></Admonition>
</AnnotatedOnly>

<MarginText>9/1</MarginText>
<MarginInfo items={["AI95-00127-01"]} />
<p>{"{"}<em>8652/0010</em>{"}"} If the expected type for an expression or <code><a href="../AA-4/AA-4.1#S0091">name</a></code> is some specific tagged type, then the expression or <code><a href="../AA-4/AA-4.1#S0091">name</a></code> shall not be dynamically tagged unless it is a controlling operand in a call on a dispatching operation. Similarly, if the expected type for an expression is an anonymous access-to-specific tagged type, then the object designated by the expression shall not be dynamically tagged unless it is a controlling operand in a call on a dispatching operation. <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This prevents implicit "truncation" of a dynamically-tagged value to the specific type of the target object/formal. An explicit conversion is required to request this truncation. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b/4</MarginText>
<MarginInfo items={["AI95-00252-01", "AI12-0039-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This rule applies to all expressions or <code><a href="../AA-4/AA-4.1#S0091">name</a></code>s with a specific expected type, not just those that are actual parameters to a dispatching call. This rule does not apply to a membership test whose <em>tested_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> is class-wide, since any type that covers the tested type is explicitly allowed. See <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>. This rule also doesn't apply to a <code><a href="../AA-4/AA-4.1#S0098">selected_component</a></code> whose <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> is a subprogram, since the rules explicitly say that the prefix may be class-wide (see <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>). <br /></Admonition>
</AnnotatedOnly>

<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00117-01", "AI95-00430-01"]} />
<p>{"{"}<em>8652/0011</em>{"}"} In the declaration of a dispatching operation of a tagged type, everywhere a subtype of the tagged type appears as a subtype of the profile (see <a href="../AA-6/AA-6.1">6.1</a>), it shall statically match the first subtype of the tagged type. If the dispatching operation overrides an inherited subprogram, it shall be subtype conformant with the inherited subprogram. The convention of an inherited dispatching operation is the convention of the corresponding primitive operation of the parent or progenitor type. The default convention of a dispatching operation that overrides an inherited primitive operation is the convention of the inherited operation; if the operation overrides multiple inherited operations, then they shall all have the same convention. An explicitly declared dispatching operation shall not be of convention Intrinsic. <br /></p>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>These rules ensure that constraint checks can be performed by the caller in a dispatching call, and parameter passing conventions match up properly. A special rule on aggregates prevents values of a tagged type from being created that are outside of its first subtype. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<p>The <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code> for a controlling formal parameter of a dispatching operation shall be tag indeterminate. <br /></p>

<AnnotatedOnly>
<MarginText>11.a/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule ensures that the <code><a href="../AA-3/AA-3.7#S0063">default_expression</a></code> always produces the "correct" tag when called with or without dispatching, or when inherited by a descendant. If it were statically tagged, the default would be useless for a dispatching call; if it were dynamically tagged, the default would be useless for a nondispatching call.<br /></Admonition>
</AnnotatedOnly>

<MarginText>11.1/2</MarginText>
<MarginInfo items={["AI95-00404-01"]} />
<p>If a dispatching operation is defined by a <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code> or the instantiation of a generic subprogram, any access parameter of the renamed subprogram or the generic subprogram that corresponds to a controlling access parameter of the dispatching operation, shall have a subtype that excludes null.<br /></p>

<MarginText>12</MarginText>
<p>A given subprogram shall not be a dispatching operation of two or more distinct tagged types. <br /></p>

<AnnotatedOnly>
<MarginText>12.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This restriction minimizes confusion since multiple dispatching is not provided. The normal solution is to replace all but one of the tagged types with their class-wide types. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.a.1/1</MarginText>
<MarginInfo items={["AI95-00183-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>{"{"}<em>8652/0098</em>{"}"} This restriction applies even if the partial view (see <a href="../AA-7/AA-7.3">7.3</a>) of one or both of the types is untagged. This follows from the definition of dispatching operation: the operation is a dispatching operation anywhere the full views of the (tagged) types are visible. <br /></Admonition>
</AnnotatedOnly>

<MarginText>13</MarginText>
<p>The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen (see <a href="../AA-13/AA-13.14">13.14</a>). [For example, new dispatching operations cannot be added after objects or values of the type exist, nor after deriving a record extension from it, nor after a body.]<br /></p>

<AnnotatedOnly>
<MarginText>13.a/2</MarginText>
<MarginInfo items={["AI95-00344-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>This rule is needed because (1) we don't want people dispatching to things that haven't been declared yet, and (2) we want to allow the static part of tagged type descriptors to be static (allocated statically, and initialized to link-time-known symbols). Suppose T2 inherits primitive P from T1, and then overrides P. Suppose P is called <em>before</em> the declaration of the overriding P. What should it dispatch to? If the answer is the new P, we've violated the first principle above. If the answer is the old P, we've violated the second principle. (A call to the new one necessarily raises Program_Error, but that's beside the point.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that a call upon a dispatching operation of type <em>T</em> will freeze <em>T</em>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.c</MarginText>
<Admonition type="aarm" aarm="note">
We considered applying this rule to all derived types, for uniformity. However, that would be upward incompatible, so we rejected the idea. As in Ada 83, for an untagged type, the above call upon P will call the old P (which is arguably confusing). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.d/2</MarginText>
<MarginInfo items={["AI95-00326-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Because of this rule, the type descriptor can be created (presumably containing linker symbols pointing at the not-yet-compiled bodies) at the first freezing point of the type. It also prevents, for a (nonincomplete) tagged type declared in a <code><a href="../AA-7/AA-7.1#S0230">package_specification</a></code>, overriding in the body or by a child subprogram. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.e/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>A consequence is that for a tagged type declaration in a <code><a href="../AA-3/AA-3.11#S0086">declarative_part</a></code>, only the last (overriding) primitive subprogram can be declared by a <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code>. (Other overridings must be provided by <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>s.) <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13.f/3</MarginText>
<MarginInfo items={["AI05-0222-1"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>This rule applies only to "original" declarations and not to the completion of a primitive subprogram, even though a completion is technically an explicit declaration, and it may declare a primitive subprogram. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>14</MarginText>
<p>For the execution of a call on a dispatching operation of a type <em>T</em>, the <em>controlling tag value</em> determines which subprogram body is executed. The controlling tag value is defined as follows: <br /></p>

<MarginText>15</MarginText>
<ul>
<li>If one or more controlling operands are statically tagged, then the controlling tag value is <em>statically determined</em> to be the tag of <em>T</em>.<br /></li>
<MarginText>16</MarginText>
<li>If one or more controlling operands are dynamically tagged, then the controlling tag value is not statically determined, but is rather determined by the tags of the controlling operands. If there is more than one dynamically tagged controlling operand, a check is made that they all have the same tag. If this check fails, Constraint_Error is raised unless the call is a <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> whose <code><a href="../AA-4/AA-4.1#S0091">name</a></code> denotes the declaration of an equality operator (predefined or user defined) that returns Boolean, in which case the result of the call is defined to indicate inequality, and no <code><a href="../AA-6/AA-6.3#S0216">subprogram_body</a></code> is executed. This check is performed prior to evaluating any tag-indeterminate controlling operands. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>Tag mismatch is considered an error (except for "=" and "/=") since the corresponding primitive subprograms in each specific type expect all controlling operands to be of the same type. For tag mismatch with an equality operator, rather than raising an exception, "=" returns False and "/=" returns True. No equality operator is actually invoked, since there is no common tag value to control the dispatch. Equality is a special case to be consistent with the existing Ada 83 principle that equality comparisons, even between objects with different constraints, never raise Constraint_Error. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17/2</MarginText>
<MarginInfo items={["AI95-00196-01"]} />
<ul>
<li>If all of the controlling operands (if any) are tag-indeterminate, then: <br /></li>
</ul>
<MarginText>18/2</MarginText>
<MarginInfo items={["AI95-00239-01", "AI95-00416-01"]} />
<ul>
<li>If the call has a controlling result or controlling access result and is itself, or designates, a (possibly parenthesized or qualified) controlling operand of an enclosing call on a dispatching operation of a descendant of type <em>T</em>, then its controlling tag value is determined by the controlling tag value of this enclosing call;<br /></li>
</ul>
<AnnotatedOnly>
<MarginText>18.a/2</MarginText>
<MarginInfo items={["AI95-00239-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>For code that a user can write explicitly, the only contexts that can control dispatching of a function with a controlling result of type T are those that involve controlling operands of the same type T: if the two types differ there is an illegality and the dynamic semantics are irrelevant.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>18.b/2</MarginText>
<Admonition type="aarm" aarm="note">
In the case of an inherited subprogram however, if a default expression is a function call, it may be of type T while the parameter is of a type derived from T. To cover this case, we talk about "a descendant of T" above. This is safe, because if the type of the parameter is descended from the type of the function result, it is guaranteed to inherit or override the function, and this ensures that there will be an appropriate body to dispatch to. Note that abstract functions are not an issue here because the call to the function is a dispatching call, so it is guaranteed to always land on a concrete body. <br /></Admonition>
</AnnotatedOnly>

<MarginText>18.1/2</MarginText>
<MarginInfo items={["AI95-00196-01", "AI95-00416-01"]} />
<ul>
<li>If the call has a controlling result or controlling access result and (possibly parenthesized, qualified, or dereferenced) is the expression of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> whose target is of a class-wide type, then its controlling tag value is determined by the target;<br /></li>
<MarginText>19</MarginText>
<li>Otherwise, the controlling tag value is statically determined to be the tag of type <em>T</em>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This includes the cases of a tag-indeterminate procedure call, and a tag-indeterminate <code><a href="../AA-6/AA-6.4#S0218">function_call</a></code> that is used to initialize a class-wide formal parameter or class-wide object. <br /></Admonition>
</AnnotatedOnly>

<MarginText>20/3</MarginText>
<MarginInfo items={["AI95-00345-01", "AI05-0126-1"]} />
<p>For the execution of a call on a dispatching operation, the action performed is determined by the properties of the corresponding dispatching operation of the specific type identified by the controlling tag value:<br /></p>

<MarginText>20.1/3</MarginText>
<MarginInfo items={["AI05-0126-1"]} />
<ul>
<li>if the corresponding operation is explicitly declared for this type, [even if the declaration occurs in a private part], then the action comprises an invocation of the explicit body for the operation;<br /></li>
<MarginText>20.2/3</MarginText>
<MarginInfo items={["AI95-00345-01", "AI05-0126-1"]} />
<li>if the corresponding operation is implicitly declared for this type and is implemented by an entry or protected subprogram (see <a href="../AA-9/AA-9.1">9.1</a> and <a href="../AA-9/AA-9.4">9.4</a>), then the action comprises a call on this entry or protected subprogram, with the target object being given by the first actual parameter of the call, and the actual parameters of the entry or protected subprogram being given by the remaining actual parameters of the call, if any;<br /></li>
<MarginText>20.3/3</MarginText>
<MarginInfo items={["AI05-0197-1"]} />
<li>if the corresponding operation is a predefined operator then the action comprises an invocation of that operator;<br /></li>
<MarginText>20.4/3</MarginText>
<MarginInfo items={["AI95-00345-01", "AI05-0126-1", "AI05-0197-1", "AI05-0250-1", "AI05-0254-1"]} />
<li>otherwise, the action is the same as the action for the corresponding operation of the parent type or progenitor type from which the operation was inherited except that additional invariant checks (see <a href="../AA-7/AA-7.3#Subclause_7.3.2">7.3.2</a>) and class-wide postcondition checks (see <a href="../AA-6/AA-6.1#Subclause_6.1.1">6.1.1</a>) may apply. If there is more than one such corresponding operation, the action is that for the operation that is not a null procedure, if any; otherwise, the action is that of an arbitrary one of the operations. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>20.a/3</MarginText>
<MarginInfo items={["AI05-0126-1"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.a.1/3</MarginText>
<MarginInfo items={["AI05-0005-1", "AI05-0126-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>&ldquo;Corresponding dispatching operation&rdquo; refers to the inheritance relationship between subprograms. Primitive operations are always inherited for a type T, but they might not be declared if the primitive operation is never visible within the immediate scope of the type T. If no corresponding operation is declared, the last bullet is used and the corresponding operation of the parent type is executed (an explicit body that happens to have the same name and profile is not called in that case).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.a.2/3</MarginText>
<MarginInfo items={["AI05-0005-1", "AI05-0126-1"]} />
<Admonition type="aarm" aarm="note">
We have to talk about progenitors in the last bullet in case the corresponding operation is a null procedure inherited from an interface. In that case, the parent type might not even have the operation in question.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.a.3/3</MarginText>
<MarginInfo items={["AI05-0197-1"]} />
<Admonition type="aarm" aarm="note">
For the last bullet, if there are multiple corresponding operations for the parent and progenitors, all but one of them have to be a null procedure. (If the progenitors declared abstract routines, there would have to be an explicit overriding of the operation, and then the first bullet would apply.) We call the nonnull routine if one exists.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.a.4/3</MarginText>
<MarginInfo items={["AI05-0126-1"]} />
<Admonition type="aarm" aarm="note">
Any explicit declaration for an inherited corresponding operation has to be an overriding routine. These rules mean that a dispatching call executes the overriding routine (if any) for the specific type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.b/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The wording of the above rules is intended to ensure that the same body is executed for a given tag, whether that tag is determined statically or dynamically. For a type declared in a package, it doesn't matter whether a given subprogram is overridden in the visible part or the private part, and it doesn't matter whether the call is inside or outside the package. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.c</MarginText>
<CodeBlock language="ada">
package P1 is{"\n"}    type T1 is tagged null record;{"\n"}    procedure Op_A(Arg : in T1);{"\n"}    procedure Op_B(Arg : in T1);{"\n"}end P1;{"\n"}
<MarginText>20.d</MarginText>
with P1; use P1;{"\n"}package P2 is{"\n"}    type T2 is new T1 with null record;{"\n"}    procedure Op_A(Param : in T2);{"\n"}private{"\n"}    procedure Op_B(Param : in T2);{"\n"}end P2;{"\n"}
<MarginText>20.e/1</MarginText>
with P1; with P2;{"\n"}procedure Main is{"\n"}    X : P2.T2;{"\n"}    Y : P1.T1'Class := X;{"\n"}begin{"\n"}    P2.Op_A(Param ={">"} X); -- Nondispatching call to a dispatching operation.{"\n"}    P1.Op_A(Arg ={">"} Y); -- Dispatching call.{"\n"}    P2.Op_B(Arg ={">"} X); -- Nondispatching call to a dispatching operation.{"\n"}    P1.Op_B(Arg ={">"} Y); -- Dispatching call.{"\n"}end Main;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>20.f</MarginText>
<Admonition type="aarm" aarm="note">
The two calls to Op_A both execute the body of Op_A that has to occur in the body of package P2. Similarly, the two calls to Op_B both execute the body of Op_B that has to occur in the body of package P2, even though Op_B is overridden in the private part of P2. Note, however, that the formal parameter names are different for P2.Op_A versus P2.Op_B. The overriding declaration for P2.Op_B is not visible in Main, so the name in the call actually denotes the implicit declaration of Op_B inherited from T1.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.g</MarginText>
<Admonition type="aarm" aarm="note">
If a call occurs in the program text before an overriding, which can happen only if the call is part of a default expression, the overriding will still take effect for that call.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>20.h</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>Even when a tag is not <em>statically determined</em>, a compiler might still be able to figure it out and thereby avoid the overhead of run-time dispatching. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   The body to be executed for a call on a dispatching operation is determined by the tag; it does not matter whether that tag is determined statically or dynamically, and it does not matter whether the subprogram's declaration is visible at the place of the call.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>22/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="note">
NOTE 2   This subclause covers calls on dispatching subprograms of a tagged type. Rules for tagged type membership tests are described in <a href="../AA-4/AA-4.5#Subclause_4.5.2">4.5.2</a>. Controlling tag determination for an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code> is described in <a href="../AA-5/AA-5.2">5.2</a>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 3   A dispatching call can dispatch to a body whose declaration is not visible at the place of the call.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 4   A call through an access-to-subprogram value is never a dispatching call, even if the access value designates a dispatching operation. Similarly a call whose <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> denotes a <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code> cannot be a dispatching call unless the renaming itself is the declaration of a primitive subprogram. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 83

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="note">
The concept of dispatching operations is new. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.b/2</MarginText>
<MarginInfo items={["AI95-00404-01"]} />
<Admonition type="aarm" aarm="note">
If a dispatching operation is defined by a <code><a href="../AA-8/AA-8.5#S0242">subprogram_renaming_declaration</a></code>, and it has a controlling access parameter, Ada 2005 requires the subtype of the parameter to exclude null. The same applies to instantiations. This is required so that all calls to the subprogram operate the same way (controlling access parameters have to exclude null so that dispatching calls will work). Since Ada 95 didn't have the notion of access subtypes that exclude null, and all access parameters excluded null, it had no such rules. These rules will require the addition of an explicit <strong>not null</strong> on nondispatching operations that are later renamed to be dispatching, or on a generic that is used to define a dispatching operation. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.c/2</MarginText>
<MarginInfo items={["AI95-00416-01"]} />
<Admonition type="aarm" aarm="note">
Functions that have an access result type can be dispatching in the same way as a function that returns a tagged object directly. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.d/3</MarginText>
<MarginInfo items={["AI95-00127-01", "AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0010</em>{"}"} <strong>Corrigendum:</strong> Allocators and access attributes of objects of class-wide types can be used as the controlling parameter in a dispatching calls. This was an oversight in the definition of Ada 95. (See <a href="../AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a> and <a href="../AA-4/AA-4.8">4.8</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.e/2</MarginText>
<MarginInfo items={["AI95-00117-01", "AI95-00430-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0011</em>{"}"} <strong>Corrigendum:</strong> Corrected the conventions of dispatching operations. This is extended in Ada 2005 to cover operations inherited from progenitors, and to ensure that the conventions of all inherited operations are the same.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.f/2</MarginText>
<MarginInfo items={["AI95-00196-01"]} />
<Admonition type="aarm" aarm="note">
Clarified the wording to ensure that functions with no controlling operands are tag-indeterminate, and to describe that the controlling tag can come from the target of an <code><a href="../AA-5/AA-5.2#S0173">assignment_statement</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.g/2</MarginText>
<MarginInfo items={["AI95-00239-01"]} />
<Admonition type="aarm" aarm="note">
Fixed the wording to cover default expressions inherited by derived subprograms. A literal reading of the old wording would have implied that operations would be called with objects of the wrong type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.h/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="note">
An abstract formal subprogram is a dispatching operation, even though it is not a primitive operation. See <a href="../AA-12/AA-12.6">12.6</a>, &ldquo;<a href="../AA-12/AA-12.6">Formal Subprograms</a>&rdquo;.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.i/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
Dispatching calls include operations implemented by entries and protected operations, so we have to update the wording to reflect that.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.j/2</MarginText>
<MarginInfo items={["AI95-00335-01"]} />
<Admonition type="aarm" aarm="note">
A stream attribute of a tagged type is usually a dispatching operation, even though it is not a primitive operation. If they weren't dispatching, T'Class'Input and T'Class'Output wouldn't work. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.k/3</MarginText>
<MarginInfo items={["AI05-0076-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Defined &ldquo;function with a controlling result&rdquo;, as it is used in <a href="../AA-3/AA-3.9#Subclause_3.9.3">3.9.3</a>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.l/3</MarginText>
<MarginInfo items={["AI05-0126-1", "AI05-0197-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Corrected holes in the definition of dynamic dispatching: the behavior for operations that are never declared and/or inherited from a progenitor were not specified. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>24.m/5</MarginText>
<MarginInfo items={["AI12-0236-1"]} />
<Admonition type="aarm" aarm="note">
Added a special rule for taggedness of <code><a href="../AA-4/AA-4.5#S0156">declare_expression</a></code>s, and added a pointer to the existing special rules for <code><a href="../AA-4/AA-4.5#S0148">conditional_expression</a></code>s, as the list of exceptions to the usual rules appear to be exhaustive.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.n/5</MarginText>
<MarginInfo items={["AI12-0419-1"]} />
<Admonition type="aarm" aarm="note">
Added wording to clarify that the Put_Image attribute is a dispatching operation. Put_Image follows the model of stream-oriented attributes, and thus need to be mentioned in the same place. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_3.9.3"></a>

## 3.9.3  Abstract Types and Subprograms

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>[ An <em>abstract type</em> is a tagged type intended for use as an ancestor of other types, but which is not allowed to have objects of its own. An <em>abstract subprogram</em> is a subprogram that has no body, but is intended to be overridden at some point when inherited. Because objects of an abstract type cannot be created, a dispatching call to an abstract subprogram always dispatches to some overriding body.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a.1/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>abstract type</strong> &mdash; tagged type intended for use as an ancestor of other types, but which is not allowed to have objects of its own<br /></Admonition>
</AnnotatedOnly>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.a/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
An abstract subprogram has no body, so the rules in this subclause are designed to ensure (at compile time) that the body will never be invoked. We do so primarily by disallowing the creation of values of the abstract type. Therefore, since type conversion and parameter passing don't change the tag, we know we will never get a class-wide value with a tag identifying an abstract type. This means that we only have to disallow nondispatching calls on abstract subprograms (dispatching calls will never reach them). <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>1.1/3</MarginText>
<MarginInfo items={["AI95-00218-03", "AI95-00348-01", "AI05-0183-1"]} />

<CodeBlock>
<code>abstract_subprogram_declaration</code><a id="S0076"></a><code> ::= </code><br />    [<code><a href="../AA-8/AA-8.3#S0234">overriding_indicator</a></code>]<br />    <code><a href="../AA-6/AA-6.1#S0196">subprogram_specification</a></code> <strong>is</strong> <strong>abstract</strong><br />        [<code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code>];<br />

</CodeBlock>

#### Static Semantics

<MarginText>1.2/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>Interface types (see <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>) are abstract types. In addition, a tagged type that has the reserved word <strong>abstract</strong> in its declaration is an abstract type. The class-wide type (see <a href="../AA-3/AA-3.4#Subclause_3.4.1">3.4.1</a>) rooted at an abstract type is not itself an abstract type. <br /></p>


#### Legality Rules

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>Only a tagged type shall have the reserved word <strong>abstract</strong> in its declaration. <br /></p>

<AnnotatedOnly>
<MarginText>2.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Untagged types are never abstract, even though they can have primitive abstract subprograms. Such subprograms cannot be called, unless they also happen to be dispatching operations of some tagged type, and then only via a dispatching call.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>2.b</MarginText>
<Admonition type="aarm" aarm="note">
Class-wide types are never abstract. If T is abstract, then it is illegal to declare a stand-alone object of type T, but it is OK to declare a stand-alone object of type T'Class; the latter will get a tag from its initial value, and this tag will necessarily be different from T'Tag. <br /></Admonition>
</AnnotatedOnly>

<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00260-02", "AI95-00348-01"]} />
<p>A subprogram declared by an <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> or a <code><a href="../AA-12/AA-12.6#S0337">formal_abstract_subprogram_declaration</a></code> (see <a href="../AA-12/AA-12.6">12.6</a>) is an <em>abstract subprogram</em>. If it is a primitive subprogram of a tagged type, then the tagged type shall be abstract. <br /></p>

<AnnotatedOnly>
<MarginText>3.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that for a private type, this applies to both views. The following is illegal: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.b</MarginText>
<CodeBlock language="ada">
package P is{"\n"}    type T is abstract tagged private;{"\n"}    function Foo (X : T) return Boolean is abstract; -- Illegal!{"\n"}private{"\n"}    type T is tagged null record; -- Illegal!{"\n"}    X : T;{"\n"}    Y : Boolean := Foo (T'Class (X));{"\n"}end P;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>3.c</MarginText>
<Admonition type="aarm" aarm="note">
The full view of T is not abstract, but has an abstract operation Foo, which is illegal. The two lines marked "--<em> Illegal!</em>" are illegal when taken together. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.d/2</MarginText>
<MarginInfo items={["AI95-00310-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>We considered disallowing untagged types from having abstract primitive subprograms. However, we rejected that plan, because it introduced some silly anomalies, and because such subprograms are harmless. For example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.e/1</MarginText>
<CodeBlock language="ada">
package P is{"\n"}   type Field_Size is range 0..100;{"\n"}   type T is abstract tagged null record;{"\n"}   procedure Print(X : in T; F : in Field_Size := 0) is abstract;{"\n"}  . . .{"\n"}package Q is{"\n"}   type My_Field_Size is new Field_Size;{"\n"}   -- implicit declaration of Print(X : T; F : My_Field_Size := 0) is abstract;{"\n"}end Q;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>3.f</MarginText>
<Admonition type="aarm" aarm="note">
It seemed silly to make the derivative of My_Field_Size illegal, just because there was an implicitly declared abstract subprogram that was not primitive on some tagged type. Other rules could be formulated to solve this problem, but the current ones seem like the simplest.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.g/2</MarginText>
<MarginInfo items={["AI95-00310-01"]} />
<Admonition type="aarm" aarm="note">
In Ada 2005, abstract primitive subprograms of an untagged type may be used to &ldquo;undefine&rdquo; an operation. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>3.h/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that the second sentence does not apply to abstract formal subprograms, as they are never primitive operations of a type. <br /></Admonition>
</AnnotatedOnly>

<MarginText>4/3</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00334-01", "AI95-00391-01", "AI05-0097-1", "AI05-0198-1"]} />
<p>If a type has an implicitly declared primitive subprogram that is inherited or is a predefined operator, and the corresponding primitive subprogram of the parent or ancestor type is abstract or is a function with a controlling access result, or if a type other than a nonabstract null extension inherits a function with a controlling result, then: <br /></p>

<AnnotatedOnly>
<MarginText>4.a/3</MarginText>
<MarginInfo items={["AI05-0068-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>These rules apply to each view of the type individually. That is necessary to preserve privacy. For instance, in the following example: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.b/3</MarginText>
<CodeBlock language="ada">
package P is{"\n"}   type I is interface;{"\n"}   procedure Op (X : I) is abstract;{"\n"}end P;{"\n"}
<MarginText>4.c/3</MarginText>
with P;{"\n"}package Q is{"\n"}   type T is abstract new P.I with private;{"\n"}   -- Op inherited here.{"\n"}private{"\n"}   type T is abstract new P.I with null record;{"\n"}   procedure Op (X : T) is null;{"\n"}end Q;{"\n"}
<MarginText>4.d/3</MarginText>
with Q;{"\n"}package R is{"\n"}   type T2 is new Q.T with null record;{"\n"}   -- Illegal. Op inherited here, but requires overriding.{"\n"}end R;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>4.e/3</MarginText>
<Admonition type="aarm" aarm="note">
If this did not depend on the view, this would be legal. But in that case, the fact that Op is overridden in the private part would be visible; package R would have to be illegal if no overriding was in the private part.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>4.f/3</MarginText>
<Admonition type="aarm" aarm="note">
Note that this means that whether an inherited subprogram is abstract or concrete depends on where it inherited. In the case of Q, Q.Op in the visible part is abstract, while Q.Op in the private part is concrete. That is, R is illegal since it is an unrelated unit (and thus it cannot see the private part), but if R had been a private child of Q, it would have been legal. <br /></Admonition>
</AnnotatedOnly>

<MarginText>5/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00334-01"]} />
<ul>
<li>If the type is abstract or untagged, the implicitly declared subprogram is <em>abstract</em>. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>5.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Note that it is possible to override a concrete subprogram with an abstract one. <br /></Admonition>
</AnnotatedOnly>

<MarginText>6/5</MarginText>
<MarginInfo items={["AI95-00391-01", "AI12-0080-1", "AI12-0444-1"]} />
<ul>
<li>Otherwise, the subprogram shall be overridden with a nonabstract subprogram or, in the case of a private extension inheriting a nonabstract function with a controlling result, have a full type that is a null extension[; for a type declared in the visible part of a package, the overriding may be either in the visible or the private part]. Such a subprogram is said to <em>require overriding</em>. However, if the type is a generic formal type, the subprogram is allowed to be inherited as is, without being  overridden for the formal type itself; [a nonabstract version will necessarily be provided by the actual type.] <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>6.a/2</MarginText>
<MarginInfo items={["AI95-00228-01", "AI95-00391-01"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>A function that returns the parent type requires overriding for a type extension (or becomes abstract for an abstract type) because conversion from a parent type to a type extension is not defined, and function return semantics is defined in terms of conversion (other than for a null extension; see below). (Note that parameters of mode <strong>in out</strong> or <strong>out</strong> do not have this problem, because the tag of the actual is not changed.)<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.b</MarginText>
<Admonition type="aarm" aarm="note">
Note that the overriding required above can be in the private part, which allows the following: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.c</MarginText>
<CodeBlock language="ada">
package Pack1 is{"\n"}    type Ancestor is abstract ...;{"\n"}    procedure Do_Something(X : in Ancestor) is abstract;{"\n"}end Pack1;{"\n"}
<MarginText>6.d</MarginText>
with Pack1; use Pack1;{"\n"}package Pack2 is{"\n"}    type T1 is new Ancestor with record ...;{"\n"}        -- A concrete type.{"\n"}    procedure Do_Something(X : in T1); -- Have to override.{"\n"}end Pack2;{"\n"}
<MarginText>6.e</MarginText>
with Pack1; use Pack1;{"\n"}with Pack2; use Pack2;{"\n"}package Pack3 is{"\n"}    type T2 is new Ancestor with private;{"\n"}        -- A concrete type.{"\n"}private{"\n"}    type T2 is new T1 with -- Parent different from ancestor.{"\n"}      record ... end record;{"\n"}    -- Here, we inherit Pack2.Do_Something.{"\n"}end Pack3;{"\n"}    {"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>6.f/2</MarginText>
<MarginInfo items={["AI95-00228-01"]} />
<Admonition type="aarm" aarm="note">
T2 inherits an abstract Do_Something, but T2 is not abstract, so Do_Something has to be overridden. However, it is OK to override it in the private part. In this case, we override it by inheriting a concrete version from a different type. Nondispatching calls to Pack3.Do_Something are allowed both inside and outside package Pack3, as the client &ldquo;knows&rdquo; that the subprogram was necessarily overridden somewhere.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.g/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<Admonition type="aarm" aarm="note">
For a null extension, the result of a function with a controlling result is defined in terms of an <code><a href="../AA-4/AA-4.3#S0111">extension_aggregate</a></code> with a <strong>null record</strong> extension part (see <a href="../AA-3/AA-3.4">3.4</a>). This means that these restrictions on functions with a controlling result do not have to apply to null extensions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.h/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<Admonition type="aarm" aarm="note">
However, functions with controlling access results still require overriding. Changing the tag in place might clobber a preexisting object, and allocating new memory would possibly change the pool of the object, leading to storage leaks. Moreover, copying the object isn't possible for limited types. We don't need to restrict functions that have an access return type of an untagged type, as derived types with primitive subprograms have to have the same representation as their parent type. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7/5</MarginText>
<MarginInfo items={["AI12-0413-1"]} />
<p>A call on an abstract subprogram shall be a dispatching call; nondispatching calls to an abstract subprogram are not allowed. In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), these rules also apply in the private part of an instance of a generic unit. <br /></p>

<AnnotatedOnly>
<MarginText>7.a/5</MarginText>
<MarginInfo items={["AI95-00310-01", "AI12-0413-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>If an abstract subprogram is not a dispatching operation of some tagged type, then it cannot be called at all. In Ada 2005, such subprograms are not even considered by name resolution (see <a href="../AA-6/AA-6.4">6.4</a>). However, this rule is still needed for cases that can arise in the instance of a generic specification where Name Resolution Rules are not reapplied, but Legality Rules are, when the equality operator for an untagged record type is abstract, while the operator for the formal type is not abstract (see <a href="../AA-12/AA-12.5">12.5</a>). <br /></Admonition>
</AnnotatedOnly>

<MarginText>7.1/5</MarginText>
<MarginInfo items={["AI12-0189-1", "AI12-0292-1", "AI12-0320-1"]} />
<p>If the <code><a href="../AA-4/AA-4.1#S0091">name</a></code> or <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> given in an <code><a href="../AA-5/AA-5.5#S0187">iterator_procedure_call</a></code> (see <a href="../AA-5/AA-5.5#Subclause_5.5.3">5.5.3</a>) denotes an abstract subprogram, the subprogram shall be a dispatching subprogram.<br /></p>

<MarginText>8/5</MarginText>
<MarginInfo items={["AI05-0073-1", "AI05-0203-1", "AI12-0437-1"]} />
<p>The type of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>,  of an object created by an <code><a href="../AA-3/AA-3.3#S0032">object_declaration</a></code> or an <code><a href="../AA-4/AA-4.8#S0164">allocator</a></code>, or of a generic formal object of mode <strong>in</strong>, shall not be abstract. The type of the target of an assignment operation (see <a href="../AA-5/AA-5.2">5.2</a>) shall not be abstract. The type of a component shall not be abstract. If the result type of a function is abstract, then the function shall be abstract. If a function has an access result type designating an abstract type, then the function shall be abstract. The type denoted by a <code><a href="../AA-6/AA-6.5#S0226">return_subtype_indication</a></code> (see <a href="../AA-6/AA-6.5">6.5</a>) shall not be abstract. A generic function shall not have an abstract result type or an access result type designating an abstract type. <br /></p>

<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This ensures that values of an abstract type cannot be created, which ensures that a dispatching call to an abstract subprogram will not try to execute the nonexistent body.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.b</MarginText>
<Admonition type="aarm" aarm="note">
Generic formal objects of mode <strong>in</strong> are like constants; therefore they should be forbidden for abstract types. Generic formal objects of mode <strong>in out</strong> are like renamings; therefore, abstract types are OK for them, though probably not terribly useful.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.c/3</MarginText>
<MarginInfo items={["AI05-0073-1"]} />
<Admonition type="aarm" aarm="note">
Generic functions returning a formal abstract type are illegal because any instance would have to be instantiated with a nonabstract type in order to avoid violating the function rule (generic functions cannot be declared abstract). But that would be an implied contract; it would be better for the contract to be explicit by the formal type not being declared abstract. Moreover, the implied contract does not add any capability. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9</MarginText>
<p>If a partial view is not abstract, the corresponding full view shall not be abstract. If a generic formal type is abstract, then for each primitive subprogram of the formal that is not abstract, the corresponding primitive subprogram of the actual shall not be abstract. <br /></p>

<AnnotatedOnly>
<MarginText>9.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>By contrast, we allow the actual type to be nonabstract even if the formal type is declared abstract. Hence, the most general formal tagged type possible is "<strong>type</strong> T({"<"}{">"}) <strong>is abstract tagged limited private</strong>;".<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.b</MarginText>
<Admonition type="aarm" aarm="note">
For an abstract private extension declared in the visible part of a package, it is only possible for the full type to be nonabstract if the private extension has no abstract dispatching operations. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.c/2</MarginText>
<MarginInfo items={["AI95-00294-01"]} />
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>In the sentence about primitive subprograms above, there is some ambiguity as to what is meant by &ldquo;corresponding&rdquo; in the case where an inherited operation is overridden.  This is best explained by an example, where the implicit declarations are shown as comments: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>9.d/2</MarginText>
<CodeBlock language="ada">
package P1 is{"\n"}   type T1 is abstract tagged null record;{"\n"}   procedure P (X : T1); -- (1){"\n"}end P1;{"\n"}
<MarginText>9.e/2</MarginText>
package P2 is{"\n"}   type T2 is abstract new P1.T1 with null record;{"\n"}   -- procedure P (X : T2); -- (2){"\n"}   procedure P (X : T2) is abstract; -- (3){"\n"}end P2;{"\n"}
<MarginText>9.f/2</MarginText>
generic{"\n"}   type D is abstract new P1.T1 with private;{"\n"}   -- procedure P (X : D); -- (4){"\n"}procedure G (X : D);{"\n"}
<MarginText>9.g/2</MarginText>
procedure I is new G (P2.T2); -- Illegal.{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>9.h/2</MarginText>
<Admonition type="aarm" aarm="note">
Type T2 inherits a nonabstract procedure P (2) from the primitive procedure P (1) of T1. P (2) is overridden by the explicitly declared abstract procedure P (3). Type D inherits a nonabstract procedure P (4) from P (1). In instantiation I, the operation corresponding to P (4) is the one which is not overridden, that is, P (3): the overridden operation P (2) does not &ldquo;reemerge&rdquo;. Therefore, the instantiation is illegal. <br /></Admonition>
</AnnotatedOnly>

<MarginText>10/3</MarginText>
<MarginInfo items={["AI05-0073-1"]} />
<p>For an abstract type declared in a visible part, an abstract primitive subprogram shall not be declared in the private part, unless it is overriding an abstract subprogram implicitly declared in the visible part. For a tagged type declared in a visible part, a primitive function with a controlling result or a controlling access result shall not be declared in the private part, unless it is overriding a function implicitly declared in the visible part. <br /></p>

<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>The &ldquo;visible part&rdquo; could be that of a package or a generic package. This rule is needed because a nonabstract type extension declared outside the package would not know about any abstract primitive subprograms or primitive functions with controlling results declared in the private part, and wouldn't know that they need to be overridden with nonabstract subprograms. The rule applies to a tagged record type or record extension declared in a visible part, just as to a tagged private type or private extension. The rule applies to explicitly and implicitly declared abstract subprograms: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>10.b</MarginText>
<CodeBlock language="ada">
package Pack is{"\n"}    type T is abstract new T1 with private;{"\n"}private{"\n"}    type T is abstract new T2 with record ... end record;{"\n"}    ...{"\n"}end Pack;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>10.c</MarginText>
<Admonition type="aarm" aarm="note">
The above example would be illegal if T1 has a nonabstract primitive procedure P, but T2 overrides P with an abstract one; the private part should override P with a nonabstract version. On the other hand, if the P were abstract for both T1 and T2, the example would be legal as is. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<p>A generic actual subprogram shall not be an abstract subprogram unless the generic formal subprogram is declared by a <code><a href="../AA-12/AA-12.6#S0337">formal_abstract_subprogram_declaration</a></code>. The <code><a href="../AA-4/AA-4.1#S0093">prefix</a></code> of an <code><a href="../AA-4/AA-4.1#S0100">attribute_reference</a></code> for the Access, Unchecked_Access, or Address attributes shall not denote an abstract subprogram. <br /></p>

<AnnotatedOnly>
<MarginText>11.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>An <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> is not syntactically a <code><a href="../AA-6/AA-6.1#S0195">subprogram_declaration</a></code>. Nonetheless, an abstract subprogram is a subprogram, and an <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> is a declaration of a subprogram.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>11.b/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="note">
The part about generic actual subprograms includes those given by default. Of course, an abstract formal subprogram's actual subprogram can be abstract. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>11.1/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<p>The elaboration of an <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> has no effect. <br /></p>

<AnnotatedOnly>
<MarginText>12/5</MarginText>
<MarginInfo items={["AI12-0447-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 1   Abstractness is not inherited; a type is abstract only if  the reserved word <strong>abstract</strong> is  used in the declaration of the type extension. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>12.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>A derived type can be abstract even if its parent is not. Similarly, an inherited concrete subprogram can be overridden with an abstract subprogram. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>13</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   A class-wide type is never abstract. Even if a class is rooted at an abstract type, the class-wide type for the class is not abstract, and an object of the class-wide type can be created; the tag of such an object will identify some nonabstract type in the class. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>14</MarginText>
<p><em>Example of an abstract type representing a set of natural numbers:</em> <br /></p>

<MarginText>15</MarginText>
<CodeBlock language="ada">
package Sets is{"\n"}    subtype Element_Type is Natural;{"\n"}    type Set is abstract tagged null record;{"\n"}    function Empty return Set is abstract;{"\n"}    function Union(Left, Right : Set) return Set is abstract;{"\n"}    function Intersection(Left, Right : Set) return Set is abstract;{"\n"}    function Unit_Set(Element : Element_Type) return Set is abstract;{"\n"}    procedure Take(Element : out Element_Type;{"\n"}                   From : in out Set) is abstract;{"\n"}end Sets;{"\n"}

</CodeBlock>
<MarginText>16/5</MarginText>
<MarginInfo items={["AI12-0442-1", "AI12-0452-1"]} />
<p>Given the above abstract type, one can derive various (nonabstract) extensions of the type, representing alternative implementations of a set. One possibility is to use a bit vector, but impose an upper bound on the largest element representable, while another possible implementation is a hash table, trading off space for flexibility.<br /></p>

<AnnotatedOnly>
<MarginText>17/5</MarginText>
<MarginInfo items={["AI12-0452-1"]} />
<Admonition type="aarm" aarm="note">
 <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>One way to export a type from a package with some components visible and some components private is as follows: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.b</MarginText>
<CodeBlock language="ada">
package P is{"\n"}    type Public_Part is abstract tagged{"\n"}        record{"\n"}            ...{"\n"}        end record;{"\n"}    type T is new Public_Part with private;{"\n"}    ...{"\n"}private{"\n"}    type T is new Public_Part with{"\n"}        record{"\n"}            ...{"\n"}        end record;{"\n"}end P;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.c</MarginText>
<Admonition type="aarm" aarm="note">
The fact that Public_Part is abstract tells clients they have to create objects of type T instead of Public_Part. Note that the public part has to come first; it would be illegal to declare a private type Private_Part, and then a record extension T of it, unless T were in the private part after the full declaration of Private_Part, but then clients of the package would not have visibility to T. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.d/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<Admonition type="aarm" aarm="note">
It is not necessary to override functions with a controlling result for a null extension. This makes it easier to derive a tagged type to complete a private type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.e/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
Updated the wording to reflect the addition of interface types (see <a href="../AA-3/AA-3.9#Subclause_3.9.4">3.9.4</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.f/2</MarginText>
<MarginInfo items={["AI95-00260-02"]} />
<Admonition type="aarm" aarm="note">
Updated the wording to reflect the addition of abstract formal subprograms (see <a href="../AA-12/AA-12.6">12.6</a>).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.g/2</MarginText>
<MarginInfo items={["AI95-00334-01"]} />
<Admonition type="aarm" aarm="note">
The wording of shall-be-overridden was clarified so that it clearly applies to abstract predefined equality.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.h/2</MarginText>
<MarginInfo items={["AI95-00348-01"]} />
<Admonition type="aarm" aarm="note">
Moved the syntax and elaboration rule for <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code> here, so the syntax and most of the semantics are together (which is consistent with null procedures).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.i/2</MarginText>
<MarginInfo items={["AI95-00391-01"]} />
<Admonition type="aarm" aarm="note">
We define the term <em>require overriding</em> to make other wording easier to understand. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.j/3</MarginText>
<MarginInfo items={["AI05-0073-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added rules to eliminate holes with controlling access results and generic functions that return abstract types. While these changes are technically incompatible, it is unlikely that they could be used in a program without violating some other rule of the use of abstract types.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.k/3</MarginText>
<MarginInfo items={["AI05-0097-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Corrected a minor glitch having to do with abstract null extensions. The Ada 2005 rule allowed such extensions to inherit concrete operations in some rare cases. It is unlikely that these cases exist in user code. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.l/3</MarginText>
<MarginInfo items={["AI05-0183-1"]} />
<Admonition type="aarm" aarm="note">
An optional <code><a href="../AA-13/AA-13.1#S0346">aspect_specification</a></code> can be used in an <code><a href="../AA-3/AA-3.9#S0076">abstract_subprogram_declaration</a></code>. This is described in <a href="../AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.m/3</MarginText>
<MarginInfo items={["AI05-0198-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified that the predefined operator corresponding to an inherited abstract operator is also abstract. The Ada 2005 rules caused the predefined operator and the inherited operator to override each other, which is weird. But the effect is the same either way (the operator is not considered for resolution).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>17.n/3</MarginText>
<MarginInfo items={["AI05-0203-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added wording to disallow abstract return objects. These were illegal in Ada 2005 by other rules; the extension to support class-wide type better opened a hole which has now been plugged. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>17.o/5</MarginText>
<MarginInfo items={["AI12-0413-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Clarified that a recheck is needed in the case of an actual that is a record type with an abstract equality. This is an incompatibility as the generic boilerplate was previously omitted, meaning that such a recheck should not have been performed in the private part of an instance. Usually, this would just change an elaboration time raise of Program_Error into an error (a good thing, as the instance will never be useful), but could break a working instance if the equality usage is in a default expression that appears in the private part of the generic unit and it is never used in a call. In that case, Ada 2022 will reject the instance while it would have worked in Ada 2012. As a practical matter, it's more likely that a compiler already does the recheck in the entire instance spec, or does not do it at all; thus for many implementations there will be no practical incompatibility. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_3.9.4"></a>

## 3.9.4  Interface Types

<MarginText>1/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />
<p>[An interface type is an abstract tagged type that provides a restricted form of multiple inheritance. A tagged type, task type, or protected type may have one or more interface types as ancestors.] <br /></p>

<AnnotatedOnly>
<MarginText>1.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>interface type</strong> &mdash; abstract tagged type that has no components or concrete operations except possibly null procedures<br /><br /></Admonition>
</AnnotatedOnly>


#### Language Design Principles

<AnnotatedOnly>
<MarginText>1.b/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
The rules are designed so that an interface can be used as either a parent type or a progenitor type without changing the meaning. That's important so that the order that interfaces are specified in a <code><a href="../AA-3/AA-3.4#S0035">derived_type_definition</a></code> is not significant. In particular, we want: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>1.c/2</MarginText>
<CodeBlock language="ada">
type Con1 is new Int1 and Int2 with null record;{"\n"}type Con2 is new Int2 and Int1 with null record;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>1.d/2</MarginText>
<Admonition type="aarm" aarm="note">
to mean exactly the same thing. <br /></Admonition>
</AnnotatedOnly>


#### Syntax

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />

<CodeBlock>
<code>interface_type_definition</code><a id="S0077"></a><code> ::= </code><br />    [<strong>limited</strong> | <strong>task</strong> | <strong>protected</strong> | <strong>synchronized</strong>] <strong>interface</strong> [<strong>and</strong> <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code>]<br />

</CodeBlock>
<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00419-01"]} />

<CodeBlock>
<code>interface_list</code><a id="S0078"></a><code> ::= </code><em>interface_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> {"{"}<strong>and</strong> <em>interface_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>{"}"}<br />

</CodeBlock>

#### Static Semantics

<MarginText>4/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<p>An interface type (also called an <em>interface</em>) is a specific abstract tagged type that is defined by an <code><a href="../AA-3/AA-3.9#S0077">interface_type_definition</a></code>.<br /></p>

<MarginText>5/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>An interface with the reserved word <strong>limited</strong>, <strong>task</strong>, <strong>protected</strong>, or <strong>synchronized</strong> in its definition is termed, respectively, a <em>limited interface</em>, a <em>task interface</em>, a <em>protected interface</em>, or a <em>synchronized interface</em>. In addition, all task and protected interfaces are synchronized interfaces, and all synchronized interfaces are limited interfaces. <br /></p>

<AnnotatedOnly>
<MarginText>5.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>synchronized</strong> &mdash; can be safely operated on by multiple tasks concurrently<br /><br /></Admonition>
</AnnotatedOnly>

<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00345-01", "AI95-00443-01"]} />
<p>[A task or protected type derived from an interface is a tagged type.] Such a tagged type is called a <em>synchronized</em> tagged type, as are synchronized interfaces and private extensions whose declaration includes the reserved word <strong>synchronized</strong>.<br /></p>

<AnnotatedOnly>
<MarginText>6.a/2</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>The full definition of tagged types given in <a href="../AA-3/AA-3.9">3.9</a> includes task and protected types derived from interfaces. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.b/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>The class-wide type associated with a tagged task type (including a task interface type) is a task type, because &ldquo;task&rdquo; is one of the language-defined classes of types (see <a href="../AA-3/AA-3.2">3.2</a>). However, the class-wide type associated with an interface is <em>not</em> an interface type, as &ldquo;interface&rdquo; is <em>not</em> one of the language-defined classes (as it is not closed under derivation). In this sense, &ldquo;interface&rdquo; is similar to &ldquo;abstract&rdquo;. The class-wide type associated with an interface is a concrete (nonabstract) indefinite tagged composite type.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>6.c/2</MarginText>
<Admonition type="aarm" aarm="note">
&ldquo;Private extension&rdquo; includes generic formal private extensions, as explained in <a href="../AA-12/AA-12.5#Subclause_12.5.1">12.5.1</a>. <br /></Admonition>
</AnnotatedOnly>

<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>A task interface is an [abstract] task type. A protected interface is an [abstract] protected type. <br /></p>

<AnnotatedOnly>
<MarginText>7.a/2</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>The &ldquo;abstract&rdquo; follows from the definition of an interface type. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>7.b/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This ensures that task operations (like abort and the Terminated attribute) can be applied to a task interface type and the associated class-wide type. While there are no protected type operations, we apply the same rule to protected interfaces for consistency. <br /></Admonition>
</AnnotatedOnly>

<MarginText>8/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<p>[An interface type has no components.] <br /></p>

<AnnotatedOnly>
<MarginText>8.a/2</MarginText>
<Admonition type="aarm" aarm="proof">
<strong></strong>This follows from the syntax and the fact that discriminants are not allowed for interface types. <br /></Admonition>
</AnnotatedOnly>

<MarginText>9/2</MarginText>
<MarginInfo items={["AI95-00419-01"]} />
<p>An <em>interface_</em><code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> in an <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code> names a <em>progenitor subtype</em>; its type is the <em>progenitor type</em>. An interface type inherits user-defined primitive subprograms from each progenitor type in the same way that a derived type inherits user-defined primitive subprograms from its progenitor types (see <a href="../AA-3/AA-3.4">3.4</a>). <br /></p>

<AnnotatedOnly>
<MarginText>9.a/5</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Term entry: </strong><strong>progenitor</strong> &mdash; type given in the interface list, if any, of an interface, task, protected, or derived type definition<br /><br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>10/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<p>All user-defined primitive subprograms of an interface type shall be abstract subprograms or null procedures.<br /></p>

<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<p>The type of a subtype named in an <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code> shall be an interface type.<br /></p>

<MarginText>12/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />
<p>A type derived from a nonlimited interface shall be nonlimited.<br /></p>

<MarginText>13/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>An interface derived from a task interface shall include the reserved word <strong>task</strong> in its definition; any other type derived from a task interface shall be a private extension or a task type declared by a task declaration (see <a href="../AA-9/AA-9.1">9.1</a>).<br /></p>

<MarginText>14/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>An interface derived from a protected interface shall include the reserved word <strong>protected</strong> in its definition; any other type derived from a protected interface shall be a private extension or a protected type declared by a protected declaration (see <a href="../AA-9/AA-9.4">9.4</a>).<br /></p>

<MarginText>15/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>An interface derived from a synchronized interface shall include one of the reserved words <strong>task</strong>, <strong>protected</strong>, or <strong>synchronized</strong> in its definition; any other type derived from a synchronized interface shall be a private extension, a task type declared by a task declaration, or a protected type declared by a protected declaration.<br /></p>

<AnnotatedOnly>
<MarginText>15.a/2</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>We require that an interface descendant of a task, protected, or synchronized interface repeat the explicit kind of interface it will be, rather than simply inheriting it, so that a reader is always aware of whether the interface provides synchronization and whether it may be implemented only by a task or protected type. The only place where inheritance of the kind of interface might be useful would be in a generic if you didn't know the kind of the actual interface. However, the value of that is low because you cannot implement an interface properly if you don't know whether it is a task, protected, or synchronized interface. Hence, we require the kind of the actual interface to match the kind of the formal interface (see <a href="../AA-12/AA-12.5#Subclause_12.5.5">12.5.5</a>). <br /></Admonition>
</AnnotatedOnly>

<MarginText>16/2</MarginText>
<MarginInfo items={["AI95-00345-01"]} />
<p>No type shall be derived from both a task interface and a protected interface.<br /></p>

<AnnotatedOnly>
<MarginText>16.a</MarginText>
<Admonition type="aarm" aarm="reason">
<strong></strong>This prevents a single private extension from inheriting from both a task and a protected interface. For a private type, there can be no legal completion. For a generic formal derived type, there can be no possible matching type (so no instantiation could be legal). This rule provides early detection of the errors. <br /></Admonition>
</AnnotatedOnly>

<MarginText>17/2</MarginText>
<MarginInfo items={["AI95-00251-01"]} />
<p>In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), these rules apply also in the private part of an instance of a generic unit. <br /></p>

<AnnotatedOnly>
<MarginText>17.a/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<Admonition type="aarm" aarm="ramification">
<strong></strong>This paragraph is intended to apply to all of the Legality Rules in this subclause. We cannot allow interface types which do not obey these rules, anywhere. Luckily, deriving from a formal type (which might be an interface) is not allowed for any tagged types in a generic body. So checking in the private part of a generic covers all of the cases. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>18/3</MarginText>
<MarginInfo items={["AI95-00251-01", "AI05-0070-1"]} />
<p>The elaboration of an <code><a href="../AA-3/AA-3.9#S0077">interface_type_definition</a></code> creates the interface type and its first subtype. <br /></p>

<AnnotatedOnly>
<MarginText>18.a/3</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>There is no other effect. An <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code> is made up of <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>s, which do not need to be elaborated, so the <code><a href="../AA-3/AA-3.9#S0078">interface_list</a></code> does not either. This is consistent with the handling of <code><a href="../AA-3/AA-3.7#S0059">discriminant_part</a></code>s. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>19/5</MarginText>
<MarginInfo items={["AI95-00411-01", "AI12-0440-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   Nonlimited interface types have predefined nonabstract equality operators. These can  be overridden with user-defined abstract equality operators. Such operators will then require an explicit overriding for any nonabstract descendant of the interface. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>20/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
<p><em>Example of a limited interface and a synchronized interface extending it:</em><br /></p>

<MarginText>21/2</MarginText>
<CodeBlock language="ada">
type Queue is limited interface;{"\n"}procedure Append(Q : in out Queue; Person : in Person_Name) is abstract;{"\n"}procedure Remove_First(Q      : in out Queue;{"\n"}                       Person :    out Person_Name) is abstract;{"\n"}function Cur_Count(Q : in Queue) return Natural is abstract;{"\n"}function Max_Count(Q : in Queue) return Natural is abstract;{"\n"}-- See <a href="../AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a> for Person_Name.{"\n"}
<MarginText>22/3</MarginText>
<MarginInfo items={["AI05-0004-1"]} />
Queue_Error : exception;{"\n"}-- Append raises Queue_Error if Cur_Count(Q) = Max_Count(Q){"\n"}-- Remove_First raises Queue_Error if Cur_Count(Q) = 0{"\n"}
<MarginText>23/2</MarginText>
type Synchronized_Queue is{"\n"}                      synchronized interface and Queue; -- see <a href="../AA-9/AA-9.11">9.11</a>{"\n"}procedure Append_Wait(Q      : in out Synchronized_Queue;{"\n"}                      Person : in     Person_Name) is abstract;{"\n"}procedure Remove_First_Wait(Q      : in out Synchronized_Queue;{"\n"}                            Person :    out Person_Name) is abstract;{"\n"}
<MarginText>24/2</MarginText>
...{"\n"}
<MarginText>25/2</MarginText>
procedure Transfer(From   : in out Queue'Class;{"\n"}                   To     : in out Queue'Class;{"\n"}                   Number : in     Natural := 1) is{"\n"}   Person : Person_Name;{"\n"}begin{"\n"}   for I in 1..Number loop{"\n"}      Remove_First(From, Person);{"\n"}      Append(To, Person);{"\n"}   end loop;{"\n"}end Transfer;{"\n"}

</CodeBlock>
<MarginText>26/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<p>This defines a Queue interface defining a queue of people. (A similar design is possible  to define any kind of queue simply by replacing Person_Name by an appropriate type.) The Queue interface has four dispatching operations, Append, Remove_First, Cur_Count, and Max_Count. The body of a class-wide operation, Transfer is also shown. Every nonabstract extension of Queue will  provide implementations for at least its four dispatching operations, as they are abstract. Any object of a type derived from Queue can  be passed to Transfer as either the From or the To operand. The two operands can be of different types in a  given call.<br /></p>

<MarginText>27/5</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<p>The Synchronized_Queue interface inherits the four dispatching operations from Queue and adds two additional dispatching operations, which wait if necessary rather than raising the Queue_Error exception. This synchronized interface can  only be implemented by a task or protected type, and as such ensures safe concurrent access.<br /></p>

<MarginText>28/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
<p><em>Example use of the interface:</em><br /></p>

<MarginText>29/3</MarginText>
<MarginInfo items={["AI05-0004-1"]} />
<CodeBlock language="ada">
type Fast_Food_Queue is new Queue with record ...;{"\n"}procedure Append(Q : in out Fast_Food_Queue; Person : in Person_Name);{"\n"}procedure Remove_First(Q : in out Fast_Food_Queue; {"\n"}                       Person : out Person_Name);{"\n"}function Cur_Count(Q : in Fast_Food_Queue) return Natural;{"\n"}function Max_Count(Q : in Fast_Food_Queue) return Natural;{"\n"}
<MarginText>30/2</MarginText>
...{"\n"}
<MarginText>31/2</MarginText>
Cashier, Counter : Fast_Food_Queue;{"\n"}
<MarginText>32/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
...{"\n"}-- Add Casey  (see <a href="../AA-3/AA-3.10#Subclause_3.10.1">3.10.1</a>) to the cashier's queue:{"\n"}Append (Cashier, Casey );{"\n"}-- After payment, move Casey  to the sandwich counter queue:{"\n"}Transfer (Cashier, Counter);{"\n"}...{"\n"}

</CodeBlock>
<MarginText>33/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<p>An interface such as Queue can be used directly as the parent of a new type (as shown here), or can be used as a progenitor when a type is derived. In either case, the primitive operations of the interface are inherited. For Queue, the implementation of the four inherited routines will necessarily  be provided. Inside the call of Transfer, calls will dispatch to the implementations of Append and Remove_First for type Fast_Food_Queue.<br /></p>

<MarginText>34/2</MarginText>
<MarginInfo items={["AI95-00433-01"]} />
<p><em>Example of a task interface:</em><br /></p>

<MarginText>35/2</MarginText>
<CodeBlock language="ada">
type Serial_Device is task interface;  -- see <a href="../AA-9/AA-9.1">9.1</a>{"\n"}procedure Read (Dev : in Serial_Device; C : out Character) is abstract;{"\n"}procedure Write(Dev : in Serial_Device; C : in  Character) is abstract;{"\n"}

</CodeBlock>
<MarginText>36/2</MarginText>
<p>The Serial_Device interface has two dispatching operations which are intended to be implemented by task entries (see 9.1).<br /></p>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>36.a/2</MarginText>
<MarginInfo items={["AI95-00251-01", "AI95-00345-01"]} />
<Admonition type="aarm" aarm="note">
Interface types are new. They provide multiple inheritance of interfaces, similar to the facility provided in Java and other recent language designs. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>36.b/3</MarginText>
<MarginInfo items={["AI05-0070-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Corrected the definition of elaboration for an <code><a href="../AA-3/AA-3.9#S0077">interface_type_definition</a></code> to match that of other type definitions. <br /></Admonition>
</AnnotatedOnly>

