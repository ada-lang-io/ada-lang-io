---
sidebar_position:  143
---

# B.3 Interfacing with C and C++

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1/4</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00376-01", "AI05-0229-1", "AI12-0028-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The facilities relevant to interfacing with the C language and the corresponding subset of the C++ language are the package Interfaces.C and its children, and support for specifying the Convention aspect with <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s C, C{"_"}Pass{"_"}By{"_"}Copy, and any of the C{"_"}Variadic{"_"}<em>n</em> conventions described below.<br /></p>

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00376-01", "AI95-0262-1", "AI95-0299-1"]} />
<p>The package Interfaces.C contains the basic types, constants, and subprograms that allow an Ada program to pass scalars and strings to C and C++ functions. When this subclause mentions a C entity, the reference also applies to the corresponding entity in C++. <br /></p>


#### Static Semantics

<MarginText>3</MarginText>
<p>The library package Interfaces.C has the following declaration: <br /></p>

<MarginText>4/5</MarginText>
<MarginInfo items={["AI12-0414-1"]} />
<CodeBlock language="ada">
package Interfaces.C{"\n"}   with Pure is{"\n"}
<MarginText>5</MarginText>
   -- Declarations based on C's {"<"}limits.h{">"}{"\n"}
<MarginText>6</MarginText>
   CHAR{"_"}BIT  : constant := implementation-defined;  -- typically 8{"\n"}   SCHAR{"_"}MIN : constant := implementation-defined;  -- typically &ndash;128{"\n"}   SCHAR{"_"}MAX : constant := implementation-defined;  -- typically 127{"\n"}   UCHAR{"_"}MAX : constant := implementation-defined;  -- typically 255{"\n"}
<MarginText>7</MarginText>
   -- Signed and Unsigned Integers{"\n"}   type int   is range implementation-defined;{"\n"}   type short is range implementation-defined;{"\n"}   type long  is range implementation-defined;{"\n"}
<MarginText>8</MarginText>
   type signed{"_"}char is range SCHAR{"_"}MIN .. SCHAR{"_"}MAX;{"\n"}   for signed{"_"}char'Size use CHAR{"_"}BIT;{"\n"}
<MarginText>9</MarginText>
   type unsigned       is mod implementation-defined;{"\n"}   type unsigned{"_"}short is mod implementation-defined;{"\n"}   type unsigned{"_"}long  is mod implementation-defined;{"\n"}
<MarginText>10</MarginText>
   type unsigned{"_"}char is mod (UCHAR{"_"}MAX+1);{"\n"}   for unsigned{"_"}char'Size use CHAR{"_"}BIT;{"\n"}
<MarginText>11</MarginText>
   subtype plain{"_"}char is implementation-defined;{"\n"}
<MarginText>12</MarginText>
   type ptrdiff{"_"}t is range implementation-defined;{"\n"}
<MarginText>13</MarginText>
   type size{"_"}t is mod implementation-defined;{"\n"}
<MarginText>13.1/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
   -- Boolean Type{"\n"}   type C{"_"}bool is new Boolean;{"\n"}
<MarginText>14</MarginText>
   -- Floating Point{"\n"}
<MarginText>15</MarginText>
   type C{"_"}float     is digits implementation-defined;{"\n"}
<MarginText>16</MarginText>
   type double      is digits implementation-defined;{"\n"}
<MarginText>17</MarginText>
   type long{"_"}double is digits implementation-defined;{"\n"}
<MarginText>18</MarginText>
   -- Characters and Strings {"\n"}
<MarginText>19</MarginText>
   type char is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>20/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    nul : constant char := implementation-defined;{"\n"}
<MarginText>21</MarginText>
   function To{"_"}C   (Item : in Character) return char;{"\n"}
<MarginText>22</MarginText>
   function To{"_"}Ada (Item : in char) return Character;{"\n"}
<MarginText>23/3</MarginText>
<MarginInfo items={["AI05-0229-1", "AI05-0269-1"]} />
   type char{"_"}array is array (size{"_"}t range {"<"}{">"}) of aliased char{"\n"}      with Pack;{"\n"}   for char{"_"}array'Component{"_"}Size use CHAR{"_"}BIT;{"\n"}
<MarginText>24</MarginText>
   function Is{"_"}Nul{"_"}Terminated (Item : in char{"_"}array) return Boolean;{"\n"}
<MarginText>25</MarginText>
   function To{"_"}C   (Item       : in String;{"\n"}                    Append{"_"}Nul : in Boolean := True){"\n"}      return char{"_"}array;{"\n"}
<MarginText>26</MarginText>
   function To{"_"}Ada (Item     : in char{"_"}array;{"\n"}                    Trim{"_"}Nul : in Boolean := True){"\n"}      return String;{"\n"}
<MarginText>27</MarginText>
   procedure To{"_"}C (Item       : in  String;{"\n"}                   Target     : out char{"_"}array;{"\n"}                   Count      : out size{"_"}t;{"\n"}                   Append{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>28</MarginText>
   procedure To{"_"}Ada (Item     : in  char{"_"}array;{"\n"}                     Target   : out String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>29</MarginText>
   -- Wide Character and Wide String{"\n"}
<MarginText>30/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    type wchar{"_"}t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>31/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    wide{"_"}nul : constant wchar{"_"}t := implementation-defined;{"\n"}
<MarginText>32</MarginText>
   function To{"_"}C   (Item : in Wide{"_"}Character) return wchar{"_"}t;{"\n"}   function To{"_"}Ada (Item : in wchar{"_"}t       ) return Wide{"_"}Character;{"\n"}
<MarginText>33/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type wchar{"_"}array is array (size{"_"}t range {"<"}{">"}) of aliased wchar{"_"}t{"\n"}      with Pack;{"\n"}
<MarginText>34/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>35</MarginText>
   function Is{"_"}Nul{"_"}Terminated (Item : in wchar{"_"}array) return Boolean;{"\n"}
<MarginText>36</MarginText>
   function To{"_"}C   (Item       : in Wide{"_"}String;{"\n"}                    Append{"_"}Nul : in Boolean := True){"\n"}      return wchar{"_"}array;{"\n"}
<MarginText>37</MarginText>
   function To{"_"}Ada (Item     : in wchar{"_"}array;{"\n"}                    Trim{"_"}Nul : in Boolean := True){"\n"}      return Wide{"_"}String;{"\n"}
<MarginText>38</MarginText>
   procedure To{"_"}C (Item       : in  Wide{"_"}String;{"\n"}                   Target     : out wchar{"_"}array;{"\n"}                   Count      : out size{"_"}t;{"\n"}                   Append{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>39</MarginText>
   procedure To{"_"}Ada (Item     : in  wchar{"_"}array;{"\n"}                     Target   : out Wide{"_"}String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>39.1/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0450-1"]} />
   -- ISO/IEC 10646 compatible types.{"\n"}
<MarginText>39.2/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
   type char16{"_"}t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>39.3/2</MarginText>
   char16{"_"}nul : constant char16{"_"}t := implementation-defined;{"\n"}
<MarginText>39.4/2</MarginText>
   function To{"_"}C (Item : in Wide{"_"}Character) return char16{"_"}t;{"\n"}   function To{"_"}Ada (Item : in char16{"_"}t) return Wide{"_"}Character;{"\n"}
<MarginText>39.5/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type char16{"_"}array is array (size{"_"}t range {"<"}{">"}) of aliased char16{"_"}t{"\n"}      with Pack;{"\n"}
<MarginText>39.6/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>39.7/2</MarginText>
   function Is{"_"}Nul{"_"}Terminated (Item : in char16{"_"}array) return Boolean;{"\n"}   function To{"_"}C (Item       : in Wide{"_"}String;{"\n"}                  Append{"_"}Nul : in Boolean := True){"\n"}      return char16{"_"}array;{"\n"}
<MarginText>39.8/2</MarginText>
   function To{"_"}Ada (Item     : in char16{"_"}array;{"\n"}                    Trim{"_"}Nul : in Boolean := True){"\n"}      return Wide{"_"}String;{"\n"}
<MarginText>39.9/2</MarginText>
   procedure To{"_"}C (Item       : in  Wide{"_"}String;{"\n"}                   Target     : out char16{"_"}array;{"\n"}                   Count      : out size{"_"}t;{"\n"}                   Append{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>39.10/2</MarginText>
   procedure To{"_"}Ada (Item     : in  char16{"_"}array;{"\n"}                     Target   : out Wide{"_"}String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>39.11/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
   type char32{"_"}t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>39.12/2</MarginText>
   char32{"_"}nul : constant char32{"_"}t := implementation-defined;{"\n"}
<MarginText>39.13/2</MarginText>
   function To{"_"}C (Item : in Wide{"_"}Wide{"_"}Character) return char32{"_"}t;{"\n"}   function To{"_"}Ada (Item : in char32{"_"}t) return Wide{"_"}Wide{"_"}Character;{"\n"}
<MarginText>39.14/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type char32{"_"}array is array (size{"_"}t range {"<"}{">"}) of aliased char32{"_"}t{"\n"}      with Pack;{"\n"}
<MarginText>39.15/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>39.16/2</MarginText>
   function Is{"_"}Nul{"_"}Terminated (Item : in char32{"_"}array) return Boolean;{"\n"}   function To{"_"}C (Item       : in Wide{"_"}Wide{"_"}String;{"\n"}                  Append{"_"}Nul : in Boolean := True){"\n"}      return char32{"_"}array;{"\n"}
<MarginText>39.17/2</MarginText>
   function To{"_"}Ada (Item     : in char32{"_"}array;{"\n"}                    Trim{"_"}Nul : in Boolean := True){"\n"}      return Wide{"_"}Wide{"_"}String;{"\n"}
<MarginText>39.18/2</MarginText>
   procedure To{"_"}C (Item       : in  Wide{"_"}Wide{"_"}String;{"\n"}                   Target     : out char32{"_"}array;{"\n"}                   Count      : out size{"_"}t;{"\n"}                   Append{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>39.19/2</MarginText>
   procedure To{"_"}Ada (Item     : in  char32{"_"}array;{"\n"}                     Target   : out Wide{"_"}Wide{"_"}String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim{"_"}Nul : in  Boolean := True);{"\n"}
<MarginText>40</MarginText>
   Terminator{"_"}Error : exception;{"\n"}
<MarginText>41</MarginText>
end Interfaces.C;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>41.a.1/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The definitions of certain types and constants in Interfaces.C.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>42</MarginText>
<p>Each of the types declared in Interfaces.C is C-compatible.<br /></p>

<MarginText>43/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0411-1"]} />
<p>The types int, short, long, unsigned, ptrdiff{"_"}t, size{"_"}t, double, char, wchar{"_"}t, char16{"_"}t, and char32{"_"}t correspond respectively to the C types having the same names. The types signed{"_"}char, unsigned{"_"}short, unsigned{"_"}long, unsigned{"_"}char, C{"_"}bool, C{"_"}float, and long{"_"}double correspond respectively to the C types signed char, unsigned short, unsigned long, unsigned char, bool,  float, and long double.<br /></p>

<AnnotatedOnly>
<MarginText>43.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The C types wchar{"_"}t and char16{"_"}t seem to be the same. However, wchar{"_"}t has an implementation-defined size, whereas char16{"_"}t is guaranteed to be an unsigned type of at least 16 bits. Also, char16{"_"}t and char32{"_"}t are encouraged to have UTF-16 and UTF-32 representations; that means that they are not directly the same as the Ada types, which most likely don't use any UTF encoding. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>44</MarginText>
<p>The type of the subtype plain{"_"}char is either signed{"_"}char or unsigned{"_"}char, depending on the C implementation. <br /></p>

<MarginText>45</MarginText>
<CodeBlock language="ada">
function To{"_"}C   (Item : in Character) return char;{"\n"}function To{"_"}Ada (Item : in char     ) return Character;{"\n"}

</CodeBlock>
<MarginText>46</MarginText>
<p class="Indented4">The functions To{"_"}C and To{"_"}Ada map between the Ada type Character and the C type char.<br /></p>

<AnnotatedOnly>
<MarginText>46.a.1/1</MarginText>
<MarginInfo items={["AI95-00038-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>{"{"}<em>8652/0114</em>{"}"} The To{"_"}C and To{"_"}Ada functions map between corresponding characters, not necessarily between characters with the same internal representation. Corresponding characters are characters defined by the same enumeration literal, if such exist; otherwise, the correspondence is unspecified.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.2/1</MarginText>
<Admonition type="aarm" aarm="note">
The following definition is equivalent to the above summary:<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.3/1</MarginText>
<Admonition type="aarm" aarm="note">
To{"_"}C (Latin{"_"}1{"_"}Char) = char'Value(Character'Image(Latin{"_"}1{"_"}Char))<br />provided that char'Value does not raise an exception; otherwise the result is unspecified.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.4/1</MarginText>
<Admonition type="aarm" aarm="note">
To{"_"}Ada (Native{"_"}C{"_"}Char) = Character'Value(char'Image(Native{"_"}C{"_"}Char))<br />provided that Character'Value does not raise an exception; otherwise the result is unspecified. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>47</MarginText>
<CodeBlock language="ada">
function Is{"_"}Nul{"_"}Terminated (Item : in char{"_"}array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>48</MarginText>
<p class="Indented4">The result of Is{"_"}Nul{"_"}Terminated is True if Item contains nul, and is False otherwise.<br /></p>

<MarginText>49</MarginText>
<CodeBlock language="ada">
function To{"_"}C   (Item : in String;     Append{"_"}Nul : in Boolean := True){"\n"}   return char{"_"}array;{"\n"}{"\n"}function To{"_"}Ada (Item : in char{"_"}array; Trim{"_"}Nul   : in Boolean := True){"\n"}   return String;{"\n"}

</CodeBlock>
<MarginText>50/2</MarginText>
<MarginInfo items={["AI95-00258-01"]} />
<p class="Indented4">The result of To{"_"}C is a char{"_"}array value of length Item'Length (if Append{"_"}Nul is False) or Item'Length+1 (if Append{"_"}Nul is True). The lower bound is 0. For each component Item(I), the corresponding component in the result is To{"_"}C applied to Item(I). The value nul is appended if Append{"_"}Nul is True. If Append{"_"}Nul is False and Item'Length is 0, then To{"_"}C propagates Constraint{"_"}Error.<br /></p>

<MarginText>51</MarginText>
<p class="Indented4">The result of To{"_"}Ada is a String whose length is Item'Length (if Trim{"_"}Nul is False) or the length of the slice of Item preceding the first nul (if Trim{"_"}Nul is True). The lower bound of the result is 1. If Trim{"_"}Nul is False, then for each component Item(I) the corresponding component in the result is To{"_"}Ada applied to Item(I). If Trim{"_"}Nul is True, then for each component Item(I) before the first nul the corresponding component in the result is To{"_"}Ada applied to Item(I). The function propagates Terminator{"_"}Error if Trim{"_"}Nul is True and Item does not contain nul.<br /></p>

<MarginText>52</MarginText>
<CodeBlock language="ada">
procedure To{"_"}C (Item       : in  String;{"\n"}                Target     : out char{"_"}array;{"\n"}                Count      : out size{"_"}t;{"\n"}                Append{"_"}Nul : in  Boolean := True);{"\n"}{"\n"}procedure To{"_"}Ada (Item     : in  char{"_"}array;{"\n"}                  Target   : out String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim{"_"}Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>53</MarginText>
<p class="Indented4">For procedure To{"_"}C, each element of Item is converted (via the To{"_"}C function) to a char, which is assigned to the corresponding element of Target. If Append{"_"}Nul is True, nul is then assigned to the next element of Target. In either case, Count is set to the number of Target elements assigned. If Target is not long enough, Constraint{"_"}Error is propagated.<br /></p>

<MarginText>54</MarginText>
<p class="Indented4">For procedure To{"_"}Ada, each element of Item (if Trim{"_"}Nul is False) or each element of Item preceding the first nul (if Trim{"_"}Nul is True) is converted (via the To{"_"}Ada function) to a Character, which is assigned to the corresponding element of Target. Count is set to the number of Target elements assigned. If Target is not long enough, Constraint{"_"}Error is propagated. If Trim{"_"}Nul is True and Item does not contain nul, then Terminator{"_"}Error is propagated.<br /></p>

<MarginText>55</MarginText>
<CodeBlock language="ada">
function Is{"_"}Nul{"_"}Terminated (Item : in wchar{"_"}array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>56</MarginText>
<p class="Indented4">The result of Is{"_"}Nul{"_"}Terminated is True if Item contains wide{"_"}nul, and is False otherwise.<br /></p>

<MarginText>57</MarginText>
<CodeBlock language="ada">
function To{"_"}C   (Item : in Wide{"_"}Character) return wchar{"_"}t;{"\n"}function To{"_"}Ada (Item : in wchar{"_"}t       ) return Wide{"_"}Character;{"\n"}

</CodeBlock>
<MarginText>58</MarginText>
<p class="Indented4">To{"_"}C and To{"_"}Ada provide the mappings between the Ada and C wide character types.<br /></p>

<MarginText>59</MarginText>
<CodeBlock language="ada">
function To{"_"}C   (Item       : in Wide{"_"}String;{"\n"}                 Append{"_"}Nul : in Boolean := True){"\n"}   return wchar{"_"}array;{"\n"}{"\n"}function To{"_"}Ada (Item     : in wchar{"_"}array;{"\n"}                 Trim{"_"}Nul : in Boolean := True){"\n"}   return Wide{"_"}String;{"\n"}{"\n"}procedure To{"_"}C (Item       : in  Wide{"_"}String;{"\n"}                Target     : out wchar{"_"}array;{"\n"}                Count      : out size{"_"}t;{"\n"}                Append{"_"}Nul : in  Boolean := True);{"\n"}{"\n"}procedure To{"_"}Ada (Item     : in  wchar{"_"}array;{"\n"}                  Target   : out Wide{"_"}String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim{"_"}Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60</MarginText>
<p class="Indented4">The To{"_"}C and To{"_"}Ada subprograms that convert between Wide{"_"}String and wchar{"_"}array have analogous effects to the To{"_"}C and To{"_"}Ada subprograms that convert between String and char{"_"}array, except that wide{"_"}nul is used instead of nul.<br /></p>

<MarginText>60.1/2</MarginText>
<CodeBlock language="ada">
function Is{"_"}Nul{"_"}Terminated (Item : in char16{"_"}array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>60.2/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p class="Indented4">The result of Is{"_"}Nul{"_"}Terminated is True if Item contains char16{"_"}nul, and is False otherwise.<br /></p>

<MarginText>60.3/2</MarginText>
<CodeBlock language="ada">
function To{"_"}C (Item : in Wide{"_"}Character) return char16{"_"}t;{"\n"}function To{"_"}Ada (Item : in char16{"_"}t ) return Wide{"_"}Character;{"\n"}

</CodeBlock>
<MarginText>60.4/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p class="Indented4">To{"_"}C and To{"_"}Ada provide mappings between the Ada and C 16-bit character types.<br /></p>

<MarginText>60.5/2</MarginText>
<CodeBlock language="ada">
function To{"_"}C (Item       : in Wide{"_"}String;{"\n"}               Append{"_"}Nul : in Boolean := True){"\n"}   return char16{"_"}array;{"\n"}{"\n"}function To{"_"}Ada (Item     : in char16{"_"}array;{"\n"}                 Trim{"_"}Nul : in Boolean := True){"\n"}   return Wide{"_"}String;{"\n"}{"\n"}procedure To{"_"}C (Item       : in  Wide{"_"}String;{"\n"}                Target     : out char16{"_"}array;{"\n"}                Count      : out size{"_"}t;{"\n"}                Append{"_"}Nul : in  Boolean := True);{"\n"}{"\n"}procedure To{"_"}Ada (Item     : in  char16{"_"}array;{"\n"}                  Target   : out Wide{"_"}String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim{"_"}Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60.6/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p class="Indented4">The To{"_"}C and To{"_"}Ada subprograms that convert between Wide{"_"}String and char16{"_"}array have analogous effects to the To{"_"}C and To{"_"}Ada subprograms that convert between String and char{"_"}array, except that char16{"_"}nul is used instead of nul.<br /></p>

<MarginText>60.7/2</MarginText>
<CodeBlock language="ada">
function Is{"_"}Nul{"_"}Terminated (Item : in char32{"_"}array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>60.8/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0437-1"]} />
<p class="Indented4">The result of Is{"_"}Nul{"_"}Terminated is True if Item contains char32{"_"}nul, and is False otherwise.<br /></p>

<MarginText>60.9/2</MarginText>
<CodeBlock language="ada">
function To{"_"}C (Item : in Wide{"_"}Wide{"_"}Character) return char32{"_"}t;{"\n"}function To{"_"}Ada (Item : in char32{"_"}t ) return Wide{"_"}Wide{"_"}Character;{"\n"}

</CodeBlock>
<MarginText>60.10/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p class="Indented4">To{"_"}C and To{"_"}Ada provide mappings between the Ada and C 32-bit character types.<br /></p>

<MarginText>60.11/2</MarginText>
<CodeBlock language="ada">
function To{"_"}C (Item       : in Wide{"_"}Wide{"_"}String;{"\n"}               Append{"_"}Nul : in Boolean := True){"\n"}   return char32{"_"}array;{"\n"}{"\n"}function To{"_"}Ada (Item     : in char32{"_"}array;{"\n"}                 Trim{"_"}Nul : in Boolean := True){"\n"}   return Wide{"_"}Wide{"_"}String;{"\n"}{"\n"}procedure To{"_"}C (Item       : in  Wide{"_"}Wide{"_"}String;{"\n"}                Target     : out char32{"_"}array;{"\n"}                Count      : out size{"_"}t;{"\n"}                Append{"_"}Nul : in  Boolean := True);{"\n"}{"\n"}procedure To{"_"}Ada (Item     : in  char32{"_"}array;{"\n"}                  Target   : out Wide{"_"}Wide{"_"}String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim{"_"}Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60.12/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p class="Indented4">The To{"_"}C and To{"_"}Ada subprograms that convert between Wide{"_"}Wide{"_"}String and char32{"_"}array have analogous effects to the To{"_"}C and To{"_"}Ada subprograms that convert between String and char{"_"}array, except that char32{"_"}nul is used instead of nul.<br /></p>

<AnnotatedOnly>
<MarginText>60.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The Interfaces.C package provides an implementation-defined character type, char, designed to model the C run-time character set, and mappings between the types char and Character.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.b</MarginText>
<Admonition type="aarm" aarm="note">
One application of the C interface package is to compose a C string and pass it to a C function. One way to do this is for the programmer to declare an object that will hold the C array, and then pass this array to the C function. This is realized via the type char{"_"}array: <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.c</MarginText>
<CodeBlock language="ada">
type char{"_"}array is array (size{"_"}t range {"<"}{">"}) of Char;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.d</MarginText>
<Admonition type="aarm" aarm="note">
The programmer can declare an Ada String, convert it to a char{"_"}array, and pass the char{"_"}array as actual parameter to the C function that is expecting a char {"*"}.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.e</MarginText>
<Admonition type="aarm" aarm="note">
An alternative approach is for the programmer to obtain a C char pointer from an Ada String (or from a char{"_"}array) by invoking an allocation function. The package Interfaces.C.Strings (see below) supplies the needed facilities, including a private type chars{"_"}ptr that corresponds to C's char {"*"}, and two allocation functions. To avoid storage leakage, a Free procedure releases the storage that was allocated by one of these allocate functions.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.f</MarginText>
<Admonition type="aarm" aarm="note">
It is typical for a C function that deals with strings to adopt the convention that the string is delimited by a nul char. The C interface packages support this convention. A constant nul of type Char is declared, and the function Value(Chars{"_"}Ptr) in Interfaces.C.Strings returns a char{"_"}array up to and including the first nul in the array that the chars{"_"}ptr points to. The Allocate{"_"}Chars function allocates an array that is nul terminated.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.g</MarginText>
<Admonition type="aarm" aarm="note">
Some C functions that deal with strings take an explicit length as a parameter, thus allowing strings to be passed that contain nul as a data element. Other C functions take an explicit length that is an upper bound: the prefix of the string up to the char before nul, or the prefix of the given length, is used by the function, whichever is shorter. The C Interface packages support calling such functions. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>60.13/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0229-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The Convention aspect with <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> C{"_"}Pass{"_"}By{"_"}Copy shall only be specified for a type.<br /></p>

<MarginText>60.14/2</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00216-01"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The eligibility rules in <a href="../AA-B/AA-B.1">B.1</a> do not apply to convention C{"_"}Pass{"_"}By{"_"}Copy. Instead, a type T is eligible for convention C{"_"}Pass{"_"}By{"_"}Copy if T is an unchecked union type or if T is a record type that has no discriminants and that only has components with statically constrained subtypes, and each component is C-compatible.<br /></p>

<MarginText>60.15/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0264-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} If a type is C{"_"}Pass{"_"}By{"_"}Copy-compatible, then it is also C-compatible.<br /></p>

<MarginText>60.16/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<p>The identifiers C{"_"}Variadic{"_"}0, C{"_"}Variadic{"_"}1, C{"_"}Variadic{"_"}2, and so on are <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s. These conventions are said to be <em>C{"_"}Variadic</em>. The convention C{"_"}Variadic{"_"}<em>n</em> is the calling convention for a variadic C function taking <em>n</em> fixed parameters and then a variable number of additional parameters. The C{"_"}Variadic{"_"}<em>n</em> convention shall only be specified as the convention aspect for a subprogram, or for an access-to-subprogram type, having at least <em>n</em> parameters. A type is compatible with a C{"_"}Variadic convention if and only if the type is C-compatible.<br /></p>

<AnnotatedOnly>
<MarginText>60.h/4</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>It is implementation defined what the largest <em>n</em> in C{"_"}Variadic{"_"}<em>n</em> is supported. We don't say this because it complicates the wording and it is true for almost any <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> (only Ada is required to be supported by the language, all others need to be documented in order for programmers to know that they are available). <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>61/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0229-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} An implementation shall support specifying aspect Convention with a C <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> for a C-eligible type (see <a href="../AA-B/AA-B.1">B.1</a>). An implementation shall support specifying aspect Convention with a C{"_"}Pass{"_"}By{"_"}Copy <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> for a C{"_"}Pass{"_"}By{"_"}Copy-eligible type. <br /></p>


#### Implementation Permissions

<MarginText>62</MarginText>
<p>An implementation may provide additional declarations in the C interface packages.<br /></p>

<MarginText>62.1/5</MarginText>
<MarginInfo items={["AI05-0002-1", "AI05-0229-1", "AI12-0444-1"]} />
<p>An implementation is not required to support specifying the Convention aspect with <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> C in the following cases:<br /></p>

<MarginText>62.2/3</MarginText>
<MarginInfo items={["AI05-0248-1"]} />
<ul>
<li>for a subprogram that has a parameter of an unconstrained array subtype, unless the Import aspect has the value True for the subprogram;<br /></li>
<MarginText>62.3/3</MarginText>
<li>for a function with an unconstrained array result subtype;<br /></li>
<MarginText>62.4/3</MarginText>
<li>for an object whose nominal subtype is an unconstrained array subtype. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>62.a/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>These rules ensure that an implementation never needs to create bounds for an unconstrained array that originates in C (and thus does not have bounds). An implementation can do so if it wishes, of course. Note that these permissions do not extend to passing an unconstrained array as a parameter to a C function; in this case, the bounds can simply be dropped and thus support is required. <br />
</Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>62.5/3</MarginText>
<MarginInfo items={["AI95-00037-01", "AI95-00285-01"]} />
<p>{"{"}<em>8652/0060</em>{"}"} The constants nul, wide{"_"}nul, char16{"_"}nul, and char32{"_"}nul should have a representation of zero. <br /></p>

<AnnotatedOnly>
<MarginText>62.b/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>The constants nul, wide{"_"}nul, char16{"_"}nul, and char32{"_"}nul in package Interfaces.C should have a representation of zero.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>63</MarginText>
<p>An implementation should support the following interface correspondences between Ada and C. <br /></p>

<MarginText>64</MarginText>
<ul>
<li>An Ada procedure corresponds to a void-returning C function. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>64.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The programmer can also choose an Ada procedure when the C function returns an int that is to be discarded.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>65</MarginText>
<ul>
<li>An Ada function corresponds to a non-void C function.<br /></li>
<MarginText>65.1/4</MarginText>
<MarginInfo items={["AI12-0135-1"]} />
<li>An Ada enumeration type corresponds to a C enumeration type with corresponding enumeration literals having the same internal codes, provided the internal codes fall within the range of the C int type.<br /></li>
<MarginText>66</MarginText>
<li>An Ada <strong>in</strong> scalar parameter is passed as a scalar argument to a C function.<br /></li>
<MarginText>67</MarginText>
<li>An Ada <strong>in</strong> parameter of an access-to-object type with designated type T is passed as a t{"*"} argument to a C function, where t is the C type corresponding to the Ada type T.<br /></li>
<MarginText>68</MarginText>
<li>An Ada <strong>access</strong> T parameter, or an Ada <strong>out</strong> or <strong>in out</strong> parameter of an elementary type T, is passed as a t{"*"} argument to a C function, where t is the C type corresponding to the Ada type T. In the case of an elementary <strong>out</strong> or <strong>in out</strong> parameter, a pointer to a temporary copy is used to preserve by-copy semantics.<br /></li>
<MarginText>68.1/2</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00343-01"]} />
<li>{"{"}<em>8652/0059</em>{"}"} An Ada parameter of a (record) type T of convention C{"_"}Pass{"_"}By{"_"}Copy, of mode <strong>in</strong>, is passed as a t argument to a C function, where t is the C struct corresponding to the Ada type T.<br /></li>
<MarginText>69/5</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00343-01", "AI12-0219-1"]} />
<li>{"{"}<em>8652/0059</em>{"}"} An Ada parameter of a record type T, other than an <strong>in</strong> parameter of a type of convention C{"_"}Pass{"_"}By{"_"}Copy, is passed as a t{"*"} argument to a C function, with the const modifier if the Ada mode is <strong>in</strong>, where t is the C struct corresponding to the Ada type T.<br /></li>
<MarginText>70/5</MarginText>
<MarginInfo items={["AI12-0219-1"]} />
<li>An Ada parameter of an array type with component type T is passed as a t{"*"} argument to a C function, with the const modifier if the Ada mode is <strong>in</strong>, where t is the C type corresponding to the Ada type T.<br /></li>
<MarginText>71</MarginText>
<li>An Ada parameter of an access-to-subprogram type is passed as a pointer to a C function whose prototype corresponds to the designated subprogram's specification.<br /></li>
<MarginText>71.1/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<li>An Ada parameter of a private type is passed as specified for the full view of the type.<br /></li>
<MarginText>71.2/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<li>The rules of correspondence given above for parameters of mode <strong>in</strong> also apply to the return object of a function.<br /></li>
</ul>
<MarginText>71.3/5</MarginText>
<MarginInfo items={["AI95-00337-01", "AI05-0002-1", "AI12-0184-1"]} />
<p>An implementation should provide unsigned{"_"}long{"_"}long and long{"_"}long as 64-bit modular and signed integer types (respectively) in package Interfaces.C if the C implementation supports unsigned long long and long long as 64-bit types.<br /></p>

<AnnotatedOnly>
<MarginText>71.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>If C interfacing is supported, the interface correspondences between Ada and C should be supported.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>71.a.1/5</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>If the C implementation supports unsigned long long and long long, unsigned{"_"}long{"_"}long and long{"_"}long should be supported.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   Values of type char{"_"}array are not implicitly terminated with nul. If a char{"_"}array is to be passed as a parameter to an imported C function requiring nul termination, it is the programmer's responsibility to obtain this effect.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>73</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   To obtain the effect of C's sizeof(item{"_"}type), where Item{"_"}Type is the corresponding Ada type, evaluate the expression: size{"_"}t(Item{"_"}Type'Size/CHAR{"_"}BIT).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>74/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>75/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   A variadic C function can correspond to several Ada subprograms, taking various specific numbers and types of parameters. <br />
</Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>76</MarginText>
<p><em>Example of using the Interfaces.C package:</em> <br /></p>

<MarginText>77/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
<CodeBlock language="ada">
--Calling the C Library Functions strcpy and printf{"\n"}with Interfaces.C;{"\n"}procedure Test is{"\n"}   package C renames Interfaces.C;{"\n"}   use type C.char{"_"}array;{"\n"}   -- Call {"<"}string.h{">"}strcpy:{"\n"}   -- C definition of strcpy:  char {"*"}strcpy(char {"*"}s1, const char {"*"}s2);{"\n"}   --    This function copies the string pointed to by s2 (including the terminating null character){"\n"}   --     into the array pointed to by s1. If copying takes place between objects that overlap,{"\n"}   --     the behavior is undefined. The strcpy function returns the value of s1.{"\n"}
<MarginText>78/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   -- {"\n"}   procedure Strcpy (Target : out C.char{"_"}array;{"\n"}                     Source : in  C.char{"_"}array){"\n"}      with Import ={">"} True, Convention ={">"} C, External{"_"}Name ={">"} "strcpy";{"\n"}
<MarginText>79/5</MarginText>
<MarginInfo items={["AI05-0229-1", "AI12-0312-1"]} />
   -- Call {"<"}sdtio.h{">"}printf:{"\n"}   -- C definition of printf:  int printf ( const char {"*"} format, ... );{"\n"}   --    This function writes the C string pointed by format to the standard output (stdout).{"\n"}   --     If format includes format specifiers (subsequences beginning with %), the additional{"\n"}   --     arguments following format are formatted and inserted in the resulting string{"\n"}   --     replacing their respective specifiers. If the number of arguments does not match{"\n"}   --     the number of format specifiers, or if the types of the arguments do not match{"\n"}   --     the corresponding format specifier, the behaviour is undefined. On success, the{"\n"}   --     printf function returns the total number of characters written to the standard output.{"\n"}   --     If a writing error occurs, a negative number is returned.{"\n"}
<MarginText>79.1/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
   -- {"\n"}   procedure Printf (Format : in C.char{"_"}array;{"\n"}                     Param1 : in C.char{"_"}array;{"\n"}                     Param2 : in C.int){"\n"}      with Import ={">"} True, Convention ={">"} C{"_"}Variadic{"_"}1, External{"_"}Name ={">"} "printf";{"\n"}
<MarginText>80</MarginText>
   Chars1 :  C.char{"_"}array(1..20);{"\n"}   Chars2 :  C.char{"_"}array(1..20);{"\n"}
<MarginText>81</MarginText>
begin{"\n"}   Chars2(1..6) := "qwert" & C.nul;{"\n"}
<MarginText>82</MarginText>
   Strcpy(Chars1, Chars2);{"\n"}
<MarginText>83</MarginText>
   -- Now Chars1(1..6) = "qwert" & C.Nul{"\n"}
<MarginText>83.1/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
   Printf("The String=%s, Length=%d", Chars1, Chars1'Length);{"\n"}
<MarginText>84</MarginText>
end Test;{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.a/3</MarginText>
<MarginInfo items={["AI95-00285-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
Types char16{"_"}t and char32{"_"}t and their related types and operations are added to Interfaces.C. If Interfaces.C is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity in Interfaces.C is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.b/2</MarginText>
<MarginInfo items={["AI95-00131-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0059</em>{"}"} <strong>Corrigendum:</strong> Convention C{"_"}Pass{"_"}By{"_"}Copy is new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.c/2</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0060</em>{"}"} <strong>Corrigendum:</strong> Clarified the intent for Nul and Wide{"_"}Nul.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.d/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
Specified that an unchecked union type (see <a href="../AA-B/AA-B.3#Subclause_B.3.3">B.3.3</a>) is eligible for convention C{"_"}Pass{"_"}By{"_"}Copy.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.e/2</MarginText>
<MarginInfo items={["AI95-00258-01"]} />
<Admonition type="aarm" aarm="note">
Specified what happens if the To{"_"}C function tries to return a null string.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.f/2</MarginText>
<MarginInfo items={["AI95-00337-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that the interface correspondences also apply to private types whose full types have the specified characteristics.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.g/2</MarginText>
<MarginInfo items={["AI95-00343-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that a type must have convention C{"_"}Pass{"_"}By{"_"}Copy in order to be passed by copy (not just a type that could have that convention).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.h/2</MarginText>
<MarginInfo items={["AI95-00376-01"]} />
<Admonition type="aarm" aarm="note">
Added wording to make it clear that these facilities can also be used with C++. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.i/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added a definition of correspondences for function results. Also added wording to make it clear that we do not expect the implementation to conjure bounds for unconstrained arrays out of thin air. These changes allow (but don't require) compilers to reject unreasonable uses of array types. Such uses probably didn't work anyway (and probably were rejected, no matter what the language definition said), so little existing code should be impacted. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.j/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
<Admonition type="aarm" aarm="note">
Added type C{"_"}bool and (implicitly) the enumeration literals True and False to the Interfaces.C package. Therefore, a use clause conflict is possible; see the introduction of <a href="../AA-A/">Annex A</a> for more on this topic. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.k/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> The <em>convention{"_"}</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s C{"_"}Variadic{"_"}0, C{"_"}Variadic{"_"}1, and so on are new. These are classified as a correction as any implementation can add such identifiers and it is important that special conventions be available for variadic functions as typical x64 conventions are different for normal and variadic C functions.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.l/4</MarginText>
<MarginInfo items={["AI12-0135-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> Defined the correspondence between an Ada enumeration type and a C enumeration type; implementations should support convention C for enumeration types. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.m/5</MarginText>
<MarginInfo items={["AI12-0184-1"]} />
<Admonition type="aarm" aarm="implementation-advice">
Added  that types be defined in Interfaces.C corresponding to long long and unsigned long long.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.n/5</MarginText>
<MarginInfo items={["AI12-0219-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added advice that const t{"*"} map to Ada <strong>in</strong> parameters and vice versa.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.o/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
<Admonition type="aarm" aarm="note">
Added advice about mapping type Boolean. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_B.3.1"></a>

## B.3.1  The Package Interfaces.C.Strings

<MarginText>1/3_B.3.1</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>The package Interfaces.C.Strings declares types and subprograms allowing an Ada program to allocate, reference, update, and free C-style strings. In particular, the private type chars{"_"}ptr corresponds to a common use of &ldquo;char {"*"}&rdquo; in C programs, and an object of this type can be passed to a subprogram to which <strong>with</strong> Import ={">"} True, Convention ={">"} C has been specified, and for which &ldquo;char {"*"}&rdquo; is the type of the argument of the C function. <br /></p>


#### Static Semantics

<MarginText>2_B.3.1</MarginText>
<p>The library package Interfaces.C.Strings has the following declaration: <br /></p>

<MarginText>3/5_B.3.1</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
package Interfaces.C.Strings {"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
<MarginText>4_B.3.1</MarginText>
   type char{"_"}array{"_"}access is access all char{"_"}array;{"\n"}
<MarginText>5/5_B.3.1</MarginText>
<MarginInfo items={["AI95-00161-01", "AI12-0399-1"]} />
   type chars{"_"}ptr is private{"\n"}      with Preelaborable{"_"}Initialization;{"\n"}
<MarginText>6/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00276-01"]} />
   type chars{"_"}ptr{"_"}array is array (size{"_"}t range {"<"}{">"}) of aliased chars{"_"}ptr;{"\n"}
<MarginText>7_B.3.1</MarginText>
   Null{"_"}Ptr : constant chars{"_"}ptr;{"\n"}
<MarginText>8_B.3.1</MarginText>
   function To{"_"}Chars{"_"}Ptr (Item      : in char{"_"}array{"_"}access;{"\n"}                          Nul{"_"}Check : in Boolean := False){"\n"}      return chars{"_"}ptr;{"\n"}
<MarginText>9_B.3.1</MarginText>
   function New{"_"}Char{"_"}Array (Chars   : in char{"_"}array) return chars{"_"}ptr;{"\n"}
<MarginText>10_B.3.1</MarginText>
   function New{"_"}String (Str : in String) return chars{"_"}ptr;{"\n"}
<MarginText>11_B.3.1</MarginText>
   procedure Free (Item : in out chars{"_"}ptr);{"\n"}
<MarginText>12_B.3.1</MarginText>
   Dereference{"_"}Error : exception;{"\n"}
<MarginText>13_B.3.1</MarginText>
   function Value (Item : in chars{"_"}ptr) return char{"_"}array;{"\n"}
<MarginText>14_B.3.1</MarginText>
   function Value (Item : in chars{"_"}ptr; Length : in size{"_"}t){"\n"}      return char{"_"}array;{"\n"}
<MarginText>15_B.3.1</MarginText>
   function Value (Item : in chars{"_"}ptr) return String;{"\n"}
<MarginText>16_B.3.1</MarginText>
   function Value (Item : in chars{"_"}ptr; Length : in size{"_"}t){"\n"}      return String;{"\n"}
<MarginText>17_B.3.1</MarginText>
   function Strlen (Item : in chars{"_"}ptr) return size{"_"}t;{"\n"}
<MarginText>18_B.3.1</MarginText>
   procedure Update (Item   : in chars{"_"}ptr;{"\n"}                     Offset : in size{"_"}t;{"\n"}                     Chars  : in char{"_"}array;{"\n"}                     Check  : in Boolean := True);{"\n"}
<MarginText>19_B.3.1</MarginText>
   procedure Update (Item   : in chars{"_"}ptr;{"\n"}                     Offset : in size{"_"}t;{"\n"}                     Str    : in String;{"\n"}                     Check  : in Boolean := True);{"\n"}
<MarginText>20_B.3.1</MarginText>
   Update{"_"}Error : exception;{"\n"}
<MarginText>21_B.3.1</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Interfaces.C.Strings;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>21.a_B.3.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The string manipulation types and subprograms appear in a child of Interfaces.C versus being there directly, since it is useful to have Interfaces.C specified as <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Pure.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b_B.3.1</MarginText>
<Admonition type="aarm" aarm="note">
Differently named functions New{"_"}String and New{"_"}Char{"_"}Array are declared, since if there were a single overloaded function a call with a string literal as actual parameter would be ambiguous. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>22_B.3.1</MarginText>
<p>The type chars{"_"}ptr is C-compatible and corresponds to the use of C's &ldquo;char {"*"}&rdquo; for a pointer to the first char in a char array terminated by nul. When an object of type chars{"_"}ptr is declared, its value is by default set to Null{"_"}Ptr, unless the object is imported (see <a href="../AA-B/AA-B.1">B.1</a>). <br /></p>

<AnnotatedOnly>
<MarginText>22.a_B.3.1</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The type char{"_"}array{"_"}access is not necessarily C-compatible, since an object of this type may carry &ldquo;dope&rdquo; information. The programmer should convert from char{"_"}array{"_"}access to chars{"_"}ptr for objects imported from, exported to, or passed to C.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>23_B.3.1</MarginText>
<CodeBlock language="ada">
function To{"_"}Chars{"_"}Ptr (Item      : in char{"_"}array{"_"}access;{"\n"}                       Nul{"_"}Check : in Boolean := False){"\n"}   return chars{"_"}ptr;{"\n"}

</CodeBlock>
<MarginText>24/3_B.3.1</MarginText>
<MarginInfo items={["AI95-00140-01", "AI05-0264-1"]} />
<p class="Indented4">{"{"}<em>8652/0061</em>{"}"} If Item is <strong>null</strong>, then To{"_"}Chars{"_"}Ptr returns Null{"_"}Ptr. If Item is not <strong>null</strong>, Nul{"_"}Check is True, and Item.<strong>all</strong> does not contain nul, then the function propagates Terminator{"_"}Error; otherwise, To{"_"}Chars{"_"}Ptr performs a pointer conversion with no allocation of memory.<br /></p>

<MarginText>25_B.3.1</MarginText>
<CodeBlock language="ada">
function New{"_"}Char{"_"}Array (Chars   : in char{"_"}array) return chars{"_"}ptr;{"\n"}

</CodeBlock>
<MarginText>26_B.3.1</MarginText>
<p class="Indented4">This function returns a pointer to an allocated object initialized to Chars(Chars'First .. Index) & nul, where <br /></p>

<MarginText>27_B.3.1</MarginText>
<ul>
<li>Index = Chars'Last if Chars does not contain nul, or<br /></li>
<MarginText>28_B.3.1</MarginText>
<li>Index is the smallest size{"_"}t value I such that Chars(I+1) = nul. <br /></li>
</ul>
<MarginText>28.1_B.3.1</MarginText>
<p class="Indented4">Storage{"_"}Error is propagated if the allocation fails.<br /></p>

<MarginText>29_B.3.1</MarginText>
<CodeBlock language="ada">
function New{"_"}String (Str : in String) return chars{"_"}ptr;{"\n"}

</CodeBlock>
<MarginText>30_B.3.1</MarginText>
<p class="Indented4">This function is equivalent to New{"_"}Char{"_"}Array(To{"_"}C(Str)).<br /></p>

<MarginText>31_B.3.1</MarginText>
<CodeBlock language="ada">
procedure Free (Item : in out chars{"_"}ptr);{"\n"}

</CodeBlock>
<MarginText>32_B.3.1</MarginText>
<p class="Indented4">If Item is Null{"_"}Ptr, then Free has no effect. Otherwise, Free releases the storage occupied by Value(Item), and resets Item to Null{"_"}Ptr.<br /></p>

<MarginText>33_B.3.1</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars{"_"}ptr) return char{"_"}array;{"\n"}

</CodeBlock>
<MarginText>34/3_B.3.1</MarginText>
<MarginInfo items={["AI05-0264-1"]} />
<p class="Indented4">If Item = Null{"_"}Ptr, then Value propagates Dereference{"_"}Error. Otherwise, Value returns the prefix of the array of chars pointed to by Item, up to and including the first nul. The lower bound of the result is 0. If Item does not point to a nul-terminated string, then execution of Value is erroneous.<br /></p>

<MarginText>35_B.3.1</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars{"_"}ptr; Length : in size{"_"}t){"\n"}   return char{"_"}array;{"\n"}

</CodeBlock>
<MarginText>36/3_B.3.1</MarginText>
<MarginInfo items={["AI95-00139-01", "AI05-0264-1"]} />
<p class="Indented4">{"{"}<em>8652/0062</em>{"}"} If Item = Null{"_"}Ptr, then Value propagates Dereference{"_"}Error. Otherwise, Value returns the shorter of two arrays, either the first Length chars pointed to by Item, or Value(Item). The lower bound of the result is 0. If Length is 0, then Value propagates Constraint{"_"}Error. <br /></p>

<AnnotatedOnly>
<MarginText>36.a_B.3.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Value(New{"_"}Char{"_"}Array(Chars)) = Chars if Chars does not contain nul; else Value(New{"_"}Char{"_"}Array( Chars)) is the prefix of Chars up to and including the first nul. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>37_B.3.1</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars{"_"}ptr) return String;{"\n"}

</CodeBlock>
<MarginText>38_B.3.1</MarginText>
<p class="Indented4">Equivalent to To{"_"}Ada(Value(Item), Trim{"_"}Nul={">"}True).<br /></p>

<MarginText>39_B.3.1</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars{"_"}ptr; Length : in size{"_"}t){"\n"}   return String;{"\n"}

</CodeBlock>
<MarginText>40/1_B.3.1</MarginText>
<MarginInfo items={["AI95-00177-01"]} />
<p class="Indented4">{"{"}<em>8652/0063</em>{"}"} Equivalent to To{"_"}Ada(Value(Item, Length) & nul, Trim{"_"}Nul={">"}True).<br /></p>

<MarginText>41_B.3.1</MarginText>
<CodeBlock language="ada">
function Strlen (Item : in chars{"_"}ptr) return size{"_"}t;{"\n"}

</CodeBlock>
<MarginText>42_B.3.1</MarginText>
<p class="Indented4">Returns <em>Val</em>'Length&ndash;1 where <em>Val</em> = Value(Item); propagates Dereference{"_"}Error if Item = Null{"_"}Ptr. <br /></p>

<AnnotatedOnly>
<MarginText>42.a_B.3.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Strlen returns the number of chars in the array pointed to by Item, up to and including the char immediately before the first nul.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.b_B.3.1</MarginText>
<Admonition type="aarm" aarm="note">
Strlen has the same possibility for erroneous execution as Value, in cases where the string has not been nul-terminated.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.c_B.3.1</MarginText>
<Admonition type="aarm" aarm="note">
Strlen has the effect of C's strlen function. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>43_B.3.1</MarginText>
<CodeBlock language="ada">
procedure Update (Item   : in chars{"_"}ptr;{"\n"}                  Offset : in size{"_"}t;{"\n"}                  Chars  : in char{"_"}array;{"\n"}                  Check  : Boolean := True);{"\n"}

</CodeBlock>
<MarginText>44/1_B.3.1</MarginText>
<MarginInfo items={["AI95-00039-01"]} />
<p class="Indented4">{"{"}<em>8652/0064</em>{"}"} If Item = Null{"_"}Ptr, then Update propagates Dereference{"_"}Error. Otherwise, this procedure updates the value pointed to by Item, starting at position Offset, using Chars as the data to be copied into the array. Overwriting the nul terminator, and skipping with the Offset past the nul terminator, are both prevented if Check is True, as follows: <br /></p>

<MarginText>45_B.3.1</MarginText>
<ul>
<li>Let N = Strlen(Item). If Check is True, then: <br /></li>
</ul>
<MarginText>46_B.3.1</MarginText>
<ul>
<li>If Offset+Chars'Length{">"}N, propagate Update{"_"}Error.<br /></li>
<MarginText>47_B.3.1</MarginText>
<li>Otherwise, overwrite the data in the array pointed to by Item, starting at the char at position Offset, with the data in Chars. <br /></li>
</ul>
<MarginText>48_B.3.1</MarginText>
<ul>
<li>If Check is False, then processing is as above, but with no check that Offset+Chars'Length{">"}N. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>48.a_B.3.1</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>If Chars contains nul, Update's effect may be to &ldquo;shorten&rdquo; the pointed-to char array.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>49_B.3.1</MarginText>
<CodeBlock language="ada">
procedure Update (Item   : in chars{"_"}ptr;{"\n"}                  Offset : in size{"_"}t;{"\n"}                  Str    : in String;{"\n"}                  Check  : in Boolean := True);{"\n"}

</CodeBlock>
<MarginText>50/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<p class="Indented4">Equivalent to Update(Item, Offset, To{"_"}C(Str, Append{"_"}Nul ={">"} False), Check). <br /></p>

<AnnotatedOnly>
<MarginText>50.a/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>To truncate the Item to the length of Str, use Update(Item, Offset, To{"_"}C(Str), Check) instead of Update(Item, Offset, Str, Check). Note that when truncating Item, Item must be longer than Str. <br />
</Admonition>
</AnnotatedOnly>


#### Erroneous Execution

<MarginText>51_B.3.1</MarginText>
<p>Execution of any of the following is erroneous if the Item parameter is not null{"_"}ptr and Item does not point to a nul-terminated array of chars. <br /></p>

<MarginText>52_B.3.1</MarginText>
<ul>
<li>a Value function not taking a Length parameter,<br /></li>
<MarginText>53_B.3.1</MarginText>
<li>the Free procedure,<br /></li>
<MarginText>54_B.3.1</MarginText>
<li>the Strlen function. <br /></li>
</ul>
<MarginText>55_B.3.1</MarginText>
<p>Execution of Free(X) is also erroneous if the chars{"_"}ptr X was not returned by New{"_"}Char{"_"}Array or New{"_"}String.<br /></p>

<MarginText>56_B.3.1</MarginText>
<p>Reading or updating a freed char{"_"}array is erroneous.<br /></p>

<MarginText>57_B.3.1</MarginText>
<p>Execution of Update is erroneous if Check is False and a call with Check equal to True would have propagated Update{"_"}Error. <br /></p>

<AnnotatedOnly>
<MarginText>58/5_B.3.1</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   New{"_"}Char{"_"}Array and New{"_"}String can be implemented either through the allocation function from the C environment (&ldquo;malloc&rdquo;) or through Ada dynamic memory allocation (&ldquo;new&rdquo;). The key points are <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>59/5_B.3.1</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<ul>
<li>the returned value (a chars{"_"}ptr) is represented as a C &ldquo;char {"*"}&rdquo; so that it can be passed to C functions;<br /></li>
<MarginText>60/5_B.3.1</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<li>the allocated object can be freed by the programmer via a call of Free, rather than by calling a C function. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>

#### Inconsistencies With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.a/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Update for a String parameter is now defined to not add a nul character. It did add a nul in Ada 95. This means that programs that used this behavior of Update to truncate a string will no longer work (the string will not be truncated). This change makes Update for a string consistent with Update for a char{"_"}array (no implicit nul is added to the end of a char{"_"}array). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.b/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00161-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Added <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable{"_"}Initialization to type chars{"_"}ptr, so that it can be used in preelaborated units.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.c/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00276-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> The components of chars{"_"}ptr{"_"}array are aliased so that it can be used to instantiate Interfaces.C.Pointers (that is its intended purpose, which is otherwise mysterious as it has no operations). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.d/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00140-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0061</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of To{"_"}Char{"_"}Ptr when Nul{"_"}Check is False.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.e/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00139-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0062</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of Value when the Length is 0.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.f/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00177-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0063</em>{"}"} <strong>Corrigendum:</strong> Corrected the definition of Value to avoid raising Terminator{"_"}Error.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.g/2_B.3.1</MarginText>
<MarginInfo items={["AI95-00039-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0064</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of Update when Item is Null{"_"}Ptr. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_B.3.2"></a>

## B.3.2  The Generic Package Interfaces.C.Pointers

<MarginText>1_B.3.2</MarginText>
<p>The generic package Interfaces.C.Pointers allows the Ada programmer to perform C-style operations on pointers. It includes an access type Pointer, Value functions that dereference a Pointer and deliver the designated array, several pointer arithmetic operations, and &ldquo;copy&rdquo; procedures that copy the contents of a source pointer into the array designated by a destination pointer. As in C, it treats an object Ptr of type Pointer as a pointer to the first element of an array, so that for example, adding 1 to Ptr yields a pointer to the second element of the array.<br /></p>

<MarginText>2/5_B.3.2</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<p>The generic allows two styles of usage: one in which the array is terminated by a special terminator element; and another in which the programmer keeps track of the length. <br /></p>


#### Static Semantics

<MarginText>3_B.3.2</MarginText>
<p>The generic library package Interfaces.C.Pointers has the following declaration: <br /></p>

<MarginText>4/5_B.3.2</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
generic{"\n"}   type Index is ({"<"}{">"});{"\n"}   type Element is private;{"\n"}   type Element{"_"}Array is array (Index range {"<"}{">"}) of aliased Element;{"\n"}   Default{"_"}Terminator : Element;{"\n"}package Interfaces.C.Pointers {"\n"}   with Preelaborate, Nonblocking, Global ={">"} in out synchronized is{"\n"}
<MarginText>5_B.3.2</MarginText>
   type Pointer is access all Element;{"\n"}
<MarginText>6_B.3.2</MarginText>
   function Value(Ref        : in Pointer;{"\n"}                  Terminator : in Element := Default{"_"}Terminator){"\n"}      return Element{"_"}Array;{"\n"}
<MarginText>7_B.3.2</MarginText>
   function Value(Ref    : in Pointer;{"\n"}                  Length : in ptrdiff{"_"}t){"\n"}      return Element{"_"}Array;{"\n"}
<MarginText>8_B.3.2</MarginText>
   Pointer{"_"}Error : exception;{"\n"}
<MarginText>9_B.3.2</MarginText>
   -- C-style Pointer arithmetic{"\n"}
<MarginText>10/3_B.3.2</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   function "+" (Left : in Pointer;   Right : in ptrdiff{"_"}t) return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "+" (Left : in ptrdiff{"_"}t; Right : in Pointer)   return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "-" (Left : in Pointer;   Right : in ptrdiff{"_"}t) return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff{"_"}t{"\n"}      with Convention ={">"} Intrinsic;{"\n"}
<MarginText>11/3_B.3.2</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   procedure Increment (Ref : in out Pointer){"\n"}      with Convention ={">"} Intrinsic;{"\n"}   procedure Decrement (Ref : in out Pointer){"\n"}      with Convention ={">"} Intrinsic;{"\n"}
<MarginText>12/3_B.3.2</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>13_B.3.2</MarginText>
   function Virtual{"_"}Length (Ref        : in Pointer;{"\n"}                            Terminator : in Element := Default{"_"}Terminator){"\n"}      return ptrdiff{"_"}t;{"\n"}
<MarginText>14_B.3.2</MarginText>
   procedure Copy{"_"}Terminated{"_"}Array{"\n"}      (Source     : in Pointer;{"\n"}       Target     : in Pointer;{"\n"}       Limit      : in ptrdiff{"_"}t := ptrdiff{"_"}t'Last;{"\n"}       Terminator : in Element :=  Default{"_"}Terminator);{"\n"}
<MarginText>15_B.3.2</MarginText>
   procedure Copy{"_"}Array (Source  : in Pointer;{"\n"}                         Target  : in Pointer;{"\n"}                         Length  : in ptrdiff{"_"}t);{"\n"}
<MarginText>16_B.3.2</MarginText>
end Interfaces.C.Pointers;{"\n"}

</CodeBlock>
<MarginText>17_B.3.2</MarginText>
<p>The type Pointer is C-compatible and corresponds to one use of C's &ldquo;Element {"*"}&rdquo;. An object of type Pointer is interpreted as a pointer to the initial Element in an Element{"_"}Array. Two styles are supported: <br /></p>

<MarginText>18_B.3.2</MarginText>
<ul>
<li>Explicit termination of an array value with Default{"_"}Terminator (a special terminator value);<br /></li>
<MarginText>19_B.3.2</MarginText>
<li>Programmer-managed length, with Default{"_"}Terminator treated simply as a data element. <br /></li>
</ul>
<MarginText>20_B.3.2</MarginText>
<CodeBlock language="ada">
function Value(Ref        : in Pointer;{"\n"}               Terminator : in Element := Default{"_"}Terminator){"\n"}   return Element{"_"}Array;{"\n"}

</CodeBlock>
<MarginText>21_B.3.2</MarginText>
<p class="Indented4">This function returns an Element{"_"}Array whose value is the array pointed to by Ref, up to and including the first Terminator; the lower bound of the array is Index'First. Interfaces.C.Strings.Dereference{"_"}Error is propagated if Ref is <strong>null</strong>.<br /></p>

<MarginText>22_B.3.2</MarginText>
<CodeBlock language="ada">
function Value(Ref    : in Pointer;{"\n"}               Length : in ptrdiff{"_"}t){"\n"}   return Element{"_"}Array;{"\n"}

</CodeBlock>
<MarginText>23_B.3.2</MarginText>
<p class="Indented4">This function returns an Element{"_"}Array comprising the first Length elements pointed to by Ref. The exception Interfaces.C.Strings.Dereference{"_"}Error is propagated if Ref is <strong>null</strong>. <br /></p>

<MarginText>24_B.3.2</MarginText>
<p>The "+" and "&ndash;" functions perform arithmetic on Pointer values, based on the Size of the array elements. In each of these functions, Pointer{"_"}Error is propagated if a Pointer parameter is <strong>null</strong>. <br /></p>

<MarginText>25_B.3.2</MarginText>
<CodeBlock language="ada">
procedure Increment (Ref : in out Pointer);{"\n"}

</CodeBlock>
<MarginText>26_B.3.2</MarginText>
<p class="Indented4">Equivalent to Ref := Ref+1.<br /></p>

<MarginText>27_B.3.2</MarginText>
<CodeBlock language="ada">
procedure Decrement (Ref : in out Pointer);{"\n"}

</CodeBlock>
<MarginText>28_B.3.2</MarginText>
<p class="Indented4">Equivalent to Ref := Ref&ndash;1.<br /></p>

<MarginText>29_B.3.2</MarginText>
<CodeBlock language="ada">
function Virtual{"_"}Length (Ref        : in Pointer;{"\n"}                         Terminator : in Element := Default{"_"}Terminator){"\n"}   return ptrdiff{"_"}t;{"\n"}

</CodeBlock>
<MarginText>30_B.3.2</MarginText>
<p class="Indented4">Returns the number of Elements, up to the one just before the first Terminator, in Value(Ref, Terminator).<br /></p>

<MarginText>31_B.3.2</MarginText>
<CodeBlock language="ada">
procedure Copy{"_"}Terminated{"_"}Array{"\n"}   (Source     : in Pointer;{"\n"}    Target     : in Pointer;{"\n"}    Limit      : in ptrdiff{"_"}t := ptrdiff{"_"}t'Last;{"\n"}    Terminator : in Element := Default{"_"}Terminator);{"\n"}

</CodeBlock>
<MarginText>32_B.3.2</MarginText>
<p class="Indented4">This procedure copies Value(Source, Terminator) into the array pointed to by Target; it stops either after Terminator has been copied, or the number of elements copied is Limit, whichever occurs first. Dereference{"_"}Error is propagated if either Source or Target is <strong>null</strong>. <br /></p>

<AnnotatedOnly>
<MarginText>32.a_B.3.2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>It is the programmer's responsibility to ensure that elements are not copied beyond the logical length of the target array. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.b_B.3.2</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>The implementation has to take care to check the Limit first. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>33_B.3.2</MarginText>
<CodeBlock language="ada">
procedure Copy{"_"}Array (Source  : in Pointer;{"\n"}                      Target  : in Pointer;{"\n"}                      Length  : in ptrdiff{"_"}t);{"\n"}

</CodeBlock>
<MarginText>34_B.3.2</MarginText>
<p class="Indented4">This procedure copies the first Length elements from the array pointed to by Source, into the array pointed to by Target. Dereference{"_"}Error is propagated if either Source or Target is <strong>null</strong>. <br /></p>


#### Erroneous Execution

<MarginText>35_B.3.2</MarginText>
<p>It is erroneous to dereference a Pointer that does not designate an aliased Element. <br /></p>

<AnnotatedOnly>
<MarginText>35.a_B.3.2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Such a Pointer could arise via "+", "&ndash;", Increment, or Decrement.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>36_B.3.2</MarginText>
<p>Execution of Value(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element{"_"}Array terminated by Terminator.<br /></p>

<MarginText>37_B.3.2</MarginText>
<p>Execution of Value(Ref, Length) is erroneous if Ref does not designate an aliased Element in an Element{"_"}Array containing at least Length Elements between the designated Element and the end of the array, inclusive.<br /></p>

<MarginText>38_B.3.2</MarginText>
<p>Execution of Virtual{"_"}Length(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element{"_"}Array terminated by Terminator.<br /></p>

<MarginText>39_B.3.2</MarginText>
<p>Execution of Copy{"_"}Terminated{"_"}Array(Source, Target, Limit, Terminator) is erroneous in either of the following situations: <br /></p>

<MarginText>40_B.3.2</MarginText>
<ul>
<li>Execution of both Value(Source, Terminator) and Value(Source, Limit) are erroneous, or<br /></li>
<MarginText>41_B.3.2</MarginText>
<li>Copying writes past the end of the array containing the Element designated by Target. <br /></li>
</ul>
<MarginText>42_B.3.2</MarginText>
<p>Execution of Copy{"_"}Array(Source, Target, Length) is erroneous if either Value(Source, Length) is erroneous, or copying writes past the end of the array containing the Element designated by Target. <br /></p>

<AnnotatedOnly>
<MarginText>43_B.3.2</MarginText>
<Admonition type="aarm" aarm="note">
NOTE   To compose a Pointer from an Element{"_"}Array, use 'Access on the first element. For example (assuming appropriate instantiations): <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44_B.3.2</MarginText>
<CodeBlock language="ada">
Some{"_"}Array   : Element{"_"}Array(0..5) ;{"\n"}Some{"_"}Pointer : Pointer := Some{"_"}Array(0)'Access;{"\n"}

</CodeBlock>
</AnnotatedOnly>

#### Examples

<MarginText>45_B.3.2</MarginText>
<p><em>Example of Interfaces.C.Pointers:</em> <br /></p>

<MarginText>46_B.3.2</MarginText>
<CodeBlock language="ada">
with Interfaces.C.Pointers;{"\n"}with Interfaces.C.Strings;{"\n"}procedure Test{"_"}Pointers is{"\n"}   package C renames Interfaces.C;{"\n"}   package Char{"_"}Ptrs is{"\n"}      new C.Pointers (Index              ={">"} C.size{"_"}t,{"\n"}                      Element            ={">"} C.char,{"\n"}                      Element{"_"}Array      ={">"} C.char{"_"}array,{"\n"}                      Default{"_"}Terminator ={">"} C.nul);{"\n"}
<MarginText>47_B.3.2</MarginText>
   use type Char{"_"}Ptrs.Pointer;{"\n"}   subtype Char{"_"}Star is Char{"_"}Ptrs.Pointer;{"\n"}
<MarginText>48_B.3.2</MarginText>
   procedure Strcpy (Target{"_"}Ptr, Source{"_"}Ptr : Char{"_"}Star) is{"\n"}      Target{"_"}Temp{"_"}Ptr : Char{"_"}Star := Target{"_"}Ptr;{"\n"}      Source{"_"}Temp{"_"}Ptr : Char{"_"}Star := Source{"_"}Ptr;{"\n"}      Element : C.char;{"\n"}   begin{"\n"}      if Target{"_"}Temp{"_"}Ptr = null or Source{"_"}Temp{"_"}Ptr = null then{"\n"}         raise C.Strings.Dereference{"_"}Error;{"\n"}      end if;{"\n"}
<MarginText>49/1_B.3.2</MarginText>
<MarginInfo items={["AI95-00142-01"]} />
{"{"}8652/0065{"}"}       loop{"\n"}         Element             := Source{"_"}Temp{"_"}Ptr.all;{"\n"}         Target{"_"}Temp{"_"}Ptr.all := Element;{"\n"}         exit when C."="(Element, C.nul);{"\n"}         Char{"_"}Ptrs.Increment(Target{"_"}Temp{"_"}Ptr);{"\n"}         Char{"_"}Ptrs.Increment(Source{"_"}Temp{"_"}Ptr);{"\n"}      end loop;{"\n"}   end Strcpy;{"\n"}begin{"\n"}   ...{"\n"}end Test{"_"}Pointers;{"\n"}
<a id="Subclause_B.3.3"></a>

</CodeBlock>

## B.3.3  Unchecked Union Types

<MarginText>1/3_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0229-1", "AI05-0269-1"]} />
<p>[Specifying aspect Unchecked{"_"}Union to have the value True defines an interface correspondence between a given discriminated type and some C union. The aspect requires that the associated type shall be given a representation that allocates no space for its discriminant(s).] <br /></p>

<p><em>Paragraphs 2 through 3 were moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo;.</em> <br /></p>


#### Static Semantics

<MarginText>3.1/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>For a discriminated record type having a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code>, the following language-defined representation aspect may be specified:<br /></p>

<MarginText>3.2/3_B.3.3</MarginText>
<dt><br/>Unchecked{"_"}Union</dt>
<dl>
<dd>The type of aspect Unchecked{"_"}Union is Boolean. If directly specified, the <code><a href="../AA-13/AA-13.1#S0348">aspect_definition</a></code> shall be a static expression. If not specified (including by inheritance), the aspect is False.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>3.a/3_B.3.3</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Aspect Description for </strong><strong>Unchecked{"_"}Union: </strong>Type is used to interface to a C union type.<br />
</Admonition>
</AnnotatedOnly>


#### Legality Rules

<p><em>Paragraphs 4 and 5 were deleted.</em> <br /></p>

<MarginText>6/3_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0229-1"]} />
<p>A type for which aspect Unchecked{"_"}Union is True is called an <em>unchecked union type</em>. A subtype of an unchecked union type is defined to be an <em>unchecked union subtype</em>. An object of an unchecked union type is defined to be an <em>unchecked union object</em>.<br /></p>

<MarginText>7/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>All component subtypes of an unchecked union type shall be C-compatible.<br /></p>

<MarginText>8/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>If a component subtype of an unchecked union type is subject to a per-object constraint, then the component subtype shall be an unchecked union subtype.<br /></p>

<MarginText>9/5_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0026-1", "AI12-0174-1"]} />
<p>Any name that denotes a discriminant of an object of an unchecked union type shall occur within the declarative region of the type or as the <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>, and shall not occur within a <code><a href="../AA-13/AA-13.5#S0352">record_representation_clause</a></code>.<br /></p>

<MarginText>10/3_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0026-1"]} />
<p>The type of a component declared in a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code> of an unchecked union type shall not need finalization. In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), this rule also applies in the private part of an instance of a generic unit. For an unchecked union type declared within the body of a generic unit, or within the body of any of its descendant library units, no part of the type of a component declared in a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code> of the unchecked union type shall be of a formal private type or formal private extension declared within the formal part of the generic unit.<br /></p>

<AnnotatedOnly>
<MarginText>10.a/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The last part is a classic assume-the-worst rule that avoids dependence on the actuals in a generic body. We did not include this in the definition of &ldquo;needs finalization&rdquo; as it has a bad interaction with the use of that term for the No{"_"}Nested{"_"}Finalization restriction. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>11/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>The completion of an incomplete or private type declaration having a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> shall not be an unchecked union type.<br /></p>

<MarginText>12/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An unchecked union subtype shall only be passed as a generic actual parameter if the corresponding formal type has no known discriminants or is an unchecked union type.<br /></p>

<AnnotatedOnly>
<MarginText>12.a/2_B.3.3</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This includes formal private types without a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>, formal derived types that do not inherit any discriminants (formal derived types do not have <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>s), and formal derived types that are unchecked union types. <br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>13/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An unchecked union type is eligible for convention C.<br /></p>

<MarginText>14/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>All objects of an unchecked union type have the same size.<br /></p>

<MarginText>15/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Discriminants of objects of an unchecked union type are of size zero.<br /></p>

<MarginText>16/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Any check which would require reading a discriminant of an unchecked union object is suppressed (see <a href="../AA-11/AA-11.5">11.5</a>). These checks include:<br /></p>

<MarginText>17/5_B.3.3</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<ul>
<li>The check performed when addressing a variant component (that is, a component that was declared in a variant part) of an unchecked union object that the object has this component (see <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>).<br /></li>
<MarginText>18/2_B.3.3</MarginText>
<li>Any checks associated with a type or subtype conversion of a value of an unchecked union type (see <a href="../AA-4/AA-4.6">4.6</a>). This includes, for example, the check associated with the implicit subtype conversion of an assignment statement.<br /></li>
<MarginText>19/2_B.3.3</MarginText>
<li>The subtype membership check associated with the evaluation of a qualified expression (see <a href="../AA-4/AA-4.7">4.7</a>) or an uninitialized allocator (see <a href="../AA-4/AA-4.8">4.8</a>). <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19.a/2_B.3.3</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>If a suppressed check would have failed, execution is erroneous (see <a href="../AA-11/AA-11.5">11.5</a>). An implementation is always allowed to make a suppressed check if it can somehow determine the discriminant value. <br />
</Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>20/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>A view of an unchecked union object (including a type conversion or function call) has <em>inferable discriminants</em> if it has a constrained nominal subtype, unless the object is a component of an enclosing unchecked union object that is subject to a per-object constraint and the enclosing object lacks inferable discriminants.<br /></p>

<MarginText>21/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An expression of an unchecked union type has inferable discriminants if it is either a name of an object with inferable discriminants or a qualified expression whose <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denotes a constrained subtype.<br /></p>

<MarginText>22/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Program{"_"}Error is raised in the following cases:<br /></p>

<MarginText>23/2_B.3.3</MarginText>
<ul>
<li>Evaluation of the predefined equality operator for an unchecked union type if either of the operands lacks inferable discriminants.<br /></li>
<MarginText>24/2_B.3.3</MarginText>
<li>Evaluation of the predefined equality operator for a type which has a subcomponent of an unchecked union type whose nominal subtype is unconstrained.<br /></li>
<MarginText>25/5_B.3.3</MarginText>
<MarginInfo items={["AI12-0162-1"]} />
<li>Evaluation of an individual membership test if the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> (if any) denotes a constrained unchecked union subtype and the <em>tested{"_"}</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code> lacks inferable discriminants.<br /></li>
<MarginText>26/2_B.3.3</MarginText>
<li>Conversion from a derived unchecked union type to an unconstrained non-unchecked-union type if the operand of the conversion lacks inferable discriminants.<br /></li>
<MarginText>27/2_B.3.3</MarginText>
<li>Execution of the default implementation of the Write or Read attribute of an unchecked union type.<br /></li>
<MarginText>28/2_B.3.3</MarginText>
<li>Execution of the default implementation of the Output or Input attribute of an unchecked union type if the type lacks default discriminant values. <br /></li>
</ul>
<p><em>Paragraph 29 was deleted.</em> <br /></p>

<AnnotatedOnly>
<MarginText>30/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
NOTE   The use of an unchecked union to obtain the effect of an unchecked conversion results in erroneous execution (see <a href="../AA-11/AA-11.5">11.5</a>). Execution of the following example is erroneous even if Float'Size = Integer'Size:<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>31/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<CodeBlock language="ada">
type T (Flag : Boolean := False) is{"\n"}   record{"\n"}       case Flag is{"\n"}           when False ={">"}{"\n"}               F1 : Float := 0.0;{"\n"}           when True ={">"}{"\n"}               F2 : Integer := 0;{"\n"}       end case;{"\n"}    end record{"\n"}    with Unchecked{"_"}Union;{"\n"}
<MarginText>32/2_B.3.3</MarginText>
X : T;{"\n"}Y : Integer := X.F2; -- erroneous{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.a/2_B.3.3</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
<code><a href="../AA-2/AA-2.8#S0019">Pragma</a></code> Unchecked{"_"}Union is new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.b/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> The use of discriminants on Unchecked{"_"}Union types is now illegal in <code><a href="../AA-13/AA-13.5#S0352">record_representation_clause</a></code>s, as it makes no sense to specify a position for something that is not supposed to exist. It is very unlikely that this change will have any impact on existing code. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.c/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
Aspect Unchecked{"_"}Union is new; <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Unchecked{"_"}Union is now obsolescent. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.d/3_B.3.3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Revised the rules to use the &ldquo;needs finalization&rdquo; definition, and eliminated generic contract issues. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.e/5_B.3.3</MarginText>
<MarginInfo items={["AI05-0162-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Adjusted the wording to reflect that membership tests can have more than one expression or <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.f/5_B.3.3</MarginText>
<MarginInfo items={["AI05-0174-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Adjusted the wording to allow named aggregates of an unchecked union type; it is clearly madness to allow positional record components in an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> but not named component associations. <br />
</Admonition>
</AnnotatedOnly>

