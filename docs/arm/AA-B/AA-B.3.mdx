---
sidebar_position:  143
---

# B.3 Interfacing with C and C++

:::warning
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1/4</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00376-01", "AI05-0229-1", "AI12-0028-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The facilities relevant to interfacing with the C language and the corresponding subset of the C++ language are the package Interfaces.C and its children, and support for specifying the Convention aspect with <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s C, C_Pass_By_Copy, and any of the C_Variadic_<em>n</em> conventions described below.<br /></p>

<MarginText>2/3</MarginText>
<MarginInfo items={["AI95-00376-01", "AI95-0262-1", "AI95-0299-1"]} />
<p>The package Interfaces.C contains the basic types, constants, and subprograms that allow an Ada program to pass scalars and strings to C and C++ functions. When this subclause mentions a C entity, the reference also applies to the corresponding entity in C++. <br /></p>


#### Static Semantics

<MarginText>3</MarginText>
<p>The library package Interfaces.C has the following declaration: <br /></p>

<MarginText>4/5</MarginText>
<MarginInfo items={["AI12-0414-1"]} />
<CodeBlock language="ada">
package Interfaces.C {"\n"}   with  Pure is {"\n"}
<MarginText>5</MarginText>
   -- Declarations based on C's {"<"}limits.h{">"}{"\n"}
<MarginText>6</MarginText>
   CHAR_BIT  : constant := implementation-defined;  -- typically 8{"\n"}   SCHAR_MIN : constant := implementation-defined;  -- typically &ndash;128{"\n"}   SCHAR_MAX : constant := implementation-defined;  -- typically 127{"\n"}   UCHAR_MAX : constant := implementation-defined;  -- typically 255{"\n"}
<MarginText>7</MarginText>
   -- Signed and Unsigned Integers{"\n"}   type int   is range implementation-defined;{"\n"}   type short is range implementation-defined;{"\n"}   type long  is range implementation-defined;{"\n"}
<MarginText>8</MarginText>
   type signed_char is range SCHAR_MIN .. SCHAR_MAX;{"\n"}   for signed_char'Size use CHAR_BIT;{"\n"}
<MarginText>9</MarginText>
   type unsigned       is mod implementation-defined;{"\n"}   type unsigned_short is mod implementation-defined;{"\n"}   type unsigned_long  is mod implementation-defined;{"\n"}
<MarginText>10</MarginText>
   type unsigned_char is mod (UCHAR_MAX+1);{"\n"}   for unsigned_char'Size use CHAR_BIT;{"\n"}
<MarginText>11</MarginText>
   subtype plain_char is implementation-defined;{"\n"}
<MarginText>12</MarginText>
   type ptrdiff_t is range implementation-defined;{"\n"}
<MarginText>13</MarginText>
   type size_t is mod implementation-defined;{"\n"}
<MarginText>13.1/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
   -- Boolean Type{"\n"}   type C_bool is new Boolean;{"\n"}
<MarginText>14</MarginText>
   -- Floating Point{"\n"}
<MarginText>15</MarginText>
   type C_float     is digits implementation-defined;{"\n"}
<MarginText>16</MarginText>
   type double      is digits implementation-defined;{"\n"}
<MarginText>17</MarginText>
   type long_double is digits implementation-defined;{"\n"}
<MarginText>18</MarginText>
   -- Characters and Strings {"\n"}
<MarginText>19</MarginText>
   type char is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>20/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    nul : constant char := implementation-defined;{"\n"}
<MarginText>21</MarginText>
   function To_C   (Item : in Character) return char;{"\n"}
<MarginText>22</MarginText>
   function To_Ada (Item : in char) return Character;{"\n"}
<MarginText>23/3</MarginText>
<MarginInfo items={["AI05-0229-1", "AI05-0269-1"]} />
   type char_array is array (size_t range {"<"}{">"}) of aliased char{"\n"}      with Pack;{"\n"}   for char_array'Component_Size use CHAR_BIT;{"\n"}
<MarginText>24</MarginText>
   function Is_Nul_Terminated (Item : in char_array) return Boolean;{"\n"}
<MarginText>25</MarginText>
   function To_C   (Item       : in String;{"\n"}                    Append_Nul : in Boolean := True){"\n"}      return char_array;{"\n"}
<MarginText>26</MarginText>
   function To_Ada (Item     : in char_array;{"\n"}                    Trim_Nul : in Boolean := True){"\n"}      return String;{"\n"}
<MarginText>27</MarginText>
   procedure To_C (Item       : in  String;{"\n"}                   Target     : out char_array;{"\n"}                   Count      : out size_t;{"\n"}                   Append_Nul : in  Boolean := True);{"\n"}
<MarginText>28</MarginText>
   procedure To_Ada (Item     : in  char_array;{"\n"}                     Target   : out String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim_Nul : in  Boolean := True);{"\n"}
<MarginText>29</MarginText>
   -- Wide Character and Wide String{"\n"}
<MarginText>30/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    type wchar_t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>31/1</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
{"{"}8652/0060{"}"}    wide_nul : constant wchar_t := implementation-defined;{"\n"}
<MarginText>32</MarginText>
   function To_C   (Item : in Wide_Character) return wchar_t;{"\n"}   function To_Ada (Item : in wchar_t       ) return Wide_Character;{"\n"}
<MarginText>33/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type wchar_array is array (size_t range {"<"}{">"}) of aliased wchar_t{"\n"}      with Pack;{"\n"}
<MarginText>34/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>35</MarginText>
   function Is_Nul_Terminated (Item : in wchar_array) return Boolean;{"\n"}
<MarginText>36</MarginText>
   function To_C   (Item       : in Wide_String;{"\n"}                    Append_Nul : in Boolean := True){"\n"}      return wchar_array;{"\n"}
<MarginText>37</MarginText>
   function To_Ada (Item     : in wchar_array;{"\n"}                    Trim_Nul : in Boolean := True){"\n"}      return Wide_String;{"\n"}
<MarginText>38</MarginText>
   procedure To_C (Item       : in  Wide_String;{"\n"}                   Target     : out wchar_array;{"\n"}                   Count      : out size_t;{"\n"}                   Append_Nul : in  Boolean := True);{"\n"}
<MarginText>39</MarginText>
   procedure To_Ada (Item     : in  wchar_array;{"\n"}                     Target   : out Wide_String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim_Nul : in  Boolean := True);{"\n"}
<MarginText>39.1/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0450-1"]} />
   -- ISO/IEC 10646  compatible types .{"\n"}
<MarginText>39.2/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
   type char16_t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>39.3/2</MarginText>
   char16_nul : constant char16_t := implementation-defined;{"\n"}
<MarginText>39.4/2</MarginText>
   function To_C (Item : in Wide_Character) return char16_t;{"\n"}   function To_Ada (Item : in char16_t) return Wide_Character;{"\n"}
<MarginText>39.5/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type char16_array is array (size_t range {"<"}{">"}) of aliased char16_t{"\n"}      with Pack;{"\n"}
<MarginText>39.6/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>39.7/2</MarginText>
   function Is_Nul_Terminated (Item : in char16_array) return Boolean;{"\n"}   function To_C (Item       : in Wide_String;{"\n"}                  Append_Nul : in Boolean := True){"\n"}      return char16_array;{"\n"}
<MarginText>39.8/2</MarginText>
   function To_Ada (Item     : in char16_array;{"\n"}                    Trim_Nul : in Boolean := True){"\n"}      return Wide_String;{"\n"}
<MarginText>39.9/2</MarginText>
   procedure To_C (Item       : in  Wide_String;{"\n"}                   Target     : out char16_array;{"\n"}                   Count      : out size_t;{"\n"}                   Append_Nul : in  Boolean := True);{"\n"}
<MarginText>39.10/2</MarginText>
   procedure To_Ada (Item     : in  char16_array;{"\n"}                     Target   : out Wide_String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim_Nul : in  Boolean := True);{"\n"}
<MarginText>39.11/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
   type char32_t is {"<"}implementation-defined character type{">"};{"\n"}
<MarginText>39.12/2</MarginText>
   char32_nul : constant char32_t := implementation-defined;{"\n"}
<MarginText>39.13/2</MarginText>
   function To_C (Item : in Wide_Wide_Character) return char32_t;{"\n"}   function To_Ada (Item : in char32_t) return Wide_Wide_Character;{"\n"}
<MarginText>39.14/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   type char32_array is array (size_t range {"<"}{">"}) of aliased char32_t{"\n"}      with Pack;{"\n"}
<MarginText>39.15/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>39.16/2</MarginText>
   function Is_Nul_Terminated (Item : in char32_array) return Boolean;{"\n"}   function To_C (Item       : in Wide_Wide_String;{"\n"}                  Append_Nul : in Boolean := True){"\n"}      return char32_array;{"\n"}
<MarginText>39.17/2</MarginText>
   function To_Ada (Item     : in char32_array;{"\n"}                    Trim_Nul : in Boolean := True){"\n"}      return Wide_Wide_String;{"\n"}
<MarginText>39.18/2</MarginText>
   procedure To_C (Item       : in  Wide_Wide_String;{"\n"}                   Target     : out char32_array;{"\n"}                   Count      : out size_t;{"\n"}                   Append_Nul : in  Boolean := True);{"\n"}
<MarginText>39.19/2</MarginText>
   procedure To_Ada (Item     : in  char32_array;{"\n"}                     Target   : out Wide_Wide_String;{"\n"}                     Count    : out Natural;{"\n"}                     Trim_Nul : in  Boolean := True);{"\n"}
<MarginText>40</MarginText>
   Terminator_Error : exception;{"\n"}
<MarginText>41</MarginText>
end Interfaces.C;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>41.a.1/2</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<strong></strong>The definitions of certain types and constants in Interfaces.C.<br /></Admonition>
</AnnotatedOnly>

<MarginText>42</MarginText>
<p>Each of the types declared in Interfaces.C is C-compatible.<br /></p>

<MarginText>43/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0411-1"]} />
<p>The types int, short, long, unsigned, ptrdiff_t, size_t, double, char, wchar_t, char16_t, and char32_t correspond respectively to the C types having the same names. The types signed_char, unsigned_short, unsigned_long, unsigned_char, C_bool, C_float, and long_double correspond respectively to the C types signed char, unsigned short, unsigned long, unsigned char, bool,  float, and long double.<br /></p>

<AnnotatedOnly>
<MarginText>43.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The C types wchar_t and char16_t seem to be the same. However, wchar_t has an implementation-defined size, whereas char16_t is guaranteed to be an unsigned type of at least 16 bits. Also, char16_t and char32_t are encouraged to have UTF-16 and UTF-32 representations; that means that they are not directly the same as the Ada types, which most likely don't use any UTF encoding. <br /></Admonition>
</AnnotatedOnly>

<MarginText>44</MarginText>
<p>The type of the subtype plain_char is either signed_char or unsigned_char, depending on the C implementation. <br /></p>

<MarginText>45</MarginText>
<CodeBlock language="ada">
function To_C   (Item : in Character) return char;{"\n"}function To_Ada (Item : in char     ) return Character;{"\n"}

</CodeBlock>
<MarginText>46</MarginText>
<p>The functions To_C and To_Ada map between the Ada type Character and the C type char.<br /></p>

<AnnotatedOnly>
<MarginText>46.a.1/1</MarginText>
<MarginInfo items={["AI95-00038-01"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>{"{"}<em>8652/0114</em>{"}"} The To_C and To_Ada functions map between corresponding characters, not necessarily between characters with the same internal representation. Corresponding characters are characters defined by the same enumeration literal, if such exist; otherwise, the correspondence is unspecified.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.2/1</MarginText>
<Admonition type="aarm" aarm="note">
The following definition is equivalent to the above summary:<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.3/1</MarginText>
<Admonition type="aarm" aarm="note">
To_C (Latin_1_Char) = char'Value(Character'Image(Latin_1_Char))<br />provided that char'Value does not raise an exception; otherwise the result is unspecified.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>46.a.4/1</MarginText>
<Admonition type="aarm" aarm="note">
To_Ada (Native_C_Char) = Character'Value(char'Image(Native_C_Char))<br />provided that Character'Value does not raise an exception; otherwise the result is unspecified. <br /></Admonition>
</AnnotatedOnly>

<MarginText>47</MarginText>
<CodeBlock language="ada">
function Is_Nul_Terminated (Item : in char_array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>48</MarginText>
<p>The result of Is_Nul_Terminated is True if Item contains nul, and is False otherwise.<br /></p>

<MarginText>49</MarginText>
<CodeBlock language="ada">
function To_C   (Item : in String;     Append_Nul : in Boolean := True){"\n"}   return char_array;{"\n"}{"\n"}function To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True){"\n"}   return String;{"\n"}

</CodeBlock>
<MarginText>50/2</MarginText>
<MarginInfo items={["AI95-00258-01"]} />
<p>The result of To_C is a char_array value of length Item'Length (if Append_Nul is False) or Item'Length+1 (if Append_Nul is True). The lower bound is 0. For each component Item(I), the corresponding component in the result is To_C applied to Item(I). The value nul is appended if Append_Nul is True. If Append_Nul is False and Item'Length is 0, then To_C propagates Constraint_Error.<br /></p>

<MarginText>51</MarginText>
<p>The result of To_Ada is a String whose length is Item'Length (if Trim_Nul is False) or the length of the slice of Item preceding the first nul (if Trim_Nul is True). The lower bound of the result is 1. If Trim_Nul is False, then for each component Item(I) the corresponding component in the result is To_Ada applied to Item(I). If Trim_Nul is True, then for each component Item(I) before the first nul the corresponding component in the result is To_Ada applied to Item(I). The function propagates Terminator_Error if Trim_Nul is True and Item does not contain nul.<br /></p>

<MarginText>52</MarginText>
<CodeBlock language="ada">
procedure To_C (Item       : in  String;{"\n"}                Target     : out char_array;{"\n"}                Count      : out size_t;{"\n"}                Append_Nul : in  Boolean := True);{"\n"}{"\n"}procedure To_Ada (Item     : in  char_array;{"\n"}                  Target   : out String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim_Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>53</MarginText>
<p>For procedure To_C, each element of Item is converted (via the To_C function) to a char, which is assigned to the corresponding element of Target. If Append_Nul is True, nul is then assigned to the next element of Target. In either case, Count is set to the number of Target elements assigned. If Target is not long enough, Constraint_Error is propagated.<br /></p>

<MarginText>54</MarginText>
<p>For procedure To_Ada, each element of Item (if Trim_Nul is False) or each element of Item preceding the first nul (if Trim_Nul is True) is converted (via the To_Ada function) to a Character, which is assigned to the corresponding element of Target. Count is set to the number of Target elements assigned. If Target is not long enough, Constraint_Error is propagated. If Trim_Nul is True and Item does not contain nul, then Terminator_Error is propagated.<br /></p>

<MarginText>55</MarginText>
<CodeBlock language="ada">
function Is_Nul_Terminated (Item : in wchar_array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>56</MarginText>
<p>The result of Is_Nul_Terminated is True if Item contains wide_nul, and is False otherwise.<br /></p>

<MarginText>57</MarginText>
<CodeBlock language="ada">
function To_C   (Item : in Wide_Character) return wchar_t;{"\n"}function To_Ada (Item : in wchar_t       ) return Wide_Character;{"\n"}

</CodeBlock>
<MarginText>58</MarginText>
<p>To_C and To_Ada provide the mappings between the Ada and C wide character types.<br /></p>

<MarginText>59</MarginText>
<CodeBlock language="ada">
function To_C   (Item       : in Wide_String;{"\n"}                 Append_Nul : in Boolean := True){"\n"}   return wchar_array;{"\n"}{"\n"}function To_Ada (Item     : in wchar_array;{"\n"}                 Trim_Nul : in Boolean := True){"\n"}   return Wide_String;{"\n"}{"\n"}procedure To_C (Item       : in  Wide_String;{"\n"}                Target     : out wchar_array;{"\n"}                Count      : out size_t;{"\n"}                Append_Nul : in  Boolean := True);{"\n"}{"\n"}procedure To_Ada (Item     : in  wchar_array;{"\n"}                  Target   : out Wide_String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim_Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60</MarginText>
<p>The To_C and To_Ada subprograms that convert between Wide_String and wchar_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that wide_nul is used instead of nul.<br /></p>

<MarginText>60.1/2</MarginText>
<CodeBlock language="ada">
function Is_Nul_Terminated (Item : in char16_array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>60.2/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p>The result of Is_Nul_Terminated is True if Item contains char16_nul, and is False otherwise.<br /></p>

<MarginText>60.3/2</MarginText>
<CodeBlock language="ada">
function To_C (Item : in Wide_Character) return char16_t;{"\n"}function To_Ada (Item : in char16_t ) return Wide_Character;{"\n"}

</CodeBlock>
<MarginText>60.4/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p>To_C and To_Ada provide mappings between the Ada and C 16-bit character types.<br /></p>

<MarginText>60.5/2</MarginText>
<CodeBlock language="ada">
function To_C (Item       : in Wide_String;{"\n"}               Append_Nul : in Boolean := True){"\n"}   return char16_array;{"\n"}{"\n"}function To_Ada (Item     : in char16_array;{"\n"}                 Trim_Nul : in Boolean := True){"\n"}   return Wide_String;{"\n"}{"\n"}procedure To_C (Item       : in  Wide_String;{"\n"}                Target     : out char16_array;{"\n"}                Count      : out size_t;{"\n"}                Append_Nul : in  Boolean := True);{"\n"}{"\n"}procedure To_Ada (Item     : in  char16_array;{"\n"}                  Target   : out Wide_String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim_Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60.6/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p>The To_C and To_Ada subprograms that convert between Wide_String and char16_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that char16_nul is used instead of nul.<br /></p>

<MarginText>60.7/2</MarginText>
<CodeBlock language="ada">
function Is_Nul_Terminated (Item : in char32_array) return Boolean;{"\n"}

</CodeBlock>
<MarginText>60.8/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0437-1"]} />
<p>The result of Is_Nul_Terminated is True if Item contains char32_nul , and is False otherwise.<br /></p>

<MarginText>60.9/2</MarginText>
<CodeBlock language="ada">
function To_C (Item : in Wide_Wide_Character) return char32_t;{"\n"}function To_Ada (Item : in char32_t ) return Wide_Wide_Character;{"\n"}

</CodeBlock>
<MarginText>60.10/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p>To_C and To_Ada provide mappings between the Ada and C 32-bit character types.<br /></p>

<MarginText>60.11/2</MarginText>
<CodeBlock language="ada">
function To_C (Item       : in Wide_Wide_String;{"\n"}               Append_Nul : in Boolean := True){"\n"}   return char32_array;{"\n"}{"\n"}function To_Ada (Item     : in char32_array;{"\n"}                 Trim_Nul : in Boolean := True){"\n"}   return Wide_Wide_String;{"\n"}{"\n"}procedure To_C (Item       : in  Wide_Wide_String;{"\n"}                Target     : out char32_array;{"\n"}                Count      : out size_t;{"\n"}                Append_Nul : in  Boolean := True);{"\n"}{"\n"}procedure To_Ada (Item     : in  char32_array;{"\n"}                  Target   : out Wide_Wide_String;{"\n"}                  Count    : out Natural;{"\n"}                  Trim_Nul : in  Boolean := True);{"\n"}

</CodeBlock>
<MarginText>60.12/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<p>The To_C and To_Ada subprograms that convert between Wide_Wide_String and char32_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that char32_nul is used instead of nul.<br /></p>

<AnnotatedOnly>
<MarginText>60.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The Interfaces.C package provides an implementation-defined character type, char, designed to model the C run-time character set, and mappings between the types char and Character.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.b</MarginText>
<Admonition type="aarm" aarm="note">
One application of the C interface package is to compose a C string and pass it to a C function. One way to do this is for the programmer to declare an object that will hold the C array, and then pass this array to the C function. This is realized via the type char_array: <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.c</MarginText>
<CodeBlock language="ada">
type char_array is array (size_t range {"<"}{">"}) of Char;{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.d</MarginText>
<Admonition type="aarm" aarm="note">
The programmer can declare an Ada String, convert it to a char_array, and pass the char_array as actual parameter to the C function that is expecting a char *.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.e</MarginText>
<Admonition type="aarm" aarm="note">
An alternative approach is for the programmer to obtain a C char pointer from an Ada String (or from a char_array) by invoking an allocation function. The package Interfaces.C.Strings (see below) supplies the needed facilities, including a private type chars_ptr that corresponds to C's char *, and two allocation functions. To avoid storage leakage, a Free procedure releases the storage that was allocated by one of these allocate functions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.f</MarginText>
<Admonition type="aarm" aarm="note">
It is typical for a C function that deals with strings to adopt the convention that the string is delimited by a nul char. The C interface packages support this convention. A constant nul of type Char is declared, and the function Value(Chars_Ptr) in Interfaces.C.Strings returns a char_array up to and including the first nul in the array that the chars_ptr points to. The Allocate_Chars function allocates an array that is nul terminated.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.g</MarginText>
<Admonition type="aarm" aarm="note">
Some C functions that deal with strings take an explicit length as a parameter, thus allowing strings to be passed that contain nul as a data element. Other C functions take an explicit length that is an upper bound: the prefix of the string up to the char before nul, or the prefix of the given length, is used by the function, whichever is shorter. The C Interface packages support calling such functions. <br /></Admonition>
</AnnotatedOnly>

<MarginText>60.13/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0229-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The Convention aspect with <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> C_Pass_By_Copy shall only be specified for a type.<br /></p>

<MarginText>60.14/2</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00216-01"]} />
<p>{"{"}<em>8652/0059</em>{"}"} The eligibility rules in <a href="../AA-B/AA-B.1">B.1</a> do not apply to convention C_Pass_By_Copy. Instead, a type T is eligible for convention C_Pass_By_Copy if T is an unchecked union type or if T is a record type that has no discriminants and that only has components with statically constrained subtypes, and each component is C-compatible.<br /></p>

<MarginText>60.15/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0264-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} If a type is C_Pass_By_Copy-compatible, then it is also C-compatible.<br /></p>

<MarginText>60.16/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<p>The identifiers C_Variadic_0, C_Variadic_1, C_Variadic_2, and so on are <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s. These conventions are said to be <em>C_Variadic</em>. The convention C_Variadic_<em>n</em> is the calling convention for a variadic C function taking <em>n</em> fixed parameters and then a variable number of additional parameters. The C_Variadic_<em>n</em> convention shall only be specified as the convention aspect for a subprogram, or for an access-to-subprogram type, having at least <em>n</em> parameters. A type is compatible with a C_Variadic convention if and only if the type is C-compatible.<br /></p>

<AnnotatedOnly>
<MarginText>60.h/4</MarginText>
<Admonition type="aarm" aarm="note">
<strong>To be honest: </strong>It is implementation defined what the largest <em>n</em> in C_Variadic_<em>n</em> is supported. We don't say this because it complicates the wording and it is true for almost any <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> (only Ada is required to be supported by the language, all others need to be documented in order for programmers to know that they are available). <br /></Admonition>
</AnnotatedOnly>


#### Implementation Requirements

<MarginText>61/3</MarginText>
<MarginInfo items={["AI95-00131-01", "AI05-0229-1"]} />
<p>{"{"}<em>8652/0059</em>{"}"} An implementation shall support specifying aspect Convention with a C <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> for a C-eligible type (see <a href="../AA-B/AA-B.1">B.1</a>). An implementation shall support specifying aspect Convention with a C_Pass_By_Copy <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> for a C_Pass_By_Copy-eligible type. <br /></p>


#### Implementation Permissions

<MarginText>62</MarginText>
<p>An implementation may provide additional declarations in the C interface packages.<br /></p>

<MarginText>62.1/5</MarginText>
<MarginInfo items={["AI05-0002-1", "AI05-0229-1", "AI12-0444-1"]} />
<p>An implementation is not required to  support specifying the Convention aspect with <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code> C in the following cases:<br /></p>

<MarginText>62.2/3</MarginText>
<MarginInfo items={["AI05-0248-1"]} />
<ul>
<li>for a subprogram that has a parameter of an unconstrained array subtype, unless the Import aspect has the value True for the subprogram;<br /></li>
<MarginText>62.3/3</MarginText>
<li>for a function with an unconstrained array result subtype;<br /></li>
<MarginText>62.4/3</MarginText>
<li>for an object whose nominal subtype is an unconstrained array subtype. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>62.a/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>These rules ensure that an implementation never needs to create bounds for an unconstrained array that originates in C (and thus does not have bounds). An implementation can do so if it wishes, of course. Note that these permissions do not extend to passing an unconstrained array as a parameter to a C function; in this case, the bounds can simply be dropped and thus support is required. <br /></Admonition>
</AnnotatedOnly>


#### Implementation Advice

<MarginText>62.5/3</MarginText>
<MarginInfo items={["AI95-00037-01", "AI95-00285-01"]} />
<p>{"{"}<em>8652/0060</em>{"}"} The constants nul, wide_nul, char16_nul, and char32_nul should have a representation of zero. <br /></p>

<AnnotatedOnly>
<MarginText>62.b/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>The constants nul, wide_nul, char16_nul, and char32_nul in package Interfaces.C should have a representation of zero.<br /></Admonition>
</AnnotatedOnly>

<MarginText>63</MarginText>
<p>An implementation should support the following interface correspondences between Ada and C. <br /></p>

<MarginText>64</MarginText>
<ul>
<li>An Ada procedure corresponds to a void-returning C function. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>64.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The programmer can also choose an Ada procedure when the C function returns an int that is to be discarded.<br /></Admonition>
</AnnotatedOnly>

<MarginText>65</MarginText>
<ul>
<li>An Ada function corresponds to a non-void C function.<br /></li>
<MarginText>65.1/4</MarginText>
<MarginInfo items={["AI12-0135-1"]} />
<li>An Ada enumeration type corresponds to a C enumeration type with corresponding enumeration literals having the same internal codes, provided the internal codes fall within the range of the C int type.<br /></li>
<MarginText>66</MarginText>
<li>An Ada <strong>in</strong> scalar parameter is passed as a scalar argument to a C function.<br /></li>
<MarginText>67</MarginText>
<li>An Ada <strong>in</strong> parameter of an access-to-object type with designated type T is passed as a t* argument to a C function, where t is the C type corresponding to the Ada type T.<br /></li>
<MarginText>68</MarginText>
<li>An Ada <strong>access</strong> T parameter, or an Ada <strong>out</strong> or <strong>in out</strong> parameter of an elementary type T, is passed as a t* argument to a C function, where t is the C type corresponding to the Ada type T. In the case of an elementary <strong>out</strong> or <strong>in out</strong> parameter, a pointer to a temporary copy is used to preserve by-copy semantics.<br /></li>
<MarginText>68.1/2</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00343-01"]} />
<li>{"{"}<em>8652/0059</em>{"}"} An Ada parameter of a (record) type T of convention C_Pass_By_Copy, of mode <strong>in</strong>, is passed as a t argument to a C function, where t is the C struct corresponding to the Ada type T.<br /></li>
<MarginText>69/5</MarginText>
<MarginInfo items={["AI95-00131-01", "AI95-00343-01", "AI12-0219-1"]} />
<li>{"{"}<em>8652/0059</em>{"}"} An Ada parameter of a record type T,  other than an <strong>in</strong> parameter of a type of convention C_Pass_By_Copy, is passed as a t* argument to a C function, with the const modifier if the Ada mode is <strong>in</strong>, where t is the C struct corresponding to the Ada type T.<br /></li>
<MarginText>70/5</MarginText>
<MarginInfo items={["AI12-0219-1"]} />
<li>An Ada parameter of an array type with component type T  is passed as a t* argument to a C function, with the const modifier if the Ada mode is <strong>in</strong>, where t is the C type corresponding to the Ada type T.<br /></li>
<MarginText>71</MarginText>
<li>An Ada parameter of an access-to-subprogram type is passed as a pointer to a C function whose prototype corresponds to the designated subprogram's specification.<br /></li>
<MarginText>71.1/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<li>An Ada parameter of a private type is passed as specified for the full view of the type.<br /></li>
<MarginText>71.2/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<li>The rules of correspondence given above for parameters of mode <strong>in</strong> also apply to the return object of a function.<br /></li>
</ul>
<MarginText>71.3/5</MarginText>
<MarginInfo items={["AI95-00337-01", "AI05-0002-1", "AI12-0184-1"]} />
<p>An implementation should provide unsigned_long_long and long_long as 64-bit modular and signed integer types (respectively) in package Interfaces.C if the C implementation supports unsigned long long and long long as 64-bit types. <br /></p>

<AnnotatedOnly>
<MarginText>71.a/2</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>If C interfacing is supported, the interface correspondences between Ada and C should be supported.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>71.a.1/5</MarginText>
<Admonition type="aarm" aarm="implementation-advice">
<strong></strong>If the C implementation supports unsigned long long and long long, unsigned_long_long and long_long should be supported.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>72</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 1   Values of type char_array are not implicitly terminated with nul. If a char_array is to be passed as a parameter to an imported C function requiring nul termination, it is the programmer's responsibility to obtain this effect.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>73</MarginText>
<Admonition type="aarm" aarm="note">
NOTE 2   To obtain the effect of C's sizeof(item_type), where Item_Type is the corresponding Ada type, evaluate the expression: size_t(Item_Type'Size/CHAR_BIT).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>74/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
<em>This paragraph was deleted.</em><br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>75/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<Admonition type="aarm" aarm="note">
NOTE 3   A variadic C function can correspond to several Ada subprograms, taking various specific numbers and types of parameters. <br /></Admonition>
</AnnotatedOnly>


#### Examples

<MarginText>76</MarginText>
<p><em>Example of using the Interfaces.C package:</em> <br /></p>

<MarginText>77/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
<CodeBlock language="ada">
--Calling the C Library Functions  strcpy and printf{"\n"}with Interfaces.C;{"\n"}procedure Test is{"\n"}   package C renames Interfaces.C;{"\n"}   use type C.char_array;{"\n"}   -- Call {"<"}string.h{">"}strcpy:{"\n"}   -- C definition of strcpy:  char *strcpy(char *s1, const char *s2);{"\n"}   --    This function copies the string pointed to by s2 (including the terminating null character){"\n"}   --     into the array pointed to by s1. If copying takes place between objects that overlap,{"\n"}   --     the behavior is undefined. The strcpy function returns the value of s1.{"\n"}
<MarginText>78/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   -- {"\n"}   procedure Strcpy (Target : out C.char_array;{"\n"}                     Source : in  C.char_array){"\n"}      with Import ={">"} True, Convention ={">"} C, External_Name ={">"} "strcpy";{"\n"}
<MarginText>79/5</MarginText>
<MarginInfo items={["AI05-0229-1", "AI12-0312-1"]} />
   -- Call {"<"}sdtio.h{">"}printf:{"\n"}   -- C definition of printf:  int printf ( const char * format, ... );{"\n"}   --    This function writes the C string pointed by format to the standard output (stdout).{"\n"}   --     If format includes format specifiers (subsequences beginning with %), the additional{"\n"}   --     arguments following format are formatted and inserted in the resulting string{"\n"}   --     replacing their respective specifiers. If the number of arguments does not match{"\n"}   --     the number of format specifiers, or if the types of the arguments do not match{"\n"}   --     the corresponding format specifier, the behaviour is undefined. On success, the{"\n"}   --     printf function returns the total number of characters written to the standard output.{"\n"}   --     If a writing error occurs, a negative number is returned. {"\n"}
<MarginText>79.1/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
   -- {"\n"}   procedure Printf (Format : in C.char_array;{"\n"}                     Param1 : in C.char_array;{"\n"}                     Param2 : in C.int){"\n"}      with Import ={">"} True, Convention ={">"} C_Variadic_1, External_Name ={">"} "printf";{"\n"}
<MarginText>80</MarginText>
   Chars1 :  C.char_array(1..20);{"\n"}   Chars2 :  C.char_array(1..20);{"\n"}
<MarginText>81</MarginText>
begin{"\n"}   Chars2(1..6) := "qwert" & C.nul;{"\n"}
<MarginText>82</MarginText>
   Strcpy(Chars1, Chars2);{"\n"}
<MarginText>83</MarginText>
   -- Now Chars1(1..6) = "qwert" & C.Nul{"\n"}
<MarginText>83.1/5</MarginText>
<MarginInfo items={["AI12-0312-1"]} />
   Printf("The String=%s, Length=%d", Chars1, Chars1'Length);{"\n"}
<MarginText>84</MarginText>
end Test;{"\n"}

</CodeBlock>
<AnnotatedOnly>

#### Incompatibilities With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.a/3</MarginText>
<MarginInfo items={["AI95-00285-01", "AI05-0005-1"]} />
<Admonition type="aarm" aarm="note">
Types char16_t and char32_t and their related types and operations are added to Interfaces.C. If Interfaces.C is referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, and an entity <em>E</em> with the same <code><a href="../AA-3/AA-3.1#S0022">defining_identifier</a></code> as a new entity in Interfaces.C is defined in a package that is also referenced in a <code><a href="../AA-8/AA-8.4#S0235">use_clause</a></code>, the entity <em>E</em> may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.b/2</MarginText>
<MarginInfo items={["AI95-00131-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0059</em>{"}"} <strong>Corrigendum:</strong> Convention C_Pass_By_Copy is new. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.c/2</MarginText>
<MarginInfo items={["AI95-00037-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0060</em>{"}"} <strong>Corrigendum:</strong> Clarified the intent for Nul and Wide_Nul.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.d/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
Specified that an unchecked union type (see <a href="../AA-B/AA-B.3#Subclause_B.3.3">B.3.3</a>) is eligible for convention C_Pass_By_Copy.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.e/2</MarginText>
<MarginInfo items={["AI95-00258-01"]} />
<Admonition type="aarm" aarm="note">
Specified what happens if the To_C function tries to return a null string.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.f/2</MarginText>
<MarginInfo items={["AI95-00337-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that the interface correspondences also apply to private types whose full types have the specified characteristics.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.g/2</MarginText>
<MarginInfo items={["AI95-00343-01"]} />
<Admonition type="aarm" aarm="note">
Clarified that a type must have convention C_Pass_By_Copy in order to be passed by copy (not just a type that could have that convention).<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.h/2</MarginText>
<MarginInfo items={["AI95-00376-01"]} />
<Admonition type="aarm" aarm="note">
Added wording to make it clear that these facilities can also be used with C++. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.i/3</MarginText>
<MarginInfo items={["AI05-0002-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added a definition of correspondences for function results. Also added wording to make it clear that we do not expect the implementation to conjure bounds for unconstrained arrays out of thin air. These changes allow (but don't require) compilers to reject unreasonable uses of array types. Such uses probably didn't work anyway (and probably were rejected, no matter what the language definition said), so little existing code should be impacted. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.j/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
<Admonition type="aarm" aarm="note">
Added type C_bool and (implicitly) the enumeration literals True and False to the Interfaces.C package. Therefore, a use clause conflict is possible; see the introduction of <a href="../AA-A/">Annex A</a> for more on this topic. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.k/4</MarginText>
<MarginInfo items={["AI12-0028-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> The <em>convention_</em><code><a href="../AA-2/AA-2.3#S0002">identifier</a></code>s C_Variadic_0, C_Variadic_1, and so on are new. These are classified as a correction as any implementation can add such identifiers and it is important that special conventions be available for variadic functions as typical x64 conventions are different for normal and variadic C functions.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.l/4</MarginText>
<MarginInfo items={["AI12-0135-1"]} />
<Admonition type="aarm" aarm="note">
<strong>Corrigendum:</strong> Defined the correspondence between an Ada enumeration type and a C enumeration type; implementations should support convention C for enumeration types. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>84.m/5</MarginText>
<MarginInfo items={["AI12-0184-1"]} />
<Admonition type="aarm" aarm="implementation-advice">
Added  that types be defined in Interfaces.C corresponding to long long and unsigned long long.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.n/5</MarginText>
<MarginInfo items={["AI12-0219-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Added advice that const t* map to Ada <strong>in</strong> parameters and vice versa.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>84.o/5</MarginText>
<MarginInfo items={["AI12-0411-1"]} />
<Admonition type="aarm" aarm="note">
Added advice about mapping type Boolean. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_B.3.1"></a>

## B.3.1  The Package Interfaces.C.Strings

<MarginText>1/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>The package Interfaces.C.Strings declares types and subprograms allowing an Ada program to allocate, reference, update, and free C-style strings. In particular, the private type chars_ptr corresponds to a common use of &ldquo;char *&rdquo; in C programs, and an object of this type can be passed to a subprogram to which <strong>with</strong> Import ={">"} True, Convention ={">"} C has been specified, and for which &ldquo;char *&rdquo; is the type of the argument of the C function. <br /></p>


#### Static Semantics

<MarginText>2</MarginText>
<p>The library package Interfaces.C.Strings has the following declaration: <br /></p>

<MarginText>3/5</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
package Interfaces.C.Strings  {"\n"}   with  Preelaborate, Nonblocking, Global ={">"} in out synchronized is {"\n"}
<MarginText>4</MarginText>
   type char_array_access is access all char_array;{"\n"}
<MarginText>5/5</MarginText>
<MarginInfo items={["AI95-00161-01", "AI12-0399-1"]} />
   type chars_ptr is private {"\n"}      with  Preelaborable_Initialization ;{"\n"}
<MarginText>6/2</MarginText>
<MarginInfo items={["AI95-00276-01"]} />
   type chars_ptr_array is array (size_t range {"<"}{">"}) of aliased chars_ptr;{"\n"}
<MarginText>7</MarginText>
   Null_Ptr : constant chars_ptr;{"\n"}
<MarginText>8</MarginText>
   function To_Chars_Ptr (Item      : in char_array_access;{"\n"}                          Nul_Check : in Boolean := False){"\n"}      return chars_ptr;{"\n"}
<MarginText>9</MarginText>
   function New_Char_Array (Chars   : in char_array) return chars_ptr;{"\n"}
<MarginText>10</MarginText>
   function New_String (Str : in String) return chars_ptr;{"\n"}
<MarginText>11</MarginText>
   procedure Free (Item : in out chars_ptr);{"\n"}
<MarginText>12</MarginText>
   Dereference_Error : exception;{"\n"}
<MarginText>13</MarginText>
   function Value (Item : in chars_ptr) return char_array;{"\n"}
<MarginText>14</MarginText>
   function Value (Item : in chars_ptr; Length : in size_t){"\n"}      return char_array;{"\n"}
<MarginText>15</MarginText>
   function Value (Item : in chars_ptr) return String;{"\n"}
<MarginText>16</MarginText>
   function Value (Item : in chars_ptr; Length : in size_t){"\n"}      return String;{"\n"}
<MarginText>17</MarginText>
   function Strlen (Item : in chars_ptr) return size_t;{"\n"}
<MarginText>18</MarginText>
   procedure Update (Item   : in chars_ptr;{"\n"}                     Offset : in size_t;{"\n"}                     Chars  : in char_array;{"\n"}                     Check  : in Boolean := True);{"\n"}
<MarginText>19</MarginText>
   procedure Update (Item   : in chars_ptr;{"\n"}                     Offset : in size_t;{"\n"}                     Str    : in String;{"\n"}                     Check  : in Boolean := True);{"\n"}
<MarginText>20</MarginText>
   Update_Error : exception;{"\n"}
<MarginText>21</MarginText>
private{"\n"}   ... -- not specified by the language{"\n"}end Interfaces.C.Strings;{"\n"}

</CodeBlock>
<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The string manipulation types and subprograms appear in a child of Interfaces.C versus being there directly, since it is useful to have Interfaces.C specified as <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Pure.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b</MarginText>
<Admonition type="aarm" aarm="note">
Differently named functions New_String and New_Char_Array are declared, since if there were a single overloaded function a call with a string literal as actual parameter would be ambiguous. <br /></Admonition>
</AnnotatedOnly>

<MarginText>22</MarginText>
<p>The type chars_ptr is C-compatible and corresponds to the use of C's &ldquo;char *&rdquo; for a pointer to the first char in a char array terminated by nul. When an object of type chars_ptr is declared, its value is by default set to Null_Ptr, unless the object is imported (see <a href="../AA-B/AA-B.1">B.1</a>). <br /></p>

<AnnotatedOnly>
<MarginText>22.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>The type char_array_access is not necessarily C-compatible, since an object of this type may carry &ldquo;dope&rdquo; information. The programmer should convert from char_array_access to chars_ptr for objects imported from, exported to, or passed to C.<br /></Admonition>
</AnnotatedOnly>

<MarginText>23</MarginText>
<CodeBlock language="ada">
function To_Chars_Ptr (Item      : in char_array_access;{"\n"}                       Nul_Check : in Boolean := False){"\n"}   return chars_ptr;{"\n"}

</CodeBlock>
<MarginText>24/3</MarginText>
<MarginInfo items={["AI95-00140-01", "AI05-0264-1"]} />
<p>{"{"}<em>8652/0061</em>{"}"} If Item is <strong>null</strong>, then To_Chars_Ptr returns Null_Ptr. If Item is not <strong>null</strong>, Nul_Check is True, and Item.<strong>all</strong> does not contain nul, then the function propagates Terminator_Error; otherwise, To_Chars_Ptr performs a pointer conversion with no allocation of memory.<br /></p>

<MarginText>25</MarginText>
<CodeBlock language="ada">
function New_Char_Array (Chars   : in char_array) return chars_ptr;{"\n"}

</CodeBlock>
<MarginText>26</MarginText>
<p>This function returns a pointer to an allocated object initialized to Chars(Chars'First .. Index) & nul, where <br /></p>

<MarginText>27</MarginText>
<ul>
<li>Index = Chars'Last if Chars does not contain nul, or<br /></li>
<MarginText>28</MarginText>
<li>Index is the smallest size_t value I such that Chars(I+1) = nul. <br /></li>
</ul>
<MarginText>28.1</MarginText>
<p>Storage_Error is propagated if the allocation fails.<br /></p>

<MarginText>29</MarginText>
<CodeBlock language="ada">
function New_String (Str : in String) return chars_ptr;{"\n"}

</CodeBlock>
<MarginText>30</MarginText>
<p>This function is equivalent to New_Char_Array(To_C(Str)).<br /></p>

<MarginText>31</MarginText>
<CodeBlock language="ada">
procedure Free (Item : in out chars_ptr);{"\n"}

</CodeBlock>
<MarginText>32</MarginText>
<p>If Item is Null_Ptr, then Free has no effect. Otherwise, Free releases the storage occupied by Value(Item), and resets Item to Null_Ptr.<br /></p>

<MarginText>33</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars_ptr) return char_array;{"\n"}

</CodeBlock>
<MarginText>34/3</MarginText>
<MarginInfo items={["AI05-0264-1"]} />
<p>If Item = Null_Ptr, then Value propagates Dereference_Error. Otherwise, Value returns the prefix of the array of chars pointed to by Item, up to and including the first nul. The lower bound of the result is 0. If Item does not point to a nul-terminated string, then execution of Value is erroneous.<br /></p>

<MarginText>35</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars_ptr; Length : in size_t){"\n"}   return char_array;{"\n"}

</CodeBlock>
<MarginText>36/3</MarginText>
<MarginInfo items={["AI95-00139-01", "AI05-0264-1"]} />
<p>{"{"}<em>8652/0062</em>{"}"} If Item = Null_Ptr, then Value propagates Dereference_Error. Otherwise, Value returns the shorter of two arrays, either the first Length chars pointed to by Item, or Value(Item). The lower bound of the result is 0. If Length is 0, then Value propagates Constraint_Error. <br /></p>

<AnnotatedOnly>
<MarginText>36.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Value(New_Char_Array(Chars)) = Chars if Chars does not contain nul; else Value(New_Char_Array( Chars)) is the prefix of Chars up to and including the first nul. <br /></Admonition>
</AnnotatedOnly>

<MarginText>37</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars_ptr) return String;{"\n"}

</CodeBlock>
<MarginText>38</MarginText>
<p>Equivalent to To_Ada(Value(Item), Trim_Nul={">"}True).<br /></p>

<MarginText>39</MarginText>
<CodeBlock language="ada">
function Value (Item : in chars_ptr; Length : in size_t){"\n"}   return String;{"\n"}

</CodeBlock>
<MarginText>40/1</MarginText>
<MarginInfo items={["AI95-00177-01"]} />
<p>{"{"}<em>8652/0063</em>{"}"} Equivalent to To_Ada(Value(Item, Length) & nul, Trim_Nul={">"}True).<br /></p>

<MarginText>41</MarginText>
<CodeBlock language="ada">
function Strlen (Item : in chars_ptr) return size_t;{"\n"}

</CodeBlock>
<MarginText>42</MarginText>
<p>Returns <em>Val</em>'Length&ndash;1 where <em>Val</em> = Value(Item); propagates Dereference_Error if Item = Null_Ptr. <br /></p>

<AnnotatedOnly>
<MarginText>42.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>Strlen returns the number of chars in the array pointed to by Item, up to and including the char immediately before the first nul.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.b</MarginText>
<Admonition type="aarm" aarm="note">
Strlen has the same possibility for erroneous execution as Value, in cases where the string has not been nul-terminated.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>42.c</MarginText>
<Admonition type="aarm" aarm="note">
Strlen has the effect of C's strlen function. <br /></Admonition>
</AnnotatedOnly>

<MarginText>43</MarginText>
<CodeBlock language="ada">
procedure Update (Item   : in chars_ptr;{"\n"}                  Offset : in size_t;{"\n"}                  Chars  : in char_array;{"\n"}                  Check  : Boolean := True);{"\n"}

</CodeBlock>
<MarginText>44/1</MarginText>
<MarginInfo items={["AI95-00039-01"]} />
<p>{"{"}<em>8652/0064</em>{"}"} If Item = Null_Ptr, then Update propagates Dereference_Error. Otherwise, this procedure updates the value pointed to by Item, starting at position Offset, using Chars as the data to be copied into the array. Overwriting the nul terminator, and skipping with the Offset past the nul terminator, are both prevented if Check is True, as follows: <br /></p>

<MarginText>45</MarginText>
<ul>
<li>Let N = Strlen(Item). If Check is True, then: <br /></li>
</ul>
<MarginText>46</MarginText>
<ul>
<li>If Offset+Chars'Length{">"}N, propagate Update_Error.<br /></li>
<MarginText>47</MarginText>
<li>Otherwise, overwrite the data in the array pointed to by Item, starting at the char at position Offset, with the data in Chars. <br /></li>
</ul>
<MarginText>48</MarginText>
<ul>
<li>If Check is False, then processing is as above, but with no check that Offset+Chars'Length{">"}N. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>48.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>If Chars contains nul, Update's effect may be to &ldquo;shorten&rdquo; the pointed-to char array.<br /></Admonition>
</AnnotatedOnly>

<MarginText>49</MarginText>
<CodeBlock language="ada">
procedure Update (Item   : in chars_ptr;{"\n"}                  Offset : in size_t;{"\n"}                  Str    : in String;{"\n"}                  Check  : in Boolean := True);{"\n"}

</CodeBlock>
<MarginText>50/2</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<p>Equivalent to Update(Item, Offset, To_C(Str, Append_Nul ={">"} False), Check). <br /></p>

<AnnotatedOnly>
<MarginText>50.a/2</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<Admonition type="aarm" aarm="discussion">
<strong></strong>To truncate the Item to the length of Str, use Update(Item, Offset, To_C(Str), Check) instead of Update(Item, Offset, Str, Check). Note that when truncating Item, Item must be longer than Str. <br /></Admonition>
</AnnotatedOnly>


#### Erroneous Execution

<MarginText>51</MarginText>
<p>Execution of any of the following is erroneous if the Item parameter is not null_ptr and Item does not point to a nul-terminated array of chars. <br /></p>

<MarginText>52</MarginText>
<ul>
<li>a Value function not taking a Length parameter,<br /></li>
<MarginText>53</MarginText>
<li>the Free procedure,<br /></li>
<MarginText>54</MarginText>
<li>the Strlen function. <br /></li>
</ul>
<MarginText>55</MarginText>
<p>Execution of Free(X) is also erroneous if the chars_ptr X was not returned by New_Char_Array or New_String.<br /></p>

<MarginText>56</MarginText>
<p>Reading or updating a freed char_array is erroneous.<br /></p>

<MarginText>57</MarginText>
<p>Execution of Update is erroneous if Check is False and a call with Check equal to True would have propagated Update_Error. <br /></p>

<AnnotatedOnly>
<MarginText>58/5</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   New_Char_Array and New_String can  be implemented either through the allocation function from the C environment (&ldquo;malloc&rdquo;) or through Ada dynamic memory allocation (&ldquo;new&rdquo;). The key points are <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>59/5</MarginText>
<MarginInfo items={["AI12-0440-1"]} />
<ul>
<li>the returned value (a chars_ptr) is represented as a C &ldquo;char *&rdquo; so that it can  be passed to C functions;<br /></li>
<MarginText>60/5</MarginText>
<MarginInfo items={["AI12-0442-1"]} />
<li>the allocated object can  be freed by the programmer via a call of Free, rather than by calling a  C function. <br /></li>
</ul>
</AnnotatedOnly>
<AnnotatedOnly>

#### Inconsistencies With Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.a/2</MarginText>
<MarginInfo items={["AI95-00242-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Update for a String parameter is now defined to not add a nul character. It did add a nul in Ada 95. This means that programs that used this behavior of Update to truncate a string will no longer work (the string will not be truncated). This change makes Update for a string consistent with Update for a char_array (no implicit nul is added to the end of a char_array). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.b/2</MarginText>
<MarginInfo items={["AI95-00161-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> Added <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Preelaborable_Initialization to type chars_ptr, so that it can be used in preelaborated units.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.c/2</MarginText>
<MarginInfo items={["AI95-00276-01"]} />
<Admonition type="aarm" aarm="correction">
<strong>Amendment </strong> The components of chars_ptr_array are aliased so that it can be used to instantiate Interfaces.C.Pointers (that is its intended purpose, which is otherwise mysterious as it has no operations). <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>60.d/2</MarginText>
<MarginInfo items={["AI95-00140-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0061</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of To_Char_Ptr when Nul_Check is False.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.e/2</MarginText>
<MarginInfo items={["AI95-00139-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0062</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of Value when the Length is 0.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.f/2</MarginText>
<MarginInfo items={["AI95-00177-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0063</em>{"}"} <strong>Corrigendum:</strong> Corrected the definition of Value to avoid raising Terminator_Error.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>60.g/2</MarginText>
<MarginInfo items={["AI95-00039-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<em>8652/0064</em>{"}"} <strong>Corrigendum:</strong> Fixed the missing semantics of Update when Item is Null_Ptr. <br /></Admonition>
</AnnotatedOnly>

<a id="Subclause_B.3.2"></a>

## B.3.2  The Generic Package Interfaces.C.Pointers

<MarginText>1</MarginText>
<p>The generic package Interfaces.C.Pointers allows the Ada programmer to perform C-style operations on pointers. It includes an access type Pointer, Value functions that dereference a Pointer and deliver the designated array, several pointer arithmetic operations, and &ldquo;copy&rdquo; procedures that copy the contents of a source pointer into the array designated by a destination pointer. As in C, it treats an object Ptr of type Pointer as a pointer to the first element of an array, so that for example, adding 1 to Ptr yields a pointer to the second element of the array.<br /></p>

<MarginText>2/5</MarginText>
<MarginInfo items={["AI12-0445-1"]} />
<p>The generic allows two styles of usage: one in which the array is terminated by a special terminator element; and another in which the programmer keeps  track of the length. <br /></p>


#### Static Semantics

<MarginText>3</MarginText>
<p>The generic library package Interfaces.C.Pointers has the following declaration: <br /></p>

<MarginText>4/5</MarginText>
<MarginInfo items={["AI12-0241-1", "AI12-0302-1"]} />
<CodeBlock language="ada">
generic{"\n"}   type Index is ({"<"}{">"});{"\n"}   type Element is private;{"\n"}   type Element_Array is array (Index range {"<"}{">"}) of aliased Element;{"\n"}   Default_Terminator : Element;{"\n"}package Interfaces.C.Pointers  {"\n"}   with  Preelaborate, Nonblocking, Global ={">"} in out synchronized is {"\n"}
<MarginText>5</MarginText>
   type Pointer is access all Element;{"\n"}
<MarginText>6</MarginText>
   function Value(Ref        : in Pointer;{"\n"}                  Terminator : in Element := Default_Terminator){"\n"}      return Element_Array;{"\n"}
<MarginText>7</MarginText>
   function Value(Ref    : in Pointer;{"\n"}                  Length : in ptrdiff_t){"\n"}      return Element_Array;{"\n"}
<MarginText>8</MarginText>
   Pointer_Error : exception;{"\n"}
<MarginText>9</MarginText>
   -- C-style Pointer arithmetic{"\n"}
<MarginText>10/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   function "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer{"\n"}      with Convention ={">"} Intrinsic;{"\n"}   function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff_t{"\n"}      with Convention ={">"} Intrinsic;{"\n"}
<MarginText>11/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
   procedure Increment (Ref : in out Pointer){"\n"}      with Convention ={">"} Intrinsic;{"\n"}   procedure Decrement (Ref : in out Pointer){"\n"}      with Convention ={">"} Intrinsic;{"\n"}
<MarginText>12/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
This paragraph was deleted.{"\n"}
<MarginText>13</MarginText>
   function Virtual_Length (Ref        : in Pointer;{"\n"}                            Terminator : in Element := Default_Terminator){"\n"}      return ptrdiff_t;{"\n"}
<MarginText>14</MarginText>
   procedure Copy_Terminated_Array{"\n"}      (Source     : in Pointer;{"\n"}       Target     : in Pointer;{"\n"}       Limit      : in ptrdiff_t := ptrdiff_t'Last;{"\n"}       Terminator : in Element :=  Default_Terminator);{"\n"}
<MarginText>15</MarginText>
   procedure Copy_Array (Source  : in Pointer;{"\n"}                         Target  : in Pointer;{"\n"}                         Length  : in ptrdiff_t);{"\n"}
<MarginText>16</MarginText>
end Interfaces.C.Pointers;{"\n"}

</CodeBlock>
<MarginText>17</MarginText>
<p>The type Pointer is C-compatible and corresponds to one use of C's &ldquo;Element *&rdquo;. An object of type Pointer is interpreted as a pointer to the initial Element in an Element_Array. Two styles are supported: <br /></p>

<MarginText>18</MarginText>
<ul>
<li>Explicit termination of an array value with Default_Terminator (a special terminator value);<br /></li>
<MarginText>19</MarginText>
<li>Programmer-managed length, with Default_Terminator treated simply as a data element. <br /></li>
</ul>
<MarginText>20</MarginText>
<CodeBlock language="ada">
function Value(Ref        : in Pointer;{"\n"}               Terminator : in Element := Default_Terminator){"\n"}   return Element_Array;{"\n"}

</CodeBlock>
<MarginText>21</MarginText>
<p>This function returns an Element_Array whose value is the array pointed to by Ref, up to and including the first Terminator; the lower bound of the array is Index'First. Interfaces.C.Strings.Dereference_Error is propagated if Ref is <strong>null</strong>.<br /></p>

<MarginText>22</MarginText>
<CodeBlock language="ada">
function Value(Ref    : in Pointer;{"\n"}               Length : in ptrdiff_t){"\n"}   return Element_Array;{"\n"}

</CodeBlock>
<MarginText>23</MarginText>
<p>This function returns an Element_Array comprising the first Length elements pointed to by Ref. The exception Interfaces.C.Strings.Dereference_Error is propagated if Ref is <strong>null</strong>. <br /></p>

<MarginText>24</MarginText>
<p>The "+" and "&ndash;" functions perform arithmetic on Pointer values, based on the Size of the array elements. In each of these functions, Pointer_Error is propagated if a Pointer parameter is <strong>null</strong>. <br /></p>

<MarginText>25</MarginText>
<CodeBlock language="ada">
procedure Increment (Ref : in out Pointer);{"\n"}

</CodeBlock>
<MarginText>26</MarginText>
<p>Equivalent to Ref := Ref+1.<br /></p>

<MarginText>27</MarginText>
<CodeBlock language="ada">
procedure Decrement (Ref : in out Pointer);{"\n"}

</CodeBlock>
<MarginText>28</MarginText>
<p>Equivalent to Ref := Ref&ndash;1.<br /></p>

<MarginText>29</MarginText>
<CodeBlock language="ada">
function Virtual_Length (Ref        : in Pointer;{"\n"}                         Terminator : in Element := Default_Terminator){"\n"}   return ptrdiff_t;{"\n"}

</CodeBlock>
<MarginText>30</MarginText>
<p>Returns the number of Elements, up to the one just before the first Terminator, in Value(Ref, Terminator).<br /></p>

<MarginText>31</MarginText>
<CodeBlock language="ada">
procedure Copy_Terminated_Array{"\n"}   (Source     : in Pointer;{"\n"}    Target     : in Pointer;{"\n"}    Limit      : in ptrdiff_t := ptrdiff_t'Last;{"\n"}    Terminator : in Element := Default_Terminator);{"\n"}

</CodeBlock>
<MarginText>32</MarginText>
<p>This procedure copies Value(Source, Terminator) into the array pointed to by Target; it stops either after Terminator has been copied, or the number of elements copied is Limit, whichever occurs first. Dereference_Error is propagated if either Source or Target is <strong>null</strong>. <br /></p>

<AnnotatedOnly>
<MarginText>32.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>It is the programmer's responsibility to ensure that elements are not copied beyond the logical length of the target array. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.b</MarginText>
<Admonition type="aarm" aarm="implementation-note">
<strong></strong>The implementation has to take care to check the Limit first. <br /></Admonition>
</AnnotatedOnly>

<MarginText>33</MarginText>
<CodeBlock language="ada">
procedure Copy_Array (Source  : in Pointer;{"\n"}                      Target  : in Pointer;{"\n"}                      Length  : in ptrdiff_t);{"\n"}

</CodeBlock>
<MarginText>34</MarginText>
<p>This procedure copies the first Length elements from the array pointed to by Source, into the array pointed to by Target. Dereference_Error is propagated if either Source or Target is <strong>null</strong>. <br /></p>


#### Erroneous Execution

<MarginText>35</MarginText>
<p>It is erroneous to dereference a Pointer that does not designate an aliased Element. <br /></p>

<AnnotatedOnly>
<MarginText>35.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>Such a Pointer could arise via "+", "&ndash;", Increment, or Decrement.<br /></Admonition>
</AnnotatedOnly>

<MarginText>36</MarginText>
<p>Execution of Value(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element_Array terminated by Terminator.<br /></p>

<MarginText>37</MarginText>
<p>Execution of Value(Ref, Length) is erroneous if Ref does not designate an aliased Element in an Element_Array containing at least Length Elements between the designated Element and the end of the array, inclusive.<br /></p>

<MarginText>38</MarginText>
<p>Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element_Array terminated by Terminator.<br /></p>

<MarginText>39</MarginText>
<p>Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is erroneous in either of the following situations: <br /></p>

<MarginText>40</MarginText>
<ul>
<li>Execution of both Value(Source, Terminator) and Value(Source, Limit) are erroneous, or<br /></li>
<MarginText>41</MarginText>
<li>Copying writes past the end of the array containing the Element designated by Target. <br /></li>
</ul>
<MarginText>42</MarginText>
<p>Execution of Copy_Array(Source, Target, Length) is erroneous if either Value(Source, Length) is erroneous, or copying writes past the end of the array containing the Element designated by Target. <br /></p>

<AnnotatedOnly>
<MarginText>43</MarginText>
<Admonition type="aarm" aarm="note">
NOTE   To compose a Pointer from an Element_Array, use 'Access on the first element. For example (assuming appropriate instantiations): <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>44</MarginText>
<CodeBlock language="ada">
Some_Array   : Element_Array(0..5) ;{"\n"}Some_Pointer : Pointer := Some_Array(0)'Access;{"\n"}

</CodeBlock>
</AnnotatedOnly>

#### Examples

<MarginText>45</MarginText>
<p><em>Example of Interfaces.C.Pointers:</em> <br /></p>

<MarginText>46</MarginText>
<CodeBlock language="ada">
with Interfaces.C.Pointers;{"\n"}with Interfaces.C.Strings;{"\n"}procedure Test_Pointers is{"\n"}   package C renames Interfaces.C;{"\n"}   package Char_Ptrs is{"\n"}      new C.Pointers (Index              ={">"} C.size_t,{"\n"}                      Element            ={">"} C.char,{"\n"}                      Element_Array      ={">"} C.char_array,{"\n"}                      Default_Terminator ={">"} C.nul);{"\n"}
<MarginText>47</MarginText>
   use type Char_Ptrs.Pointer;{"\n"}   subtype Char_Star is Char_Ptrs.Pointer;{"\n"}
<MarginText>48</MarginText>
   procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is{"\n"}      Target_Temp_Ptr : Char_Star := Target_Ptr;{"\n"}      Source_Temp_Ptr : Char_Star := Source_Ptr;{"\n"}      Element : C.char;{"\n"}   begin{"\n"}      if Target_Temp_Ptr = null or Source_Temp_Ptr = null then{"\n"}         raise C.Strings.Dereference_Error;{"\n"}      end if;{"\n"}
<MarginText>49/1</MarginText>
<MarginInfo items={["AI95-00142-01"]} />
{"{"}8652/0065{"}"}       loop{"\n"}         Element             := Source_Temp_Ptr.all;{"\n"}         Target_Temp_Ptr.all := Element;{"\n"}         exit when C."="(Element, C.nul);{"\n"}         Char_Ptrs.Increment(Target_Temp_Ptr);{"\n"}         Char_Ptrs.Increment(Source_Temp_Ptr);{"\n"}      end loop;{"\n"}   end Strcpy;{"\n"}begin{"\n"}   ...{"\n"}end Test_Pointers;{"\n"}
<a id="Subclause_B.3.3"></a>

</CodeBlock>

## B.3.3  Unchecked Union Types

<MarginText>1/3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0229-1", "AI05-0269-1"]} />
<p>[Specifying aspect Unchecked_Union to have the value True defines an interface correspondence between a given discriminated type and some C union. The aspect requires that the associated type shall be given a representation that allocates no space for its discriminant(s).] <br /></p>

<p><em>Paragraphs 2 through 3 were moved to <a href="../AA-J/">Annex J</a>, &ldquo;<a href="../AA-J/">Obsolescent Features</a>&rdquo;.</em> <br /></p>


#### Static Semantics

<MarginText>3.1/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<p>For a discriminated record type having a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code>, the following language-defined representation aspect may be specified:<br /></p>

<MarginText>3.2/3</MarginText>
<dt><br/>Unchecked_Union</dt>
<dl>
<dd>The type of aspect Unchecked_Union is Boolean. If directly specified, the <code><a href="../AA-13/AA-13.1#S0348">aspect_definition</a></code> shall be a static expression. If not specified (including by inheritance), the aspect is False.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>3.a/3</MarginText>
<Admonition type="aarm" aarm="note">
<strong>Aspect Description for </strong><strong>Unchecked_Union: </strong>Type is used to interface to a C union type.<br /></Admonition>
</AnnotatedOnly>


#### Legality Rules

<p><em>Paragraphs 4 and 5 were deleted.</em> <br /></p>

<MarginText>6/3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0229-1"]} />
<p>A type for which aspect Unchecked_Union is True is called an <em>unchecked union type</em>. A subtype of an unchecked union type is defined to be an <em>unchecked union subtype</em>. An object of an unchecked union type is defined to be an <em>unchecked union object</em>.<br /></p>

<MarginText>7/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>All component subtypes of an unchecked union type shall be C-compatible.<br /></p>

<MarginText>8/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>If a component subtype of an unchecked union type is subject to a per-object constraint, then the component subtype shall be an unchecked union subtype.<br /></p>

<MarginText>9/5</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0026-1", "AI12-0174-1"]} />
<p>Any name that denotes a discriminant of an object of an unchecked union type shall occur within the declarative region of the type or as the <code><a href="../AA-4/AA-4.1#S0099">selector_name</a></code> of an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code>, and shall not occur within a <code><a href="../AA-13/AA-13.5#S0352">record_representation_clause</a></code>.<br /></p>

<MarginText>10/3</MarginText>
<MarginInfo items={["AI95-00216-01", "AI05-0026-1"]} />
<p>The type of a component declared in a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code> of an unchecked union type shall not need finalization. In addition to the places where Legality Rules normally apply (see <a href="../AA-12/AA-12.3">12.3</a>), this rule also applies in the private part of an instance of a generic unit. For an unchecked union type declared within the body of a generic unit, or within the body of any of its descendant library units, no part of the type of a component declared in a <code><a href="../AA-3/AA-3.8#S0071">variant_part</a></code> of the unchecked union type shall be of a formal private type or formal private extension declared within the formal part of the generic unit.<br /></p>

<AnnotatedOnly>
<MarginText>10.a/3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="reason">
<strong></strong>The last part is a classic assume-the-worst rule that avoids dependence on the actuals in a generic body. We did not include this in the definition of &ldquo;needs finalization&rdquo; as it has a bad interaction with the use of that term for the No_Nested_Finalization restriction. <br /></Admonition>
</AnnotatedOnly>

<MarginText>11/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>The completion of an incomplete or private type declaration having a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code> shall not be an unchecked union type.<br /></p>

<MarginText>12/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An unchecked union subtype shall only be passed as a generic actual parameter if the corresponding formal type has no known discriminants or is an unchecked union type.<br /></p>

<AnnotatedOnly>
<MarginText>12.a/2</MarginText>
<Admonition type="aarm" aarm="ramification">
<strong></strong>This includes formal private types without a <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>, formal derived types that do not inherit any discriminants (formal derived types do not have <code><a href="../AA-3/AA-3.7#S0061">known_discriminant_part</a></code>s), and formal derived types that are unchecked union types. <br /></Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>13/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An unchecked union type is eligible for convention C.<br /></p>

<MarginText>14/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>All objects of an unchecked union type have the same size.<br /></p>

<MarginText>15/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Discriminants of objects of an unchecked union type are of size zero.<br /></p>

<MarginText>16/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Any check which would require reading a discriminant of an unchecked union object is suppressed (see <a href="../AA-11/AA-11.5">11.5</a>). These checks include:<br /></p>

<MarginText>17/5</MarginText>
<MarginInfo items={["AI12-0453-1"]} />
<ul>
<li>The check performed when addressing a variant component (that is , a component that was declared in a variant part) of an unchecked union object that the object has this component (see <a href="../AA-4/AA-4.1#Subclause_4.1.3">4.1.3</a>).<br /></li>
<MarginText>18/2</MarginText>
<li>Any checks associated with a type or subtype conversion of a value of an unchecked union type (see <a href="../AA-4/AA-4.6">4.6</a>). This includes, for example, the check associated with the implicit subtype conversion of an assignment statement.<br /></li>
<MarginText>19/2</MarginText>
<li>The subtype membership check associated with the evaluation of a qualified expression (see <a href="../AA-4/AA-4.7">4.7</a>) or an uninitialized allocator (see <a href="../AA-4/AA-4.8">4.8</a>). <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>19.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<strong></strong>If a suppressed check would have failed, execution is erroneous (see <a href="../AA-11/AA-11.5">11.5</a>). An implementation is always allowed to make a suppressed check if it can somehow determine the discriminant value. <br /></Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>20/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>A view of an unchecked union object (including a type conversion or function call) has <em>inferable discriminants</em> if it has a constrained nominal subtype, unless the object is a component of an enclosing unchecked union object that is subject to a per-object constraint and the enclosing object lacks inferable discriminants.<br /></p>

<MarginText>21/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>An expression of an unchecked union type has inferable discriminants if it is either a name of an object with inferable discriminants or a qualified expression whose <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> denotes a constrained subtype.<br /></p>

<MarginText>22/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<p>Program_Error is raised in the following cases:<br /></p>

<MarginText>23/2</MarginText>
<ul>
<li>Evaluation of the predefined equality operator for an unchecked union type if either of the operands lacks inferable discriminants.<br /></li>
<MarginText>24/2</MarginText>
<li>Evaluation of the predefined equality operator for a type which has a subcomponent of an unchecked union type whose nominal subtype is unconstrained.<br /></li>
<MarginText>25/5</MarginText>
<MarginInfo items={["AI12-0162-1"]} />
<li>Evaluation of an individual  membership test if the <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code> (if any) denotes a constrained unchecked union subtype and the <em>tested_</em><code><a href="../AA-4/AA-4.4#S0138">simple_expression</a></code>  lacks inferable discriminants.<br /></li>
<MarginText>26/2</MarginText>
<li>Conversion from a derived unchecked union type to an unconstrained non-unchecked-union type if the operand of the conversion lacks inferable discriminants.<br /></li>
<MarginText>27/2</MarginText>
<li>Execution of the default implementation of the Write or Read attribute of an unchecked union type.<br /></li>
<MarginText>28/2</MarginText>
<li>Execution of the default implementation of the Output or Input attribute of an unchecked union type if the type lacks default discriminant values. <br /></li>
</ul>
<p><em>Paragraph 29 was deleted.</em> <br /></p>

<AnnotatedOnly>
<MarginText>30/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
NOTE   The use of an unchecked union to obtain the effect of an unchecked conversion results in erroneous execution (see <a href="../AA-11/AA-11.5">11.5</a>). Execution of the following example is erroneous even if Float'Size = Integer'Size:<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>31/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<CodeBlock language="ada">
type T (Flag : Boolean := False) is{"\n"}   record{"\n"}       case Flag is{"\n"}           when False ={">"}{"\n"}               F1 : Float := 0.0;{"\n"}           when True ={">"}{"\n"}               F2 : Integer := 0;{"\n"}       end case;{"\n"}    end record{"\n"}    with Unchecked_Union;{"\n"}
<MarginText>32/2</MarginText>
X : T;{"\n"}Y : Integer := X.F2; -- erroneous{"\n"}

</CodeBlock>
</AnnotatedOnly>
<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.a/2</MarginText>
<MarginInfo items={["AI95-00216-01"]} />
<Admonition type="aarm" aarm="note">
<code><a href="../AA-2/AA-2.8#S0019">Pragma</a></code> Unchecked_Union is new. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.b/3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> The use of discriminants on Unchecked_Union types is now illegal in <code><a href="../AA-13/AA-13.5#S0352">record_representation_clause</a></code>s, as it makes no sense to specify a position for something that is not supposed to exist. It is very unlikely that this change will have any impact on existing code. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.c/3</MarginText>
<MarginInfo items={["AI05-0229-1"]} />
<Admonition type="aarm" aarm="note">
Aspect Unchecked_Union is new; <code><a href="../AA-2/AA-2.8#S0019">pragma</a></code> Unchecked_Union is now obsolescent. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.d/3</MarginText>
<MarginInfo items={["AI05-0026-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Revised the rules to use the &ldquo;needs finalization&rdquo; definition, and eliminated generic contract issues. <br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>32.e/5</MarginText>
<MarginInfo items={["AI05-0162-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Adjusted the wording to reflect that membership tests can have more than one expression or <code><a href="../AA-3/AA-3.2#S0028">subtype_mark</a></code>.<br /></Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>32.f/5</MarginText>
<MarginInfo items={["AI05-0174-1"]} />
<Admonition type="aarm" aarm="correction">
<strong></strong> Adjusted the wording to allow named aggregates of an unchecked union type; it is clearly madness to allow positional record components in an <code><a href="../AA-4/AA-4.3#S0106">aggregate</a></code> but not named component associations. <br /></Admonition>
</AnnotatedOnly>

