---
sidebar_position:  189
---

# H.4. High Integrity Restrictions

:::danger
This Reference Manual output has not been verified,
and may contain omissions or errors.
Report any problems on the [tracking issue](https://github.com/ada-lang-io/ada-lang-io/issues/20)
:::

import Admonition from "@theme/Admonition";
import AnnotatedOnly from "@site/src/components/AnnotatedOnly";
import CodeBlock from "@theme/CodeBlock";
import MarginText from "@site/src/components/MarginText";
import MarginInfo from "@site/src/components/MarginInfo";

<MarginText>1/3</MarginText>
<MarginInfo items={["AI05-0299-1"]} />
<p>This subclause defines restrictions that can be used with pragma Restrictions (see <a href="/docs/arm/AA-13/AA-13.12">13.12</a>); these facilitate the demonstration of program correctness by allowing tailored versions of the run-time system. <br /></p>

<AnnotatedOnly>
<MarginText>1.a/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>Note that the restrictions are absolute. If a partition has 100 library units and just one needs Unchecked{"_"}Conversion, then the pragma cannot be used to ensure the other 99 units do not use Unchecked{"_"}Conversion. Note also that these are restrictions on all Ada code within a partition, and therefore it might not be evident from the specification of a package whether a restriction can be imposed.<br />
</Admonition>
</AnnotatedOnly>


#### Static Semantics

<MarginText>2/2</MarginText>
<MarginInfo items={["AI95-00347-01", "AI95-00394-01"]} />
<p><i>This paragraph was deleted.</i><br /></p>

<MarginText>3/2</MarginText>
<MarginInfo items={["AI95-00394-01"]} />
<p>The following <i>restriction{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code>s are language defined:<br /></p>

<MarginText>4</MarginText>
<p><b>Tasking-related restriction:</b><br /></p>

<MarginText>5</MarginText>
<dt><br/>No{"_"}Protected{"_"}Types </dt>
<dl>
<dd>There are no declarations of protected types or protected objects. <br /></dd>
</dl>
<MarginText>6</MarginText>
<p><b>Memory-management related restrictions:</b><br /></p>

<MarginText>7</MarginText>
<dt><br/>No{"_"}Allocators </dt>
<dl>
<dd>There are no occurrences of an <code><a href="/docs/arm/AA-4/AA-4.8#S0164">allocator</a></code>.<br /></dd>
<MarginText>8/1</MarginText>
<MarginInfo items={["AI95-00130"]} />
<dt><br/>{"{"}<i>8652/0042</i>{"}"} No{"_"}Local{"_"}Allocators </dt>
<dd><code><a href="/docs/arm/AA-4/AA-4.8#S0164">Allocator</a></code>s are prohibited in subprograms, generic subprograms, tasks, and entry bodies. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>8.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Thus <code><a href="/docs/arm/AA-4/AA-4.8#S0164">allocator</a></code>s are permitted only in expressions whose evaluation can only be performed before the main subprogram is invoked. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>8.b/1</MarginText>
<MarginInfo items={["AI95-00130"]} />
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i>{"{"}<i>8652/0042</i>{"}"} <br />
</Admonition>
</AnnotatedOnly>

<MarginText>8.1/3</MarginText>
<MarginInfo items={["AI05-0152-1", "AI05-0262-1"]} />
<dt><br/>No{"_"}Anonymous{"_"}Allocators </dt>
<dl>
<dd>There are no <code><a href="/docs/arm/AA-4/AA-4.8#S0164">allocator</a></code>s of anonymous access types.<br /></dd>
<MarginText>8.2/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<dt><br/>No{"_"}Coextensions </dt>
<dd>There are no coextensions. See <a href="/docs/arm/AA-3/AA-3.10#Subclause_3.10.2">3.10.2</a>.<br /></dd>
<MarginText>8.3/3</MarginText>
<MarginInfo items={["AI05-0190-1"]} />
<dt><br/>No{"_"}Access{"_"}Parameter{"_"}Allocators </dt>
<dd><code><a href="/docs/arm/AA-4/AA-4.8#S0164">Allocator</a></code>s are not permitted as the actual parameter to an access parameter. See <a href="/docs/arm/AA-6/AA-6.1">6.1</a>.<br /></dd>
<MarginText>9/2</MarginText>
<dt><br/></dt>
<MarginInfo items={["AI95-00394-01"]} />
<dd><i>This paragraph was deleted.</i><br /></dd>
<MarginText>10</MarginText>
<dt><br/>Immediate{"_"}Reclamation </dt>
<dd>Except for storage occupied by objects created by <code><a href="/docs/arm/AA-4/AA-4.8#S0164">allocator</a></code>s and not deallocated via unchecked deallocation, any storage reserved at run time for an object is immediately reclaimed when the object no longer exists. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>10.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Immediate reclamation would apply to storage created by the compiler, such as for a return value from a function whose size is not known at the call site. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>11</MarginText>
<p><b>Exception-related restriction:</b><br /></p>

<MarginText>12/5</MarginText>
<MarginInfo items={["AI12-0344-1"]} />
<dt><br/>No{"_"}Exceptions </dt>
<dl>
<dd><code><a href="/docs/arm/AA-11/AA-11.3#S0308">Raise_statement</a></code>s and <code><a href="/docs/arm/AA-11/AA-11.2#S0305">exception_handler</a></code>s are not allowed. No language-defined runtime checks are generated; however, a runtime check performed automatically by the hardware is permitted. The callable entity associated with a <code><a href="/docs/arm/AA-5/AA-5.5#S0185">procedural_iterator</a></code> (see <a href="/docs/arm/AA-5/AA-5.5#Subclause_5.5.3">5.5.3</a>) is considered to not allow exit, independent of the value of its Allows{"_"}Exit aspect.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>12.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>This restriction mirrors a method of working that is quite common in the safety area. The programmer is required to show that exceptions cannot be raised. Then a simplified run-time system is used without exception handling. However, some hardware checks may still be enforced. If the software check would have failed, or if the hardware check actually fails, then the execution of the program is unpredictable. There are obvious dangers in this approach, but it is similar to programming at the assembler level.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>13</MarginText>
<p><b>Other restrictions:</b><br /></p>

<MarginText>14</MarginText>
<dt><br/>No{"_"}Floating{"_"}Point </dt>
<dl>
<dd>Uses of predefined floating point types and operations, and declarations of new floating point types, are not allowed. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>14.a/2</MarginText>
<MarginInfo items={["AI95-00114-01"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The intention is to avoid the use of floating point hardware at run time, but this is expressed in language terms. It is conceivable that floating point is used implicitly in some contexts, say fixed point type conversions of high accuracy. However, the Implementation Requirements below make it clear that the restriction would apply to the &ldquo;run-time system&rdquo; and hence not be allowed. This restriction could be used to inform a compiler that a variant of the architecture is being used which does not have floating point instructions.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>15</MarginText>
<dt><br/>No{"_"}Fixed{"_"}Point </dt>
<dl>
<dd>Uses of predefined fixed point types and operations, and declarations of new fixed point types, are not allowed. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>15.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>This restriction would have the side effect of prohibiting the <code><a href="/docs/arm/AA-9/AA-9.6#S0268">delay_relative_statement</a></code>. As with the No{"_"}Floating{"_"}Point restriction, this might be used to avoid any question of rounding errors. Unless an Ada run-time is written in Ada, it seems hard to rule out implicit use of fixed point, since at the machine level, fixed point is virtually the same as integer arithmetic.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>16/2</MarginText>
<dt><br/></dt>
<MarginInfo items={["AI95-00394-01"]} />
<dl>
<dd><i>This paragraph was deleted.</i><br /></dd>
<MarginText>17</MarginText>
<dt><br/>No{"_"}Access{"_"}Subprograms </dt>
<dd>The declaration of access-to-subprogram types is not allowed. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>17.a.1/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Most critical applications would require some restrictions or additional validation checks on uses of access-to-subprogram types. If the application does not require the functionality, then this restriction provides a means of ensuring the design requirement has been satisfied. The same applies to several of the following restrictions, and to restriction No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Conversion. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>18</MarginText>
<dt><br/>No{"_"}Unchecked{"_"}Access </dt>
<dl>
<dd>The Unchecked{"_"}Access attribute is not allowed.<br /></dd>
<MarginText>19</MarginText>
<dt><br/>No{"_"}Dispatch </dt>
<dd>Occurrences of T'Class are not allowed, for any (tagged) subtype T.<br /></dd>
<MarginText>20/5</MarginText>
<MarginInfo items={["AI95-00285-01", "AI12-0318-1"]} />
<dt><br/>No{"_"}IO </dt>
<dd>Semantic dependence on any of the library units Sequential{"_"}IO, Direct{"_"}IO, Text{"_"}IO, Wide{"_"}Text{"_"}IO, Wide{"_"}Wide{"_"}Text{"_"}IO, Stream{"_"}IO, or Directories is not allowed. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>20.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>Excluding the input-output facilities of an implementation may be needed in those environments which cannot support the supplied functionality. A program in such an environment is likely to require some low level facilities or a call on a non-Ada feature.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>21</MarginText>
<dt><br/>No{"_"}Delay </dt>
<dl>
<dd><code><a href="/docs/arm/AA-9/AA-9.6#S0266">Delay_Statement</a></code>s and semantic dependence on package Calendar are not allowed. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>21.a</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>This implies that <code><a href="/docs/arm/AA-9/AA-9.7#S0274">delay_alternative</a></code>s in a <code><a href="/docs/arm/AA-9/AA-9.7#S0269">select_statement</a></code> are prohibited.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>21.b</MarginText>
<Admonition type="aarm" aarm="note">
The purpose of this restriction is to avoid the need for timing facilities within the run-time system.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>22</MarginText>
<dt><br/>No{"_"}Recursion </dt>
<dl>
<dd>As part of the execution of a subprogram, the same subprogram is not invoked.<br /></dd>
<MarginText>23</MarginText>
<dt><br/>No{"_"}Reentrancy </dt>
<dd>During the execution of a subprogram by a task, no other task invokes the same subprogram.<br /></dd>
<MarginText>23.1/5</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<dt><br/>No{"_"}Unspecified{"_"}Globals</dt>
<dd>No library-level entity shall have a Global aspect of Unspecified, either explicitly or by default. No library-level entity shall have a Global'Class aspect of Unspecified, explicitly or by default, if it is used as part of a dispatching call.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>23.a/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>Global'Class need not be specified on an operation if there are no dispatching calls to the operation, or if all of the dispatching calls are covered by <code><a href="/docs/arm/AA-H/AA-H.7#S0366">dispatching_operation_specifier</a></code>s for operations with such calls (see <a href="/docs/arm/AA-H/AA-H.7">H.7</a>). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>23.2/5</MarginText>
<MarginInfo items={["AI12-0079-3", "AI12-0380-1"]} />
<dt><br/>No{"_"}Hidden{"_"}Indirect{"_"}Globals</dt>
<dl>
<dd>When within a context where an applicable global aspect is neither Unspecified nor <b>in out all</b>, any execution within such a context does neither of the following:<br /></dd>
</dl>
<MarginText>23.3/5</MarginText>
<ul>
<li>Update (or return a writable reference to) a variable that is reachable via a sequence of zero or more dereferences of access-to-object values from a parameter of a visibly access-to-constant type, from a part of a non-access-type formal parameter of mode <b>in</b> (after any <b>overriding</b> &ndash; see <a href="/docs/arm/AA-H/AA-H.7">H.7</a>), or from a global that has mode <b>in</b> or is not within the applicable global variable set, unless the initial dereference is of a part of a formal parameter or global that is visibly of an access-to-variable type;<br /></li>
<MarginText>23.4/5</MarginText>
<li>Read (or return a readable reference to) a variable that is reachable via a sequence of zero or more dereferences of access-to-object values from a global that is not within the applicable global variable set, unless the initial dereference is of a part of a formal parameter or global that is visibly of an access-to-object type. <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>23.b/5</MarginText>
<Admonition type="aarm" aarm="ramification">
<b></b>The above two rules specify that any hidden indirect references are covered by the global or formal parameter modes that apply, and are <i>not</i> subject to alternative paths of access (such as aliasing) that could result in conflicts. On the other hand, any visible access-to-object parts are allowed to designate objects that are accessible via other means, and side-effects on such objects are permitted if the value is visibly of an access-to-variable type. Such effects do not need to be covered by the applicable global aspect(s), but are rather for the caller to worry about. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>23.5/5</MarginText>
<dl>
<dd>For the purposes of the above rules:<br /></dd>
</dl>
<MarginText>23.6/5</MarginText>
<ul>
<li>a part of an object is <i>visibly of an access type</i> if the type of the object is declared immediately within the visible part of a package specification, and at the point of declaration of the type the part is visible and of an access type;<br /></li>
<MarginText>23.7/5</MarginText>
<li>a function <i>returns a writable reference to V</i> if it returns a result with a part that is visibly of an access-to-variable type designating <i>V</i>; similarly, a function <i>returns a readable reference to V</i> if it returns a result with a part that is visibly of an access-to-constant type designating <i>V</i>;<br /></li>
<MarginText>23.8/5</MarginText>
<li>if an applicable global variable set includes a package name, and the collection of some pool-specific access type (see <a href="/docs/arm/AA-7/AA-7.6#Subclause_7.6.1">7.6.1</a>) is implicitly declared in a part of the declarative region of the package included within the global variable set, then all objects allocated from that collection are considered included within the global variable set. <br /></li>
</ul>
<MarginText>23.9/5</MarginText>
<dl>
<dd>The consequences of violating the No{"_"}Hidden{"_"}Indirect{"_"}Globals restriction is implementation-defined. Any aspects or other means for identifying such violations prior to or during execution are implementation-defined. <br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>23.b.1/5</MarginText>
<Admonition type="aarm" aarm="implementation-defined">
<b></b>The consequences of violating No{"_"}Hidden{"_"}Indirect{"_"}Globals.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>23.c/5</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>We do not make violations automatically erroneous, because if the implementation chooses to never fully trust it, there is nothing erroneous that can happen. If an implementation chooses to trust the restriction, and performs some optimization as a result of the restriction, the implementation would define such a violation as erroneous. Such an implementation might also endeavor to detect most violations, perhaps by providing additional aspects, thereby reducing the situations which result in erroneous execution. Implementations might detect some but not all violations of the restrictions. Implementations that completely ignore the restriction should treat the restriction as an unsupported capability of <a href="/docs/arm/AA-H/">Annex H</a>, &ldquo;<a href="/docs/arm/AA-H/">High Integrity Systems</a>&rdquo;. <br />
</Admonition>
</AnnotatedOnly>


#### Dynamic Semantics

<MarginText>23.10/5</MarginText>
<MarginInfo items={["AI12-0020-1", "AI12-0340-1"]} />
<p>The following <i>restriction{"_"}parameter{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code> is language defined:<br /></p>

<MarginText>23.11/5</MarginText>
<dt><br/>Max{"_"}Image{"_"}Length</dt>
<dl>
<dd>Specifies the maximum length for the result of an Image, Wide{"_"}Image, or Wide{"_"}Wide{"_"}Image attribute. Violation of this restriction results in the raising of Program{"_"}Error at the point of the invocation of an image attribute. <br /></dd>
</dl>

#### Implementation Requirements

<MarginText>23.12/5</MarginText>
<MarginInfo items={["AI95-00394-01"]} />
<p>An implementation of this Annex shall support: <br /></p>

<MarginText>23.13/5</MarginText>
<ul>
<li>the restrictions defined in this subclause; and<br /></li>
<MarginText>23.14/5</MarginText>
<MarginInfo items={["AI05-0189-1"]} />
<li>the following restrictions defined in <a href="/docs/arm/AA-D/AA-D.7">D.7</a>: No{"_"}Task{"_"}Hierarchy, No{"_"}Abort{"_"}Statement, No{"_"}Implicit{"_"}Heap{"_"}Allocation, No{"_"}Standard{"_"}Allocators{"_"}After{"_"}Elaboration; and<br /></li>
<MarginText>23.15/5</MarginText>
<MarginInfo items={["AI95-00347-01"]} />
<li>the <b>pragma</b> Profile(Ravenscar); and <br /></li>
</ul>
<AnnotatedOnly>
<MarginText>23.d/2</MarginText>
<MarginInfo items={["AI95-00347-01"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The reference to pragma Profile(Ravenscar) is intended to show that properly restricted tasking is appropriate for use in high integrity systems. The Ada 95 Annex seemed to suggest that tasking was inappropriate for such systems. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>23.16/5</MarginText>
<ul>
<li>the following uses of <i>restriction{"_"}parameter{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code>s defined in <a href="/docs/arm/AA-D/AA-D.7">D.7</a>[, which are checked prior to program execution]: <br /></li>
</ul>
<MarginText>23.17/5</MarginText>
<ul>
<li>Max{"_"}Task{"_"}Entries ={">"} 0,<br /></li>
<MarginText>23.18/5</MarginText>
<li>Max{"_"}Asynchronous{"_"}Select{"_"}Nesting ={">"} 0, and<br /></li>
<MarginText>23.19/5</MarginText>
<li>Max{"_"}Tasks ={">"} 0. <br /></li>
</ul>
<MarginText>23.20/5</MarginText>
<MarginInfo items={["AI12-0020-1", "AI12-0340-1"]} />
<p>If a Max{"_"}Image{"_"}Length restriction applies to any compilation unit in the partition, then for any subtype S, S'Image, S'Wide{"_"}Image, and S'Wide{"_"}Wide{"_"}Image shall be implemented within that partition without any dynamic allocation.<br /></p>

<AnnotatedOnly>
<MarginText>23.e/5</MarginText>
<MarginInfo items={["AI12-0340-1", "AI12-0384-2"]} />
<Admonition type="aarm" aarm="implementation-note">
<b></b>This can be accomplished by using an object of the Text{"_"}Buffers.Bounded.Buffer{"_"}Type with the maximum characters as specified in the Max{"_"}Image{"_"}Length restriction, with a raise of Program{"_"}Error afterward if Text{"_"}Truncated (Buf) is True after the call on Put{"_"}Image (Buf, Arg). <br />
</Admonition>
</AnnotatedOnly>

<MarginText>24/5</MarginText>
<MarginInfo items={["AI05-0263-1", "AI05-0272-1", "AI12-0308-1"]} />
<p>If an implementation supports <code><a href="/docs/arm/AA-2/AA-2.8#S0019">pragma</a></code> Restrictions for a particular argument, then except for the restrictions No{"_"}Access{"_"}Subprograms, No{"_"}Unchecked{"_"}Access, No{"_"}Specification{"_"}of{"_"}Aspect, No{"_"}Use{"_"}of{"_"}Attribute, No{"_"}Use{"_"}of{"_"}Pragma, No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Conversion, and No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Deallocation, the associated restriction applies to the run-time system. <br /></p>

<AnnotatedOnly>
<MarginText>24.a</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>Permission is granted for the run-time system to use the specified otherwise-restricted features, since the use of these features may simplify the run-time system by allowing more of it to be written in Ada. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.b</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The restrictions that are applied to the partition are also applied to the run-time system. For example, if No{"_"}Floating{"_"}Point is specified, then an implementation that uses floating point for implementing the delay statement (say) would require that No{"_"}Floating{"_"}Point is only used in conjunction with No{"_"}Delay. It is clearly important that restrictions are effective so that Max{"_"}Tasks=0 does imply that tasking is not used, even implicitly (for input-output, say).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.c</MarginText>
<Admonition type="aarm" aarm="note">
An implementation of tasking could be produced based upon a run-time system written in Ada in which the rendezvous was controlled by protected types. In this case, No{"_"}Protected{"_"}Types could only be used in conjunction with Max{"_"}Task{"_"}Entries=0. Other implementation dependencies could be envisaged.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>24.d</MarginText>
<Admonition type="aarm" aarm="note">
If the run-time system is not written in Ada, then the wording needs to be applied in an appropriate fashion.<br />
</Admonition>
</AnnotatedOnly>


#### Documentation Requirements

<MarginText>25</MarginText>
<p>If a pragma Restrictions(No{"_"}Exceptions) is specified, the implementation shall document the effects of all constructs where language-defined checks are still performed automatically (for example, an overflow check performed by the processor). <br /></p>

<AnnotatedOnly>
<MarginText>25.a/2</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.b/2</MarginText>
<Admonition type="aarm" aarm="note">
<b>Documentation Requirement: </b>If a pragma Restrictions(No{"_"}Exceptions) is specified, the effects of all constructs where language-defined checks are still performed.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>25.c/2</MarginText>
<MarginInfo items={["AI95-00114-01"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>The documentation requirements here are quite difficult to satisfy. One method is to review the object code generated and determine the checks that are still present, either explicitly, or implicitly within the architecture. As another example from that of overflow, consider the question of dereferencing a null pointer. This could be undertaken by a memory access trap when checks are performed. When checks are suppressed via the argument No{"_"}Exceptions, it would not be necessary to have the memory access trap mechanism enabled.<br />
</Admonition>
</AnnotatedOnly>


#### Erroneous Execution

<MarginText>26</MarginText>
<p>Program execution is erroneous if pragma Restrictions(No{"_"}Exceptions) has been specified and the conditions arise under which a generated language-defined runtime check would fail. <br /></p>

<AnnotatedOnly>
<MarginText>26.a</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The situation here is very similar to the application of pragma Suppress. Since users are removing some of the protection the language provides, they had better be careful!<br />
</Admonition>
</AnnotatedOnly>

<MarginText>27</MarginText>
<p>Program execution is erroneous if pragma Restrictions(No{"_"}Recursion) has been specified and a subprogram is invoked as part of its own execution, or if pragma Restrictions(No{"_"}Reentrancy) has been specified and during the execution of a subprogram by a task, another task invokes the same subprogram. <br /></p>

<AnnotatedOnly>
<MarginText>27.a/3</MarginText>
<MarginInfo items={["AI05-0005-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>In practice, many implementations might not exploit the absence of recursion or need for reentrancy, in which case the program execution would be unaffected by the use of recursion or reentrancy, even though the program is still formally erroneous.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>27.b/2</MarginText>
<Admonition type="aarm" aarm="note">
<i>This paragraph was deleted.</i><br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28/5</MarginText>
<MarginInfo items={["AI95-00394-01", "AI12-0440-1"]} />
<Admonition type="aarm" aarm="note">
NOTE   Uses of <i>restriction{"_"}parameter{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code> No{"_"}Dependence defined in <a href="/docs/arm/AA-13/AA-13.12#Subclause_13.12.1">13.12.1</a>: No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Deallocation and No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Conversion can be appropriate for high-integrity systems. Other uses of No{"_"}Dependence can also be appropriate for high-integrity systems. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.a/2</MarginText>
<Admonition type="aarm" aarm="discussion">
<b></b>The specific mention of these two uses is meant to replace the identifiers now banished to <a href="/docs/arm/AA-J/AA-J.13">J.13</a>, &ldquo;<a href="/docs/arm/AA-J/AA-J.13">Dependence Restriction Identifiers</a>&rdquo;.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.b/2</MarginText>
<Admonition type="aarm" aarm="note">
Restriction No{"_"}Dependence ={">"} Ada.Unchecked{"_"}Deallocation would be useful in those contexts in which heap storage is needed on program start-up, but need not be increased subsequently. The danger of a dangling pointer can therefore be avoided. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.c/2</MarginText>
<MarginInfo items={["AI95-00130-01"]} />
<Admonition type="aarm" aarm="note">
{"{"}<i>8652/0042</i>{"}"} No{"_"}Local{"_"}Allocators no longer prohibits generic instantiations. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 95

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.d/2</MarginText>
<MarginInfo items={["AI95-00285-01"]} />
<Admonition type="aarm" aarm="note">
Wide{"_"}Wide{"_"}Text{"_"}IO (which is new) is added to the No{"_"}IO restriction.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.e/3</MarginText>
<MarginInfo items={["AI95-00347-01", "AI05-0299-1"]} />
<Admonition type="aarm" aarm="note">
The title of this subclause was changed to match the change to the Annex title. Pragma Profile(Ravenscar) is part of this annex.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.f/2</MarginText>
<MarginInfo items={["AI95-00394-01"]} />
<Admonition type="aarm" aarm="note">
Restriction No{"_"}Dependence is used instead of special <i>restriction{"_"}</i><code><a href="/docs/arm/AA-2/AA-2.3#S0002">identifier</a></code>s. The old names are banished to Obsolescent Features (see <a href="/docs/arm/AA-J/AA-J.13">J.13</a>).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.g/2</MarginText>
<MarginInfo items={["AI95-00394-01"]} />
<Admonition type="aarm" aarm="note">
The bizarre wording &ldquo;apply in this Annex&rdquo; (which no one quite can explain the meaning of) is banished. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.h/3</MarginText>
<MarginInfo items={["AI05-0152-1", "AI05-0190-1"]} />
<Admonition type="aarm" aarm="note">
Restrictions No{"_"}Anonymous{"_"}Allocators, No{"_"}Coextensions, and No{"_"}Access{"_"}Parameter{"_"}Allocators are new. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Wording Changes from Ada 2005

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.i/3</MarginText>
<MarginInfo items={["AI05-0189-1"]} />
<Admonition type="aarm" aarm="note">
New restriction No{"_"}Standard{"_"}Allocators{"_"}After{"_"}Elaboration is added to the list of restrictions that are required by this annex.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.j/3</MarginText>
<MarginInfo items={["AI05-0263-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Ada 2005 restriction No{"_"}Dependence is added where needed (this was missed in Ada 2005).<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.k/3</MarginText>
<MarginInfo items={["AI05-0272-1"]} />
<Admonition type="aarm" aarm="note">
Restrictions against individual aspects, pragmas, and attributes do not apply to the run-time system, in order that an implementation can use whatever aspects, pragmas, and attributes are needed to do the job. For instance, attempting to write a run-time system for Linux that does not use the Import aspect would be very difficult and probably is not what the user is trying to prevent anyway. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Incompatibilities With Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.l/5</MarginText>
<MarginInfo items={["AI12-0318-1"]} />
<Admonition type="aarm" aarm="correction">
<b></b> Restriction No{"_"}IO now excludes use of Ada.Directories. If a program using No{"_"}IO used Ada.Directories, it would be legal in Ada 2012 and illegal in Ada 2022. However, given the role of Ada.Directories as a support package for the other packages that are excluded by No{"_"}IO, it seems unlikely that any use of the restriction would use this package (and it's possible that implementations wouldn't support its use with No{"_"}IO anyway). <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>28.m/5</MarginText>
<MarginInfo items={["AI12-0020-1"]} />
<Admonition type="aarm" aarm="note">
Restriction Max{"_"}Image{"_"}Length is new.<br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>28.n/5</MarginText>
<MarginInfo items={["AI12-0079-3"]} />
<Admonition type="aarm" aarm="note">
Restrictions No{"_"}Unspecified{"_"}Globals and No{"_"}Hidden{"_"}Indirect{"_"}Globals are new. <br />
</Admonition>
</AnnotatedOnly>

<a id="Subclause_H.4.1"></a>

## H.4.1  Aspect No_Controlled_Parts


#### Static Semantics

<MarginText>1/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0256-1", "AI12-0403-1"]} />
<p>For a type, the following type-related, operational aspect may be specified:<br /></p>

<MarginText>2/5_H.4.1</MarginText>
<dt><br/>No{"_"}Controlled{"_"}Parts</dt>
<dl>
<dd>The type of this aspect is Boolean. If True, the type and any descendants shall not have any controlled parts. If specified, the value of the expression shall be static. If not specified, the value of this aspect is False.<br /></dd>
</dl>
<AnnotatedOnly>
<MarginText>2.a/5_H.4.1</MarginText>
<Admonition type="aarm" aarm="note">
<b>Aspect Description for </b><b>No{"_"}Controlled{"_"}Parts: </b>A specification that a type and its descendants do not have controlled parts.<br />
</Admonition>
</AnnotatedOnly>

<MarginText>3/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0256-1"]} />
<p>The No{"_"}Controlled{"_"}Parts aspect is nonoverridable (see <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a>).<br /></p>

<AnnotatedOnly>
<MarginText>3.a/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>Since this is a Boolean-valued aspect, the blanket restrictions defined by <a href="/docs/arm/AA-13/AA-13.1#Subclause_13.1.1">13.1.1</a> apply to the specification of Boolean-valued aspects on descendants of types with such aspects. But we still need rules about inheritance from progenitors and about hiding the aspect; it would be too painful to repeat those rules here (and have future maintenance fixes not get applied to this aspect). <br />
</Admonition>
</AnnotatedOnly>


#### Legality Rules

<MarginText>4/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0256-1", "AI12-0407-1"]} />
<p>If No{"_"}Controlled{"_"}Parts is True for a type, no component of the type shall have a controlled part nor shall the type itself be controlled. For the purposes of this rule, a type has a controlled part if its full type has a controlled part; this is applied recursively. In addition to the places where Legality Rules normally apply (see <a href="/docs/arm/AA-12/AA-12.3">12.3</a>), this rule also applies in the private part of an instance of a generic unit.<br /></p>

<AnnotatedOnly>
<MarginText>4.a/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
<Admonition type="aarm" aarm="discussion">
<b></b>This check breaks privacy by looking at the full definition of all of the types involved. This is more like a representation aspect than an operational aspect, but representation aspects are not allowed on partial views and we need this aspect to be visible to clients. <br />
</Admonition>
</AnnotatedOnly>

<MarginText>5/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0256-1", "AI12-0407-1"]} />
<p>When enforcing the above rule within a generic body <i>G</i> or within the body of a generic unit declared within the declarative region of generic unit <i>G</i>, a generic formal private type of <i>G</i> and a generic formal derived type of <i>G</i> whose ancestor is a tagged type whose No{"_"}Controlled{"_"}Parts aspect is False are considered to have a controlled part.<br /></p>

<AnnotatedOnly>
<MarginText>5.a/5_H.4.1</MarginText>
<Admonition type="aarm" aarm="reason">
<b></b>This is a typical generic assume-the-worst rule. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>
<MarginText>5.b/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0407-1"]} />
<Admonition type="aarm" aarm="note">
<b>To be honest: </b>If the ancestor of the generic derived type is class-wide, the aspect in question belongs to the specific type associated with the class-wide type. <br />
</Admonition>
</AnnotatedOnly>

<AnnotatedOnly>

#### Extensions to Ada 2012

</AnnotatedOnly>
<AnnotatedOnly>
<MarginText>5.c/5_H.4.1</MarginText>
<MarginInfo items={["AI12-0256-1", "AI12-0407-1"]} />
<Admonition type="aarm" aarm="note">
Aspect No{"_"}Controlled{"_"}Parts is new. <br />
</Admonition>
</AnnotatedOnly>

