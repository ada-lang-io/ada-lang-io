"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["3755"],{26339:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>s,toc:()=>d,default:()=>h,metadata:()=>i,assets:()=>o,contentTitle:()=>l});var i=JSON.parse('{"id":"style-guide/s8/01","title":"8.1 Understanding and Clarity","description":"It is particularly important that parts intended for reuse should be","source":"@site/docs/style-guide/s8/01.mdx","sourceDirName":"style-guide/s8","slug":"/style-guide/s8/01","permalink":"/docs/style-guide/s8/01","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"8.1 Understanding and Clarity"},"sidebar":"styleGuideSidebar","previous":{"title":"8. Reusability","permalink":"/docs/style-guide/s8/"},"next":{"title":"8.2 Robustness","permalink":"/docs/style-guide/s8/02"}}'),t=a(85893),r=a(50065);let s={title:"8.1 Understanding and Clarity"},l=void 0,o={},d=[{value:"Application-Independent Naming",id:"application-independent-naming",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Abbreviations",id:"abbreviations",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Generic Formal Parameters",id:"generic-formal-parameters",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4}];function c(e){let n={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"It is particularly important that parts intended for reuse should be\neasy to understand. What the part does, how to use it, what anticipated\nchanges might be made to it in the future, and how it works are facts\nthat must be immediately apparent from inspection of the comments and\nthe code itself. For maximum readability of reusable parts, follow the\nguidelines in Chapter 3, some of which are repeated more strongly below."}),"\n",(0,t.jsx)(n.h3,{id:"application-independent-naming",children:"Application-Independent Naming"}),"\n",(0,t.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Select the least restrictive names possible for reusable parts and\ntheir identifiers ."}),"\n",(0,t.jsx)(n.li,{children:"Select the generic name to avoid conflicting with the naming\nconventions of instantiations of the generic."}),"\n",(0,t.jsx)(n.li,{children:"Use names that indicate the behavioral characteristics of the\nreusable part, as well as its abstraction."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"General-purpose stack abstraction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ada",children:"------------------------------------------------------------------------\ngeneric\n   type Item is private;\npackage Bounded_Stack is\n   procedure Push (New_Item    : in     Item);\n   procedure Pop  (Newest_Item :    out Item);\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n"})}),"\n",(0,t.jsx)(n.p,{children:"Renamed appropriately for use in current application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ada",children:"with Bounded_Stack;\n\n...\n\n   type Tray is ...\n   package Tray_Stack is\n      new Bounded_Stack (Item => Tray);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"Choosing a general or application-independent name for a reusable part\nencourages its wide reuse. When the part is used in a specific context,\nit can be instantiated (if generic) or renamed with a more specific\nname."}),"\n",(0,t.jsx)(n.p,{children:"When there is an obvious choice for the simplest, clearest name for a\nreusable part, it is a good idea to leave that name for use by the\nreuser of the part, choosing a longer, more descriptive name for the\nreusable part. Thus, Bounded_Stack is a better name than Stack for a\ngeneric stack package because it leaves the simpler name Stack available\nto be used by an instantiation."}),"\n",(0,t.jsx)(n.p,{children:"Include indications of the behavioral characteristics (but not\nindications of the implementation) in the name of a reusable part so\nthat multiple parts with the same abstraction (e.g., multiple stack\npackages) but with different restrictions (bounded, unbounded, etc.) can\nbe stored in the same Ada library and used as part of the same Ada\nprogram."}),"\n",(0,t.jsx)(n.h3,{id:"abbreviations",children:"Abbreviations"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Do not use abbreviations in identifier or unit names."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ada",children:"------------------------------------------------------------------------\nwith Ada.Calendar;\npackage Greenwich_Mean_Time is\n   function Clock return Ada.Calendar.Time;\n   ...\nend Greenwich_Mean_Time;\n------------------------------------------------------------------------\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following abbreviation may not be clear when used in an application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ada",children:"with Ada.Calendar;\nwith Greenwich_Mean_Time;\n...\n   function Get_GMT return Ada.Calendar.Time renames\n          Greenwich_Mean_Time.Clock;\n"})}),"\n",(0,t.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"This is a stronger guideline than Guideline 3.1.4. However well\ncommented, an abbreviation may cause confusion in some future reuse\ncontext. Even universally accepted abbreviations, such as GMT for\nGreenwich Mean Time, can cause problems and should be used only with\ngreat caution."}),"\n",(0,t.jsx)(n.p,{children:"The difference between this guideline and Guideline 3.1.4 involves\nissues of domain. When the domain is well-defined, abbreviations and\nacronyms that are accepted in that domain will clarify the meaning of\nthe application. When that same code is removed from its domain-specific\ncontext, those abbreviations may become meaningless."}),"\n",(0,t.jsx)(n.p,{children:"In the example above, the package, Greenwich_Mean_Time, could be used\nin any application without loss of meaning. But the function Get_GMT\ncould easily be confused with some other acronym in a different domain."}),"\n",(0,t.jsx)(n.h4,{id:"notes",children:"notes"}),"\n",(0,t.jsx)(n.p,{children:"See Guideline 5.7.2 concerning the proper use of the renames clause. If\na particular application makes extensive use of the\nGreenwich_Mean_Time domain, it may be appropriate to rename the\npackage GMT within that application:"}),"\n",(0,t.jsx)(n.p,{children:"with Greenwich_Mean_Time; ..."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:" package GMT renames Greenwich_Mean_Time;"})}),"\n",(0,t.jsx)(n.h3,{id:"generic-formal-parameters",children:"Generic Formal Parameters"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Document the expected behavior of generic formal parameters just as\nyou document any package specification."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-2",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"The following example shows how a very general algorithm can be\ndeveloped but must be clearly documented to be used:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ada",children:"------------------------------------------------------------------------\ngeneric\n   -- Index provides access to values in a structure.  For example,\n   -- an array, A.\n   type Index is (<>);\n   type Element is private;\n   type Element_Array is array (Index range <>) of Element;\n   -- The function, Should_Precede, does NOT compare the indexes\n   -- themselves; it compares the elements of the structure.\n   -- The function Should_Precede is provided rather than a \"Less_Than\" function\n   -- because the sort criterion need not be smallest first.\n   with function Should_Precede (Left  : in     Element;\n                                 Right : in     Element)\n     return Boolean;\n   -- This procedure swaps values of the structure (the mode won't\n   -- allow the indexes themselves to be swapped!)\n   with procedure Swap (Index1 : in     Index;\n                        Index2 : in     Index;\n                        A      : in out Element_Array);\n   -- After the call to Quick_Sort, the indexed structure will be\n   -- sorted:\n   --     For all i,j in First..Last :  i<j  =>  A(i) < A(j).\nprocedure Quick_Sort (First : in     Index := Index'First;\n                      Last  : in     Index := Index'Last);\n------------------------------------------------------------------------\n"})}),"\n",(0,t.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"The generic capability is one of Ada's strongest features because of its\nformalization. However, not all of the assumptions made about generic\nformal parameters can be expressed directly in Ada. It is important that\nany user of a generic know exactly what that generic needs in order to\nbehave correctly."}),"\n",(0,t.jsx)(n.p,{children:"In a sense, a generic specification is a contract where the instantiator\nmust supply the formal parameters and, in return, receives a working\ninstance of the specification. Both parties are best served when the\ncontract is complete and clear about all assumptions."})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);