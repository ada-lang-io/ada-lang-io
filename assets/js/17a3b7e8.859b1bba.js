"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6213],{917:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>A,contentTitle:()=>x,default:()=>p,frontMatter:()=>h,metadata:()=>r,toc:()=>j});const r=JSON.parse('{"id":"arm/AA-12/AA-12.3","title":"12.3 Generic Instantiation","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-12/AA-12.3.mdx","sourceDirName":"arm/AA-12","slug":"/arm/AA-12/AA-12.3","permalink":"/docs/arm/AA-12/AA-12.3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":98,"frontMatter":{"sidebar_position":98},"sidebar":"referenceManualSidebar","previous":{"title":"12.2 Generic Bodies","permalink":"/docs/arm/AA-12/AA-12.2"},"next":{"title":"12.4 Formal Objects","permalink":"/docs/arm/AA-12/AA-12.4"}}');var a=i(4848),s=i(8453),t=i(3204),c=i(4220),o=i(8069),d=i(8011),l=i(6465);const h={sidebar_position:98},x="12.3 Generic Instantiation",A={},j=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}];function m(e){const n={a:"a",admonition:"admonition",h1:"h1",h4:"h4",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"123-generic-instantiation",children:"12.3 Generic Instantiation"})}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsxs)(n.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.jsx)(n.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,a.jsx)(d.A,{children:"1"}),"\n",(0,a.jsxs)("p",{children:["[ An instance of a generic unit is declared by a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),".] ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(n.h4,{id:"language-design-principles",children:"Language Design Principles"}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"1.a/5"}),(0,a.jsx)(l.A,{items:["AI12-0300-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The legality of an instance should be determinable without looking at the generic body. Likewise, the legality of a generic body should be determinable without looking at any instances. Thus, the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0310",children:"generic_declaration"})})," forms a contract between the body and the instances; if each obeys the rules with respect to the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0310",children:"generic_declaration"})}),", then no legality problems will arise. This is really a special case of the \u201clegality determinable via semantic dependences\u201d Language Design Principle (see Clause ",(0,a.jsx)("a",{href:"/docs/arm/AA-10/",children:"10"}),"), given that a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," does not depend semantically upon the generic body, nor vice versa.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"1.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Run-time issues are another story. For example, whether parameter passing is by copy or by reference is determined in part by the properties of the generic actuals, and thus cannot be determined at compile time of the generic body. Similarly, the contract model does not apply to Post-Compilation Rules. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsx)(d.A,{children:"2/3"}),"\n",(0,a.jsx)(l.A,{items:["AI95-00218-03","AI05-0183-1"]}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsxs)(n.p,{children:[(0,a.jsxs)("code",{children:["generic","_","instantiation"]}),(0,a.jsx)("a",{id:"S0315"}),(0,a.jsx)("code",{children:" ::= "}),(0,a.jsx)("br",{}),"     ",(0,a.jsx)("strong",{children:"package"})," ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0201",children:"defining_program_unit_name"})})," ",(0,a.jsx)("strong",{children:"is"}),(0,a.jsx)("br",{}),"         ",(0,a.jsx)("strong",{children:"new"})," ",(0,a.jsxs)("em",{children:["generic","_","package","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0316",children:"generic_actual_part"})}),"]",(0,a.jsx)("br",{}),"            [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"];",(0,a.jsx)("br",{}),"   | [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3#S0234",children:"overriding_indicator"})}),"]",(0,a.jsx)("br",{}),"     ",(0,a.jsx)("strong",{children:"procedure"})," ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0201",children:"defining_program_unit_name"})})," ",(0,a.jsx)("strong",{children:"is"}),(0,a.jsx)("br",{}),"         ",(0,a.jsx)("strong",{children:"new"})," ",(0,a.jsxs)("em",{children:["generic","_","procedure","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0316",children:"generic_actual_part"})}),"]",(0,a.jsx)("br",{}),"            [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"];",(0,a.jsx)("br",{}),"   | [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3#S0234",children:"overriding_indicator"})}),"]",(0,a.jsx)("br",{}),"     ",(0,a.jsx)("strong",{children:"function"})," ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0200",children:"defining_designator"})})," ",(0,a.jsx)("strong",{children:"is"}),(0,a.jsx)("br",{}),"         ",(0,a.jsx)("strong",{children:"new"})," ",(0,a.jsxs)("em",{children:["generic","_","function","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0316",children:"generic_actual_part"})}),"]",(0,a.jsx)("br",{}),"            [",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"];",(0,a.jsx)("br",{})]})}),"\n",(0,a.jsx)(d.A,{children:"3"}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsxs)(n.p,{children:[(0,a.jsxs)("code",{children:["generic","_","actual","_","part"]}),(0,a.jsx)("a",{id:"S0316"}),(0,a.jsx)("code",{children:" ::= "}),(0,a.jsx)("br",{}),"   (",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," ","{",", ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})}),"}",")",(0,a.jsx)("br",{})]})}),"\n",(0,a.jsx)(d.A,{children:"4"}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsxs)(n.p,{children:[(0,a.jsxs)("code",{children:["generic","_","association"]}),(0,a.jsx)("a",{id:"S0317"}),(0,a.jsx)("code",{children:" ::= "}),(0,a.jsx)("br",{}),"   [",(0,a.jsxs)("em",{children:["generic","_","formal","_","parameter","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0099",children:"selector_name"})})," =",">","] ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0318",children:"explicit_generic_actual_parameter"})}),(0,a.jsx)("br",{})]})}),"\n",(0,a.jsx)(d.A,{children:"5"}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsxs)(n.p,{children:[(0,a.jsxs)("code",{children:["explicit","_","generic","_","actual","_","parameter"]}),(0,a.jsx)("a",{id:"S0318"}),(0,a.jsx)("code",{children:" ::= "}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," | ",(0,a.jsxs)("em",{children:["variable","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),(0,a.jsx)("br",{}),"   | ",(0,a.jsxs)("em",{children:["subprogram","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," | ",(0,a.jsxs)("em",{children:["entry","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," | ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),(0,a.jsx)("br",{}),"   | ",(0,a.jsxs)("em",{children:["package","_","instance","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),(0,a.jsx)("br",{})]})}),"\n",(0,a.jsx)(d.A,{children:"6"}),"\n",(0,a.jsxs)("p",{class:"Indented2",children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," is ",(0,a.jsx)("em",{children:"named"})," or ",(0,a.jsx)("em",{children:"positional"})," according to whether or not the ",(0,a.jsxs)("em",{children:["generic","_","formal","_","parameter","_"]}),(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.1#S0099",children:["selector","_","name"]})})," is specified. Any positional associations shall precede any named associations. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"7/5"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0004-1","AI12-0205-1"]}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsx)("em",{children:"generic actual parameter"})," is either the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0318",children:"explicit_generic_actual_parameter"})})," given in a ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:["generic","_","association"]})})," for each formal, or the corresponding ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:["default","_","expression"]})}),", ",(0,a.jsxs)("em",{children:["default","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),", or ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-12/AA-12.6#S0339",children:["default","_","name"]})})," if no ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:["generic","_","association"]})})," is given for the formal. When the meaning is clear from context, the term \u201cgeneric actual\u201d, or simply \u201cactual\u201d, is used as a synonym for \u201cgeneric actual parameter\u201d and also for the view denoted by one, or the value of one.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"7.a/5"}),(0,a.jsx)(l.A,{items:["AI12-0205-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"Any matching or other Legality Rules that apply to a generic actual are applied to any ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:"default_expression"})}),", ",(0,a.jsxs)("em",{children:["default","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),", or ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.6#S0339",children:"default_name"})})," that are used as an actual. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,a.jsx)(d.A,{children:"8"}),"\n",(0,a.jsxs)("p",{children:["In a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," for a particular kind of program unit [(package, procedure, or function)], the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," shall denote a generic unit of the corresponding kind [(generic package, generic procedure, or generic function, respectively)].",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"9/3"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0118-1"]}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsxs)("em",{children:["generic","_","formal","_","parameter","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0099",children:"selector_name"})})," of a named ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," shall denote a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})})," of the generic unit being instantiated. If two or more formal subprograms have the same defining name, then named associations are not allowed for the corresponding actuals.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"9.1/3"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0118-1"]}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})})," for a positional ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," is the parameter with the corresponding position in the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0313",children:"generic_formal_part"})})," of the generic unit being instantiated.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"10/5"}),"\n",(0,a.jsx)(l.A,{items:["AI12-0205-1"]}),"\n",(0,a.jsxs)("p",{children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," shall contain at most one ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," for each formal. Each formal without an association shall have a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:"default_expression"})}),", ",(0,a.jsxs)("em",{children:["default","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),", or ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.6#S0338",children:"subprogram_default"})}),".",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"11/5"}),"\n",(0,a.jsx)(l.A,{items:["AI12-0418-1"]}),"\n",(0,a.jsxs)("p",{children:["In a generic unit, Legality Rules are enforced at compile time of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0310",children:"generic_declaration"})})," and generic body, given the properties of the formals. In the visible part and formal part of an instance, Legality Rules are enforced at compile time of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),", given the properties of the actuals. In other parts of an instance, Legality Rules are not enforced; this rule does not apply when a given rule explicitly specifies otherwise. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.a/2"}),(0,a.jsx)(l.A,{items:["AI95-00114-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"Since rules are checked using the properties of the formals, and since these properties do not always carry over to the actuals, we need to check the rules again in the visible part of the instance. For example, only if a tagged type is limited may an extension of it have limited components in the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#S0075",children:"record_extension_part"})}),". A formal tagged limited type is limited, but the actual might be nonlimited. Hence any rule that requires a tagged type to be limited runs into this problem. Such rules are rare; in most cases, the rules for matching of formals and actuals guarantee that if the rule is obeyed in the generic unit, then it has to be obeyed in the instance.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.a.1/3"}),(0,a.jsx)(l.A,{items:["AI05-0005-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Ada 2012 addendum: Such Legality Rules are not as rare as the authors of Ada 95 hoped; there are more than 30 of them known at this point. They are indexed under \u201cgeneric contract issue\u201d and are associated with the boilerplate \u201cIn addition to the places where Legality Rules normally apply...\u201d. Indeed, there is only one known rule where rechecking in the specification is needed and where rechecking in the private part is ",(0,a.jsx)("em",{children:"not"})," wanted (it is in ",(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),", but even it needs rechecking when tagged types are involved). ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The \u201cproperties\u201d of the formals are determined without knowing anything about the actuals: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.c/1"}),(0,a.jsx)(l.A,{items:["AI95-00034-01"]}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:["{",(0,a.jsx)("em",{children:"8652/0095"}),"}"," A formal derived subtype is constrained if and only if the ancestor subtype is constrained. A formal array type is constrained if and only if the declarations say so. A formal private type is constrained if it does not have a discriminant part. Other formal subtypes are unconstrained, even though they might be constrained in an instance.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.d"}),(0,a.jsxs)("li",{children:["A formal subtype can be indefinite, even though the copy might be definite in an instance.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.e"}),(0,a.jsxs)("li",{children:["A formal object of mode ",(0,a.jsx)("strong",{children:"in"})," is not a static constant; in an instance, the copy is static if the actual is.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.f"}),(0,a.jsxs)("li",{children:["A formal subtype is not static, even though the actual might be.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.g"}),(0,a.jsxs)("li",{children:["Formal types are specific, even though the actual can be class-wide.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.h"}),(0,a.jsxs)("li",{children:["The subtype of a formal object of mode ",(0,a.jsx)("strong",{children:"in out"})," is not static. (This covers the case of AI83-00878.)",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.i"}),(0,a.jsxs)("li",{children:["The subtype of a formal parameter of a formal subprogram does not provide an applicable index constraint.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.j/3"}),(0,a.jsx)(l.A,{items:["AI05-0239-1"]}),(0,a.jsxs)("li",{children:["The profile of a formal subprogram is not subtype conformant with any other profile. ",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.k"}),(0,a.jsxs)("li",{children:["A generic formal function is not static. ",(0,a.jsx)("br",{})]})]})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.l"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The exceptions to the above rule about when legality rules are enforced fall into these categories: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.m"}),(0,a.jsx)("ul",{children:(0,a.jsxs)("li",{children:["Some rules are checked in the generic declaration, and then again in both the visible and private parts of the instance: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.n"}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:["The parent type of a record extension has to be specific (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#Subclause_3.9.1",children:"3.9.1"}),"). This rule is not checked in the instance body.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.o"}),(0,a.jsxs)("li",{children:["The parent type of a private extension has to be specific (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3",children:"7.3"}),"). This rule is not checked in the instance body.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.p/3"}),(0,a.jsx)(l.A,{items:["AI95-00402-01","AI05-0093-1"]}),(0,a.jsxs)("li",{children:["A type with an access discriminant with a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:"default_expression"})})," has to be immutably limited. In the generic body, the definition of immutably limited is adjusted in an assume-the-worst manner (thus the rule is checked that way).",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.q"}),(0,a.jsxs)("li",{children:["In the declaration of a record extension, if the parent type is nonlimited, then each of the components of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#S0075",children:"record_extension_part"})})," have to be nonlimited (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#Subclause_3.9.1",children:"3.9.1"}),"). In the generic body, this rule is checked in an assume-the-worst manner.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.r"}),(0,a.jsxs)("li",{children:["A preelaborated library unit has to be preelaborable (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-10/AA-10.2#Subclause_10.2.1",children:"10.2.1"}),"). In the generic body, this rule is checked in an assume-the-worst manner. ",(0,a.jsx)("br",{})]})]})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.r.1/2"}),(0,a.jsx)(l.A,{items:["AI95-00402-01"]}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:["The corrections made by the Corrigendum added a number of such rules, and the Amendment added many more. There doesn't seem to be much value in repeating all of these rules here (as of this writing, there are roughly 33 such rules). As noted below, all such rules are indexed in the AARM.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.s"}),(0,a.jsxs)("li",{children:["For the accessibility rules, the formals have nothing to say about the property in question. Like the above rules, these rules are checked in the generic declaration, and then again in both the visible and private parts of the instance. In the generic body, we have explicit rules that essentially assume the worst (in the cases of type extensions and access-to-subprogram types), and we have runtime checks (in the case of access-to-object types). See ",(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#Subclause_3.9.1",children:"3.9.1"}),", ",(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#Subclause_3.10.2",children:"3.10.2"}),", and ",(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.6",children:"4.6"}),".",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.t"}),(0,a.jsxs)("li",{children:["We considered runtime checks for access-to-subprogram types as well. However, this would present difficulties for implementations that share generic bodies.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.u"}),(0,a.jsxs)("li",{children:["The rules requiring \u201creasonable\u201d values for static expressions are ignored when the expected type for the expression is a descendant of a generic formal type other than a generic formal derived type, and do not apply in an instance.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.v"}),(0,a.jsxs)("li",{children:["The rule forbidding two explicit homographs in the same declarative region does not apply in an instance of a generic unit, except that it ",(0,a.jsx)("em",{children:"does"})," apply in the declaration of a record extension that appears in the visible part of an instance.",(0,a.jsx)("br",{})]}),(0,a.jsx)(d.A,{children:"11.w"}),(0,a.jsxs)("li",{children:["Some rules do not apply at all in an instance, not even in the visible part: ",(0,a.jsx)("br",{})]})]})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.x"}),(0,a.jsx)("ul",{children:(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0297",children:"Body_stub"})}),"s are not normally allowed to be multiply nested, but they can be in instances. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.y"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Each rule that is an exception is marked with \u201cgeneric contract issue;\u201d look that up in the index to find them all. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.z"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The Legality Rules are the ones labeled Legality Rules. We are talking about all Legality Rules in the entire language here. Note that, with some exceptions, the legality of a generic unit is checked even if there are no instantiations of the generic unit. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.aa/5"}),(0,a.jsx)(l.A,{items:["AI05-0299-1","AI12-0005-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The Legality Rules are described here, and the overloading rules were described earlier in this subclause. Presumably, every Static Semantic Item is included indirectly by one of those. Thus, we have covered all the compile-time rules of the language. There is no need to say anything special about the Post-Compilation Rules or the Dynamic Semantic Items. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.bb"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"Here is an example illustrating how this rule is checked: \u201cIn the declaration of a record extension, if the parent type is nonlimited, then each of the components of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#S0075",children:"record_extension_part"})})," shall be nonlimited.\u201d ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.cc"}),(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["generic","\n","    type Parent is tagged private;","\n","    type Comp is limited private;","\n","package G1 is","\n","    type Extension is new Parent with","\n","        record","\n","            C : Comp; -- Illegal!","\n","        end record;","\n","end G1;","\n"]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.dd/1"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The parent type is nonlimited, and the component type is limited, which is illegal. It doesn't matter that one could imagine writing an instantiation with the actual for Comp being nonlimited \u2014 we never get to the instance, because the generic itself is illegal.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.ee"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["On the other hand: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.ff"}),(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["generic","\n","    type Parent is tagged limited private; -- Parent is limited.","\n","    type Comp is limited private;","\n","package G2 is","\n","    type Extension is new Parent with","\n","        record","\n","            C : Comp; -- OK.","\n","        end record;","\n","end G2;","\n","\n",(0,a.jsx)(d.A,{children:"11.gg"}),"\ntype Limited","_","Tagged is tagged limited null record;","\n","type Non","_","Limited","_","Tagged is tagged null record;","\n","\n",(0,a.jsx)(d.A,{children:"11.hh"}),"\ntype Limited","_","Untagged is limited null record;","\n","type Non","_","Limited","_","Untagged is null record;","\n","\n",(0,a.jsx)(d.A,{children:"11.ii"}),"\npackage Good","_","1 is new G2(Parent =",">"," Limited","_","Tagged,","\n","                         Comp =",">"," Limited","_","Untagged);","\n","package Good","_","2 is new G2(Parent =",">"," Non","_","Limited","_","Tagged,","\n","                         Comp =",">"," Non","_","Limited","_","Untagged);","\n","package Bad  is new G2(Parent =",">"," Non","_","Limited","_","Tagged,","\n","                         Comp =",">"," Limited","_","Untagged); -- Illegal!","\n"]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"11.jj"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The first instantiation is legal, because in the instance the parent is limited, so the rule is not violated. Likewise, in the second instantiation, the rule is not violated in the instance. However, in the Bad instance, the parent type is nonlimited, and the component type is limited, so this instantiation is illegal. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,a.jsx)(d.A,{children:"12"}),"\n",(0,a.jsxs)("p",{children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," declares an instance; it is equivalent to the instance declaration (a ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-7/AA-7.1#S0229",children:["package","_","declaration"]})})," or ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.1#S0195",children:["subprogram","_","declaration"]})}),") immediately followed by the instance body, both at the place of the instantiation. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"12.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The declaration and the body of the instance are not \u201cimplicit\u201d in the technical sense, even though you can't see them in the program text. Nor are declarations within an instance \u201cimplicit\u201d (unless they are implicit by other rules). This is necessary because implicit declarations have special semantics that should not be attached to instances. For a generic subprogram, the profile of a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," is that of the instance declaration, by the stated equivalence. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"12.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The visible and private parts of a package instance are defined in ",(0,a.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1",children:"7.1"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1",children:"Package Specifications and Declarations"}),"\u201d and ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.7",children:"12.7"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.7",children:"Formal Packages"}),"\u201d. The visible and private parts of a subprogram instance are defined in ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.2",children:"8.2"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.2",children:"Scope of Declarations"}),"\u201d. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"13"}),"\n",(0,a.jsxs)("p",{children:["The instance is a copy of the text of the template. [Each use of a formal parameter becomes (in the copy) a use of the actual, as explained below.] An instance of a generic package is a package, that of a generic procedure is a procedure, and that of a generic function is a function. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"13.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"An instance is a package or subprogram (because we say so), even though it contains a copy of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0313",children:"generic_formal_part"})}),", and therefore doesn't look like one. This is strange, but it's OK, since the syntax rules are overloading rules, and therefore do not apply in an instance. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"13.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"We use a macro-expansion model, with some explicitly-stated exceptions (see below). The main exception is that the interpretation of each construct in a generic unit (especially including the denotation of each name) is determined when the declaration and body of the generic unit (as opposed to the instance) are compiled, and in each instance this interpretation is (a copy of) the template interpretation. In other words, if a construct is interpreted as a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," denoting a declaration D, then in an instance, the copy of the construct will still be a name, and will still denote D (or a copy of D). From an implementation point of view, overload resolution is performed on the template, and not on each copy.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"13.c"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["We describe the substitution of generic actual parameters by saying (in most cases) that the copy of each generic formal parameter declares a view of the actual. Suppose a name in a generic unit denotes a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})}),". The copy of that name in an instance will denote the copy of that ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})})," in the instance. Since the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})})," in the instance declares a view of the actual, the name will denote a view of the actual.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"13.d/2"}),(0,a.jsx)(l.A,{items:["AI95-00442-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Other properties of the copy (for example, staticness, categories to which types belong) are recalculated for each instance; this is implied by the fact that it's a copy.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"13.e/2"}),(0,a.jsx)(l.A,{items:["AI95-00317-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Although the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0313",children:"generic_formal_part"})})," is included in an instance, the declarations in the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0313",children:"generic_formal_part"})})," are only visible outside the instance in the case of a generic formal package whose ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.7#S0341",children:"formal_package_actual_part"})})," includes one or more ","<",">"," indicators \u2014 see ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.7",children:"12.7"}),". ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"14"}),"\n",(0,a.jsxs)("p",{children:["The interpretation of each construct within a generic declaration or body is determined using the overloading rules when that generic declaration or body is compiled. In an instance, the interpretation of each (copied) construct is the same, except in the case of a name that denotes the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0310",children:"generic_declaration"})})," or some declaration within the generic unit; the corresponding name in the instance then denotes the corresponding copy of the denoted declaration. The overloading rules do not apply in the instance. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"See ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.6",children:"8.6"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.6",children:"The Context of Overload Resolution"}),"\u201d for definitions of \u201cinterpretation\u201d and \u201coverloading rule\u201d.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Even the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})}),"s have corresponding declarations in the instance, which declare views of the actuals.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.c"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Although the declarations in the instance are copies of those in the generic unit, they often have quite different properties, as explained below. For example a constant declaration in the generic unit might declare a nonstatic constant, whereas the copy of that declaration might declare a static constant. This can happen when the staticness depends on some generic formal.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.d"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["This rule is partly a ramification of the \u201ccurrent instance\u201d rule in ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.6",children:"8.6"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.6",children:"The Context of Overload Resolution"}),"\u201d. Note that that rule doesn't cover the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0313",children:"generic_formal_part"})}),".",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.e/5"}),(0,a.jsx)(l.A,{items:["AI12-0347-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Although the overloading rules are not observed in the instance, they are, of course, observed in the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," in order to determine the interpretation of the constituents of the ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),".",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.f"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Since children are considered to occur within their parent's declarative region, the above rule applies to a name that denotes a child of a generic unit, or a declaration inside such a child.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"14.g"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Since the Syntax Rules are overloading rules, it is possible (legal) to violate them in an instance. For example, it is possible for an instance body to occur in a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})}),", even though the Syntax Rules forbid bodies in ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})}),"s. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"15/5"}),"\n",(0,a.jsx)(l.A,{items:["AI12-0407-1"]}),"\n",(0,a.jsxs)("p",{children:["In an instance, a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})})," declares a view whose properties are identical to those of the actual, except when specified otherwise (in particular, see ",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"6.1.1"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"Preconditions and Postconditions"}),"\u201d, ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.4",children:"12.4"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.4",children:"Formal Objects"}),"\u201d, and ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.6",children:"12.6"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.6",children:"Formal Subprograms"}),"\u201d). Similarly, for a declaration within a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1#S0314",children:"generic_formal_parameter_declaration"})}),", the corresponding declaration in an instance declares a view whose properties are identical to the corresponding declaration within the declaration of the actual. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"In an instance, there are no \u201cproperties\u201d of types and subtypes that come from the formal. The primitive operations of the type come from the formal, but these are declarations in their own right, and are therefore handled separately.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Note that certain properties that come from the actuals are irrelevant in the instance. For example, if an actual type is of a class deeper in the derived-type hierarchy than the formal, it is impossible to call the additional operations of the deeper class in the instance, because any such call would have to be a copy of some corresponding call in the generic unit, which would have been illegal. However, it is sometimes possible to reach into the specification of the instance from outside, and notice such properties. For example, one could pass an object declared in the instance specification to one of the additional operations of the deeper type.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.c/2"}),(0,a.jsx)(l.A,{items:["AI95-00114-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.5#S0320",children:"formal_type_declaration"})})," can contain ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0062",children:"discriminant_specification"})}),"s, a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.6#S0335",children:"formal_subprogram_declaration"})})," can contain ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0207",children:"parameter_specification"})}),"s, and a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.7#S0340",children:"formal_package_declaration"})})," can contain many kinds of declarations. These are all inside the generic unit, and have corresponding declarations in the instance.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.d"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["This rule implies, for example, that if a subtype in a generic unit is a subtype of a generic formal subtype, then the corresponding subtype in the instance is a subtype of the corresponding actual subtype.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.e"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["For a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),", if a generic actual is a static [(scalar or string)] subtype, then each use of the corresponding formal parameter within the specification of the instance is considered to be static. (See AI83-00409.)",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.f"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Similarly, if a generic actual is a static expression and the corresponding formal parameter has a static [(scalar or string)] subtype, then each use of the formal parameter in the specification of the instance is considered to be static. (See AI83-00505.)",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.g"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["If a primitive subprogram of a type derived from a generic formal derived tagged type is not overriding (that is, it is a new subprogram), it is possible for the copy of that subprogram in an instance to override a subprogram inherited from the actual. For example: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.h"}),(0,a.jsxs)(o.A,{language:"ada",children:[(0,a.jsxs)(n.p,{children:["type T1 is tagged record ... end record;","\n","\n",(0,a.jsx)(d.A,{children:"15.i/5"})]}),(0,a.jsx)(l.A,{items:["AI12-0005-1"]}),(0,a.jsxs)(n.p,{children:["generic","\n","    type Formal is new T1 with private;","\n","package G is","\n","    type Derived","_","From","_","Formal is new Formal with record ... end record;","\n","    procedure Foo(X : in Derived","_","From","_","Formal); -- Does not override anything.","\n","end G;","\n","\n",(0,a.jsx)(d.A,{children:"15.j"}),"\ntype T2 is new T1 with record ... end record;","\n","procedure Foo(X : in T2);","\n","\n",(0,a.jsx)(d.A,{children:"15.k"}),"\npackage Inst is new G(Formal =",">"," T2);","\n"]})]})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.l"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["In the instance Inst, the declaration of Foo for Derived","_","From","_","Formal overrides the Foo inherited from T2. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.m/1"}),(0,a.jsx)(l.A,{items:["AI95-00137-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"implementation-note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"{",(0,a.jsx)("em",{children:"8652/0009"}),"}"," For formal types, an implementation that shares the code among multiple instances of the same generic unit needs to beware that things like parameter passing mechanisms (by-copy vs. by-reference) and ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0343",children:"aspect_clause"})}),"s are determined by the actual. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"15.n/5"}),(0,a.jsx)(l.A,{items:["AI12-0407-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"In particular, we allow differences for aspects that can be specified on generic formal parameters. For instance, Pre (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"6.1.1"}),") can be specified on generic formal subprograms to be added to the Pre of the actual. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"16"}),"\n",(0,a.jsxs)("p",{children:["[Implicit declarations are also copied, and a name that denotes an implicit declaration in the generic denotes the corresponding copy in the instance. However, for a type declared within the visible part of the generic, a whole new set of primitive subprograms is implicitly declared for use outside the instance, and may differ from the copied set if the properties of the type in some way depend on the properties of some actual type specified in the instantiation. For example, if the type in the generic is derived from a formal private type, then in the instance the type will inherit subprograms from the corresponding actual type.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"17"}),"\n",(0,a.jsxs)("p",{children:["These new implicit declarations occur immediately after the type declaration in the instance, and override the copied ones. The copied ones can be called only from within the instance; the new ones can be called only from outside the instance, although for tagged types, the body of a new one can be executed by a call to an old one.] ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"17.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"proof",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"This rule is stated officially in ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3",children:"8.3"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3",children:"Visibility"}),"\u201d. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"17.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),'The new ones follow from the class(es) of the formal types. For example, for a type T derived from a generic formal private type, if the actual is Integer, then the copy of T in the instance has a "+" primitive operator, which can be called from outside the instance (assuming T is declared in the visible part of the instance).',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"17.c"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["AI83-00398.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"17.d/2"}),(0,a.jsx)(l.A,{items:["AI95-00442-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:['Since an actual type is always in the category determined for the formal, the new subprograms hide all of the copied ones, except for a declaration of "/=" that corresponds to an explicit declaration of "=". Such "/=" operators are special, because unlike other implicit declarations of primitive subprograms, they do not appear by virtue of the class, but because of an explicit declaration of "=". If the declaration of "=" is implicit (and therefore overridden in the instance), then a corresponding implicitly declared "/=" is also overridden. But if the declaration of "=" is explicit (and therefore not overridden in the instance), then a corresponding implicitly declared "/=" is not overridden either, even though it\'s implicit.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"17.e"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Note that the copied ones can be called from inside the instance, even though they are hidden from all visibility, because the names are resolved in the generic unit \u2014 visibility is irrelevant for calls in the instance. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"18"}),"\n",(0,a.jsxs)("p",{children:["[In the visible part of an instance, an explicit declaration overrides an implicit declaration if they are homographs, as described in ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3",children:"8.3"}),".] On the other hand, an explicit declaration in the private part of an instance overrides an implicit declaration in the instance, only if the corresponding explicit declaration in the generic overrides a corresponding implicit declaration in the generic. Corresponding rules apply to the other kinds of overriding described in ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3",children:"8.3"}),". ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"18.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"For example: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"18.b"}),(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["type Ancestor is tagged null record;","\n","\n",(0,a.jsx)(d.A,{children:"18.c"}),"\ngeneric","\n","    type Formal is new Ancestor with private;","\n","package G is","\n","    type T is new Formal with null record;","\n","    procedure P(X : in T); -- (1)","\n","private","\n","    procedure Q(X : in T); -- (2)","\n","end G;","\n","\n",(0,a.jsx)(d.A,{children:"18.d"}),"\ntype Actual is new Ancestor with null record;","\n","procedure P(X : in Actual);","\n","procedure Q(X : in Actual);","\n","\n",(0,a.jsx)(d.A,{children:"18.e"}),"\npackage Instance is new G(Formal =",">"," Actual);","\n"]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"18.f"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["In the instance, the copy of P at (1) overrides Actual's P, whereas the copy of Q at (2) does not override anything; in implementation terms, it occupies a separate slot in the type descriptor. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"18.g/5"}),(0,a.jsx)(l.A,{items:["AI12-0347-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The reason for this rule is so a programmer writing a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," need not look at the private part of the generic in order to determine which subprograms will be overridden. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"post-compilation-rules",children:"Post-Compilation Rules"}),"\n",(0,a.jsx)(d.A,{children:"19"}),"\n",(0,a.jsxs)("p",{children:["Recursive generic instantiation is not allowed in the following sense: if a given generic unit includes an instantiation of a second generic unit, then the instance generated by this instantiation shall not include an instance of the first generic unit [(whether this instance is generated directly, or indirectly by intermediate instantiations)]. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"19.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"Note that this rule is not a violation of the generic contract model, because it is not a Legality Rule. Some implementations may be able to check this rule at compile time, but that requires access to all the bodies, so we allow implementations to check the rule at link time. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,a.jsx)(d.A,{children:"20"}),"\n",(0,a.jsxs)("p",{children:["For the elaboration of a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),", each ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," is first evaluated. If a default is used, an implicit ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," is assumed for this rule. These evaluations are done in an arbitrary order, except that the evaluation for a default actual takes place after the evaluation for another actual if the default includes a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," that denotes the other one. Finally, the instance declaration and body are elaborated. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"20.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"Note that if the evaluation of a default depends on some side effect of some other evaluation, the order is still arbitrary. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(d.A,{children:"21"}),"\n",(0,a.jsxs)("p",{children:["For the evaluation of a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0317",children:"generic_association"})})," the generic actual parameter is evaluated. Additional actions are performed in the case of a formal object of mode ",(0,a.jsx)("strong",{children:"in"})," (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.4",children:"12.4"}),"). ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"21.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{children:"To be honest: "}),"Actually, the actual is evaluated only if evaluation is defined for that kind of construct \u2014 we don't actually \u201cevaluate\u201d ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),"s. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["NOTE   If a formal type is not tagged, then the type is treated as an untagged type within the generic body. Deriving from such a type in a generic body is permitted; the new type does not get a new tag value, even if the actual is tagged. Overriding operations for such a derived type cannot be dispatched to from outside the instance. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"If two overloaded subprograms declared in a generic package specification differ only by the (formal) type of their parameters and results, then there exist legal instantiations for which all calls of these subprograms from outside the instance are ambiguous. For example: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.b"}),(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["generic","\n","   type A is (","<",">",");","\n","   type B is private;","\n","package G is","\n","   function Next(X : A) return A;","\n","   function Next(X : B) return B;","\n","end G;","\n","\n",(0,a.jsx)(d.A,{children:"22.c"}),"\npackage P is new G(A =",">"," Boolean, B =",">"," Boolean);","\n","-- All calls of P.Next are ambiguous.","\n"]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.d"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{}),"The following example illustrates some of the subtleties of the substitution of formals and actuals: ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.e/5"}),(0,a.jsx)(l.A,{items:["AI12-0005-1"]}),(0,a.jsxs)(o.A,{language:"ada",children:[(0,a.jsxs)(n.p,{children:["generic","\n","    type T1 is private;","\n",'    -- A predefined "=" operator is implicitly declared here:',"\n",'    -- function "="(Left, Right : T1) return Boolean;',"\n",'    -- Call this "="1.',"\n","    ...","\n","package G is","\n","    subtype S1 is T1; -- So we can get our hands on the type from","\n","                      -- outside an instance.","\n","    type T2 is new T1;","\n",'    -- An inherited "=" operator is implicitly declared here:',"\n",'    -- function "="(Left, Right : T2) return Boolean;',"\n",'    -- Call this "="2.',"\n","\n",(0,a.jsx)(d.A,{children:"22.f"}),"\nT1","_","Obj : T1 := ...;","\n","    Bool","_","1 : Boolean := T1","_","Obj = T1","_","Obj;","\n","\n",(0,a.jsx)(d.A,{children:"22.g"}),"\nT2","_","Obj : T2 := ...;","\n","    Bool","_","2 : Boolean := T2","_","Obj = T2","_","Obj;","\n","end G;","\n","...","\n","\n",(0,a.jsx)(d.A,{children:"22.h/5"})]}),(0,a.jsx)(l.A,{items:["AI12-0005-1"]}),(0,a.jsxs)(n.p,{children:["package P is","\n","    type My","_","Int is new Integer;","\n",'    -- A predefined "=" operator is implicitly declared here:',"\n",'    -- function "="(Left, Right : My',"_","Int) return Boolean;","\n",'    -- Call this "="3.',"\n",'    function "="(X, Y : My',"_","Int) return Boolean;","\n",'    -- Call this "="4.',"\n",'    -- "="3 is hidden from all visibility by "="4.',"\n",'    -- Nonetheless, "="3 can \u201creemerge\u201d in certain circumstances.',"\n","end P;","\n","use P;","\n","...","\n","package I is new G(T1 =",">"," My","_",'Int, ...); -- "="5 is declared in I (see below).',"\n","use I;","\n","\n",(0,a.jsx)(d.A,{children:"22.i"}),"\nAnother","_","T1","_","Obj : S1 := 13; -- Can't denote T1, but S1 will do.","\n","Bool","_","3 : Boolean := Another","_","T1","_","Obj = Another","_","T1","_","Obj;","\n","\n",(0,a.jsx)(d.A,{children:"22.j"}),"\nAnother","_","T2","_","Obj : T2 := 45;","\n","Bool","_","4 : Boolean := Another","_","T2","_","Obj = Another","_","T2","_","Obj;","\n","\n",(0,a.jsx)(d.A,{children:"22.k"}),"\nDouble : T2 := T2","_","Obj + Another","_","T2","_","Obj;","\n"]})]})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.l"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:['In the instance I, there is a copy of "="1 (call it "="1i) and "="2 (call it "="2i). The "="1i and "="2i declare views of the predefined "=" of My',"_",'Int (that is, "="3). In the initialization of Bool',"_","1 and Bool","_",'2 in the generic unit G, the names "=" denote "="1 and "="2, respectively. Therefore, the copies of these names in the instances denote "="1i and "="2i, respectively. Thus, the initialization of I.Bool',"_","1 and I.Bool","_","2 call the predefined equality operator of My","_",'Int; they will not call "="4.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.m"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:['The declarations "="1i and "="2i are hidden from all visibility. This prevents them from being called from outside the instance.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.n"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The declaration of Bool","_",'3 calls "="4.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"22.o"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:['The instance I also contains implicit declarations of the primitive operators of T2, such as "=" (call it "="5) and "+". These operations cannot be called from within the instance, but the declaration of Bool',"_",'4 calls "="5. ',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(d.A,{children:"23"}),"\n",(0,a.jsxs)("p",{children:[(0,a.jsxs)("em",{children:["Examples of generic instantiations (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.1",children:"12.1"}),"):"]})," ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"24/5"}),"\n",(0,a.jsx)(l.A,{items:["AI12-0178-1"]}),"\n",(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["procedure Swap is new Exchange(Elem =",">"," Integer);","\n","procedure Swap is new Exchange(Character);  \t--  Swap is overloaded ","\n",'function Square is new Squaring(Integer); \t--  "',"*",'" of Integer used by default',"\n","function Square1 is new Squaring(Item =",">",' Matrix, "',"*",'" =',">"," Matrix","_","Product);","\n","function Square2 is new Squaring(Matrix, Matrix","_","Product); -- same as previous","\n","\n",(0,a.jsx)(d.A,{children:"25"}),"\npackage Int","_","Vectors is new On","_",'Vectors(Integer, Table, "+");',"\n"]})}),"\n",(0,a.jsx)(d.A,{children:"26"}),"\n",(0,a.jsxs)("p",{children:[(0,a.jsx)("em",{children:"Examples of uses of instantiated units:"})," ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(d.A,{children:"27"}),"\n",(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(n.p,{children:["Swap(A, B);","\n","A := Square(A);","\n","\n",(0,a.jsx)(d.A,{children:"28"}),"\nT : Table(1 .. 5) := (10, 20, 30, 40, 50);","\n","N : Integer := Int","_","Vectors.Sigma(T);  --  150","\n","                                      -- (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.2",children:"12.2"})," for the body of Sigma)","\n","\n",(0,a.jsx)(d.A,{children:"29"}),"\nuse Int","_","Vectors;","\n","M : Integer := Sigma(T);  --  150","\n"]})}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"inconsistencies-with-ada-83",children:"Inconsistencies With Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.a"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["In Ada 83, all explicit actuals are evaluated before all defaults, and the defaults are evaluated in the order of the formal declarations. This ordering requirement is relaxed in Ada 95. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"incompatibilities-with-ada-83",children:"Incompatibilities With Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.b"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["We have attempted to remove every violation of the contract model. Any remaining contract model violations should be considered bugs in the RM95. The unfortunate property of reverting to the predefined operators of the actual types is retained for upward compatibility. (Note that fixing this would require subtype conformance rules.) However, tagged types do not revert in this sense. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.c"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The syntax rule for ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0318",children:"explicit_generic_actual_parameter"})})," is modified to allow a ",(0,a.jsxs)("em",{children:["package","_","instance","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),". ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.d"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The fact that named associations cannot be used for two formal subprograms with the same defining name is moved to AARM-only material, because it is a ramification of other rules, and because it is not of interest to the average user.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.e/2"}),(0,a.jsx)(l.A,{items:["AI95-00114-01"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["The rule that \u201cAn explicit ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0318",children:"explicit_generic_actual_parameter"})})," shall not be supplied more than once for a given generic formal parameter\u201d seems to be missing from RM83, although it was clearly the intent.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.f"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["In the explanation that the instance is a copy of the template, we have left out RM83-12.3(5)'s \u201capart from the generic formal part\u201d, because it seems that things in the formal part still need to exist in instances. This is particularly true for generic formal packages, where you're sometimes allowed to reach in and denote the formals of the formal package from outside it. This simplifies the explanation of what each name in an instance denotes: there are just two cases: the declaration can be inside or outside (where inside needs to include the generic unit itself). Note that the RM83 approach of listing many cases (see RM83-12.5(5-14)) would have become even more unwieldy with the addition of generic formal packages, and the declarations that occur therein.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.g"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["We have corrected the definition of the elaboration of a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})})," (RM83-12.3(17)); we don't elaborate entities, and the instance is not \u201cimplicit\u201d.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.h"}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["In RM83, there is a rule saying the formal and actual shall match, and then there is much text defining what it means to match. Here, we simply state all the latter text as rules. For example, \u201cA formal foo is matched by an actual greenish bar\u201d becomes \u201cFor a formal foo, the actual shall be a greenish bar\u201d. This is necessary to split the Name Resolution Rules from the Legality Rules. Besides, there's really no need to define the concept of matching for generic parameters. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.i/2"}),(0,a.jsx)(l.A,{items:["AI95-00218-03"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3#S0234",children:"overriding_indicator"})})," (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3#Subclause_8.3.1",children:"8.3.1"}),") is allowed on a subprogram instantiation. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.j/3"}),(0,a.jsx)(l.A,{items:["AI05-0183-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["An optional ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})})," can be used in a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),". This is described in ",(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"}),". ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.k/3"}),(0,a.jsx)(l.A,{items:["AI05-0118-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,a.jsxs)(n.p,{children:[(0,a.jsx)("strong",{})," Added a definition for positional parameters, as this is missing from Ada 95 and Ada 2005. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(n.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(d.A,{children:"29.l/5"}),(0,a.jsx)(l.A,{items:["AI12-0205-1"]}),(0,a.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(n.p,{children:["Added uses of ",(0,a.jsxs)("em",{children:["default","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),"s so formal types can have defaults (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.5",children:"12.5"}),"). ",(0,a.jsx)("br",{})]})})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);