"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1076],{9683:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>x,default:()=>A,frontMatter:()=>l,metadata:()=>i,toc:()=>j});const i=JSON.parse('{"id":"arm/AA-B/AA-B.3","title":"B.3. Interfacing with C and C++","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-B/AA-B.3.mdx","sourceDirName":"arm/AA-B","slug":"/arm/AA-B/AA-B.3","permalink":"/docs/arm/AA-B/AA-B.3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":143,"frontMatter":{"sidebar_position":143},"sidebar":"referenceManualSidebar","previous":{"title":"B.2. The Package Interfaces","permalink":"/docs/arm/AA-B/AA-B.2"},"next":{"title":"B.4. Interfacing with COBOL","permalink":"/docs/arm/AA-B/AA-B.4"}}');var s=r(4848),t=r(8453),a=r(3204),c=r(4220),o=r(8069),d=r(8011),h=r(6465);const l={sidebar_position:143},x="B.3. Interfacing with C and C++",p={},j=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"B.3.1  The Package Interfaces.C.Strings",id:"b31--the-package-interfacescstrings",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"B.3.2  The Generic Package Interfaces.C.Pointers",id:"b32--the-generic-package-interfacescpointers",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"B.3.3  Unchecked Union Types",id:"b33--unchecked-union-types",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-2",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4}];function u(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"b3-interfacing-with-c-and-c",children:"B.3. Interfacing with C and C++"})}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsxs)(n.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,s.jsx)(n.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,s.jsx)(d.A,{children:"1/4"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00131-01","AI95-00376-01","AI05-0229-1","AI12-0028-1"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," The facilities relevant to interfacing with the C language and the corresponding subset of the C++ language are the package Interfaces.C and its children, and support for specifying the Convention aspect with ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s C, C","_","Pass","_","By","_","Copy, and any of the C","_","Variadic","_",(0,s.jsx)("i",{children:"n"})," conventions described below.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"2/3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00376-01","AI95-0262-1","AI95-0299-1"]}),"\n",(0,s.jsxs)("p",{children:["The package Interfaces.C contains the basic types, constants, and subprograms that allow an Ada program to pass scalars and strings to C and C++ functions. When this subclause mentions a C entity, the reference also applies to the corresponding entity in C++. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"3"}),"\n",(0,s.jsxs)("p",{children:["The library package Interfaces.C has the following declaration: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"4/5"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0414-1"]}),"\n",(0,s.jsxs)(o.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["package Interfaces.C","\n","   with Pure is","\n","\n",(0,s.jsx)(d.A,{children:"5"}),"\n-- Declarations based on C's ","<","limits.h",">","\n","\n",(0,s.jsx)(d.A,{children:"6"}),"\nCHAR","_","BIT  : constant := implementation-defined;  -- typically 8","\n","   SCHAR","_","MIN : constant := implementation-defined;  -- typically \u2013128","\n","   SCHAR","_","MAX : constant := implementation-defined;  -- typically 127","\n","   UCHAR","_","MAX : constant := implementation-defined;  -- typically 255","\n","\n",(0,s.jsx)(d.A,{children:"7"}),"\n-- Signed and Unsigned Integers","\n","   type int   is range implementation-defined;","\n","   type short is range implementation-defined;","\n","   type long  is range implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"8"}),"\ntype signed","_","char is range SCHAR","_","MIN .. SCHAR","_","MAX;","\n","   for signed","_","char'Size use CHAR","_","BIT;","\n","\n",(0,s.jsx)(d.A,{children:"9"}),"\ntype unsigned       is mod implementation-defined;","\n","   type unsigned","_","short is mod implementation-defined;","\n","   type unsigned","_","long  is mod implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"10"}),"\ntype unsigned","_","char is mod (UCHAR","_","MAX+1);","\n","   for unsigned","_","char'Size use CHAR","_","BIT;","\n","\n",(0,s.jsx)(d.A,{children:"11"}),"\nsubtype plain","_","char is implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"12"}),"\ntype ptrdiff","_","t is range implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"13"}),"\ntype size","_","t is mod implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"13.1/5"})]}),(0,s.jsx)(h.A,{items:["AI12-0411-1"]}),(0,s.jsxs)(n.p,{children:["-- Boolean Type","\n","   type C","_","bool is new Boolean;","\n","\n",(0,s.jsx)(d.A,{children:"14"}),"\n-- Floating Point","\n","\n",(0,s.jsx)(d.A,{children:"15"}),"\ntype C","_","float     is digits implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"16"}),"\ntype double      is digits implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"17"}),"\ntype long","_","double is digits implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"18"}),"\n-- Characters and Strings ","\n","\n",(0,s.jsx)(d.A,{children:"19"}),"\ntype char is ","<","implementation-defined character type",">",";","\n","\n",(0,s.jsx)(d.A,{children:"20/1"})]}),(0,s.jsx)(h.A,{items:["AI95-00037-01"]}),(0,s.jsxs)(n.p,{children:["{","8652/0060","}","    nul : constant char := implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"21"}),"\nfunction To","_","C   (Item : in Character) return char;","\n","\n",(0,s.jsx)(d.A,{children:"22"}),"\nfunction To","_","Ada (Item : in char) return Character;","\n","\n",(0,s.jsx)(d.A,{children:"23/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1","AI05-0269-1"]}),(0,s.jsxs)(n.p,{children:["type char","_","array is array (size","_","t range ","<",">",") of aliased char","\n","      with Pack;","\n","   for char","_","array'Component","_","Size use CHAR","_","BIT;","\n","\n",(0,s.jsx)(d.A,{children:"24"}),"\nfunction Is","_","Nul","_","Terminated (Item : in char","_","array) return Boolean;","\n","\n",(0,s.jsx)(d.A,{children:"25"}),"\nfunction To","_","C   (Item       : in String;","\n","                    Append","_","Nul : in Boolean := True)","\n","      return char","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"26"}),"\nfunction To","_","Ada (Item     : in char","_","array;","\n","                    Trim","_","Nul : in Boolean := True)","\n","      return String;","\n","\n",(0,s.jsx)(d.A,{children:"27"}),"\nprocedure To","_","C (Item       : in  String;","\n","                   Target     : out char","_","array;","\n","                   Count      : out size","_","t;","\n","                   Append","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"28"}),"\nprocedure To","_","Ada (Item     : in  char","_","array;","\n","                     Target   : out String;","\n","                     Count    : out Natural;","\n","                     Trim","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"29"}),"\n-- Wide Character and Wide String","\n","\n",(0,s.jsx)(d.A,{children:"30/1"})]}),(0,s.jsx)(h.A,{items:["AI95-00037-01"]}),(0,s.jsxs)(n.p,{children:["{","8652/0060","}","    type wchar","_","t is ","<","implementation-defined character type",">",";","\n","\n",(0,s.jsx)(d.A,{children:"31/1"})]}),(0,s.jsx)(h.A,{items:["AI95-00037-01"]}),(0,s.jsxs)(n.p,{children:["{","8652/0060","}","    wide","_","nul : constant wchar","_","t := implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"32"}),"\nfunction To","_","C   (Item : in Wide","_","Character) return wchar","_","t;","\n","   function To","_","Ada (Item : in wchar","_","t       ) return Wide","_","Character;","\n","\n",(0,s.jsx)(d.A,{children:"33/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["type wchar","_","array is array (size","_","t range ","<",">",") of aliased wchar","_","t","\n","      with Pack;","\n","\n",(0,s.jsx)(d.A,{children:"34/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["This paragraph was deleted.","\n","\n",(0,s.jsx)(d.A,{children:"35"}),"\nfunction Is","_","Nul","_","Terminated (Item : in wchar","_","array) return Boolean;","\n","\n",(0,s.jsx)(d.A,{children:"36"}),"\nfunction To","_","C   (Item       : in Wide","_","String;","\n","                    Append","_","Nul : in Boolean := True)","\n","      return wchar","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"37"}),"\nfunction To","_","Ada (Item     : in wchar","_","array;","\n","                    Trim","_","Nul : in Boolean := True)","\n","      return Wide","_","String;","\n","\n",(0,s.jsx)(d.A,{children:"38"}),"\nprocedure To","_","C (Item       : in  Wide","_","String;","\n","                   Target     : out wchar","_","array;","\n","                   Count      : out size","_","t;","\n","                   Append","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"39"}),"\nprocedure To","_","Ada (Item     : in  wchar","_","array;","\n","                     Target   : out Wide","_","String;","\n","                     Count    : out Natural;","\n","                     Trim","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"39.1/5"})]}),(0,s.jsx)(h.A,{items:["AI95-00285-01","AI12-0450-1"]}),(0,s.jsxs)(n.p,{children:["-- ISO/IEC 10646 compatible types.","\n","\n",(0,s.jsx)(d.A,{children:"39.2/2"})]}),(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),(0,s.jsxs)(n.p,{children:["type char16","_","t is ","<","implementation-defined character type",">",";","\n","\n",(0,s.jsx)(d.A,{children:"39.3/2"}),"\nchar16","_","nul : constant char16","_","t := implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"39.4/2"}),"\nfunction To","_","C (Item : in Wide","_","Character) return char16","_","t;","\n","   function To","_","Ada (Item : in char16","_","t) return Wide","_","Character;","\n","\n",(0,s.jsx)(d.A,{children:"39.5/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["type char16","_","array is array (size","_","t range ","<",">",") of aliased char16","_","t","\n","      with Pack;","\n","\n",(0,s.jsx)(d.A,{children:"39.6/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["This paragraph was deleted.","\n","\n",(0,s.jsx)(d.A,{children:"39.7/2"}),"\nfunction Is","_","Nul","_","Terminated (Item : in char16","_","array) return Boolean;","\n","   function To","_","C (Item       : in Wide","_","String;","\n","                  Append","_","Nul : in Boolean := True)","\n","      return char16","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"39.8/2"}),"\nfunction To","_","Ada (Item     : in char16","_","array;","\n","                    Trim","_","Nul : in Boolean := True)","\n","      return Wide","_","String;","\n","\n",(0,s.jsx)(d.A,{children:"39.9/2"}),"\nprocedure To","_","C (Item       : in  Wide","_","String;","\n","                   Target     : out char16","_","array;","\n","                   Count      : out size","_","t;","\n","                   Append","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"39.10/2"}),"\nprocedure To","_","Ada (Item     : in  char16","_","array;","\n","                     Target   : out Wide","_","String;","\n","                     Count    : out Natural;","\n","                     Trim","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"39.11/2"})]}),(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),(0,s.jsxs)(n.p,{children:["type char32","_","t is ","<","implementation-defined character type",">",";","\n","\n",(0,s.jsx)(d.A,{children:"39.12/2"}),"\nchar32","_","nul : constant char32","_","t := implementation-defined;","\n","\n",(0,s.jsx)(d.A,{children:"39.13/2"}),"\nfunction To","_","C (Item : in Wide","_","Wide","_","Character) return char32","_","t;","\n","   function To","_","Ada (Item : in char32","_","t) return Wide","_","Wide","_","Character;","\n","\n",(0,s.jsx)(d.A,{children:"39.14/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["type char32","_","array is array (size","_","t range ","<",">",") of aliased char32","_","t","\n","      with Pack;","\n","\n",(0,s.jsx)(d.A,{children:"39.15/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["This paragraph was deleted.","\n","\n",(0,s.jsx)(d.A,{children:"39.16/2"}),"\nfunction Is","_","Nul","_","Terminated (Item : in char32","_","array) return Boolean;","\n","   function To","_","C (Item       : in Wide","_","Wide","_","String;","\n","                  Append","_","Nul : in Boolean := True)","\n","      return char32","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"39.17/2"}),"\nfunction To","_","Ada (Item     : in char32","_","array;","\n","                    Trim","_","Nul : in Boolean := True)","\n","      return Wide","_","Wide","_","String;","\n","\n",(0,s.jsx)(d.A,{children:"39.18/2"}),"\nprocedure To","_","C (Item       : in  Wide","_","Wide","_","String;","\n","                   Target     : out char32","_","array;","\n","                   Count      : out size","_","t;","\n","                   Append","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"39.19/2"}),"\nprocedure To","_","Ada (Item     : in  char32","_","array;","\n","                     Target   : out Wide","_","Wide","_","String;","\n","                     Count    : out Natural;","\n","                     Trim","_","Nul : in  Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"40"}),"\nTerminator","_","Error : exception;","\n","\n",(0,s.jsx)(d.A,{children:"41"}),"\nend Interfaces.C;","\n"]})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"41.a.1/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-defined",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The definitions of certain types and constants in Interfaces.C.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"42"}),"\n",(0,s.jsxs)("p",{children:["Each of the types declared in Interfaces.C is C-compatible.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"43/5"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01","AI12-0411-1"]}),"\n",(0,s.jsxs)("p",{children:["The types int, short, long, unsigned, ptrdiff","_","t, size","_","t, double, char, wchar","_","t, char16","_","t, and char32","_","t correspond respectively to the C types having the same names. The types signed","_","char, unsigned","_","short, unsigned","_","long, unsigned","_","char, C","_","bool, C","_","float, and long","_","double correspond respectively to the C types signed char, unsigned short, unsigned long, unsigned char, bool,  float, and long double.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"43.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The C types wchar","_","t and char16","_","t seem to be the same. However, wchar","_","t has an implementation-defined size, whereas char16","_","t is guaranteed to be an unsigned type of at least 16 bits. Also, char16","_","t and char32","_","t are encouraged to have UTF-16 and UTF-32 representations; that means that they are not directly the same as the Ada types, which most likely don't use any UTF encoding. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"44"}),"\n",(0,s.jsxs)("p",{children:["The type of the subtype plain","_","char is either signed","_","char or unsigned","_","char, depending on the C implementation. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"45"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C   (Item : in Character) return char;","\n","function To","_","Ada (Item : in char     ) return Character;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"46"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The functions To","_","C and To","_","Ada map between the Ada type Character and the C type char.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"46.a.1/1"}),(0,s.jsx)(h.A,{items:["AI95-00038-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"{",(0,s.jsx)("i",{children:"8652/0114"}),"}"," The To","_","C and To","_","Ada functions map between corresponding characters, not necessarily between characters with the same internal representation. Corresponding characters are characters defined by the same enumeration literal, if such exist; otherwise, the correspondence is unspecified.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"46.a.2/1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The following definition is equivalent to the above summary:",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"46.a.3/1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["To","_","C (Latin","_","1","_","Char) = char'Value(Character'Image(Latin","_","1","_","Char))",(0,s.jsx)("br",{}),"provided that char'Value does not raise an exception; otherwise the result is unspecified.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"46.a.4/1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["To","_","Ada (Native","_","C","_","Char) = Character'Value(char'Image(Native","_","C","_","Char))",(0,s.jsx)("br",{}),"provided that Character'Value does not raise an exception; otherwise the result is unspecified. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"47"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Is","_","Nul","_","Terminated (Item : in char","_","array) return Boolean;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"48"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of Is","_","Nul","_","Terminated is True if Item contains nul, and is False otherwise.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"49"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C   (Item : in String;     Append","_","Nul : in Boolean := True)","\n","   return char","_","array;","\n","\n","function To","_","Ada (Item : in char","_","array; Trim","_","Nul   : in Boolean := True)","\n","   return String;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"50/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00258-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of To","_","C is a char","_","array value of length Item'Length (if Append","_","Nul is False) or Item'Length+1 (if Append","_","Nul is True). The lower bound is 0. For each component Item(I), the corresponding component in the result is To","_","C applied to Item(I). The value nul is appended if Append","_","Nul is True. If Append","_","Nul is False and Item'Length is 0, then To","_","C propagates Constraint","_","Error.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"51"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of To","_","Ada is a String whose length is Item'Length (if Trim","_","Nul is False) or the length of the slice of Item preceding the first nul (if Trim","_","Nul is True). The lower bound of the result is 1. If Trim","_","Nul is False, then for each component Item(I) the corresponding component in the result is To","_","Ada applied to Item(I). If Trim","_","Nul is True, then for each component Item(I) before the first nul the corresponding component in the result is To","_","Ada applied to Item(I). The function propagates Terminator","_","Error if Trim","_","Nul is True and Item does not contain nul.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"52"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure To","_","C (Item       : in  String;","\n","                Target     : out char","_","array;","\n","                Count      : out size","_","t;","\n","                Append","_","Nul : in  Boolean := True);","\n","\n","procedure To","_","Ada (Item     : in  char","_","array;","\n","                  Target   : out String;","\n","                  Count    : out Natural;","\n","                  Trim","_","Nul : in  Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"53"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["For procedure To","_","C, each element of Item is converted (via the To","_","C function) to a char, which is assigned to the corresponding element of Target. If Append","_","Nul is True, nul is then assigned to the next element of Target. In either case, Count is set to the number of Target elements assigned. If Target is not long enough, Constraint","_","Error is propagated.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"54"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["For procedure To","_","Ada, each element of Item (if Trim","_","Nul is False) or each element of Item preceding the first nul (if Trim","_","Nul is True) is converted (via the To","_","Ada function) to a Character, which is assigned to the corresponding element of Target. Count is set to the number of Target elements assigned. If Target is not long enough, Constraint","_","Error is propagated. If Trim","_","Nul is True and Item does not contain nul, then Terminator","_","Error is propagated.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"55"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Is","_","Nul","_","Terminated (Item : in wchar","_","array) return Boolean;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"56"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of Is","_","Nul","_","Terminated is True if Item contains wide","_","nul, and is False otherwise.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"57"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C   (Item : in Wide","_","Character) return wchar","_","t;","\n","function To","_","Ada (Item : in wchar","_","t       ) return Wide","_","Character;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"58"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["To","_","C and To","_","Ada provide the mappings between the Ada and C wide character types.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"59"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C   (Item       : in Wide","_","String;","\n","                 Append","_","Nul : in Boolean := True)","\n","   return wchar","_","array;","\n","\n","function To","_","Ada (Item     : in wchar","_","array;","\n","                 Trim","_","Nul : in Boolean := True)","\n","   return Wide","_","String;","\n","\n","procedure To","_","C (Item       : in  Wide","_","String;","\n","                Target     : out wchar","_","array;","\n","                Count      : out size","_","t;","\n","                Append","_","Nul : in  Boolean := True);","\n","\n","procedure To","_","Ada (Item     : in  wchar","_","array;","\n","                  Target   : out Wide","_","String;","\n","                  Count    : out Natural;","\n","                  Trim","_","Nul : in  Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The To","_","C and To","_","Ada subprograms that convert between Wide","_","String and wchar","_","array have analogous effects to the To","_","C and To","_","Ada subprograms that convert between String and char","_","array, except that wide","_","nul is used instead of nul.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.1/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Is","_","Nul","_","Terminated (Item : in char16","_","array) return Boolean;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.2/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of Is","_","Nul","_","Terminated is True if Item contains char16","_","nul, and is False otherwise.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.3/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C (Item : in Wide","_","Character) return char16","_","t;","\n","function To","_","Ada (Item : in char16","_","t ) return Wide","_","Character;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.4/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["To","_","C and To","_","Ada provide mappings between the Ada and C 16-bit character types.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.5/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C (Item       : in Wide","_","String;","\n","               Append","_","Nul : in Boolean := True)","\n","   return char16","_","array;","\n","\n","function To","_","Ada (Item     : in char16","_","array;","\n","                 Trim","_","Nul : in Boolean := True)","\n","   return Wide","_","String;","\n","\n","procedure To","_","C (Item       : in  Wide","_","String;","\n","                Target     : out char16","_","array;","\n","                Count      : out size","_","t;","\n","                Append","_","Nul : in  Boolean := True);","\n","\n","procedure To","_","Ada (Item     : in  char16","_","array;","\n","                  Target   : out Wide","_","String;","\n","                  Count    : out Natural;","\n","                  Trim","_","Nul : in  Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.6/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The To","_","C and To","_","Ada subprograms that convert between Wide","_","String and char16","_","array have analogous effects to the To","_","C and To","_","Ada subprograms that convert between String and char","_","array, except that char16","_","nul is used instead of nul.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.7/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Is","_","Nul","_","Terminated (Item : in char32","_","array) return Boolean;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.8/5"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01","AI12-0437-1"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The result of Is","_","Nul","_","Terminated is True if Item contains char32","_","nul, and is False otherwise.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.9/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C (Item : in Wide","_","Wide","_","Character) return char32","_","t;","\n","function To","_","Ada (Item : in char32","_","t ) return Wide","_","Wide","_","Character;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.10/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["To","_","C and To","_","Ada provide mappings between the Ada and C 32-bit character types.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.11/2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","C (Item       : in Wide","_","Wide","_","String;","\n","               Append","_","Nul : in Boolean := True)","\n","   return char32","_","array;","\n","\n","function To","_","Ada (Item     : in char32","_","array;","\n","                 Trim","_","Nul : in Boolean := True)","\n","   return Wide","_","Wide","_","String;","\n","\n","procedure To","_","C (Item       : in  Wide","_","Wide","_","String;","\n","                Target     : out char32","_","array;","\n","                Count      : out size","_","t;","\n","                Append","_","Nul : in  Boolean := True);","\n","\n","procedure To","_","Ada (Item     : in  char32","_","array;","\n","                  Target   : out Wide","_","Wide","_","String;","\n","                  Count    : out Natural;","\n","                  Trim","_","Nul : in  Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"60.12/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["The To","_","C and To","_","Ada subprograms that convert between Wide","_","Wide","_","String and char32","_","array have analogous effects to the To","_","C and To","_","Ada subprograms that convert between String and char","_","array, except that char32","_","nul is used instead of nul.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.a"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The Interfaces.C package provides an implementation-defined character type, char, designed to model the C run-time character set, and mappings between the types char and Character.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.b"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["One application of the C interface package is to compose a C string and pass it to a C function. One way to do this is for the programmer to declare an object that will hold the C array, and then pass this array to the C function. This is realized via the type char","_","array: ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.c"}),(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["type char","_","array is array (size","_","t range ","<",">",") of Char;","\n"]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.d"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The programmer can declare an Ada String, convert it to a char","_","array, and pass the char","_","array as actual parameter to the C function that is expecting a char ","*",".",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.e"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["An alternative approach is for the programmer to obtain a C char pointer from an Ada String (or from a char","_","array) by invoking an allocation function. The package Interfaces.C.Strings (see below) supplies the needed facilities, including a private type chars","_","ptr that corresponds to C's char ","*",", and two allocation functions. To avoid storage leakage, a Free procedure releases the storage that was allocated by one of these allocate functions.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.f"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["It is typical for a C function that deals with strings to adopt the convention that the string is delimited by a nul char. The C interface packages support this convention. A constant nul of type Char is declared, and the function Value(Chars","_","Ptr) in Interfaces.C.Strings returns a char","_","array up to and including the first nul in the array that the chars","_","ptr points to. The Allocate","_","Chars function allocates an array that is nul terminated.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.g"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Some C functions that deal with strings take an explicit length as a parameter, thus allowing strings to be passed that contain nul as a data element. Other C functions take an explicit length that is an upper bound: the prefix of the string up to the char before nul, or the prefix of the given length, is used by the function, whichever is shorter. The C Interface packages support calling such functions. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"60.13/3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00131-01","AI05-0229-1"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," The Convention aspect with ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," C","_","Pass","_","By","_","Copy shall only be specified for a type.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.14/2"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00131-01","AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," The eligibility rules in ",(0,s.jsx)("a",{href:"/docs/arm/AA-B/AA-B.1",children:"B.1"})," do not apply to convention C","_","Pass","_","By","_","Copy. Instead, a type T is eligible for convention C","_","Pass","_","By","_","Copy if T is an unchecked union type or if T is a record type that has no discriminants and that only has components with statically constrained subtypes, and each component is C-compatible.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.15/3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00131-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," If a type is C","_","Pass","_","By","_","Copy-compatible, then it is also C-compatible.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"60.16/4"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0028-1"]}),"\n",(0,s.jsxs)("p",{children:["The identifiers C","_","Variadic","_","0, C","_","Variadic","_","1, C","_","Variadic","_","2, and so on are ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s. These conventions are said to be ",(0,s.jsxs)("i",{children:["C","_","Variadic"]}),". The convention C","_","Variadic","_",(0,s.jsx)("i",{children:"n"})," is the calling convention for a variadic C function taking ",(0,s.jsx)("i",{children:"n"})," fixed parameters and then a variable number of additional parameters. The C","_","Variadic","_",(0,s.jsx)("i",{children:"n"})," convention shall only be specified as the convention aspect for a subprogram, or for an access-to-subprogram type, having at least ",(0,s.jsx)("i",{children:"n"})," parameters. A type is compatible with a C","_","Variadic convention if and only if the type is C-compatible.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.h/4"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"To be honest: "}),"It is implementation defined what the largest ",(0,s.jsx)("i",{children:"n"})," in C","_","Variadic","_",(0,s.jsx)("i",{children:"n"})," is supported. We don't say this because it complicates the wording and it is true for almost any ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," (only Ada is required to be supported by the language, all others need to be documented in order for programmers to know that they are available). ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,s.jsx)(d.A,{children:"61/3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00131-01","AI05-0229-1"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," An implementation shall support specifying aspect Convention with a C ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," for a C-eligible type (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-B/AA-B.1",children:"B.1"}),"). An implementation shall support specifying aspect Convention with a C","_","Pass","_","By","_","Copy ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," for a C","_","Pass","_","By","_","Copy-eligible type. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,s.jsx)(d.A,{children:"62"}),"\n",(0,s.jsxs)("p",{children:["An implementation may provide additional declarations in the C interface packages.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"62.1/5"}),"\n",(0,s.jsx)(h.A,{items:["AI05-0002-1","AI05-0229-1","AI12-0444-1"]}),"\n",(0,s.jsxs)("p",{children:["An implementation is not required to support specifying the Convention aspect with ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," C in the following cases:",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"62.2/3"}),"\n",(0,s.jsx)(h.A,{items:["AI05-0248-1"]}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["for a subprogram that has a parameter of an unconstrained array subtype, unless the Import aspect has the value True for the subprogram;",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"62.3/3"}),(0,s.jsxs)("li",{children:["for a function with an unconstrained array result subtype;",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"62.4/3"}),(0,s.jsxs)("li",{children:["for an object whose nominal subtype is an unconstrained array subtype. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"62.a/3"}),(0,s.jsx)(h.A,{items:["AI05-0002-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"These rules ensure that an implementation never needs to create bounds for an unconstrained array that originates in C (and thus does not have bounds). An implementation can do so if it wishes, of course. Note that these permissions do not extend to passing an unconstrained array as a parameter to a C function; in this case, the bounds can simply be dropped and thus support is required. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-advice",children:"Implementation Advice"}),"\n",(0,s.jsx)(d.A,{children:"62.5/3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00037-01","AI95-00285-01"]}),"\n",(0,s.jsxs)("p",{children:["{",(0,s.jsx)("i",{children:"8652/0060"}),"}"," The constants nul, wide","_","nul, char16","_","nul, and char32","_","nul should have a representation of zero. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"62.b/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-advice",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The constants nul, wide","_","nul, char16","_","nul, and char32","_","nul in package Interfaces.C should have a representation of zero.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"63"}),"\n",(0,s.jsxs)("p",{children:["An implementation should support the following interface correspondences between Ada and C. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"64"}),"\n",(0,s.jsx)("ul",{children:(0,s.jsxs)("li",{children:["An Ada procedure corresponds to a void-returning C function. ",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"64.a"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The programmer can also choose an Ada procedure when the C function returns an int that is to be discarded.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"65"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["An Ada function corresponds to a non-void C function.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"65.1/4"}),(0,s.jsx)(h.A,{items:["AI12-0135-1"]}),(0,s.jsxs)("li",{children:["An Ada enumeration type corresponds to a C enumeration type with corresponding enumeration literals having the same internal codes, provided the internal codes fall within the range of the C int type.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"66"}),(0,s.jsxs)("li",{children:["An Ada ",(0,s.jsx)("b",{children:"in"})," scalar parameter is passed as a scalar argument to a C function.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"67"}),(0,s.jsxs)("li",{children:["An Ada ",(0,s.jsx)("b",{children:"in"})," parameter of an access-to-object type with designated type T is passed as a t","*"," argument to a C function, where t is the C type corresponding to the Ada type T.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"68"}),(0,s.jsxs)("li",{children:["An Ada ",(0,s.jsx)("b",{children:"access"})," T parameter, or an Ada ",(0,s.jsx)("b",{children:"out"})," or ",(0,s.jsx)("b",{children:"in out"})," parameter of an elementary type T, is passed as a t","*"," argument to a C function, where t is the C type corresponding to the Ada type T. In the case of an elementary ",(0,s.jsx)("b",{children:"out"})," or ",(0,s.jsx)("b",{children:"in out"})," parameter, a pointer to a temporary copy is used to preserve by-copy semantics.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"68.1/2"}),(0,s.jsx)(h.A,{items:["AI95-00131-01","AI95-00343-01"]}),(0,s.jsxs)("li",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," An Ada parameter of a (record) type T of convention C","_","Pass","_","By","_","Copy, of mode ",(0,s.jsx)("b",{children:"in"}),", is passed as a t argument to a C function, where t is the C struct corresponding to the Ada type T.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"69/5"}),(0,s.jsx)(h.A,{items:["AI95-00131-01","AI95-00343-01","AI12-0219-1"]}),(0,s.jsxs)("li",{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," An Ada parameter of a record type T, other than an ",(0,s.jsx)("b",{children:"in"})," parameter of a type of convention C","_","Pass","_","By","_","Copy, is passed as a t","*"," argument to a C function, with the const modifier if the Ada mode is ",(0,s.jsx)("b",{children:"in"}),", where t is the C struct corresponding to the Ada type T.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"70/5"}),(0,s.jsx)(h.A,{items:["AI12-0219-1"]}),(0,s.jsxs)("li",{children:["An Ada parameter of an array type with component type T is passed as a t","*"," argument to a C function, with the const modifier if the Ada mode is ",(0,s.jsx)("b",{children:"in"}),", where t is the C type corresponding to the Ada type T.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"71"}),(0,s.jsxs)("li",{children:["An Ada parameter of an access-to-subprogram type is passed as a pointer to a C function whose prototype corresponds to the designated subprogram's specification.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"71.1/3"}),(0,s.jsx)(h.A,{items:["AI05-0002-1"]}),(0,s.jsxs)("li",{children:["An Ada parameter of a private type is passed as specified for the full view of the type.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"71.2/3"}),(0,s.jsx)(h.A,{items:["AI05-0002-1"]}),(0,s.jsxs)("li",{children:["The rules of correspondence given above for parameters of mode ",(0,s.jsx)("b",{children:"in"})," also apply to the return object of a function.",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"71.3/5"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00337-01","AI05-0002-1","AI12-0184-1"]}),"\n",(0,s.jsxs)("p",{children:["An implementation should provide unsigned","_","long","_","long and long","_","long as 64-bit modular and signed integer types (respectively) in package Interfaces.C if the C implementation supports unsigned long long and long long as 64-bit types.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"71.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-advice",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"If C interfacing is supported, the interface correspondences between Ada and C should be supported.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"71.a.1/5"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-advice",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"If the C implementation supports unsigned long long and long long, unsigned","_","long","_","long and long","_","long should be supported.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"72"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE 1   Values of type char","_","array are not implicitly terminated with nul. If a char","_","array is to be passed as a parameter to an imported C function requiring nul termination, it is the programmer's responsibility to obtain this effect.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"73"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE 2   To obtain the effect of C's sizeof(item","_","type), where Item","_","Type is the corresponding Ada type, evaluate the expression: size","_","t(Item","_","Type'Size/CHAR","_","BIT).",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"74/2"}),(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),(0,s.jsxs)(a.A,{type:"aarm",aarm:"note",children:[(0,s.jsx)("i",{children:"This paragraph was deleted."}),(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"75/4"}),(0,s.jsx)(h.A,{items:["AI12-0028-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE 3   A variadic C function can correspond to several Ada subprograms, taking various specific numbers and types of parameters. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(d.A,{children:"76"}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("i",{children:"Example of using the Interfaces.C package:"})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"77/5"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0312-1"]}),"\n",(0,s.jsxs)(o.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["--Calling the C Library Functions strcpy and printf","\n","with Interfaces.C;","\n","procedure Test is","\n","   package C renames Interfaces.C;","\n","   use type C.char","_","array;","\n","   -- Call ","<","string.h",">","strcpy:","\n","   -- C definition of strcpy:  char ","*","strcpy(char ","*","s1, const char ","*","s2);","\n","   --    This function copies the string pointed to by s2 (including the terminating null character)","\n","   --     into the array pointed to by s1. If copying takes place between objects that overlap,","\n","   --     the behavior is undefined. The strcpy function returns the value of s1.","\n","\n",(0,s.jsx)(d.A,{children:"78/3"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["-- ","\n","   procedure Strcpy (Target : out C.char","_","array;","\n","                     Source : in  C.char","_","array)","\n","      with Import =",">"," True, Convention =",">"," C, External","_","Name =",">",' "strcpy";',"\n","\n",(0,s.jsx)(d.A,{children:"79/5"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1","AI12-0312-1"]}),(0,s.jsxs)(n.p,{children:["-- Call ","<","sdtio.h",">","printf:","\n","   -- C definition of printf:  int printf ( const char ","*"," format, ... );","\n","   --    This function writes the C string pointed by format to the standard output (stdout).","\n","   --     If format includes format specifiers (subsequences beginning with %), the additional","\n","   --     arguments following format are formatted and inserted in the resulting string","\n","   --     replacing their respective specifiers. If the number of arguments does not match","\n","   --     the number of format specifiers, or if the types of the arguments do not match","\n","   --     the corresponding format specifier, the behaviour is undefined. On success, the","\n","   --     printf function returns the total number of characters written to the standard output.","\n","   --     If a writing error occurs, a negative number is returned.","\n","\n",(0,s.jsx)(d.A,{children:"79.1/5"})]}),(0,s.jsx)(h.A,{items:["AI12-0312-1"]}),(0,s.jsxs)(n.p,{children:["-- ","\n","   procedure Printf (Format : in C.char","_","array;","\n","                     Param1 : in C.char","_","array;","\n","                     Param2 : in C.int)","\n","      with Import =",">"," True, Convention =",">"," C","_","Variadic","_","1, External","_","Name =",">",' "printf";',"\n","\n",(0,s.jsx)(d.A,{children:"80"}),"\nChars1 :  C.char","_","array(1..20);","\n","   Chars2 :  C.char","_","array(1..20);","\n","\n",(0,s.jsx)(d.A,{children:"81"}),"\nbegin","\n",'   Chars2(1..6) := "qwert" & C.nul;',"\n","\n",(0,s.jsx)(d.A,{children:"82"}),"\nStrcpy(Chars1, Chars2);","\n","\n",(0,s.jsx)(d.A,{children:"83"}),'\n-- Now Chars1(1..6) = "qwert" & C.Nul',"\n","\n",(0,s.jsx)(d.A,{children:"83.1/5"})]}),(0,s.jsx)(h.A,{items:["AI12-0312-1"]}),(0,s.jsxs)(n.p,{children:['Printf("The String=%s, Length=%d", Chars1, Chars1\'Length);',"\n","\n",(0,s.jsx)(d.A,{children:"84"}),"\nend Test;","\n"]})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"incompatibilities-with-ada-95",children:"Incompatibilities With Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.a/3"}),(0,s.jsx)(h.A,{items:["AI95-00285-01","AI05-0005-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Types char16","_","t and char32","_","t and their related types and operations are added to Interfaces.C. If Interfaces.C is referenced in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", and an entity ",(0,s.jsx)("i",{children:"E"})," with the same ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," as a new entity in Interfaces.C is defined in a package that is also referenced in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", the entity ",(0,s.jsx)("i",{children:"E"})," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.b/2"}),(0,s.jsx)(h.A,{items:["AI95-00131-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0059"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Convention C","_","Pass","_","By","_","Copy is new. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.c/2"}),(0,s.jsx)(h.A,{items:["AI95-00037-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0060"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Clarified the intent for Nul and Wide","_","Nul.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.d/2"}),(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Specified that an unchecked union type (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-B/AA-B.3#Subclause_B.3.3",children:"B.3.3"}),") is eligible for convention C","_","Pass","_","By","_","Copy.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.e/2"}),(0,s.jsx)(h.A,{items:["AI95-00258-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Specified what happens if the To","_","C function tries to return a null string.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.f/2"}),(0,s.jsx)(h.A,{items:["AI95-00337-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Clarified that the interface correspondences also apply to private types whose full types have the specified characteristics.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.g/2"}),(0,s.jsx)(h.A,{items:["AI95-00343-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Clarified that a type must have convention C","_","Pass","_","By","_","Copy in order to be passed by copy (not just a type that could have that convention).",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.h/2"}),(0,s.jsx)(h.A,{items:["AI95-00376-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Added wording to make it clear that these facilities can also be used with C++. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"incompatibilities-with-ada-2005",children:"Incompatibilities With Ada 2005"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.i/3"}),(0,s.jsx)(h.A,{items:["AI05-0002-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," Added a definition of correspondences for function results. Also added wording to make it clear that we do not expect the implementation to conjure bounds for unconstrained arrays out of thin air. These changes allow (but don't require) compilers to reject unreasonable uses of array types. Such uses probably didn't work anyway (and probably were rejected, no matter what the language definition said), so little existing code should be impacted. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"incompatibilities-with-ada-2012",children:"Incompatibilities With Ada 2012"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.j/5"}),(0,s.jsx)(h.A,{items:["AI12-0411-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Added type C","_","bool and (implicitly) the enumeration literals True and False to the Interfaces.C package. Therefore, a use clause conflict is possible; see the introduction of ",(0,s.jsx)("a",{href:"/docs/arm/AA-A/",children:"Annex A"})," for more on this topic. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-2012",children:"Extensions to Ada 2012"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.k/4"}),(0,s.jsx)(h.A,{items:["AI12-0028-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Corrigendum:"})," The ",(0,s.jsxs)("i",{children:["convention","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s C","_","Variadic","_","0, C","_","Variadic","_","1, and so on are new. These are classified as a correction as any implementation can add such identifiers and it is important that special conventions be available for variadic functions as typical x64 conventions are different for normal and variadic C functions.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.l/4"}),(0,s.jsx)(h.A,{items:["AI12-0135-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Corrigendum:"})," Defined the correspondence between an Ada enumeration type and a C enumeration type; implementations should support convention C for enumeration types. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.m/5"}),(0,s.jsx)(h.A,{items:["AI12-0184-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-advice",children:(0,s.jsxs)(n.p,{children:["Added  that types be defined in Interfaces.C corresponding to long long and unsigned long long.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.n/5"}),(0,s.jsx)(h.A,{items:["AI12-0219-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," Added advice that const t","*"," map to Ada ",(0,s.jsx)("b",{children:"in"})," parameters and vice versa.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"84.o/5"}),(0,s.jsx)(h.A,{items:["AI12-0411-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Added advice about mapping type Boolean. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)("a",{id:"Subclause_B.3.1"}),"\n",(0,s.jsx)(n.h2,{id:"b31--the-package-interfacescstrings",children:"B.3.1  The Package Interfaces.C.Strings"}),"\n",(0,s.jsx)(d.A,{children:"1/3_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),"\n",(0,s.jsxs)("p",{children:["The package Interfaces.C.Strings declares types and subprograms allowing an Ada program to allocate, reference, update, and free C-style strings. In particular, the private type chars","_","ptr corresponds to a common use of \u201cchar ","*","\u201d in C programs, and an object of this type can be passed to a subprogram to which ",(0,s.jsx)("b",{children:"with"})," Import =",">"," True, Convention =",">"," C has been specified, and for which \u201cchar ","*","\u201d is the type of the argument of the C function. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"2_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["The library package Interfaces.C.Strings has the following declaration: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"3/5_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsxs)(o.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["package Interfaces.C.Strings ","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,s.jsx)(d.A,{children:"4_B.3.1"}),"\ntype char","_","array","_","access is access all char","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"5/5_B.3.1"})]}),(0,s.jsx)(h.A,{items:["AI95-00161-01","AI12-0399-1"]}),(0,s.jsxs)(n.p,{children:["type chars","_","ptr is private","\n","      with Preelaborable","_","Initialization;","\n","\n",(0,s.jsx)(d.A,{children:"6/2_B.3.1"})]}),(0,s.jsx)(h.A,{items:["AI95-00276-01"]}),(0,s.jsxs)(n.p,{children:["type chars","_","ptr","_","array is array (size","_","t range ","<",">",") of aliased chars","_","ptr;","\n","\n",(0,s.jsx)(d.A,{children:"7_B.3.1"}),"\nNull","_","Ptr : constant chars","_","ptr;","\n","\n",(0,s.jsx)(d.A,{children:"8_B.3.1"}),"\nfunction To","_","Chars","_","Ptr (Item      : in char","_","array","_","access;","\n","                          Nul","_","Check : in Boolean := False)","\n","      return chars","_","ptr;","\n","\n",(0,s.jsx)(d.A,{children:"9_B.3.1"}),"\nfunction New","_","Char","_","Array (Chars   : in char","_","array) return chars","_","ptr;","\n","\n",(0,s.jsx)(d.A,{children:"10_B.3.1"}),"\nfunction New","_","String (Str : in String) return chars","_","ptr;","\n","\n",(0,s.jsx)(d.A,{children:"11_B.3.1"}),"\nprocedure Free (Item : in out chars","_","ptr);","\n","\n",(0,s.jsx)(d.A,{children:"12_B.3.1"}),"\nDereference","_","Error : exception;","\n","\n",(0,s.jsx)(d.A,{children:"13_B.3.1"}),"\nfunction Value (Item : in chars","_","ptr) return char","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"14_B.3.1"}),"\nfunction Value (Item : in chars","_","ptr; Length : in size","_","t)","\n","      return char","_","array;","\n","\n",(0,s.jsx)(d.A,{children:"15_B.3.1"}),"\nfunction Value (Item : in chars","_","ptr) return String;","\n","\n",(0,s.jsx)(d.A,{children:"16_B.3.1"}),"\nfunction Value (Item : in chars","_","ptr; Length : in size","_","t)","\n","      return String;","\n","\n",(0,s.jsx)(d.A,{children:"17_B.3.1"}),"\nfunction Strlen (Item : in chars","_","ptr) return size","_","t;","\n","\n",(0,s.jsx)(d.A,{children:"18_B.3.1"}),"\nprocedure Update (Item   : in chars","_","ptr;","\n","                     Offset : in size","_","t;","\n","                     Chars  : in char","_","array;","\n","                     Check  : in Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"19_B.3.1"}),"\nprocedure Update (Item   : in chars","_","ptr;","\n","                     Offset : in size","_","t;","\n","                     Str    : in String;","\n","                     Check  : in Boolean := True);","\n","\n",(0,s.jsx)(d.A,{children:"20_B.3.1"}),"\nUpdate","_","Error : exception;","\n","\n",(0,s.jsx)(d.A,{children:"21_B.3.1"}),"\nprivate","\n","   ... -- not specified by the language","\n","end Interfaces.C.Strings;","\n"]})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"21.a_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The string manipulation types and subprograms appear in a child of Interfaces.C versus being there directly, since it is useful to have Interfaces.C specified as ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Pure.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"21.b_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Differently named functions New","_","String and New","_","Char","_","Array are declared, since if there were a single overloaded function a call with a string literal as actual parameter would be ambiguous. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"22_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["The type chars","_","ptr is C-compatible and corresponds to the use of C's \u201cchar ","*","\u201d for a pointer to the first char in a char array terminated by nul. When an object of type chars","_","ptr is declared, its value is by default set to Null","_","Ptr, unless the object is imported (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-B/AA-B.1",children:"B.1"}),"). ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"22.a_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The type char","_","array","_","access is not necessarily C-compatible, since an object of this type may carry \u201cdope\u201d information. The programmer should convert from char","_","array","_","access to chars","_","ptr for objects imported from, exported to, or passed to C.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"23_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function To","_","Chars","_","Ptr (Item      : in char","_","array","_","access;","\n","                       Nul","_","Check : in Boolean := False)","\n","   return chars","_","ptr;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"24/3_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00140-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["{",(0,s.jsx)("i",{children:"8652/0061"}),"}"," If Item is ",(0,s.jsx)("b",{children:"null"}),", then To","_","Chars","_","Ptr returns Null","_","Ptr. If Item is not ",(0,s.jsx)("b",{children:"null"}),", Nul","_","Check is True, and Item.",(0,s.jsx)("b",{children:"all"})," does not contain nul, then the function propagates Terminator","_","Error; otherwise, To","_","Chars","_","Ptr performs a pointer conversion with no allocation of memory.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"25_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function New","_","Char","_","Array (Chars   : in char","_","array) return chars","_","ptr;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"26_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This function returns a pointer to an allocated object initialized to Chars(Chars'First .. Index) & nul, where ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"27_B.3.1"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["Index = Chars'Last if Chars does not contain nul, or",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"28_B.3.1"}),(0,s.jsxs)("li",{children:["Index is the smallest size","_","t value I such that Chars(I+1) = nul. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"28.1_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Storage","_","Error is propagated if the allocation fails.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"29_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function New","_","String (Str : in String) return chars","_","ptr;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"30_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This function is equivalent to New","_","Char","_","Array(To","_","C(Str)).",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"31_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Free (Item : in out chars","_","ptr);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"32_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["If Item is Null","_","Ptr, then Free has no effect. Otherwise, Free releases the storage occupied by Value(Item), and resets Item to Null","_","Ptr.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"33_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value (Item : in chars","_","ptr) return char","_","array;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"34/3_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["If Item = Null","_","Ptr, then Value propagates Dereference","_","Error. Otherwise, Value returns the prefix of the array of chars pointed to by Item, up to and including the first nul. The lower bound of the result is 0. If Item does not point to a nul-terminated string, then execution of Value is erroneous.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"35_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value (Item : in chars","_","ptr; Length : in size","_","t)","\n","   return char","_","array;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"36/3_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00139-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["{",(0,s.jsx)("i",{children:"8652/0062"}),"}"," If Item = Null","_","Ptr, then Value propagates Dereference","_","Error. Otherwise, Value returns the shorter of two arrays, either the first Length chars pointed to by Item, or Value(Item). The lower bound of the result is 0. If Length is 0, then Value propagates Constraint","_","Error. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"36.a_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"Value(New","_","Char","_","Array(Chars)) = Chars if Chars does not contain nul; else Value(New","_","Char","_","Array( Chars)) is the prefix of Chars up to and including the first nul. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"37_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value (Item : in chars","_","ptr) return String;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"38_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Equivalent to To","_","Ada(Value(Item), Trim","_","Nul=",">","True).",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"39_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value (Item : in chars","_","ptr; Length : in size","_","t)","\n","   return String;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"40/1_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00177-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["{",(0,s.jsx)("i",{children:"8652/0063"}),"}"," Equivalent to To","_","Ada(Value(Item, Length) & nul, Trim","_","Nul=",">","True).",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"41_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Strlen (Item : in chars","_","ptr) return size","_","t;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"42_B.3.1"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Returns ",(0,s.jsx)("i",{children:"Val"}),"'Length\u20131 where ",(0,s.jsx)("i",{children:"Val"})," = Value(Item); propagates Dereference","_","Error if Item = Null","_","Ptr. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"42.a_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"Strlen returns the number of chars in the array pointed to by Item, up to and including the char immediately before the first nul.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"42.b_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Strlen has the same possibility for erroneous execution as Value, in cases where the string has not been nul-terminated.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"42.c_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Strlen has the effect of C's strlen function. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"43_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Update (Item   : in chars","_","ptr;","\n","                  Offset : in size","_","t;","\n","                  Chars  : in char","_","array;","\n","                  Check  : Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"44/1_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00039-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["{",(0,s.jsx)("i",{children:"8652/0064"}),"}"," If Item = Null","_","Ptr, then Update propagates Dereference","_","Error. Otherwise, this procedure updates the value pointed to by Item, starting at position Offset, using Chars as the data to be copied into the array. Overwriting the nul terminator, and skipping with the Offset past the nul terminator, are both prevented if Check is True, as follows: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"45_B.3.1"}),"\n",(0,s.jsx)("ul",{children:(0,s.jsxs)("li",{children:["Let N = Strlen(Item). If Check is True, then: ",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsx)(d.A,{children:"46_B.3.1"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["If Offset+Chars'Length",">","N, propagate Update","_","Error.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"47_B.3.1"}),(0,s.jsxs)("li",{children:["Otherwise, overwrite the data in the array pointed to by Item, starting at the char at position Offset, with the data in Chars. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"48_B.3.1"}),"\n",(0,s.jsx)("ul",{children:(0,s.jsxs)("li",{children:["If Check is False, then processing is as above, but with no check that Offset+Chars'Length",">","N. ",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"48.a_B.3.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"If Chars contains nul, Update's effect may be to \u201cshorten\u201d the pointed-to char array.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"49_B.3.1"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Update (Item   : in chars","_","ptr;","\n","                  Offset : in size","_","t;","\n","                  Str    : in String;","\n","                  Check  : in Boolean := True);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"50/2_B.3.1"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00242-01"]}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Equivalent to Update(Item, Offset, To","_","C(Str, Append","_","Nul =",">"," False), Check). ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"50.a/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00242-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"To truncate the Item to the length of Str, use Update(Item, Offset, To","_","C(Str), Check) instead of Update(Item, Offset, Str, Check). Note that when truncating Item, Item must be longer than Str. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"erroneous-execution",children:"Erroneous Execution"}),"\n",(0,s.jsx)(d.A,{children:"51_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["Execution of any of the following is erroneous if the Item parameter is not null","_","ptr and Item does not point to a nul-terminated array of chars. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"52_B.3.1"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["a Value function not taking a Length parameter,",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"53_B.3.1"}),(0,s.jsxs)("li",{children:["the Free procedure,",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"54_B.3.1"}),(0,s.jsxs)("li",{children:["the Strlen function. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"55_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["Execution of Free(X) is also erroneous if the chars","_","ptr X was not returned by New","_","Char","_","Array or New","_","String.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"56_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["Reading or updating a freed char","_","array is erroneous.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"57_B.3.1"}),"\n",(0,s.jsxs)("p",{children:["Execution of Update is erroneous if Check is False and a call with Check equal to True would have propagated Update","_","Error. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"58/5_B.3.1"}),(0,s.jsx)(h.A,{items:["AI12-0440-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE   New","_","Char","_","Array and New","_","String can be implemented either through the allocation function from the C environment (\u201cmalloc\u201d) or through Ada dynamic memory allocation (\u201cnew\u201d). The key points are ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"59/5_B.3.1"}),(0,s.jsx)(h.A,{items:["AI12-0440-1"]}),(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["the returned value (a chars","_","ptr) is represented as a C \u201cchar ","*","\u201d so that it can be passed to C functions;",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"60/5_B.3.1"}),(0,s.jsx)(h.A,{items:["AI12-0442-1"]}),(0,s.jsxs)("li",{children:["the allocated object can be freed by the programmer via a call of Free, rather than by calling a C function. ",(0,s.jsx)("br",{})]})]})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"inconsistencies-with-ada-95",children:"Inconsistencies With Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.a/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00242-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Amendment "})," Update for a String parameter is now defined to not add a nul character. It did add a nul in Ada 95. This means that programs that used this behavior of Update to truncate a string will no longer work (the string will not be truncated). This change makes Update for a string consistent with Update for a char","_","array (no implicit nul is added to the end of a char","_","array). ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95-1",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.b/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00161-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Amendment "})," Added ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Preelaborable","_","Initialization to type chars","_","ptr, so that it can be used in preelaborated units.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.c/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00276-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Amendment "})," The components of chars","_","ptr","_","array are aliased so that it can be used to instantiate Interfaces.C.Pointers (that is its intended purpose, which is otherwise mysterious as it has no operations). ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-95-1",children:"Wording Changes from Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.d/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00140-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0061"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Fixed the missing semantics of To","_","Char","_","Ptr when Nul","_","Check is False.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.e/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00139-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0062"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Fixed the missing semantics of Value when the Length is 0.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.f/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00177-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0063"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Corrected the definition of Value to avoid raising Terminator","_","Error.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"60.g/2_B.3.1"}),(0,s.jsx)(h.A,{items:["AI95-00039-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["{",(0,s.jsx)("i",{children:"8652/0064"}),"}"," ",(0,s.jsx)("b",{children:"Corrigendum:"})," Fixed the missing semantics of Update when Item is Null","_","Ptr. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)("a",{id:"Subclause_B.3.2"}),"\n",(0,s.jsx)(n.h2,{id:"b32--the-generic-package-interfacescpointers",children:"B.3.2  The Generic Package Interfaces.C.Pointers"}),"\n",(0,s.jsx)(d.A,{children:"1_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["The generic package Interfaces.C.Pointers allows the Ada programmer to perform C-style operations on pointers. It includes an access type Pointer, Value functions that dereference a Pointer and deliver the designated array, several pointer arithmetic operations, and \u201ccopy\u201d procedures that copy the contents of a source pointer into the array designated by a destination pointer. As in C, it treats an object Ptr of type Pointer as a pointer to the first element of an array, so that for example, adding 1 to Ptr yields a pointer to the second element of the array.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"2/5_B.3.2"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0445-1"]}),"\n",(0,s.jsxs)("p",{children:["The generic allows two styles of usage: one in which the array is terminated by a special terminator element; and another in which the programmer keeps track of the length. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-2",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"3_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["The generic library package Interfaces.C.Pointers has the following declaration: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"4/5_B.3.2"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsxs)(o.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["generic","\n","   type Index is (","<",">",");","\n","   type Element is private;","\n","   type Element","_","Array is array (Index range ","<",">",") of aliased Element;","\n","   Default","_","Terminator : Element;","\n","package Interfaces.C.Pointers ","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,s.jsx)(d.A,{children:"5_B.3.2"}),"\ntype Pointer is access all Element;","\n","\n",(0,s.jsx)(d.A,{children:"6_B.3.2"}),"\nfunction Value(Ref        : in Pointer;","\n","                  Terminator : in Element := Default","_","Terminator)","\n","      return Element","_","Array;","\n","\n",(0,s.jsx)(d.A,{children:"7_B.3.2"}),"\nfunction Value(Ref    : in Pointer;","\n","                  Length : in ptrdiff","_","t)","\n","      return Element","_","Array;","\n","\n",(0,s.jsx)(d.A,{children:"8_B.3.2"}),"\nPointer","_","Error : exception;","\n","\n",(0,s.jsx)(d.A,{children:"9_B.3.2"}),"\n-- C-style Pointer arithmetic","\n","\n",(0,s.jsx)(d.A,{children:"10/3_B.3.2"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:['function "+" (Left : in Pointer;   Right : in ptrdiff',"_","t) return Pointer","\n","      with Convention =",">"," Intrinsic;","\n",'   function "+" (Left : in ptrdiff',"_","t; Right : in Pointer)   return Pointer","\n","      with Convention =",">"," Intrinsic;","\n",'   function "-" (Left : in Pointer;   Right : in ptrdiff',"_","t) return Pointer","\n","      with Convention =",">"," Intrinsic;","\n",'   function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff',"_","t","\n","      with Convention =",">"," Intrinsic;","\n","\n",(0,s.jsx)(d.A,{children:"11/3_B.3.2"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["procedure Increment (Ref : in out Pointer)","\n","      with Convention =",">"," Intrinsic;","\n","   procedure Decrement (Ref : in out Pointer)","\n","      with Convention =",">"," Intrinsic;","\n","\n",(0,s.jsx)(d.A,{children:"12/3_B.3.2"})]}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsxs)(n.p,{children:["This paragraph was deleted.","\n","\n",(0,s.jsx)(d.A,{children:"13_B.3.2"}),"\nfunction Virtual","_","Length (Ref        : in Pointer;","\n","                            Terminator : in Element := Default","_","Terminator)","\n","      return ptrdiff","_","t;","\n","\n",(0,s.jsx)(d.A,{children:"14_B.3.2"}),"\nprocedure Copy","_","Terminated","_","Array","\n","      (Source     : in Pointer;","\n","       Target     : in Pointer;","\n","       Limit      : in ptrdiff","_","t := ptrdiff","_","t'Last;","\n","       Terminator : in Element :=  Default","_","Terminator);","\n","\n",(0,s.jsx)(d.A,{children:"15_B.3.2"}),"\nprocedure Copy","_","Array (Source  : in Pointer;","\n","                         Target  : in Pointer;","\n","                         Length  : in ptrdiff","_","t);","\n","\n",(0,s.jsx)(d.A,{children:"16_B.3.2"}),"\nend Interfaces.C.Pointers;","\n"]})]}),"\n",(0,s.jsx)(d.A,{children:"17_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["The type Pointer is C-compatible and corresponds to one use of C's \u201cElement ","*","\u201d. An object of type Pointer is interpreted as a pointer to the initial Element in an Element","_","Array. Two styles are supported: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"18_B.3.2"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["Explicit termination of an array value with Default","_","Terminator (a special terminator value);",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"19_B.3.2"}),(0,s.jsxs)("li",{children:["Programmer-managed length, with Default","_","Terminator treated simply as a data element. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"20_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value(Ref        : in Pointer;","\n","               Terminator : in Element := Default","_","Terminator)","\n","   return Element","_","Array;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"21_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This function returns an Element","_","Array whose value is the array pointed to by Ref, up to and including the first Terminator; the lower bound of the array is Index'First. Interfaces.C.Strings.Dereference","_","Error is propagated if Ref is ",(0,s.jsx)("b",{children:"null"}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"22_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Value(Ref    : in Pointer;","\n","               Length : in ptrdiff","_","t)","\n","   return Element","_","Array;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"23_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This function returns an Element","_","Array comprising the first Length elements pointed to by Ref. The exception Interfaces.C.Strings.Dereference","_","Error is propagated if Ref is ",(0,s.jsx)("b",{children:"null"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"24_B.3.2"}),"\n",(0,s.jsxs)("p",{children:['The "+" and "\u2013" functions perform arithmetic on Pointer values, based on the Size of the array elements. In each of these functions, Pointer',"_","Error is propagated if a Pointer parameter is ",(0,s.jsx)("b",{children:"null"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"25_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Increment (Ref : in out Pointer);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"26_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Equivalent to Ref := Ref+1.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"27_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Decrement (Ref : in out Pointer);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"28_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Equivalent to Ref := Ref\u20131.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"29_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["function Virtual","_","Length (Ref        : in Pointer;","\n","                         Terminator : in Element := Default","_","Terminator)","\n","   return ptrdiff","_","t;","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"30_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["Returns the number of Elements, up to the one just before the first Terminator, in Value(Ref, Terminator).",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"31_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Copy","_","Terminated","_","Array","\n","   (Source     : in Pointer;","\n","    Target     : in Pointer;","\n","    Limit      : in ptrdiff","_","t := ptrdiff","_","t'Last;","\n","    Terminator : in Element := Default","_","Terminator);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"32_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This procedure copies Value(Source, Terminator) into the array pointed to by Target; it stops either after Terminator has been copied, or the number of elements copied is Limit, whichever occurs first. Dereference","_","Error is propagated if either Source or Target is ",(0,s.jsx)("b",{children:"null"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.a_B.3.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"It is the programmer's responsibility to ensure that elements are not copied beyond the logical length of the target array. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.b_B.3.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The implementation has to take care to check the Limit first. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"33_B.3.2"}),"\n",(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Copy","_","Array (Source  : in Pointer;","\n","                      Target  : in Pointer;","\n","                      Length  : in ptrdiff","_","t);","\n"]})}),"\n",(0,s.jsx)(d.A,{children:"34_B.3.2"}),"\n",(0,s.jsxs)("p",{class:"Indented4",children:["This procedure copies the first Length elements from the array pointed to by Source, into the array pointed to by Target. Dereference","_","Error is propagated if either Source or Target is ",(0,s.jsx)("b",{children:"null"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"erroneous-execution-1",children:"Erroneous Execution"}),"\n",(0,s.jsx)(d.A,{children:"35_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["It is erroneous to dereference a Pointer that does not designate an aliased Element. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"35.a_B.3.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),'Such a Pointer could arise via "+", "\u2013", Increment, or Decrement.',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"36_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["Execution of Value(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element","_","Array terminated by Terminator.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"37_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["Execution of Value(Ref, Length) is erroneous if Ref does not designate an aliased Element in an Element","_","Array containing at least Length Elements between the designated Element and the end of the array, inclusive.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"38_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["Execution of Virtual","_","Length(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element","_","Array terminated by Terminator.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"39_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["Execution of Copy","_","Terminated","_","Array(Source, Target, Limit, Terminator) is erroneous in either of the following situations: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"40_B.3.2"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["Execution of both Value(Source, Terminator) and Value(Source, Limit) are erroneous, or",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"41_B.3.2"}),(0,s.jsxs)("li",{children:["Copying writes past the end of the array containing the Element designated by Target. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsx)(d.A,{children:"42_B.3.2"}),"\n",(0,s.jsxs)("p",{children:["Execution of Copy","_","Array(Source, Target, Length) is erroneous if either Value(Source, Length) is erroneous, or copying writes past the end of the array containing the Element designated by Target. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"43_B.3.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE   To compose a Pointer from an Element","_","Array, use 'Access on the first element. For example (assuming appropriate instantiations): ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"44_B.3.2"}),(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["Some","_","Array   : Element","_","Array(0..5) ;","\n","Some","_","Pointer : Pointer := Some","_","Array(0)'Access;","\n"]})})]}),"\n",(0,s.jsx)(n.h4,{id:"examples-1",children:"Examples"}),"\n",(0,s.jsx)(d.A,{children:"45_B.3.2"}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("i",{children:"Example of Interfaces.C.Pointers:"})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"46_B.3.2"}),"\n",(0,s.jsxs)(o.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["with Interfaces.C.Pointers;","\n","with Interfaces.C.Strings;","\n","procedure Test","_","Pointers is","\n","   package C renames Interfaces.C;","\n","   package Char","_","Ptrs is","\n","      new C.Pointers (Index              =",">"," C.size","_","t,","\n","                      Element            =",">"," C.char,","\n","                      Element","_","Array      =",">"," C.char","_","array,","\n","                      Default","_","Terminator =",">"," C.nul);","\n","\n",(0,s.jsx)(d.A,{children:"47_B.3.2"}),"\nuse type Char","_","Ptrs.Pointer;","\n","   subtype Char","_","Star is Char","_","Ptrs.Pointer;","\n","\n",(0,s.jsx)(d.A,{children:"48_B.3.2"}),"\nprocedure Strcpy (Target","_","Ptr, Source","_","Ptr : Char","_","Star) is","\n","      Target","_","Temp","_","Ptr : Char","_","Star := Target","_","Ptr;","\n","      Source","_","Temp","_","Ptr : Char","_","Star := Source","_","Ptr;","\n","      Element : C.char;","\n","   begin","\n","      if Target","_","Temp","_","Ptr = null or Source","_","Temp","_","Ptr = null then","\n","         raise C.Strings.Dereference","_","Error;","\n","      end if;","\n","\n",(0,s.jsx)(d.A,{children:"49/1_B.3.2"})]}),(0,s.jsx)(h.A,{items:["AI95-00142-01"]}),(0,s.jsxs)(n.p,{children:["{","8652/0065","}","       loop","\n","         Element             := Source","_","Temp","_","Ptr.all;","\n","         Target","_","Temp","_","Ptr.all := Element;","\n",'         exit when C."="(Element, C.nul);',"\n","         Char","_","Ptrs.Increment(Target","_","Temp","_","Ptr);","\n","         Char","_","Ptrs.Increment(Source","_","Temp","_","Ptr);","\n","      end loop;","\n","   end Strcpy;","\n","begin","\n","   ...","\n","end Test","_","Pointers;","\n"]}),(0,s.jsx)("a",{id:"Subclause_B.3.3"})]}),"\n",(0,s.jsx)(n.h2,{id:"b33--unchecked-union-types",children:"B.3.3  Unchecked Union Types"}),"\n",(0,s.jsx)(d.A,{children:"1/3_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01","AI05-0229-1","AI05-0269-1"]}),"\n",(0,s.jsxs)("p",{children:["[Specifying aspect Unchecked","_","Union to have the value True defines an interface correspondence between a given discriminated type and some C union. The aspect requires that the associated type shall be given a representation that allocates no space for its discriminant(s).] ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsxs)("i",{children:["Paragraphs 2 through 3 were moved to ",(0,s.jsx)("a",{href:"/docs/arm/AA-J/",children:"Annex J"}),", \u201c",(0,s.jsx)("a",{href:"/docs/arm/AA-J/",children:"Obsolescent Features"}),"\u201d."]})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-3",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"3.1/3_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),"\n",(0,s.jsxs)("p",{children:["For a discriminated record type having a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0071",children:"variant_part"})}),", the following language-defined representation aspect may be specified:",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"3.2/3_B.3.3"}),"\n",(0,s.jsxs)("dt",{children:[(0,s.jsx)("br",{}),"Unchecked","_","Union"]}),"\n",(0,s.jsx)("dl",{children:(0,s.jsxs)("dd",{children:["The type of aspect Unchecked","_","Union is Boolean. If directly specified, the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0348",children:"aspect_definition"})})," shall be a static expression. If not specified (including by inheritance), the aspect is False.",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"3.a/3_B.3.3"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{children:"Aspect Description for "}),(0,s.jsxs)("b",{children:["Unchecked","_","Union: "]}),"Type is used to interface to a C union type.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("i",{children:"Paragraphs 4 and 5 were deleted."})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"6/3_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01","AI05-0229-1"]}),"\n",(0,s.jsxs)("p",{children:["A type for which aspect Unchecked","_","Union is True is called an ",(0,s.jsx)("i",{children:"unchecked union type"}),". A subtype of an unchecked union type is defined to be an ",(0,s.jsx)("i",{children:"unchecked union subtype"}),". An object of an unchecked union type is defined to be an ",(0,s.jsx)("i",{children:"unchecked union object"}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"7/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["All component subtypes of an unchecked union type shall be C-compatible.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"8/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["If a component subtype of an unchecked union type is subject to a per-object constraint, then the component subtype shall be an unchecked union subtype.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"9/5_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01","AI05-0026-1","AI12-0174-1"]}),"\n",(0,s.jsxs)("p",{children:["Any name that denotes a discriminant of an object of an unchecked union type shall occur within the declarative region of the type or as the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0099",children:"selector_name"})})," of an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.3#S0106",children:"aggregate"})}),", and shall not occur within a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-13/AA-13.5#S0352",children:"record_representation_clause"})}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"10/3_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01","AI05-0026-1"]}),"\n",(0,s.jsxs)("p",{children:["The type of a component declared in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0071",children:"variant_part"})})," of an unchecked union type shall not need finalization. In addition to the places where Legality Rules normally apply (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3",children:"12.3"}),"), this rule also applies in the private part of an instance of a generic unit. For an unchecked union type declared within the body of a generic unit, or within the body of any of its descendant library units, no part of the type of a component declared in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0071",children:"variant_part"})})," of the unchecked union type shall be of a formal private type or formal private extension declared within the formal part of the generic unit.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"10.a/3_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0026-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"reason",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"The last part is a classic assume-the-worst rule that avoids dependence on the actuals in a generic body. We did not include this in the definition of \u201cneeds finalization\u201d as it has a bad interaction with the use of that term for the No","_","Nested","_","Finalization restriction. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(d.A,{children:"11/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["The completion of an incomplete or private type declaration having a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0061",children:"known_discriminant_part"})})," shall not be an unchecked union type.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"12/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["An unchecked union subtype shall only be passed as a generic actual parameter if the corresponding formal type has no known discriminants or is an unchecked union type.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"12.a/2_B.3.3"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"This includes formal private types without a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0061",children:"known_discriminant_part"})}),", formal derived types that do not inherit any discriminants (formal derived types do not have ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0061",children:"known_discriminant_part"})}),"s), and formal derived types that are unchecked union types. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-4",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"13/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["An unchecked union type is eligible for convention C.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"14/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["All objects of an unchecked union type have the same size.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"15/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["Discriminants of objects of an unchecked union type are of size zero.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"16/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["Any check which would require reading a discriminant of an unchecked union object is suppressed (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-11/AA-11.5",children:"11.5"}),"). These checks include:",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"17/5_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI12-0453-1"]}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["The check performed when addressing a variant component (that is, a component that was declared in a variant part) of an unchecked union object that the object has this component (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#Subclause_4.1.3",children:"4.1.3"}),").",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"18/2_B.3.3"}),(0,s.jsxs)("li",{children:["Any checks associated with a type or subtype conversion of a value of an unchecked union type (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.6",children:"4.6"}),"). This includes, for example, the check associated with the implicit subtype conversion of an assignment statement.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"19/2_B.3.3"}),(0,s.jsxs)("li",{children:["The subtype membership check associated with the evaluation of a qualified expression (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7",children:"4.7"}),") or an uninitialized allocator (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8",children:"4.8"}),"). ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"19.a/2_B.3.3"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{}),"If a suppressed check would have failed, execution is erroneous (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-11/AA-11.5",children:"11.5"}),"). An implementation is always allowed to make a suppressed check if it can somehow determine the discriminant value. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,s.jsx)(d.A,{children:"20/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["A view of an unchecked union object (including a type conversion or function call) has ",(0,s.jsx)("i",{children:"inferable discriminants"})," if it has a constrained nominal subtype, unless the object is a component of an enclosing unchecked union object that is subject to a per-object constraint and the enclosing object lacks inferable discriminants.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"21/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["An expression of an unchecked union type has inferable discriminants if it is either a name of an object with inferable discriminants or a qualified expression whose ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," denotes a constrained subtype.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"22/2_B.3.3"}),"\n",(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),"\n",(0,s.jsxs)("p",{children:["Program","_","Error is raised in the following cases:",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"23/2_B.3.3"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["Evaluation of the predefined equality operator for an unchecked union type if either of the operands lacks inferable discriminants.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"24/2_B.3.3"}),(0,s.jsxs)("li",{children:["Evaluation of the predefined equality operator for a type which has a subcomponent of an unchecked union type whose nominal subtype is unconstrained.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"25/5_B.3.3"}),(0,s.jsx)(h.A,{items:["AI12-0162-1"]}),(0,s.jsxs)("li",{children:["Evaluation of an individual membership test if the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," (if any) denotes a constrained unchecked union subtype and the ",(0,s.jsxs)("i",{children:["tested","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0138",children:"simple_expression"})})," lacks inferable discriminants.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"26/2_B.3.3"}),(0,s.jsxs)("li",{children:["Conversion from a derived unchecked union type to an unconstrained non-unchecked-union type if the operand of the conversion lacks inferable discriminants.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"27/2_B.3.3"}),(0,s.jsxs)("li",{children:["Execution of the default implementation of the Write or Read attribute of an unchecked union type.",(0,s.jsx)("br",{})]}),(0,s.jsx)(d.A,{children:"28/2_B.3.3"}),(0,s.jsxs)("li",{children:["Execution of the default implementation of the Output or Input attribute of an unchecked union type if the type lacks default discriminant values. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("i",{children:"Paragraph 29 was deleted."})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"30/2_B.3.3"}),(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE   The use of an unchecked union to obtain the effect of an unchecked conversion results in erroneous execution (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-11/AA-11.5",children:"11.5"}),"). Execution of the following example is erroneous even if Float'Size = Integer'Size:",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"31/3_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsx)(o.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["type T (Flag : Boolean := False) is","\n","   record","\n","       case Flag is","\n","           when False =",">","\n","               F1 : Float := 0.0;","\n","           when True =",">","\n","               F2 : Integer := 0;","\n","       end case;","\n","    end record","\n","    with Unchecked","_","Union;","\n","\n",(0,s.jsx)(d.A,{children:"32/2_B.3.3"}),"\nX : T;","\n","Y : Integer := X.F2; -- erroneous","\n"]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95-2",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.a/2_B.3.3"}),(0,s.jsx)(h.A,{items:["AI95-00216-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"Pragma"})})," Unchecked","_","Union is new. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"incompatibilities-with-ada-2005-1",children:"Incompatibilities With Ada 2005"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.b/3_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0026-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," The use of discriminants on Unchecked","_","Union types is now illegal in ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-13/AA-13.5#S0352",children:"record_representation_clause"})}),"s, as it makes no sense to specify a position for something that is not supposed to exist. It is very unlikely that this change will have any impact on existing code. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.c/3_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0229-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Aspect Unchecked","_","Union is new; ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Unchecked","_","Union is now obsolescent. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.d/3_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0026-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," Revised the rules to use the \u201cneeds finalization\u201d definition, and eliminated generic contract issues. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-2012-1",children:"Wording Changes from Ada 2012"})}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.e/5_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0162-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," Adjusted the wording to reflect that membership tests can have more than one expression or ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),".",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(c.A,{children:[(0,s.jsx)(d.A,{children:"32.f/5_B.3.3"}),(0,s.jsx)(h.A,{items:["AI05-0174-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("b",{})," Adjusted the wording to allow named aggregates of an unchecked union type; it is clearly madness to allow positional record components in an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-4/AA-4.3#S0106",children:"aggregate"})})," but not named component associations. ",(0,s.jsx)("br",{})]})})]})]})}function A(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);