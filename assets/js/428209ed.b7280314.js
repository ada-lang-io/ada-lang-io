"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["3206"],{51267:function(e,s,r){r.r(s),r.d(s,{frontMatter:()=>h,toc:()=>j,default:()=>A,metadata:()=>i,assets:()=>p,contentTitle:()=>x});var i=JSON.parse('{"id":"arm/AA-3/AA-3.2","title":"3.2. Types and Subtypes","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-3/AA-3.2.mdx","sourceDirName":"arm/AA-3","slug":"/arm/AA-3/AA-3.2","permalink":"/docs/arm/AA-3/AA-3.2","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20},"sidebar":"referenceManualSidebar","previous":{"title":"3.1. Declarations","permalink":"/docs/arm/AA-3/AA-3.1"},"next":{"title":"3.3. Objects and Named Numbers","permalink":"/docs/arm/AA-3/AA-3.3"}}'),n=r(85893),a=r(50065),t=r(13393),c=r(82315),d=r(88514),o=r(1927),l=r(96470);let h={sidebar_position:20},x="3.2. Types and Subtypes",p={},j=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"3.2.1  Type Declarations",id:"321--type-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"3.2.2  Subtype Declarations",id:"322--subtype-declarations",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"3.2.3  Classification of Operations",id:"323--classification-of-operations",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"3.2.4  Subtype Predicates",id:"324--subtype-predicates",level:2},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-2",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}];function m(e){let s={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"32-types-and-subtypes",children:"3.2. Types and Subtypes"})}),"\n",(0,n.jsx)(s.admonition,{type:"danger",children:(0,n.jsxs)(s.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.jsx)(s.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,n.jsx)(s.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"1"}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("i",{children:"type"})," is characterized by a set of values, and a set of ",(0,n.jsx)("i",{children:"primitive operations"})," which implement the fundamental aspects of its semantics. An ",(0,n.jsx)("i",{children:"object"})," of a given type is a run-time entity that contains (has) a value of the type. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.a/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"type"})," \u2014 defining characteristic of each object and expression of the language, with an associated set of values, and a set of primitive operations that implement the fundamental aspects of its semantics",(0,n.jsx)("br",{}),"Note: Types are grouped into categories. Most language-defined categories of types are also classes of types.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.b/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"subtype"})," \u2014 type together with optional constraints, null exclusions, and predicates, which constrain the values of the type to the subset that satisfies the implied conditions",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"2/5"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00442-01","AI12-0451-1"]}),"\n",(0,n.jsxs)("p",{children:["Types are grouped into ",(0,n.jsx)("i",{children:"categories"})," of types. There exist several ",(0,n.jsx)("i",{children:"language-defined categories"})," of types (summarized in the NOTE below), reflecting the similarity of their values and primitive operations. [Most categories of types form ",(0,n.jsx)("i",{children:"classes"})," of types.] ",(0,n.jsx)("i",{children:"Elementary"})," types are those whose values are logically indivisible; ",(0,n.jsx)("i",{children:"composite"})," types are those whose values are composed of ",(0,n.jsx)("i",{children:"component"})," values. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.a/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"proof",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The formal definition of ",(0,n.jsx)("i",{children:"category"})," and ",(0,n.jsx)("i",{children:"class"})," is found in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.b/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"class of types"})," \u2014 set of types that is closed under derivation, which means that if a given type is in the class, then all types derived from that type are also in the class",(0,n.jsx)("br",{}),"Note: The set of types of a class share common properties, such as their primitive operations.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.c/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"category of types"})," \u2014 set of types with one or more common properties, such as primitive operations",(0,n.jsx)("br",{}),"Note: A category of types that is closed under derivation is also known as a class.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.d/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"elementary type"})," \u2014 type that does not have components",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.e/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"composite type"})," \u2014 type with components, such as an array or record",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.f/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"scalar type"})," \u2014 either a discrete type or a real type",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.g/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"access type"})," \u2014 type that has values that designate aliased objects",(0,n.jsx)("br",{}),"Note: Access types correspond to \u201Cpointer types\u201D or \u201Creference types\u201D in some other languages.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.h/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"discrete type"})," \u2014 type that is either an integer type or an enumeration type",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.i/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"real type"})," \u2014 type that has values that are approximations of the real numbers",(0,n.jsx)("br",{}),"Note: Floating point and fixed point types are real types.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.j/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"integer type"})," \u2014 type that represents signed or modular integers",(0,n.jsx)("br",{}),"Note: A signed integer type has a base range that includes both positive and negative numbers, and has operations that can raise an exception when the result is outside the base range. A modular type has a base range whose lower bound is zero, and has operations with \u201Cwraparound\u201D semantics. Modular types subsume what are called \u201Cunsigned types\u201D in some other languages.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.k/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"enumeration type"})," \u2014 type defined by an enumeration of its values, which can be denoted by identifiers or character literals",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.l/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"character type"})," \u2014 enumeration type whose values include characters",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.m/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"record type"})," \u2014 composite type consisting of zero or more named components, possibly of different types",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.n/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"record extension"})," \u2014 type that extends another type optionally with additional components",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.o/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"array type"})," \u2014 composite type whose components are all of the same type",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.p/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"task type"})," \u2014 composite type used to represent active entities which execute concurrently and that can communicate via queued task entries",(0,n.jsx)("br",{}),"Note: The top-level task of a partition is called the environment task.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.q/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"protected type"})," \u2014 composite type whose components are accessible only through one of its protected operations, which synchronize concurrent access by multiple tasks",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.r/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"partial view"})," \u2014 view of a type that reveals only some of its properties",(0,n.jsx)("br",{}),"Note: The remaining properties are defined by the full view given elsewhere.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.s/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"full view"})," \u2014 view of a type that reveals all of its properties",(0,n.jsx)("br",{}),"Note: There can be other views of the type that reveal fewer properties.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.t/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"incomplete view"})," \u2014 view of a type that reveals minimal properties",(0,n.jsx)("br",{}),"Note: The remaining properties are defined by the full view given elsewhere.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.u/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"private type"})," \u2014 type that defines a partial view",(0,n.jsx)("br",{}),"Note: Private types can be used for defining abstractions that hide unnecessary details from their clients.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.v/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"private extension"})," \u2014 type that extends another type, with the additional properties hidden from its clients",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.w/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"full type"})," \u2014 type that defines a full view",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"2.x/5"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"incomplete type"})," \u2014 type that defines an incomplete view",(0,n.jsx)("br",{}),"Note: Incomplete types can be used for defining recursive data structures.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"3"}),"\n",(0,n.jsxs)("p",{children:["The elementary types are the ",(0,n.jsx)("i",{children:"scalar"})," types (",(0,n.jsx)("i",{children:"discrete"})," and ",(0,n.jsx)("i",{children:"real"}),") and the ",(0,n.jsx)("i",{children:"access"})," types (whose values provide access to objects or subprograms). Discrete types are either ",(0,n.jsx)("i",{children:"integer"})," types or are defined by enumeration of their values (",(0,n.jsx)("i",{children:"enumeration"})," types). Real types are either ",(0,n.jsx)("i",{children:"floating point"})," types or ",(0,n.jsx)("i",{children:"fixed point"})," types.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"4/2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00251-01","AI95-00326-01"]}),"\n",(0,n.jsxs)("p",{children:["The composite types are the ",(0,n.jsx)("i",{children:"record"})," types, ",(0,n.jsx)("i",{children:"record extensions"}),", ",(0,n.jsx)("i",{children:"array"})," types, ",(0,n.jsx)("i",{children:"interface"})," types, ",(0,n.jsx)("i",{children:"task"})," types, and ",(0,n.jsx)("i",{children:"protected"})," types. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"4.a/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsxs)(t.Z,{type:"aarm",aarm:"note",children:[(0,n.jsx)("i",{children:"This paragraph was deleted."}),(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsx)(o.Z,{children:"4.1/2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00326-01"]}),"\n",(0,n.jsxs)("p",{children:["There can be multiple views of a type with varying sets of operations. [An ",(0,n.jsx)("i",{children:"incomplete"})," type represents an incomplete view (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#Subclause_3.10.1",children:"3.10.1"}),") of a type with a very restricted usage, providing support for recursive data structures. A ",(0,n.jsx)("i",{children:"private"})," type or ",(0,n.jsx)("i",{children:"private extension"})," represents a partial view (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3",children:"7.3"}),") of a type, providing support for data abstraction. The full view (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.1",children:"3.2.1"}),") of a type represents its complete definition.] An incomplete or partial view is considered a composite type[, even if the full view is not]. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"4.b/3"}),(0,n.jsx)(l.Z,{items:["AI05-0299-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"proof",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The real definitions of the views are in the referenced subclauses. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"5/2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00326-01"]}),"\n",(0,n.jsxs)("p",{children:["Certain composite types (and views thereof) have special components called ",(0,n.jsx)("i",{children:"discriminants"})," whose values affect the presence, constraints, or initialization of other components. Discriminants can be thought of as parameters of the type.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"6/2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00366-01"]}),"\n",(0,n.jsxs)("p",{children:["The term ",(0,n.jsx)("i",{children:"subcomponent"})," is used in this Reference Manual in place of the term component to indicate either a component, or a component of another subcomponent. Where other subcomponents are excluded, the term component is used instead. Similarly, a ",(0,n.jsx)("i",{children:"part"})," of an object or value is used to mean the whole object or value, or any set of its subcomponents. The terms component, subcomponent, and part are also applied to a type meaning the component, subcomponent, or part of objects and values of the type. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"6.a"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The definition of \u201Cpart\u201D here is designed to simplify rules elsewhere. By design, the intuitive meaning of \u201Cpart\u201D will convey the correct result to the casual reader, while this formalistic definition will answer the concern of the compiler-writer.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"6.b"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["We use the term \u201Cpart\u201D when talking about the parent part, ancestor part, or extension part of a type extension. In contexts such as these, the part might represent an empty set of subcomponents (e.g. in a null record extension, or a nonnull extension of a null record). We also use \u201Cpart\u201D when specifying rules such as those that apply to an object with a \u201Ccontrolled part\u201D meaning that it applies if the object as a whole is controlled, or any subcomponent is. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"7/2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00231-01"]}),"\n",(0,n.jsxs)("p",{children:["The set of possible values for an object of a given type can be subjected to a condition that is called a ",(0,n.jsx)("i",{children:"constraint"})," (the case of a ",(0,n.jsx)("i",{children:"null constraint"})," that specifies no restriction is also included)[; the rules for which values satisfy a given kind of constraint are given in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5",children:"3.5"})," for ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})}),"s, ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#Subclause_3.6.1",children:"3.6.1"})," for ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0057",children:"index_constraint"})}),"s, and ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#Subclause_3.7.1",children:"3.7.1"})," for ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0064",children:"discriminant_constraint"})}),"s]. The set of possible values for an object of an access type can also be subjected to a condition that excludes the null value (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10",children:"3.10"}),").",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.a/5"}),(0,n.jsx)(l.Z,{items:["AI12-0140-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"\u201CNull constraint\u201D includes the cases of no explicit constraint, as well as unknown discriminants and unconstrained array type declarations (which are explicit ways to declare no constraint). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"8/5"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00231-01","AI95-00415-01","AI12-0445-1"]}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("i",{children:"subtype"})," of a given type is a combination of the type, a constraint on values of the type, and certain attributes specific to the subtype. The given type is called the ",(0,n.jsx)("i",{children:"type of the subtype"}),". Similarly, the associated constraint is called the ",(0,n.jsx)("i",{children:"constraint of the subtype"}),". The set of values of a subtype consists of the values of its type that satisfy its constraint and any exclusion of the null value. Such values ",(0,n.jsx)("i",{children:"belong"})," to the subtype. The other values of the type are ",(0,n.jsx)("i",{children:"outside"})," the subtype. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.a"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We make a strong distinction between a type and its subtypes. In particular, a type is ",(0,n.jsx)("i",{children:"not"})," a subtype of itself. There is no constraint associated with a type (not even a null one), and type-related attributes are distinct from subtype-specific attributes. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.b"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),'We no longer use the term "base type." All types were "base types" anyway in Ada 83, so the term was redundant, and occasionally confusing. In the RM95 we say simply "the type ',(0,n.jsx)("i",{children:"of"}),' the subtype" instead of "the base type of the subtype." ',(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.c"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The value subset for a subtype might be empty, and need not be a proper subset. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.d/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"To be honest: "}),"Any name of a category of types (such as \u201Cdiscrete\u201D, \u201Creal\u201D, or \u201Climited\u201D) is also used to qualify its subtypes, as well as its objects, values, declarations, and definitions, such as an \u201Cinteger type declaration\u201D or an \u201Cinteger value\u201D. In addition, if a term such as \u201Cparent subtype\u201D or \u201Cindex subtype\u201D is defined, then the corresponding term for the type of the subtype is \u201Cparent type\u201D or \u201Cindex type\u201D. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.e"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We use these corresponding terms without explicitly defining them, when the meaning is obvious. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"9"}),"\n",(0,n.jsxs)("p",{children:["A subtype is called an ",(0,n.jsx)("i",{children:"unconstrained"})," subtype if its type has unknown discriminants, or if its type allows range, index, or discriminant constraints, but the subtype does not impose such a constraint; otherwise, the subtype is called a ",(0,n.jsx)("i",{children:"constrained"})," subtype (since it has no unconstrained characteristics). ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"9.a"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),'In an earlier version of Ada 9X, "constrained" meant "has a nonnull constraint." However, we changed to this definition since we kept having to special case composite non-array/nondiscriminated types. It also corresponds better to the (now obsolescent) attribute \'Constrained.',(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"9.b"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["For scalar types, \u201Cconstrained\u201D means \u201Chas a nonnull constraint\u201D. For composite types, in implementation terms, \u201Cconstrained\u201D means that the size of all objects of the subtype is the same, assuming a typical implementation model.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"9.c"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Class-wide subtypes are always unconstrained. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE   Any set of types can be called a \u201Ccategory\u201D of types, and any set of types that is closed under derivation (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),") can be called a \u201Cclass\u201D of types. However, only certain categories and classes are used in the description of the rules of the language \u2014 generally those that have their own particular set of primitive operations (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.3",children:"3.2.3"}),"), or that correspond to a set of types that are matched by a given kind of generic formal type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-12/AA-12.5",children:"12.5"}),"). The following are examples of \u201Cinteresting\u201D ",(0,n.jsx)("i",{children:"language-defined classes"}),": elementary, scalar, discrete, enumeration, character, boolean, integer, signed integer, modular, real, floating point, fixed point, ordinary fixed point, decimal fixed point, numeric, access, access-to-object, access-to-subprogram, composite, array, string, (untagged) record, tagged, task, protected, nonlimited. Special syntax is provided to define types in each of these classes. In addition to these classes, the following are examples of \u201Cinteresting\u201D ",(0,n.jsx)("i",{children:"language-defined categories"}),": abstract, incomplete, interface, limited, private, record. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.a"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"A ",(0,n.jsx)("i",{children:"value"})," is a run-time entity with a given type which can be assigned to an object of an appropriate subtype of the type. An ",(0,n.jsx)("i",{children:"operation"})," is a program entity that operates on zero or more operands to produce an effect, or yield a result, or both. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.b/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Note that a type's category (and class) depends on the place of the reference \u2014 a private type is composite outside and possibly elementary inside. It's really the ",(0,n.jsx)("i",{children:"view"})," that is elementary or composite. Note that although private types are composite, there are some properties that depend on the corresponding full view \u2014 for example, parameter passing modes, and the constraint checks that apply in various places.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.c/2"}),(0,n.jsx)(l.Z,{items:["AI95-00345-01","AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Every property of types forms a category, but not every property of types represents a class. For example, the set of all abstract types does not form a class, because this set is not closed under derivation. Similarly, the set of all interface types does not form a class.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.d/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The set of limited types does not form a class (since nonlimited types can inherit from limited interfaces), but the set of nonlimited types does. The set of tagged record types and the set of tagged private types do not form a class (because each of them can be extended to create a type of the other category); that implies that the set of record types and the set of private types also do not form a class (even though untagged record types and untagged private types do form a class). In all of these cases, we can talk about the category of the type; for instance, we can talk about the \u201Ccategory of limited types\u201D.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.e/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Normatively, the ",(0,n.jsx)("i",{children:"language-defined classes"})," are those that are defined to be inherited on derivation by ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),"; other properties either aren't interesting or form categories, not classes. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"11/2"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["These language-defined categories are organized like this: ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"12/2"}),(0,n.jsx)(l.Z,{items:["AI95-00345-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["all types",(0,n.jsx)("br",{}),"	elementary",(0,n.jsx)("br",{}),"		scalar",(0,n.jsx)("br",{}),"			discrete",(0,n.jsx)("br",{}),"				enumeration",(0,n.jsx)("br",{}),"					character",(0,n.jsx)("br",{}),"					boolean",(0,n.jsx)("br",{}),"					other enumeration",(0,n.jsx)("br",{}),"				integer",(0,n.jsx)("br",{}),"					signed integer",(0,n.jsx)("br",{}),"					modular integer",(0,n.jsx)("br",{}),"			real",(0,n.jsx)("br",{}),"				floating point",(0,n.jsx)("br",{}),"				fixed point",(0,n.jsx)("br",{}),"					ordinary fixed point",(0,n.jsx)("br",{}),"					decimal fixed point",(0,n.jsx)("br",{}),"		access",(0,n.jsx)("br",{}),"			access-to-object",(0,n.jsx)("br",{}),"			access-to-subprogram",(0,n.jsx)("br",{}),"	composite",(0,n.jsx)("br",{}),"		untagged",(0,n.jsx)("br",{}),"			array",(0,n.jsx)("br",{}),"				string",(0,n.jsx)("br",{}),"				other array",(0,n.jsx)("br",{}),"			record",(0,n.jsx)("br",{}),"			task",(0,n.jsx)("br",{}),"			protected",(0,n.jsx)("br",{}),"		tagged (including interfaces)",(0,n.jsx)("br",{}),"			nonlimited tagged record",(0,n.jsx)("br",{}),"			limited tagged",(0,n.jsx)("br",{}),"				limited tagged record",(0,n.jsx)("br",{}),"				synchronized tagged",(0,n.jsx)("br",{}),"					tagged task",(0,n.jsx)("br",{}),"					tagged protected",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13/2"}),(0,n.jsx)(l.Z,{items:["AI95-00345-01","AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["There are other categories, such as \u201Cnumeric\u201D and \u201Cdiscriminated\u201D, which represent other categorization dimensions, but do not fit into the above strictly hierarchical picture. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.a.1/2"}),(0,n.jsx)(l.Z,{items:["AI95-00345-01","AI95-00442-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Note that this is also true for some categories mentioned in the chart. The category \u201Ctask\u201D includes both untagged tasks and tagged tasks. Similarly for \u201Cprotected\u201D, \u201Climited\u201D, and \u201Cnonlimited\u201D (note that limited and nonlimited are not shown for untagged composite types). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.a/3"}),(0,n.jsx)(l.Z,{items:["AI05-0299-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["This subclause now precedes the subclauses on objects and named numbers, to cut down on the number of forward references.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.b"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:['We have dropped the term "base type" in favor of simply "type" (all types in Ada 83 were "base types" so it wasn\'t clear when it was appropriate/necessary to say "base type"). Given a subtype S of a type T, we call T the "type of the subtype S." ',(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.c/2"}),(0,n.jsx)(l.Z,{items:["AI95-00231-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added a mention of null exclusions when we're talking about constraints (these are not constraints, but they are similar).",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.d/2"}),(0,n.jsx)(l.Z,{items:["AI95-00251-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Defined an interface type to be a composite type.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.e/2"}),(0,n.jsx)(l.Z,{items:["AI95-00326-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Revised the wording so that it is clear that an incomplete view is similar to a partial view in terms of the language.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.f/2"}),(0,n.jsx)(l.Z,{items:["AI95-00366-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added a definition of component of a type, subcomponent of a type, and part of a type. These are commonly used in the standard, but they were not previously defined.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13.g/3"}),(0,n.jsx)(l.Z,{items:["AI95-00442-01","AI05-0299-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Reworded most of this subclause to use category rather than class, since so many interesting properties are not, strictly speaking, classes. Moreover, there was no normative description of exactly which properties formed classes, and which did not. The real definition of class, along with a list of properties, is now in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)("a",{id:"Subclause_3.2.1"}),"\n",(0,n.jsx)(s.h2,{id:"321--type-declarations",children:"3.2.1  Type Declarations"}),"\n",(0,n.jsx)(o.Z,{children:"1_3.2.1"}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:"type_declaration"})})," declares a type and its first subtype. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"syntax",children:"Syntax"}),"\n",(0,n.jsx)(o.Z,{children:"2_3.2.1"}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["type","_","declaration"]}),(0,n.jsx)("a",{id:"S0023"}),(0,n.jsx)("code",{children:" ::= "})," ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:"full_type_declaration"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0085",children:"incomplete_type_declaration"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#S0232",children:"private_type_declaration"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#S0233",children:"private_extension_declaration"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"3/3_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0183-1"]}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["full","_","type","_","declaration"]}),(0,n.jsx)("a",{id:"S0024"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("br",{}),"     ",(0,n.jsx)("b",{children:"type"})," ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," [",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0061",children:"known_discriminant_part"})}),"] ",(0,n.jsx)("b",{children:"is"})," ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0025",children:"type_definition"})}),(0,n.jsx)("br",{}),"        [",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"];",(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0244",children:"task_type_declaration"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-9/AA-9.4#S0249",children:"protected_type_declaration"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"4/2_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00251-01"]}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["type","_","definition"]}),(0,n.jsx)("a",{id:"S0025"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("br",{}),"     ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0038",children:"enumeration_type_definition"})}),"	| ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0041",children:"integer_type_definition"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0044",children:"real_type_definition"})}),"	| ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0051",children:"array_type_definition"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0066",children:"record_type_definition"})}),"	| ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0079",children:"access_type_definition"})}),(0,n.jsx)("br",{}),"   | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4#S0035",children:"derived_type_definition"})}),"	| ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#S0077",children:"interface_type_definition"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(s.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,n.jsx)(o.Z,{children:"5_3.2.1"}),"\n",(0,n.jsxs)("p",{children:["A given type shall not have a subcomponent whose type is the given type itself. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"6/5_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0449-1"]}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:["defining","_","identifier"]})})," of a ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:["type","_","declaration"]})})," denotes the ",(0,n.jsx)("i",{children:"first subtype"})," of the type. The ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.7#S0061",children:["known","_","discriminant","_","part"]})}),", if any, defines the discriminants of the type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7",children:"3.7"}),"). The remainder of the ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:["type","_","declaration"]})})," defines the remaining characteristics of (the view of) the type.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"7/2_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00230-01"]}),"\n",(0,n.jsxs)("p",{children:["A type defined by a ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:["type","_","declaration"]})})," is a ",(0,n.jsx)("i",{children:"named"})," type; such a type has one or more nameable subtypes. Certain other forms of declaration also include type definitions as part of the declaration for an object. The type defined by such a declaration is ",(0,n.jsx)("i",{children:"anonymous"})," \u2014 it has no nameable subtypes. For explanatory purposes, this document sometimes refers to an anonymous type by a pseudo-name, written in italics, and uses such pseudo-names at places where the syntax normally requires an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),". For a named type whose first subtype is T, this document sometimes refers to the type of T as simply \u201Cthe type T\u201D. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.a/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00230-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The only user-defined types that can be anonymous in the above sense are array, access, task, and protected types. An anonymous array, task, or protected type can be defined as part of an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.3#S0032",children:"object_declaration"})}),". An anonymous access type can be defined as part of numerous other constructs. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"8/2_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00230-01","AI95-00326-01"]}),"\n",(0,n.jsxs)("p",{children:["A named type that is declared by a ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:["full","_","type","_","declaration"]})}),", or an anonymous type that is defined by an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0084",children:"access_definition"})})," or as part of declaring an object of the type, is called a ",(0,n.jsx)("i",{children:"full type"}),". The declaration of a full type also declares the ",(0,n.jsx)("i",{children:"full view"})," of the type. The ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0025",children:["type","_","definition"]})}),", ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-9/AA-9.1#S0246",children:["task","_","definition"]})}),", ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-9/AA-9.4#S0251",children:["protected","_","definition"]})}),", or ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.10#S0084",children:["access","_","definition"]})})," that defines a full type is called a ",(0,n.jsx)("i",{children:"full type definition"}),". [Types declared by other forms of ",(0,n.jsx)("code",{children:(0,n.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:["type","_","declaration"]})})," are not separate types; they are partial or incomplete views of some full type.] ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.a_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"To be honest: "}),"Class-wide, universal, and root numeric types are full types. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.b/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00230-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We need to mention ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0084",children:"access_definition"})})," separately, as it may occur in renames, which do not declare objects. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"9/5_3.2.1"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0449-1"]}),"\n",(0,n.jsxs)("p",{children:["The definition of a type implicitly declares certain ",(0,n.jsx)("i",{children:"predefined operators"})," that operate on the type, according to what classes the type belongs, as specified in ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5",children:"4.5"}),". ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"9.a_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We no longer talk about the implicit declaration of basic operations. These are treated like an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-5/AA-5.3#S0175",children:"if_statement"})})," \u2014 they don't need to be declared, but are still applicable to only certain classes of types.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"10_3.2.1"}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("i",{children:"predefined types"})," [(for example the types Boolean, Wide","_","Character, Integer, ",(0,n.jsxs)("i",{children:["root","_","integer"]}),", and ",(0,n.jsxs)("i",{children:["universal","_","integer"]}),")] are the types that are defined in [a predefined library package called] Standard[; this package also includes the [(implicit)] declarations of their predefined operators]. [The package Standard is described in ",(0,n.jsx)("a",{href:"/docs/arm/AA-A/AA-A.1",children:"A.1"}),".] ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"10.a_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We use the term \u201Cpredefined\u201D to refer to entities declared in the visible part of Standard, to implicitly declared operators of a type whose semantics are defined by the language, to Standard itself, and to the \u201Cpredefined environment\u201D. We do not use this term to refer to library packages other than Standard. For example Text","_","IO is a language-defined package, not a predefined package, and Text","_","IO.Put","_","Line is not a predefined operation. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"11_3.2.1"}),"\n",(0,n.jsxs)("p",{children:["The elaboration of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:"full_type_declaration"})})," consists of the elaboration of the full type definition. Each elaboration of a full type definition creates a distinct type and its first subtype. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"11.a_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The creation is associated with the type ",(0,n.jsx)("i",{children:"definition"}),", rather than the type ",(0,n.jsx)("i",{children:"declaration"}),", because there are types that are created by full type definitions that are not immediately contained within a type declaration (e.g. an array object declaration, a singleton task declaration, etc.). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"11.b_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Any implicit declarations that occur immediately following the full type definition are elaborated where they (implicitly) occur. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(o.Z,{children:"12_3.2.1"}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"Examples of type definitions:"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"13_3.2.1"}),"\n",(0,n.jsx)(d.Z,{language:"ada",children:(0,n.jsxs)(s.p,{children:["(White, Red, Yellow, Green, Blue, Brown, Black)","\n","range 1 .. 72","\n","array(1 .. 10) of Integer","\n"]})}),"\n",(0,n.jsx)(o.Z,{children:"14_3.2.1"}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"Examples of type declarations:"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"15_3.2.1"}),"\n",(0,n.jsx)(d.Z,{language:"ada",children:(0,n.jsxs)(s.p,{children:["type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);","\n","type Column is range 1 .. 72;","\n","type Table  is array(1 .. 10) of Integer;","\n"]})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE   Each of the above examples declares a named type. The identifier given denotes the first subtype of the type. Other named subtypes of the type can be declared with ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})}),"s (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.2",children:"3.2.2"}),"). Although names do not directly denote types, a phrase like \u201Cthe type Column\u201D is sometimes used in this document to refer to the type of Column, where Column denotes the first subtype of the type. For an example of the definition of an anonymous type, see the declaration of the array Color","_","Table in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.3#Subclause_3.3.1",children:"3.3.1"}),"; its type is anonymous \u2014 it has no nameable subtypes. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-83-1",children:"Wording Changes from Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.a_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The syntactic category ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:"full_type_declaration"})})," now includes task and protected type declarations.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.b_3.2.1"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["We have generalized the concept of first-named subtype (now called simply \u201Cfirst subtype\u201D) to cover all kinds of types, for uniformity of description elsewhere. RM83 defined first-named subtype in Section 13. We define first subtype here, because it is now a more fundamental concept. We renamed the term, because in Ada 95 some first subtypes have no name.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.c/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00230-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["We no longer elaborate ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0059",children:"discriminant_part"})}),"s, because there is nothing to do, and it was complex to say that you only wanted to elaborate it once for a private or incomplete type. This is also consistent with the fact that subprogram specifications are not elaborated (neither in Ada 83 nor in Ada 95). Note, however, that an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0084",children:"access_definition"})})," appearing in a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0059",children:"discriminant_part"})})," is elaborated at the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:"full_type_declaration"})})," (for a nonlimited type) or when an object with such a discriminant is created (for a limited type). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-95-1",children:"Wording Changes from Ada 95"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.d/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00230-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added wording so that anonymous access types are always full types, even if they appear in renames.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.e/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00251-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added interface types (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9#Subclause_3.9.4",children:"3.9.4"}),") to the syntax.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.f/2_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI95-00326-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added a definition of full view, so that all types have a well-defined full view. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"16.g/3_3.2.1"}),(0,n.jsx)(l.Z,{items:["AI05-0183-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["An optional ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})})," can be used in a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0024",children:"full_type_declaration"})}),". This is described in ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)("a",{id:"Subclause_3.2.2"}),"\n",(0,n.jsx)(s.h2,{id:"322--subtype-declarations",children:"3.2.2  Subtype Declarations"}),"\n",(0,n.jsx)(o.Z,{children:"1_3.2.2"}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})})," declares a subtype of some previously declared type, as defined by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),". ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"syntax-1",children:"Syntax"}),"\n",(0,n.jsx)(o.Z,{children:"2/3_3.2.2"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0183-1"]}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["subtype","_","declaration"]}),(0,n.jsx)("a",{id:"S0026"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("br",{}),"   ",(0,n.jsx)("b",{children:"subtype"})," ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," ",(0,n.jsx)("b",{children:"is"})," ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),(0,n.jsx)("br",{}),"        [",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"];",(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"3/2_3.2.2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00231-01"]}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["subtype","_","indication"]}),(0,n.jsx)("a",{id:"S0027"}),(0,n.jsx)("code",{children:" ::= "})," [",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0083",children:"null_exclusion"})}),"] ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," [",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})}),"]",(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"4_3.2.2"}),"\n",(0,n.jsxs)(d.Z,{children:[(0,n.jsxs)("code",{children:["subtype","_","mark"]}),(0,n.jsx)("a",{id:"S0028"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsxs)("i",{children:["subtype","_"]}),(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"4.a_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Note that ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," includes ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0100",children:"attribute_reference"})}),"; thus, S'Base can be used as a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"4.b_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We considered changing ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," to ",(0,n.jsxs)("code",{children:["subtype","_","name"]}),'. However, existing users are used to the word "mark," so we\'re keeping it. ',(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"5_3.2.2"}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("code",{children:"constraint"}),(0,n.jsx)("a",{id:"S0029"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0030",children:"scalar_constraint"})})," | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0031",children:"composite_constraint"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"6_3.2.2"}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["scalar","_","constraint"]}),(0,n.jsx)("a",{id:"S0030"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("br",{}),"     ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})})," | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0050",children:"digits_constraint"})})," | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-J/AA-J.3#S0367",children:"delta_constraint"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(o.Z,{children:"7_3.2.2"}),"\n",(0,n.jsx)(d.Z,{children:(0,n.jsxs)(s.p,{children:[(0,n.jsxs)("code",{children:["composite","_","constraint"]}),(0,n.jsx)("a",{id:"S0031"}),(0,n.jsx)("code",{children:" ::= "}),(0,n.jsx)("br",{}),"     ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0057",children:"index_constraint"})})," | ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0064",children:"discriminant_constraint"})}),(0,n.jsx)("br",{})]})}),"\n",(0,n.jsx)(s.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,n.jsx)(o.Z,{children:"8_3.2.2"}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," shall resolve to denote a subtype. The type ",(0,n.jsx)("i",{children:"determined by"})," a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," is the type of the subtype denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),". ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.a/3_3.2.2"}),(0,n.jsx)(l.Z,{items:["AI05-0005-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Types are never directly named; all ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),"s denote subtypes \u2014 possibly an unconstrained (base) subtype, but never the type. When we use the term ",(0,n.jsx)("i",{children:"anonymous type"})," we really mean a type with no nameable subtypes. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"dynamic-semantics-1",children:"Dynamic Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"9_3.2.2"}),"\n",(0,n.jsxs)("p",{children:["The elaboration of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})})," consists of the elaboration of the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),". The elaboration of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})})," creates a new subtype. If the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})})," does not include a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})}),", the new subtype has the same (possibly null) constraint as that denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),". The elaboration of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})})," that includes a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," proceeds as follows: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"10_3.2.2"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," is first elaborated.",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"11_3.2.2"}),(0,n.jsxs)("li",{children:["A check is then made that the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," is ",(0,n.jsx)("i",{children:"compatible"})," with the subtype denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),". ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"11.a_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The checks associated with constraint compatibility are all Range","_","Checks. Discriminant","_","Checks and Index","_","Checks are associated only with checks that a value satisfies a constraint. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"12_3.2.2"}),"\n",(0,n.jsxs)("p",{children:["The condition imposed by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," is the condition obtained after elaboration of the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})}),". The rules defining compatibility are given for each form of ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," in the appropriate subclause. These rules are such that if a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," is ",(0,n.jsx)("i",{children:"compatible"})," with a subtype, then the condition imposed by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," cannot contradict any condition already imposed by the subtype on its values. The exception Constraint","_","Error is raised if any check of compatibility fails. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"12.a_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"To be honest: "}),"The condition imposed by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})})," is named after it \u2014 a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})})," imposes a range constraint, etc. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"12.b_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"A ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})})," causes freezing of its type. Other ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0029",children:"constraint"})}),"s do not. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"13/5_3.2.2"}),(0,n.jsx)(l.Z,{items:["AI12-0440-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE   A ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0030",children:"scalar_constraint"})})," can be applied to a subtype of an appropriate scalar type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5",children:"3.5"}),", ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#Subclause_3.5.9",children:"3.5.9"}),", and ",(0,n.jsx)("a",{href:"/docs/arm/AA-J/AA-J.3",children:"J.3"}),"), even if the subtype is already constrained. On the other hand, a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0031",children:"composite_constraint"})})," can be applied to a composite subtype (or an access-to-composite subtype) only if the composite subtype is unconstrained (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#Subclause_3.6.1",children:"3.6.1"})," and ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#Subclause_3.7.1",children:"3.7.1"}),"). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"examples-1",children:"Examples"}),"\n",(0,n.jsx)(o.Z,{children:"14_3.2.2"}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"Examples of subtype declarations:"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"15/2_3.2.2"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00433-01"]}),"\n",(0,n.jsx)(d.Z,{language:"ada",children:(0,n.jsxs)(s.p,{children:["subtype Rainbow   is Color range Red .. Blue;      -- see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.1",children:"3.2.1"}),"\n","subtype Red","_","Blue  is Rainbow;","\n","subtype Int       is Integer;","\n","subtype Small","_","Int is Integer range -10 .. 10;","\n","subtype Up","_","To","_","K   is Column range 1 .. K;          -- see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.1",children:"3.2.1"}),"\n","subtype Square    is Matrix(1 .. 10, 1 .. 10);     -- see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6",children:"3.6"}),"\n","subtype Male      is Person(Sex =",">"," M);             -- see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#Subclause_3.10.1",children:"3.10.1"}),"\n","subtype Binop","_","Ref is not null Binop","_","Ptr;           -- see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10",children:"3.10"}),"\n"]})}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"incompatibilities-with-ada-83",children:"Incompatibilities With Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"15.a_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["In Ada 95, all ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})}),"s cause freezing of their type. Hence, a type-related representation item for a scalar type has to precede any ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#S0036",children:"range_constraint"})}),"s whose type is the scalar type. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-83-2",children:"Wording Changes from Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"15.b_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"Subtype_mark"})}),"s allow only subtype names now, since types are never directly named. There is no need for RM83-3.3.2(3), which says a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," can denote both the type and the subtype; in Ada 95, you denote an unconstrained (base) subtype if you want, but never the type.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"15.c_3.2.2"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The syntactic category ",(0,n.jsxs)("code",{children:["type","_","mark"]})," is now called ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),", since it always denotes a subtype. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"15.d/2_3.2.2"}),(0,n.jsx)(l.Z,{items:["AI95-00231-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["An optional ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#S0083",children:"null_exclusion"})})," can be used in a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),". This is described in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10",children:"3.10"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-2005-1",children:"Extensions to Ada 2005"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"15.e/3_3.2.2"}),(0,n.jsx)(l.Z,{items:["AI05-0183-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["An optional ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})})," can be used in a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})}),". This is described in ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)("a",{id:"Subclause_3.2.3"}),"\n",(0,n.jsx)(s.h2,{id:"323--classification-of-operations",children:"3.2.3  Classification of Operations"}),"\n",(0,n.jsx)(s.h4,{id:"static-semantics-2",children:"Static Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"1/2_3.2.3"}),"\n",(0,n.jsx)(l.Z,{items:["AI95-00416-01"]}),"\n",(0,n.jsxs)("p",{children:["An operation ",(0,n.jsx)("i",{children:"operates on a type"})," ",(0,n.jsx)("i",{children:"T"})," if it yields a value of type ",(0,n.jsx)("i",{children:"T"}),", if it has an operand whose expected type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-8/AA-8.6",children:"8.6"}),") is ",(0,n.jsx)("i",{children:"T"}),", or if it has an access parameter or access result type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1",children:"6.1"}),") designating ",(0,n.jsx)("i",{children:"T"}),". A predefined operator, or other language-defined operation such as assignment or a membership test, that operates on a type, is called a ",(0,n.jsx)("i",{children:"predefined operation"})," of the type. The ",(0,n.jsx)("i",{children:"primitive operations"})," of a type are the predefined operations of the type, plus any user-defined primitive subprograms. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.a.1/5_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Term entry: "}),(0,n.jsx)("b",{children:"primitive operations of a type"})," \u2014 operations (such as subprograms) declared together with the type declarations",(0,n.jsx)("br",{}),"Note: Primitive operations are inherited by other types in the same derivation class of types.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.a_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"To be honest: "}),"Protected subprograms are not considered to be \u201Cprimitive subprograms\u201D, even though they are subprograms, and they are inherited by derived types. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.b_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We use the term \u201Cprimitive subprogram\u201D in most of the rest of the manual. The term \u201Cprimitive operation\u201D is used mostly in conceptual discussions. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"2_3.2.3"}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("i",{children:"primitive subprograms"})," of a specific type are defined as follows: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"3_3.2.3"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["The predefined operators of the type (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5",children:"4.5"}),");",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"4_3.2.3"}),(0,n.jsxs)("li",{children:["For a derived type, the inherited (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),") user-defined subprograms;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"5_3.2.3"}),(0,n.jsxs)("li",{children:["For an enumeration type, the enumeration literals (which are considered parameterless functions \u2014 see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#Subclause_3.5.1",children:"3.5.1"}),");",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"6_3.2.3"}),(0,n.jsxs)("li",{children:["For a specific type declared immediately within a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})}),", any subprograms (in addition to the enumeration literals) that are explicitly declared immediately within the same ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})})," and that operate on the type;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"6.1/3_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI05-0128-1"]}),(0,n.jsxs)("li",{children:['For a specific type with an explicitly declared primitive "=" operator whose result type is Boolean, the corresponding "/=" operator (see ',(0,n.jsx)("a",{href:"/docs/arm/AA-6/AA-6.6",children:"6.6"}),");",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"7/2_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI95-00200-01"]}),(0,n.jsxs)("li",{children:["For a nonformal type, any subprograms not covered above [that are explicitly declared immediately within the same declarative region as the type] and that override (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-8/AA-8.3",children:"8.3"}),") other implicitly declared primitive subprograms of the type. ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.a_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"In Ada 83, only subprograms declared in the visible part were \u201Cprimitive\u201D (i.e. derivable). In Ada 95, mostly because of child library units, we include all operations declared in the private part as well, and all operations that override implicit declarations. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.b_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"It is possible for a subprogram to be primitive for more than one type, though it is illegal for a subprogram to be primitive for more than one tagged type. See ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.9",children:"3.9"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.c_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The order of the implicit declarations when there are both predefined operators and inherited subprograms is described in ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"3.4"}),", \u201C",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.4",children:"Derived Types and Classes"}),"\u201D. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"7.d/2_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI95-00200-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Subprograms declared in a generic package specification are never primitive for a formal type, even if they happen to override an operation of the formal type. This includes formal subprograms, which are never primitive operations (that's true even for an abstract formal subprogram). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"8_3.2.3"}),"\n",(0,n.jsxs)("p",{children:["A primitive subprogram whose designator is an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0202",children:"operator_symbol"})})," is called a ",(0,n.jsx)("i",{children:"primitive operator"}),".",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"incompatibilities-with-ada-83-1",children:"Incompatibilities With Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.a_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The attribute S'Base is no longer defined for nonscalar subtypes. Since this was only permitted as the prefix of another attribute, and there are no interesting nonscalar attributes defined for an unconstrained composite or access subtype, this should not affect any existing programs. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.b_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The primitive subprograms (derivable subprograms) include subprograms declared in the private part of a package specification as well, and those that override implicitly declared subprograms, even if declared in a body. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-83-3",children:"Wording Changes from Ada 83"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.c_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["We have dropped the confusing term ",(0,n.jsx)("i",{children:"operation of a type"})," in favor of the more useful ",(0,n.jsx)("i",{children:"primitive operation of a type"})," and the phrase ",(0,n.jsx)("i",{children:"operates on a type"}),".",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.d_3.2.3"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["The description of S'Base has been moved to ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5",children:"3.5"}),", \u201C",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5",children:"Scalar Types"}),"\u201D because it is now defined only for scalar types. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-95-2",children:"Wording Changes from Ada 95"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.e/2_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI95-00200-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Clarified that a formal subprogram that happens to override a primitive operation of a formal type is not a primitive operation (and thus not a dispatching operation) of the formal type.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.f/2_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI95-00416-01"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Added wording to include access result types in the kinds of operations that operate on a type T. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"8.g/3_3.2.3"}),(0,n.jsx)(l.Z,{items:["AI05-0128-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"correction",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),' The implicitly declared "/=" for a primitive "=" operator is also primitive; this makes it eligible to be made visible by a ',(0,n.jsx)("b",{children:"use type"})," clause. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)("a",{id:"Subclause_3.2.4"}),"\n",(0,n.jsx)(s.h2,{id:"324--subtype-predicates",children:"3.2.4  Subtype Predicates"}),"\n",(0,n.jsx)(o.Z,{children:"1/5_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0269-1","AI05-0299-1","AI12-0396-1","AI12-0419-1"]}),"\n",(0,n.jsxs)("p",{children:["The language-defined ",(0,n.jsx)("i",{children:"predicate aspects"})," Static","_","Predicate and Dynamic","_","Predicate may be used to define properties of subtypes. A ",(0,n.jsx)("i",{children:"predicate specification"})," is an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})})," for one of the two predicate aspects. General rules for aspects and ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})}),"s are found in Clause ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/",children:"13"})," (",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1",children:"13.1"})," and ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"})," respectively). The predicate aspects are assertion aspects (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-11/AA-11.4#Subclause_11.4.2",children:"11.4.2"}),"). [The predicate aspects are not inherited, but their effects are additive, as defined below.] ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.a/5_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Aspect Description for "}),(0,n.jsxs)("b",{children:["Static","_","Predicate: "]}),"Condition that will hold true for objects of a given subtype; the subtype may be static.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"1.b/5_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Aspect Description for "}),(0,n.jsxs)("b",{children:["Dynamic","_","Predicate: "]}),"Condition that will hold true for objects of a given subtype; the subtype is not static.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"name-resolution-rules-1",children:"Name Resolution Rules"}),"\n",(0,n.jsx)(o.Z,{children:"2/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),"\n",(0,n.jsxs)("p",{children:["The expected type for a predicate aspect ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," is any boolean type.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"static-semantics-3",children:"Static Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"3/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),"\n",(0,n.jsxs)("p",{children:["A predicate specification may be given on a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:"type_declaration"})})," or a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})}),", and applies to the declared subtype. In addition, predicate specifications apply to certain other subtypes: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"4/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0071-1","AI12-0099-1"]}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["For a (first) subtype defined by a type declaration, any predicates of parent or progenitor subtypes apply.",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"5/3_3.2.4"}),(0,n.jsxs)("li",{children:["For a subtype created by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),", the predicate of the subtype denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," applies. ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsx)(o.Z,{children:"6/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI12-0071-1"]}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"This paragraph was deleted."}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"7/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0290-1"]}),"\n",(0,n.jsxs)("p",{children:["Predicate checks are defined to be ",(0,n.jsx)("i",{children:"enabled"})," or ",(0,n.jsx)("i",{children:"disabled"})," for a given subtype as follows:",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"8/3_3.2.4"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["If a subtype is declared by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0023",children:"type_declaration"})})," or ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0026",children:"subtype_declaration"})})," that includes a predicate specification, then: ",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"9/3_3.2.4"}),(0,n.jsxs)("li",{children:["if performing checks is required by the Static","_","Predicate assertion policy (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-11/AA-11.4#Subclause_11.4.2",children:"11.4.2"}),") and the declaration includes a Static","_","Predicate specification, then predicate checks are enabled for the subtype;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"10/3_3.2.4"}),(0,n.jsxs)("li",{children:["if performing checks is required by the Dynamic","_","Predicate assertion policy (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-11/AA-11.4#Subclause_11.4.2",children:"11.4.2"}),") and the declaration includes a Dynamic","_","Predicate specification, then predicate checks are enabled for the subtype;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"11/3_3.2.4"}),(0,n.jsxs)("li",{children:["otherwise, predicate checks are disabled for the subtype[, regardless of whether predicate checking is enabled for any other subtypes mentioned in the declaration]; ",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"12/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0099-1"]}),(0,n.jsxs)("li",{children:["If a subtype is defined by a type declaration that does not include a predicate specification, then predicate checks are enabled for the subtype if and only if any predicate checks are enabled for parent or progenitor subtypes;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"13/3_3.2.4"}),(0,n.jsxs)("li",{children:["If a subtype is created by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})})," other than in one of the previous cases, then predicate checks are enabled for the subtype if and only if predicate checks are enabled for the subtype denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),";",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"14/3_3.2.4"}),(0,n.jsxs)("li",{children:["Otherwise, predicate checks are disabled for the given subtype.",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"14.a/3_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"In this case, no predicate specifications can apply to the subtype and so it doesn't typically matter whether predicate checks are enabled. This rule does make a difference, however, when determining whether predicate checks are enabled for another type when this type is one of multiple progenitors. See the \u201Cderived type declaration\u201D wording above.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"14.b/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0071-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Even when predicate checks are disabled, a predicate can affect various Legality Rules, the results of membership tests, the items in a ",(0,n.jsx)("b",{children:"for"})," loop, and the result of the Valid attribute. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"14.1/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),"\n",(0,n.jsxs)("p",{children:["For a subtype with a directly-specified predicate aspect, the following additional language-defined aspect may be specified with an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0346",children:"aspect_specification"})})," (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"}),"):",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"14.2/4_3.2.4"}),"\n",(0,n.jsxs)("dt",{children:[(0,n.jsx)("br",{}),"Predicate","_","Failure"]}),"\n",(0,n.jsx)("dl",{children:(0,n.jsxs)("dd",{children:["This aspect shall be specified by an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),", which determines the action to be performed when a predicate check fails because a directly-specified predicate aspect of the subtype evaluates to False, as explained below. ",(0,n.jsx)("br",{})]})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"14.b.1/4_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Aspect Description for "}),(0,n.jsxs)("b",{children:["Predicate","_","Failure: "]}),"Action to be performed when a predicate check fails.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"name-resolution-rules-2",children:"Name Resolution Rules"}),"\n",(0,n.jsx)(o.Z,{children:"14.3/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),"\n",(0,n.jsxs)("p",{children:["The expected type for the Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," is String. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"legality-rules-1",children:"Legality Rules"}),"\n",(0,n.jsx)(o.Z,{children:"15/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0269-1"]}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," of a Static","_","Predicate specification shall be ",(0,n.jsx)("i",{children:"predicate-static"}),"; that is, one of the following: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"16/3_3.2.4"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["a static expression;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"17/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0039-1"]}),(0,n.jsxs)("li",{children:["a membership test whose ",(0,n.jsxs)("i",{children:["tested","_"]}),(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0138",children:"simple_expression"})})," is the current instance, and whose ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0136",children:"membership_choice_list"})})," meets the requirements for a static membership test (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.9",children:"4.9"}),");",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"18/3_3.2.4"}),(0,n.jsxs)("li",{children:["a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5#S0151",children:"case_expression"})})," whose ",(0,n.jsxs)("i",{children:["selecting","_"]}),(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," is the current instance, and whose ",(0,n.jsxs)("i",{children:["dependent","_"]}),(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),"s are static expressions;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"19/3_3.2.4"}),(0,n.jsxs)("li",{children:["a call to a predefined equality or ordering operator, where one operand is the current instance, and the other is a static expression;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"20/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0262-1","AI12-0099-1"]}),(0,n.jsxs)("li",{children:["a call to a predefined boolean operator ",(0,n.jsx)("b",{children:"and"}),", ",(0,n.jsx)("b",{children:"or"}),", ",(0,n.jsx)("b",{children:"xor"}),", or ",(0,n.jsx)("b",{children:"not"}),", where each operand is predicate-static;",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"21/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0269-1"]}),(0,n.jsxs)("li",{children:["a short-circuit control form where both operands are predicate-static; or",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"22/3_3.2.4"}),(0,n.jsxs)("li",{children:["a parenthesized predicate-static ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),". ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsx)(o.Z,{children:"23/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0262-1"]}),"\n",(0,n.jsxs)("p",{children:["A predicate shall not be specified for an incomplete subtype.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"23.a/3_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The expression of such a predicate could not depend on the properties of the value of the type (since it doesn't have any), so it is useless and we don't want to require the added complexity needed to support it. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"24/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0287-1"]}),"\n",(0,n.jsxs)("p",{children:["If a predicate applies to a subtype, then that predicate shall not mention any other subtype to which the same predicate applies.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"24.a/3_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"This is intended to prevent recursive predicates, which cause definitional problems for static predicates. Inside of the predicate, the subtype name refers to the current instance of the subtype, which is an object, so a direct use of the subtype name cannot be recursive. But other subtypes naming the same type might: ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"24.b/3_3.2.4"}),(0,n.jsx)(d.Z,{language:"ada",children:(0,n.jsxs)(s.p,{children:["type Really","_","Ugly is private;","\n","private","\n","   subtype Ugly is Really","_","Ugly;","\n","   type Really","_","Ugly is new Integer","\n","      with Static","_","Predicate =",">"," Really","_","Ugly not in Ugly; -- Illegal!","\n"]})})]}),"\n",(0,n.jsx)(o.Z,{children:"25/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),"\n",(0,n.jsxs)("p",{children:["An index subtype, ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0058",children:"discrete_range"})})," of an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0057",children:"index_constraint"})})," or ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0097",children:"slice"})}),", or a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0055",children:"discrete_subtype_definition"})})," of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0054",children:"constrained_array_definition"})}),", ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0257",children:"entry_declaration"})}),", or ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0263",children:"entry_index_specification"})})," shall not denote a subtype to which predicate specifications apply.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"26/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," of an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0100",children:"attribute_reference"})})," whose ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0101",children:"attribute_designator"})})," is First, Last, or Range shall not denote a scalar subtype to which predicate specifications apply.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"26.a/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0297-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"This is to prevent confusion about whether the First value is the lowest value of the subtype (which does not depend on the predicate) or the lowest value of the subtype which meets the predicate. (For a dynamic predicate, determining this latter value is expensive as it would usually require a loop.) For a static subtype that has a static predicate, the First","_","Valid and Last","_","Valid attributes (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.5#Subclause_3.5.5",children:"3.5.5"}),") can be used instead. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"27/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0262-1","AI05-0287-1"]}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.6#S0055",children:"discrete_subtype_definition"})})," of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-5/AA-5.5#S0181",children:"loop_parameter_specification"})})," shall not denote a nonstatic subtype to which predicate specifications apply or any subtype to which Dynamic","_","Predicate specifications apply.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"28/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0262-1"]}),"\n",(0,n.jsxs)("p",{children:["The ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0074",children:"discrete_choice"})})," of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.3#S0116",children:"named_array_aggregate"})})," shall not denote a nonstatic subtype to which predicate specifications apply.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"28.a/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0262-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"reason",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"This rule prevents noncontiguous dynamically bounded array aggregates, which could be expensive to check for. (Array aggregates have rules to prevent problems with static subtypes.) We define this rule here so that the runtime generic body check applies. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"29/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0262-1"]}),"\n",(0,n.jsxs)("p",{children:["In addition to the places where Legality Rules normally apply (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3",children:"12.3"}),"), these rules apply also in the private part of an instance of a generic unit. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(s.h4,{id:"dynamic-semantics-2",children:"Dynamic Semantics"}),"\n",(0,n.jsx)(o.Z,{children:"29.1/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0071-1"]}),"\n",(0,n.jsxs)("p",{children:["If any of the above Legality Rules is violated in an instance of a generic unit, Program","_","Error is raised at the point of the violation.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"29.a/4_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),'This is the usual way around the contract model; this applies even in instance bodies. Note that errors in instance specifications will be detected at compile time by the "recheck" of the specification; only errors in the body should raise Program',"_","Error. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"29.2/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0071-1"]}),"\n",(0,n.jsxs)("p",{children:["To determine whether a value ",(0,n.jsx)("i",{children:"satisfies the predicates"})," of a subtype ",(0,n.jsx)("i",{children:"S"}),", the following tests are performed in the following order, until one of the tests fails, in which case the predicates are not satisfied and no further tests are performed, or all of the tests succeed, in which case the predicates are satisfied:",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"29.3/4_3.2.4"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["the value is first tested to determine whether it satisfies any constraints or any null exclusion of ",(0,n.jsx)("i",{children:"S"}),";",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"29.4/4_3.2.4"}),(0,n.jsxs)("li",{children:["then:",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"29.5/5_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0419-1"]}),(0,n.jsxs)("li",{children:["if ",(0,n.jsx)("i",{children:"S"})," is a first subtype, the value is tested to determine whether it satisfies the predicates of the parent and progenitor subtypes (if any) of ",(0,n.jsx)("i",{children:"S"})," (in an arbitrary order), after a (view) conversion of the value to the corresponding parent or progenitor type;",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"29.b/4_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"This rule has an effect for derived types (which have a parent subtype and may have progenitors) and for task and protected types (which may have progentitors). Other kinds of type declarations can have neither, and no test is required for other first subtypes. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"29.6/4_3.2.4"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["if ",(0,n.jsx)("i",{children:"S"})," is defined by a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),", the value is tested to determine whether it satisfies the predicates of the subtype denoted by the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})})," of the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0027",children:"subtype_indication"})}),"; ",(0,n.jsx)("br",{})]}),(0,n.jsx)(o.Z,{children:"29.7/4_3.2.4"}),(0,n.jsxs)("li",{children:["finally, if ",(0,n.jsx)("i",{children:"S"})," is defined by a declaration to which one or more predicate specifications apply, the predicates are evaluated (in an arbitrary order) to test that all of them yield True for the given value. ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"29.b.1/4_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"It is important to stop on the first of the above steps that fails, as later steps might presume that the earlier steps had succeeded. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"30/3_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0290-1"]}),"\n",(0,n.jsxs)("p",{children:["If predicate checks are enabled for a given subtype, then: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"31/5_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2","AI12-0071-1","AI12-0301-1","AI12-0333-1","AI12-0432-1"]}),"\n",(0,n.jsxs)("p",{class:"Indented4",children:["[On a subtype conversion, a check is performed that the operand satisfies the predicates of the target subtype, except for certain view conversions (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.6",children:"4.6"}),").] In addition, after normal completion and leaving of a subprogram, for each ",(0,n.jsx)("b",{children:"in out"})," or ",(0,n.jsx)("b",{children:"out"})," parameter that is passed by reference, a check is performed that the value of the parameter satisfies the predicates of the subtype of the actual. For an object created by an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.3#S0032",children:"object_declaration"})})," with no explicit initialization ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),", or by an uninitialized ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})}),", if the types of any parts have specified Default","_","Value or Default","_","Component","_","Value aspects, or any subcomponents have ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:"default_expression"})}),"s, a check is performed that the value of the created object satisfies the predicates of the nominal subtype.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"31.a.1/5_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0333-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Most parameter passing is covered by the subtype conversion rule: all inbound ",(0,n.jsx)("b",{children:"in"})," and ",(0,n.jsx)("b",{children:"in out"})," parameters are converted to the formal subtype, and the copy-back for by-copy ",(0,n.jsx)("b",{children:"out"})," and ",(0,n.jsx)("b",{children:"in out"})," parameters includes a conversion to the actual subtype. The remaining parameter-passing cases are covered by special rules: by-reference ",(0,n.jsx)("b",{children:"out"})," and ",(0,n.jsx)("b",{children:"in out"})," parameters by the rule given above, and we don't want any predicate checks on inbound ",(0,n.jsx)("b",{children:"out"})," parameters, accomplished in part by a special rule in ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.6",children:"4.6"}),". ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(o.Z,{children:"31.1/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),"\n",(0,n.jsxs)("p",{class:"Indented4",children:["If any of the predicate checks fail, Assertion","_","Error is raised, unless the subtype whose directly-specified predicate aspect evaluated to False also has a directly-specified Predicate","_","Failure aspect. In that case, the specified Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," is evaluated; if the evaluation of the Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," propagates an exception occurrence, then this occurrence is propagated for the failure of the predicate check; otherwise, Assertion","_","Error is raised, with an associated message string defined by the value of the Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),". In the absence of such a Predicate","_","Failure aspect, an implementation-defined message string is associated with the Assertion","_","Error exception.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"31.a/3_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"ramification",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Predicates are not evaluated at the point of the (sub)type declaration. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"31.b/3_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"implementation-note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"Static","_","Predicate checks can be removed even in the presence of potentially invalid values, just as constraint checks can be removed. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"31.c/4_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"implementation-defined",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"The message string associated with the Assertion","_","Error exception raised by the failure of a predicate check if there is no applicable Predicate","_","Failure aspect.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"Paragraphs 32 and 33 were moved above"})," ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"33.a/4_3.2.4"}),(0,n.jsxs)(t.Z,{type:"aarm",aarm:"note",children:[(0,n.jsx)("i",{children:"This paragraph was deleted."}),(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"34/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE 1   A predicate specification does not cause a subtype to be considered constrained.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"35/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0153-3"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE 2   A Static","_","Predicate, like a constraint, always remains True for all objects of the subtype, except in the case of uninitialized variables and other invalid values. A Dynamic","_","Predicate, on the other hand, is checked as specified above, but can become False at other times. For example, the predicate of a record subtype is not checked when a subcomponent is modified.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"36/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0071-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE 3   No predicates apply to the base subtype of a scalar type; every value of a scalar type ",(0,n.jsx)("i",{children:"T"})," is considered to satisfy the predicates of ",(0,n.jsx)("i",{children:"T"}),"'Base.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"37/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE 4   Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),"s are never evaluated during the evaluation of a membership test (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5#Subclause_4.5.2",children:"4.5.2"}),") or Valid attribute (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-13/AA-13.9#Subclause_13.9.2",children:"13.9.2"}),").",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"38/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["NOTE 5   A Predicate","_","Failure ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," can be a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0309",children:"raise_expression"})})," (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3",children:"11.3"}),"). ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(s.h4,{id:"examples-2",children:"Examples"}),"\n",(0,n.jsx)(o.Z,{children:"39/5_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0429-1"]}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsx)("i",{children:"Examples of predicates applied to scalar types:"}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"40/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),"\n",(0,n.jsxs)(d.Z,{language:"ada",children:[(0,n.jsxs)(s.p,{children:["subtype Basic","_","Letter is Character -- See ",(0,n.jsx)("a",{href:"/docs/arm/AA-A/AA-A.3#Subclause_A.3.2",children:"A.3.2"}),' for "basic letter".',"\n","   with Static","_","Predicate =",">"," Basic","_","Letter in 'A'..'Z' | 'a'..'z' | '\xc6' | ","\n","                             '\xe6' | '\xd0' | '\xf0' | '\xde' | '\xfe' | '\xdf';","\n","\n",(0,n.jsx)(o.Z,{children:"41/4_3.2.4"})]}),(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),(0,n.jsxs)(s.p,{children:["subtype Even","_","Integer is Integer","\n","   with Dynamic","_","Predicate =",">"," Even","_","Integer mod 2 = 0,","\n","        Predicate","_","Failure =",">",' "Even',"_",'Integer must be a multiple of 2";',"\n"]})]}),"\n",(0,n.jsx)(o.Z,{children:"42/4_3.2.4"}),"\n",(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),"\n",(0,n.jsxs)("p",{children:[(0,n.jsxs)("i",{children:["Text","_","IO (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-A/AA-A.10#Subclause_A.10.1",children:"A.10.1"}),") could have used predicates to describe some common exceptional conditions as follows:"]}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(o.Z,{children:"43/4_3.2.4"}),"\n",(0,n.jsx)(d.Z,{language:"ada",children:(0,n.jsxs)(s.p,{children:["with Ada.IO","_","Exceptions;","\n","package Ada.Text","_","IO is","\n","\n",(0,n.jsx)(o.Z,{children:"44/4_3.2.4"}),"\ntype File","_","Type is limited private;","\n","\n",(0,n.jsx)(o.Z,{children:"45/4_3.2.4"}),"\nsubtype Open","_","File","_","Type is File","_","Type","\n","      with Dynamic","_","Predicate =",">"," Is","_","Open (Open","_","File","_","Type),","\n","           Predicate","_","Failure =",">"," raise Status","_",'Error with "File not open";',"\n","   subtype Input","_","File","_","Type is Open","_","File","_","Type","\n","      with Dynamic","_","Predicate =",">"," Mode (Input","_","File","_","Type) = In","_","File,","\n","           Predicate","_","Failure =",">"," raise Mode","_","Error","\n",'              with "Cannot read file: " & Name (Input',"_","File","_","Type);","\n","   subtype Output","_","File","_","Type is Open","_","File","_","Type","\n","      with Dynamic","_","Predicate =",">"," Mode (Output","_","File","_","Type) /= In","_","File,","\n","           Predicate","_","Failure =",">"," raise Mode","_","Error","\n",'              with "Cannot write file: " & Name (Output',"_","File","_","Type);","\n","\n",(0,n.jsx)(o.Z,{children:"46/4_3.2.4"}),"\n...","\n","\n",(0,n.jsx)(o.Z,{children:"47/4_3.2.4"}),"\nfunction Mode (File : in Open","_","File","_","Type) return File","_","Mode;","\n","   function Name (File : in Open","_","File","_","Type) return String;","\n","   function Form (File : in Open","_","File","_","Type) return String;","\n","\n",(0,n.jsx)(o.Z,{children:"48/4_3.2.4"}),"\n...","\n","\n",(0,n.jsx)(o.Z,{children:"49/4_3.2.4"}),"\nprocedure Get (File : in Input","_","File","_","Type; Item : out Character);","\n","\n",(0,n.jsx)(o.Z,{children:"50/4_3.2.4"}),"\nprocedure Put (File : in Output","_","File","_","Type; Item : in Character);","\n","\n",(0,n.jsx)(o.Z,{children:"51/4_3.2.4"}),"\n...","\n","\n",(0,n.jsx)(o.Z,{children:"52/4_3.2.4"}),"\n-- Similarly for all of the other input and output subprograms.","\n"]})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.a/5_3.2.4"}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{}),"We didn't change the language-defined Text","_","IO this way for Ada 2022 as it would be incompatible in marginal cases: these subprogram specifications would not be subtype conformant with existing access-to-subprogram types, so Put","_","Line'Access (for instance) would become illegal in existing code. The gain would not be worth the disruption. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-2005-2",children:"Extensions to Ada 2005"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.b/3_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI05-0153-3","AI05-0262-1","AI05-0276-1","AI05-0290-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:["Predicate aspects are new in Ada 2012. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"inconsistencies-with-ada-2012",children:"Inconsistencies With Ada 2012"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.c/5_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0301-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"correction",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{})," Predicate checks are now performed on default-initialized objects with parts that have Default","_","Value or Default","_","Component","_","Value specified. This is consistent with the handling of constraint checks for such objects; it is thought that the omission was unintended. However, a program that declares such an object and depends on there not being a predicate check in original Ada 2012 will fail in Ada 2022. As these attributes were new in Ada 2012, their use is uncommon, so we believe that this inconsistency will be rare and more likely to catch a bug than create one. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"extensions-to-ada-2012",children:"Extensions to Ada 2012"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.d/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0054-2"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Corrigendum:"})," The Predicate","_","Failure aspect is new. We can consider this a correction as it is always possible for implementers to add implementation-defined aspects, so the same is true for language-defined aspects. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(c.Z,{children:(0,n.jsx)(s.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.e/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0071-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Corrigendum:"}),' Specified the order of evaluation of most predicates, by defining the new term "satisfies the predicates of the subtype". This is not inconsistent, as the order previously was unspecified, so any code depending on the order was incorrect. The change is necessary so that the Predicate',"_","Failure aspect has consistent results in cases where multiple predicates and aspects apply; see the Ada.Text","_","IO example above for such a case.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.f/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0099-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Corrigendum:"})," Revised wording to ensure all kinds of types are covered, including the anonymous task associated with a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0245",children:"single_task_declaration"})}),", and generalized it.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.g/4_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0099-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"note",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{children:"Corrigendum:"})," Revised wording to list the boolean operators that can be predicate-static, to eliminate confusion about whether ",(0,n.jsx)("b",{children:"not"})," is included.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(c.Z,{children:[(0,n.jsx)(o.Z,{children:"52.h/5_3.2.4"}),(0,n.jsx)(l.Z,{items:["AI12-0333-1","AI12-0432-1"]}),(0,n.jsx)(t.Z,{type:"aarm",aarm:"correction",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)("b",{})," Predicate checks are no longer made for any inbound ",(0,n.jsx)("b",{children:"out"})," parameters nor for the target of an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-5/AA-5.2#S0173",children:"assignment_statement"})})," when it is a view conversion. The rule change for this is found in ",(0,n.jsx)("a",{href:"/docs/arm/AA-4/AA-4.6",children:"4.6"}),", so the inconsistency is documented there. ",(0,n.jsx)("br",{})]})})]})]})}function A(e={}){let{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}}}]);