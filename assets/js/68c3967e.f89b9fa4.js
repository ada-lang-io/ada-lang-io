"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1642],{4107:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>x,contentTitle:()=>h,default:()=>f,frontMatter:()=>c,metadata:()=>m,toc:()=>p});var r=i(74848),t=i(28453),s=i(13842),a=i(91435),o=i(21432),l=i(79162),d=i(34421);const c={sidebar_position:136},h="A.16 The Package Directories",m={id:"arm/AA-A/AA-A.16",title:"A.16 The Package Directories",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-A/AA-A.16.mdx",sourceDirName:"arm/AA-A",slug:"/arm/AA-A/AA-A.16",permalink:"/docs/arm/AA-A/AA-A.16",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:136,frontMatter:{sidebar_position:136},sidebar:"referenceManualSidebar",previous:{title:"A.15 The Package Command_Line",permalink:"/docs/arm/AA-A/AA-A.15"},next:{title:"A.17 The Package Environment_Variables",permalink:"/docs/arm/AA-A/AA-A.17"}},x={},p=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"A.16.1  The Package Directories.Hierarchical_File_Names",id:"a161--the-package-directorieshierarchical_file_names",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"A.16.2  The Packages Wide_Directories and Wide_Wide_Directories",id:"a162--the-packages-wide_directories-and-wide_wide_directories",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4}];function j(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",p:"p",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"a16-the-package-directories",children:"A.16 The Package Directories"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.jsx)(n.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n","\n",(0,r.jsx)(l.A,{children:"1/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The package Directories provides operations for manipulating files and directories, and their names. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"1.a/3"}),(0,r.jsx)(d.A,{items:["AI05-0299-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The notes for this subclause contain the expected interpretations of some of the operations on various target systems. \u201cUnix\u201d refers to the UNIX\xae operating system, and in most cases also covers Unix-like systems such as Linux and POSIX. \u201cWindows\xae\u201d refers to the Microsoft\xae Windows\xae 2000 operating system and usually also covers most other versions that use the Win32 API. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,r.jsx)(l.A,{children:"2/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The library package Directories has the following declaration: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"3/5"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0302-1"]}),"\n",(0,r.jsxs)(o.A,{language:"ada",children:[(0,r.jsxs)(n.p,{children:["with Ada.IO","_","Exceptions;","\n","with Ada.Calendar;","\n","package Ada.Directories ","\n","   with Global =",">"," in out synchronized is","\n","\n",(0,r.jsx)(l.A,{children:"4/2"}),"\n-- Directory and file operations:","\n","\n",(0,r.jsx)(l.A,{children:"5/2"}),"\nfunction Current","_","Directory return String;","\n","\n",(0,r.jsx)(l.A,{children:"6/2"}),"\nprocedure Set","_","Directory (Directory : in String);","\n","\n",(0,r.jsx)(l.A,{children:"7/2"}),"\nprocedure Create","_","Directory (New","_","Directory : in String;","\n",'                               Form          : in String := "");',"\n","\n",(0,r.jsx)(l.A,{children:"8/2"}),"\nprocedure Delete","_","Directory (Directory : in String);","\n","\n",(0,r.jsx)(l.A,{children:"9/2"}),"\nprocedure Create","_","Path (New","_","Directory : in String;","\n",'                          Form          : in String := "");',"\n","\n",(0,r.jsx)(l.A,{children:"10/2"}),"\nprocedure Delete","_","Tree (Directory : in String);","\n","\n",(0,r.jsx)(l.A,{children:"11/2"}),"\nprocedure Delete","_","File (Name : in String);","\n","\n",(0,r.jsx)(l.A,{children:"12/2"}),"\nprocedure Rename (Old","_","Name, New","_","Name : in String);","\n","\n",(0,r.jsx)(l.A,{children:"13/2"}),"\nprocedure Copy","_","File (Source","_","Name,","\n","                        Target","_","Name : in String;","\n",'                        Form        : in String := "");',"\n","\n",(0,r.jsx)(l.A,{children:"14/2"}),"\n-- File and directory name operations:","\n","\n",(0,r.jsx)(l.A,{children:"15/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Full","_","Name (Name : in String) return String","\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"16/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Simple","_","Name (Name : in String) return String","\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"17/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Containing","_","Directory (Name : in String) return String","\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"18/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Extension (Name : in String) return String","\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"19/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Base","_","Name (Name : in String) return String","\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"20/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0241-1"]}),(0,r.jsxs)(n.p,{children:["function Compose (Containing","_",'Directory : in String := "";',"\n","                     Name                 : in String;","\n",'                     Extension            : in String := "") return String',"\n","      with Nonblocking;","\n","\n",(0,r.jsx)(l.A,{children:"20.1/3"})]}),(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),(0,r.jsxs)(n.p,{children:["type Name","_","Case","_","Kind is","\n","      (Unknown, Case","_","Sensitive, Case","_","Insensitive, Case","_","Preserving);","\n","\n",(0,r.jsx)(l.A,{children:"20.2/3"})]}),(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),(0,r.jsxs)(n.p,{children:["function Name","_","Case","_","Equivalence (Name : in String) return Name","_","Case","_","Kind;","\n","\n",(0,r.jsx)(l.A,{children:"21/2"}),"\n-- File and directory queries:","\n","\n",(0,r.jsx)(l.A,{children:"22/2"}),"\ntype File","_","Kind is (Directory, Ordinary","_","File, Special","_","File);","\n","\n",(0,r.jsx)(l.A,{children:"23/2"}),"\ntype File","_","Size is range 0 .. implementation-defined;","\n","\n",(0,r.jsx)(l.A,{children:"24/2"}),"\nfunction Exists (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"25/2"}),"\nfunction Kind (Name : in String) return File","_","Kind;","\n","\n",(0,r.jsx)(l.A,{children:"26/2"}),"\nfunction Size (Name : in String) return File","_","Size;","\n","\n",(0,r.jsx)(l.A,{children:"27/2"}),"\nfunction Modification","_","Time (Name : in String) return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"28/2"}),"\n-- Directory searching:","\n","\n",(0,r.jsx)(l.A,{children:"29/2"}),"\ntype Directory","_","Entry","_","Type is limited private;","\n","\n",(0,r.jsx)(l.A,{children:"30/2"}),"\ntype Filter","_","Type is array (File","_","Kind) of Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"31/2"}),"\ntype Search","_","Type is limited private;","\n","\n",(0,r.jsx)(l.A,{children:"32/2"}),"\nprocedure Start","_","Search (Search    : in out Search","_","Type;","\n","                           Directory : in String;","\n","                           Pattern   : in String;","\n","                           Filter    : in Filter","_","Type := (others =",">"," True));","\n","\n",(0,r.jsx)(l.A,{children:"33/2"}),"\nprocedure End","_","Search (Search : in out Search","_","Type);","\n","\n",(0,r.jsx)(l.A,{children:"34/2"}),"\nfunction More","_","Entries (Search : in Search","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"35/2"}),"\nprocedure Get","_","Next","_","Entry (Search : in out Search","_","Type;","\n","                             Directory","_","Entry : out Directory","_","Entry","_","Type);","\n","\n",(0,r.jsx)(l.A,{children:"36/5"})]}),(0,r.jsx)(d.A,{items:["AI12-0286-1"]}),(0,r.jsxs)(n.p,{children:["procedure Search (","\n","      Directory : in String;","\n","      Pattern   : in String;","\n","      Filter    : in Filter","_","Type := (others =",">"," True);","\n","      Process   : not null access procedure (","\n","          Directory","_","Entry : in Directory","_","Entry","_","Type))","\n","      with Allows","_","Exit;","\n","\n",(0,r.jsx)(l.A,{children:"37/2"}),"\n-- Operations on Directory Entries:","\n","\n",(0,r.jsx)(l.A,{children:"38/2"}),"\nfunction Simple","_","Name (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return String;","\n","\n",(0,r.jsx)(l.A,{children:"39/2"}),"\nfunction Full","_","Name (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return String;","\n","\n",(0,r.jsx)(l.A,{children:"40/2"}),"\nfunction Kind (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return File","_","Kind;","\n","\n",(0,r.jsx)(l.A,{children:"41/2"}),"\nfunction Size (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return File","_","Size;","\n","\n",(0,r.jsx)(l.A,{children:"42/2"}),"\nfunction Modification","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"43/2"}),"\nStatus","_","Error : exception renames Ada.IO","_","Exceptions.Status","_","Error;","\n","   Name","_","Error   : exception renames Ada.IO","_","Exceptions.Name","_","Error;","\n","   Use","_","Error    : exception renames Ada.IO","_","Exceptions.Use","_","Error;","\n","   Device","_","Error : exception renames Ada.IO","_","Exceptions.Device","_","Error;","\n","\n",(0,r.jsx)(l.A,{children:"44/3"})]}),(0,r.jsx)(d.A,{items:["AI05-0092-1"]}),(0,r.jsxs)(n.p,{children:["private","\n","    ... -- not specified by the language","\n","end Ada.Directories;","\n"]})]}),"\n",(0,r.jsx)(l.A,{children:"45/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["External files may be classified as directories, special files, or ordinary files. A ",(0,r.jsx)("em",{children:"directory"})," is an external file that is a container for files on the target system. A ",(0,r.jsx)("em",{children:"special file"})," is an external file that cannot be created or read by a predefined Ada input-output package. External files that are not special files or directories are called ",(0,r.jsx)("em",{children:"ordinary files"}),". ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"45.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"A directory is an external file, although it may not have a name on some targets. A directory is not a special file, as it can be created and read by Directories. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"45.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Devices and soft links are examples of special files on Windows\xae and Unix.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"45.c/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Even if an implementation provides a package to create and read soft links, such links are still special files. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"46/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("em",{children:"file name"})," is a string identifying an external file. Similarly, a ",(0,r.jsx)("em",{children:"directory name"})," is a string identifying a directory. The interpretation of file names and directory names is implementation defined. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"46.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The interpretation of file names and directory names.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"47/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The ",(0,r.jsx)("em",{children:"full name"})," of an external file is a full specification of the name of the file. If the external environment allows alternative specifications of the name (for example, abbreviations), the full name should not use such alternatives. A full name typically will include the names of all of the directories that contain the item. The ",(0,r.jsx)("em",{children:"simple name"})," of an external file is the name of the item, not including any containing directory names. Unless otherwise specified, a file name or directory name parameter in a call to a predefined Ada input-output subprogram can be a full name, a simple name, or any other form of name supported by the implementation. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"47.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'The full name on Unix is a complete path to the root. For Windows\xae, the full name includes a complete path, as well as a disk name ("C:") or network share name. For both systems, the simple name is the part of the name following the last \'/\' (or \'\' for Windows\xae). For example, in the name "/usr/randy/ada-directories.ads", "ada-directories.ads" is the simple name. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"47.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'It is possible for a file or directory name to be neither a full name nor a simple name. For instance, the Unix name "../parent/myfile" is neither a full name nor a simple name. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"47.1/5"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("em",{children:"root directory"})," is a directory that has no containing directory.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"47.c/5"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'For Unix and Unix-like systems, "/" is the root. For Windows\xae, "C:" and "\\Computer\\Share" are roots. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"48/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The ",(0,r.jsx)("em",{children:"default directory"})," is the directory that is used if a directory or file name is not a full name (that is, when the name does not fully identify all of the containing directories). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"48.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The default directory is the one maintained by the familiar \u201ccd\u201d command on Unix and Windows\xae. Note that Windows\xae maintains separate default directories for each disk drive; implementations should use the natural implementation. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"49/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("em",{children:"directory entry"})," is a single item in a directory, identifying a single external file (including directories and special files). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"50/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["For each function that returns a string, the lower bound of the returned value is 1.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"51/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The following file and directory operations are provided:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"52/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Current","_","Directory return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"53/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the full directory name for the current default directory. The name returned shall be suitable for a future call to Set","_","Directory. The exception Use","_","Error is propagated if a default directory is not supported by the external environment.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"54/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Set","_","Directory (Directory : in String);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"55/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Sets the current default directory. The exception Name","_","Error is propagated if the string given as Directory does not identify an existing directory. The exception Use","_","Error is propagated if the external environment does not support making Directory (in the absence of Name","_","Error) a default directory.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"56/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Create","_","Directory (New","_","Directory : in String;","\n",'                            Form          : in String := "");',"\n"]})}),"\n",(0,r.jsx)(l.A,{children:"57/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Creates a directory with name New","_","Directory. The Form parameter can be used to give system-dependent characteristics of the directory; the interpretation of the Form parameter is implementation defined. A null string for Form specifies the use of the default options of the implementation of the new directory. The exception Name","_","Error is propagated if the string given as New","_","Directory does not allow the identification of a directory. The exception Use","_","Error is propagated if the external environment does not support the creation of a directory with the given name (in the absence of Name","_","Error) and form.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"58/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Delete","_","Directory (Directory : in String);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"59/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0231-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Deletes an existing empty directory with name Directory. The exception Name","_","Error is propagated if the string given as Directory does not identify an existing directory. The exception Use","_","Error is propagated if the directory is not empty or the external environment does not support the deletion of the directory with the given name (in the absence of Name","_","Error).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"60/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Create","_","Path (New","_","Directory : in String;","\n",'                       Form          : in String := "");',"\n"]})}),"\n",(0,r.jsx)(l.A,{children:"61/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0271-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Creates zero or more directories with name New","_","Directory. Each nonexistent directory named by New","_","Directory is created.[ For example, on a typical Unix system, Create","_",'Path ("/usr/me/my"); would create directory "me" in directory "usr", then create directory "my" in directory "me".] The Form parameter can be used to give system-dependent characteristics of the directory; the interpretation of the Form parameter is implementation defined. A null string for Form specifies the use of the default options of the implementation of the new directory. The exception Name',"_","Error is propagated if the string given as New","_","Directory does not allow the identification of any directory. The exception Use","_","Error is propagated if the external environment does not support the creation of any directories with the given name (in the absence of Name","_","Error) and form. If Use","_","Error is propagated, it is unspecified whether a portion of the directory path is created.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"62/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Delete","_","Tree (Directory : in String);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"63/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Deletes an existing directory with name Directory. The directory and all of its contents (possibly including other directories) are deleted. The exception Name","_","Error is propagated if the string given as Directory does not identify an existing directory. The exception Use","_","Error is propagated if the external environment does not support the deletion of the directory or some portion of its contents with the given name (in the absence of Name","_","Error). If Use","_","Error is propagated, it is unspecified whether a portion of the contents of the directory is deleted.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"64/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Delete","_","File (Name : in String);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"65/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Deletes an existing ordinary or special file with name Name. The exception Name","_","Error is propagated if the string given as Name does not identify an existing ordinary or special external file. The exception Use","_","Error is propagated if the external environment does not support the deletion of the file with the given name (in the absence of Name","_","Error).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"66/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Rename (Old","_","Name, New","_","Name : in String);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"67/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0231-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Renames an existing external file (including directories) with name Old","_","Name to New","_","Name. The exception Name","_","Error is propagated if the string given as Old","_","Name does not identify an existing external file or if the string given as New","_","Name does not allow the identification of an external file. The exception Use","_","Error is propagated if the external environment does not support the renaming of the file with the given name (in the absence of Name","_","Error). In particular, Use","_","Error is propagated if a file or directory already exists with name New","_","Name.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"67.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"This operation is expected to work within a single directory, and implementers are encouraged to support it across directories on a single device. Copying files from one device to another is discouraged (that's what Copy","_","File is for). However, there is no requirement to detect file copying by the target system. If the target system has an API that gives that for \u201cfree\u201d, it can be used. For Windows\xae, for instance, MoveFile can be used to implement Rename. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"68/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0092-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Copy","_","File (Source","_","Name,","\n","                     Target","_","Name : in String;","\n",'                     Form        : in String := "");',"\n"]})}),"\n",(0,r.jsx)(l.A,{children:"69/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0271-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Copies the contents of the existing external file with name Source","_","Name to an external file with name Target","_","Name. The resulting external file is a duplicate of the source external file. The Form parameter can be used to give system-dependent characteristics of the resulting external file; the interpretation of the Form parameter is implementation defined. Exception Name","_","Error is propagated if the string given as Source","_","Name does not identify an existing external ordinary or special file, or if the string given as Target","_","Name does not allow the identification of an external file. The exception Use","_","Error is propagated if the external environment does not support creating the file with the name given by Target","_","Name and form given by Form, or copying of the file with the name given by Source","_","Name (in the absence of Name","_","Error). If Use","_","Error is propagated, it is unspecified whether a portion of the file is copied. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"69.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Name","_","Error is always raised if Source","_","Name identifies a directory. It is up to the implementation whether special files can be copied, or if Use","_","Error will be raised. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"70/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The following file and directory name operations are provided:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"71/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Full","_","Name (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"72/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the full name corresponding to the file name specified by Name. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"72.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'Full name means that no abbreviations are used in the returned name, and that it is a full specification of the name. Thus, for Unix and Windows\xae, the result should be a full path that does not contain any "." or ".." directories. Typically, the default directory is used to fill in any missing information. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"73/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Simple","_","Name (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"74/5"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0337-1","AI12-0433-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the simple name portion of the file name specified by Name. The simple name of a root directory is a name of the root itself. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"74.a/5"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The result of Simple","_","Name corresponds to the result of the \u201cbasename\u201d command on Linux and Unix. If the filename ends with a '/', and is not a root, then \u201cbasename\u201d returns the part in front of all of the trailing '/'s. It returns a root intact. The null string is never returned. Similar rules should be used for Windows filenames. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"75/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Containing","_","Directory (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"76/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the name of the containing directory of the external file (including directories) identified by Name. (If more than one directory can contain Name, the directory name returned is implementation defined.) The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file. The exception Use","_","Error is propagated if the external file does not have a containing directory. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"76.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"This is purely a string manipulation function. If Name is not given as a full name, the containing directory probably won't be one, either. For example, if Containing","_",'Directory ("..\\AARM\\RM-A-8") is called on Windows\xae, the result should be "..\\AARM". If there is no path at all on the name, the result should be "." (which represents the current directory). Use Full',"_","Name on the result of Containing","_","Directory if the full name is needed. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"76.b/5"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Containing","_","Directory raises Use","_","Error when passed a string representing a root directory. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"77/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Extension (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"78/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the extension name corresponding to Name. The extension name is a portion of a simple name (not including any separator characters), typically used to identify the file class. If the external environment does not have extension names, then the null string is returned. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"78.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'For Unix and Windows\xae, the extension is the portion of the simple name following the rightmost period. For example, in the simple name "RM-A-8.html", the extension is "html". ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"79/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Base","_","Name (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"80/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the base name corresponding to Name. The base name is the remainder of a simple name after removing any extension and extension separators. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"80.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),'For Unix and Windows\xae, the base name is the portion of the simple name preceding the rightmost period (except for the special directory names "." and "..", whose Base',"_",'Name is "." and ".."). For example, in the simple name "RM-A-8.html", the base name is "RM-A-8". ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"81/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Compose (Containing","_",'Directory : in String := "";',"\n","                  Name                 : in String;","\n",'                  Extension            : in String := "") return String;',"\n"]})}),"\n",(0,r.jsx)(l.A,{children:"82/5"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0264-1","AI12-0337-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the name of the external file with the specified Containing","_","Directory, Name, and Extension. If Extension is the null string, then Name is interpreted as a simple name; otherwise, Name is interpreted as a base name. The exception Name","_","Error is propagated if: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"82.1/5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["the string given as Containing","_","Directory is not null and does not allow the identification of a directory;",(0,r.jsx)("br",{})]}),(0,r.jsx)(l.A,{children:"82.2/5"}),(0,r.jsxs)("li",{children:["the string given as Extension is not null and is not a possible extension;",(0,r.jsx)("br",{})]}),(0,r.jsx)(l.A,{children:"82.3/5"}),(0,r.jsxs)("li",{children:["the string given as Name is not a possible simple name (if Extension is null) or base name (if Extension is nonnull); or",(0,r.jsx)("br",{})]}),(0,r.jsx)(l.A,{children:"82.4/5"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsxs)("li",{children:["the string given as Name is a root directory, and Containing","_","Directory or Extension is nonnull. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"82.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The above definition implies that if the Extension is null, for Unix and Windows\xae no '.' is added to Name. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"82.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"If Name is null, Name","_","Error should be raised, as nothing is not a possible simple name or base name.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"82.c/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Generally, Compose(Containing","_","Directory(F), Base","_","Name(F),Extension(F)) = F. However, this is not true on Unix or Windows\xae for file names that end with a '.'; Compose(Base","_",'Name("Fooey."),Extension("Fooey.")) = "Fooey". This is not a problem for Windows\xae, as the names have the same meaning with or without the \'.\', but these are different names for Unix. Thus, care needs to be taken on Unix; if Extension is null, Base',"_","Name should be avoided. (That's not usually a problem with file names generated by a program.) ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"82.5/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Name","_","Case","_","Equivalence (Name : in String) return Name","_","Case","_","Kind;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"82.6/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1","AI05-0248-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the file name equivalence rule for the directory containing Name. Raises Name","_","Error if Name is not a full name. Returns Case","_","Sensitive if file names that differ only in the case of letters are considered different names. If file names that differ only in the case of letters are considered the same name, then Case","_","Preserving is returned if names have the case of the file name used when a file is created; and Case","_","Insensitive is returned otherwise. Returns Unknown if the file name equivalence is not known. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"82.c.1/3"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Unix, Linux, and their relatives are Case","_","Sensitive systems. Microsoft\xae Windows\xae is a Case","_","Preserving system (unless the rarely used POSIX mode is used). Ancient systems like CP/M and early MS-DOS were Case","_","Insensitive systems (file names were always in UPPER CASE). Unknown is provided in case it is impossible to tell (such as could be the case for network files). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"83/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The following file and directory queries and types are provided:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"84/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type File","_","Kind is (Directory, Ordinary","_","File, Special","_","File);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"85/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The type File","_","Kind represents the kind of file represented by an external file or directory.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"86/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type File","_","Size is range 0 .. implementation-defined;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"87/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The type File","_","Size represents the size of an external file. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"87.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The maximum value for a file size in Directories.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"88/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Exists (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"89/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if an external file represented by Name exists, and False otherwise. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"90/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Kind (Name : in String) return File","_","Kind;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"91/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the kind of external file represented by Name. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an existing external file.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"92/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Size (Name : in String) return File","_","Size;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"93/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the size of the external file represented by Name. The size of an external file is the number of stream elements contained in the file. If the external file is not an ordinary file, the result is implementation defined. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an existing external file. The exception Constraint","_","Error is propagated if the file size is not a value of type File","_","Size. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"93.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The result for Directories.Size for a directory or special file.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"93.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"We allow raising Constraint","_","Error, so that an implementation for a system with 64-bit file sizes does not need to support full numerics on 64-bit integers just to implement this package. Of course, if 64-bit integers are available on such a system, they should be used when defining type File","_","Size. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"94/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Modification","_","Time (Name : in String) return Ada.Calendar.Time;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"95/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the time that the external file represented by Name was most recently modified. If the external file is not an ordinary file, the result is implementation defined. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an existing external file. The exception Use","_","Error is propagated if the external environment does not support reading the modification time of the file with the name given by Name (in the absence of Name","_","Error). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"95.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The result for Directories.Modification","_","Time for a directory or special file.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"96/2"}),"\n",(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),"\n",(0,r.jsxs)("p",{children:["The following directory searching operations and types are provided:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"97/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type Directory","_","Entry","_","Type is limited private;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"98/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The type Directory","_","Entry","_","Type represents a single item in a directory. These items can only be created by the Get","_","Next","_","Entry procedure in this package. Information about the item can be obtained from the functions declared in this package. A default-initialized object of this type is invalid; objects returned from Get","_","Next","_","Entry are valid.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"99/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type Filter","_","Type is array (File","_","Kind) of Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"100/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The type Filter","_","Type specifies which directory entries are provided from a search operation. If the Directory component is True, directory entries representing directories are provided. If the Ordinary","_","File component is True, directory entries representing ordinary files are provided. If the Special","_","File component is True, directory entries representing special files are provided.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"101/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type Search","_","Type is limited private;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"102/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The type Search","_","Type contains the state of a directory search. A default-initialized Search","_","Type object has no entries available (function More","_","Entries returns False). Type Search","_","Type needs finalization (see ",(0,r.jsx)("a",{href:"../AA-7/AA-7.6",children:"7.6"}),").",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"103/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Start","_","Search (Search    : in out Search","_","Type;","\n","                        Directory : in String;","\n","                        Pattern   : in String;","\n","                        Filter    : in Filter","_","Type := (others =",">"," True));","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"104/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0092-1","AI05-0262-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Starts a search in the directory named by Directory for entries matching Pattern and Filter. Pattern represents a pattern for matching file names. If Pattern is the null string, all items in the directory are matched; otherwise, the interpretation of Pattern is implementation defined. Only items that match Filter will be returned. After a successful call on Start","_","Search, the object Search may have entries available, but it may have no entries available if no files or directories match Pattern and Filter. The exception Name","_","Error is propagated if the string given by Directory does not identify an existing directory, or if Pattern does not allow the identification of any possible external file or directory. The exception Use","_","Error is propagated if the external environment does not support the searching of the directory with the given name (in the absence of Name","_","Error). When Start","_","Search propagates Name","_","Error or Use","_","Error, the object Search will have no entries available. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"104.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The interpretation of a nonnull search pattern in Directories.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"105/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure End","_","Search (Search : in out Search","_","Type);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"106/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Ends the search represented by Search. After a successful call on End","_","Search, the object Search will have no entries available.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"106.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The only way that a call to End","_","Search could be unsuccessful if Device","_","Error (see ",(0,r.jsx)("a",{href:"../AA-A/AA-A.13",children:"A.13"}),") is raised because of an underlying failure (or bug). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"107/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function More","_","Entries (Search : in Search","_","Type) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"108/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if more entries are available to be returned by a call to Get","_","Next","_","Entry for the specified search object, and False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"109/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Get","_","Next","_","Entry (Search : in out Search","_","Type;","\n","                          Directory","_","Entry : out Directory","_","Entry","_","Type);","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"110/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0262-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the next Directory","_","Entry for the search described by Search that matches the pattern and filter. If no further matches are available, Status","_","Error is raised. It is implementation defined as to whether the results returned by this subprogram are altered if the contents of the directory are altered while the Search object is valid (for example, by another program). The exception Use","_","Error is propagated if the external environment does not support continued searching of the directory represented by Search. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"110.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The results of a Directories search if the contents of the directory are altered while a search is in progress.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"111/5"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0286-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Search (","\n","   Directory : in String;","\n","   Pattern   : in String;","\n","   Filter    : in Filter","_","Type := (others =",">"," True);","\n","   Process   : not null access procedure (","\n","       Directory","_","Entry : in Directory","_","Entry","_","Type))","\n","   with Allows","_","Exit;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"112/3"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0092-1","AI05-0262-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Searches in the directory named by Directory for entries matching Pattern and Filter. The subprogram designated by Process is called with each matching entry in turn. Pattern represents a pattern for matching file names. If Pattern is the null string, all items in the directory are matched; otherwise, the interpretation of Pattern is implementation defined. Only items that match Filter will be returned. The exception Name","_","Error is propagated if the string given by Directory does not identify an existing directory, or if Pattern does not allow the identification of any possible external file or directory. The exception Use","_","Error is propagated if the external environment does not support the searching of the directory with the given name (in the absence of Name","_","Error). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"112.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"\u201cIn turn\u201d means that the calls to the subprogram designated by Process are not made in parallel; they can be made in any order but must be in sequence. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"113/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Simple","_","Name (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","     return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"114/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the simple external name of the external file (including directories) represented by Directory","_","Entry. The format of the name returned is implementation defined. The exception Status","_","Error is propagated if Directory","_","Entry is invalid.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"115/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Full","_","Name (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","     return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"116/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the full external name of the external file (including directories) represented by Directory","_","Entry. The format of the name returned is implementation defined. The exception Status","_","Error is propagated if Directory","_","Entry is invalid.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"117/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Kind (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","     return File","_","Kind;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"118/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the kind of external file represented by Directory","_","Entry. The exception Status","_","Error is propagated if Directory","_","Entry is invalid.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"119/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Size (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","     return File","_","Size;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"120/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the size of the external file represented by Directory","_","Entry. The size of an external file is the number of stream elements contained in the file. If the external file represented by Directory","_","Entry is not an ordinary file, the result is implementation defined. The exception Status","_","Error is propagated if Directory","_","Entry is invalid. The exception Constraint","_","Error is propagated if the file size is not a value of type File","_","Size.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"121/2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Modification","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","     return Ada.Calendar.Time;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"122/2"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the time that the external file represented by Directory","_","Entry was most recently modified. If the external file represented by Directory","_","Entry is not an ordinary file, the result is implementation defined. The exception Status","_","Error is propagated if Directory","_","Entry is invalid. The exception Use","_","Error is propagated if the external environment does not support reading the modification time of the file represented by Directory","_","Entry.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,r.jsx)(l.A,{children:"123/2"}),"\n",(0,r.jsxs)("p",{children:["For Copy","_","File, if Source","_","Name identifies an existing external ordinary file created by a predefined Ada input-output package, and Target","_","Name and Form can be used in the Create operation of that input-output package with mode Out","_","File without raising an exception, then Copy","_","File shall not propagate Use","_","Error.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"123.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"This means that Copy","_","File will copy any file that the Ada programmer could copy (by writing some possibly complicated Ada code). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-advice",children:"Implementation Advice"}),"\n",(0,r.jsx)(l.A,{children:"124/2"}),"\n",(0,r.jsxs)("p",{children:["If other information about a file (such as the owner or creation date) is available in a directory entry, the implementation should provide functions in a child package Directories.Information to retrieve it. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Package Directories.Information should be provided to retrieve other information about a file.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"For Windows\xae, Directories.Information should contain at least the following routines:",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.c/5"}),(0,r.jsx)(d.A,{items:["AI12-0302-1"]}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["package Ada.Directories.Information ","\n","   with Global =",">"," in out synchronized is","\n","    -- System-specific directory information.","\n","    -- Version for the Microsoft\xae Windows\xae operating system.","\n","\n",(0,r.jsx)(l.A,{children:"124.d/2"}),"\nfunction Creation","_","Time (Name : in String) return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.e/2"}),"\nfunction Last","_","Access","_","Time (Name : in String) return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.f/2"}),"\nfunction Is","_","Read","_","Only (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.g/2"}),"\nfunction Needs","_","Archiving (Name : in String) return Boolean;","\n","        -- This generally means that the file needs to be backed up.","\n","        -- The flag is only cleared by backup programs.","\n","\n",(0,r.jsx)(l.A,{children:"124.h/2"}),"\nfunction Is","_","Compressed (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.i/2"}),"\nfunction Is","_","Encrypted (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.j/2"}),"\nfunction Is","_","Hidden (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.k/2"}),"\nfunction Is","_","System (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.l/2"}),"\nfunction Is","_","Offline (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.m/2"}),"\nfunction Is","_","Temporary (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.n/2"}),"\nfunction Is","_","Sparse (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.o/2"}),"\nfunction Is","_","Not","_","Indexed (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.p/2"}),"\nfunction Creation","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","         return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.q/2"}),"\nfunction Last","_","Access","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","         return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.r/2"}),"\nfunction Is","_","Read","_","Only (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.s/2"}),"\nfunction Needs","_","Archiving (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","        -- This generally means that the file needs to be backed up.","\n","        -- The flag is only cleared by backup programs.","\n","\n",(0,r.jsx)(l.A,{children:"124.t/2"}),"\nfunction Is","_","Compressed (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.u/2"}),"\nfunction Is","_","Encrypted (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.v/2"}),"\nfunction Is","_","Hidden (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.w/2"}),"\nfunction Is","_","System (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.x/2"}),"\nfunction Is","_","Offline (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.y/2"}),"\nfunction Is","_","Temporary (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.z/2"}),"\nfunction Is","_","Sparse (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.aa/2"}),"\nfunction Is","_","Not","_","Indexed (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.bb/2"}),"\n-- Additional implementation-defined subprograms allowed here.","\n","end Ada.Directories.Information;","\n"]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.cc/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["For Unix-like systems (Unix, POSIX, Linux, etc.), Directories.Information should contain at least the following routines:",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.dd/5"}),(0,r.jsx)(d.A,{items:["AI12-0302-1"]}),(0,r.jsxs)(o.A,{language:"ada",children:[(0,r.jsxs)(n.p,{children:["package Ada.Directories.Information ","\n","   with Global =",">"," in out synchronized is","\n","    -- System-specific directory information.","\n","    -- Unix and similar systems version.","\n","\n",(0,r.jsx)(l.A,{children:"124.ee/2"}),"\nfunction Last","_","Access","_","Time (Name : in String) return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.ff/2"}),"\nfunction Last","_","Status","_","Change","_","Time (Name : in String) return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.gg/2"}),"\ntype Permission is","\n","      (Others","_","Execute, Others","_","Write, Others","_","Read,","\n","       Group","_","Execute,  Group","_","Write,  Group","_","Read,","\n","       Owner","_","Execute,  Owner","_","Write,  Owner","_","Read,","\n","       Set","_","Group","_","ID,   Set","_","User","_","ID);","\n","\n",(0,r.jsx)(l.A,{children:"124.hh/2"}),"\ntype Permission","_","Set","_","Type is array (Permission) of Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.ii/2"}),"\nfunction Permission","_","Set (Name : in String) return Permission","_","Set","_","Type;","\n","\n",(0,r.jsx)(l.A,{children:"124.jj/2"}),"\nfunction Owner (Name : in String) return String;","\n","        -- Returns the image of the User","_","Id. If a definition of User","_","Id","\n","        -- is available, an implementation-defined version of Owner","\n","        -- returning User","_","Id should also be defined.","\n","\n",(0,r.jsx)(l.A,{children:"124.kk/3"})]}),(0,r.jsx)(d.A,{items:["AI05-0005-1"]}),(0,r.jsxs)(n.p,{children:["function Group (Name : in String) return String;","\n","        -- Returns the image of the Group","_","Id. If a definition of Group","_","Id","\n","        -- is available, an implementation-defined version of Group","\n","        -- returning Group","_","Id should also be defined.","\n","\n",(0,r.jsx)(l.A,{children:"124.ll/2"}),"\nfunction Is","_","Block","_","Special","_","File (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.mm/2"}),"\nfunction Is","_","Character","_","Special","_","File (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.nn/2"}),"\nfunction Is","_","FIFO (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.oo/2"}),"\nfunction Is","_","Symbolic","_","Link (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.pp/2"}),"\nfunction Is","_","Socket (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.qq/2"}),"\nfunction Last","_","Access","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.rr/2"}),"\nfunction Last","_","Status","_","Change","_","Time (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Ada.Calendar.Time;","\n","\n",(0,r.jsx)(l.A,{children:"124.ss/2"}),"\nfunction Permission","_","Set (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Permission","_","Set","_","Type;","\n","\n",(0,r.jsx)(l.A,{children:"124.tt/2"}),"\nfunction Owner (Directory","_","Entry : in Directory","_","Entry","_","Type) return String;","\n","       -- See Owner above.","\n","\n",(0,r.jsx)(l.A,{children:"124.uu/2"}),"\nfunction Group (Directory","_","Entry : in Directory","_","Entry","_","Type) return String;","\n","       -- See Group above.","\n","\n",(0,r.jsx)(l.A,{children:"124.vv/2"}),"\nfunction Is","_","Block","_","Special","_","File (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.ww/2"}),"\nfunction Is","_","Character","_","Special","_","File (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.xx/2"}),"\nfunction Is","_","FIFO (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.yy/2"}),"\nfunction Is","_","Symbolic","_","Link (Directory","_","Entry : in Directory","_","Entry","_","Type)","\n","       return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.zz/2"}),"\nfunction Is","_","Socket (Directory","_","Entry : in Directory","_","Entry","_","Type) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"124.aaa/2"}),"\n-- Additional implementation-defined subprograms allowed here.","\n","end Ada.Directories.Information;","\n"]})]})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"124.bbb/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["We give these definitions to give guidance so that every implementation for a given target is not unnecessarily different. Implementers are encouraged to make packages for other targets as similar to these as possible.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"125/5"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0231-1","AI12-0439-1"]}),"\n",(0,r.jsxs)("p",{children:["Start","_","Search and Search should raise Name","_","Error if Pattern is malformed, but not if it can represent a file in the directory but does not actually do so.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"125.a/3"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Directories.Start","_","Search and Directories.Search should raise Name","_","Error for malformed patterns.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"126/2"}),"\n",(0,r.jsxs)("p",{children:["Rename should be supported at least when both New","_","Name and Old","_","Name are simple names and New","_","Name does not identify an existing external file. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"126.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Directories.Rename should be supported at least when both New","_","Name and Old","_","Name are simple names and New","_","Name does not identify an existing external file.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"126.b/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"\u201cSupported\u201d includes raising an exception if either name is malformed, the file to rename doesn't exist, insufficient permission for the operation exists, or similar problems. But this advice requires implementations to document what they do, and tells implementers that simply raising Use","_","Error isn't acceptable. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"127/5"}),(0,r.jsx)(d.A,{items:["AI12-0442-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 1   The operations Containing","_","Directory, Full","_","Name, Simple","_","Name, Base","_","Name, Extension, and Compose operate on file names, not external files. The files identified by these operations do not necessarily exist. Name","_","Error is raised only if the file name is malformed and cannot possibly identify a file. Of these operations, only the result of Full","_","Name depends on the current default directory; the result of the others depends only on their parameters.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"128/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 2   Using access types, values of Search","_","Type and Directory","_","Entry","_","Type can be saved and queried later. However, another task or application can modify or delete the file represented by a Directory","_","Entry","_","Type value or the directory represented by a Search","_","Type value; such a value can only give the information valid at the time it is created. Therefore, long-term storage of these values is not recommended.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"129/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 3   If the target system does not support directories inside of directories, then Kind will never return Directory and Containing","_","Directory will always raise Use","_","Error.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"130/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 4   If the target system does not support creation or deletion of directories, then Create","_","Directory, Create","_","Path, Delete","_","Directory, and Delete","_","Tree will always propagate Use","_","Error.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131/5"}),(0,r.jsx)(d.A,{items:["AI12-0442-1","AI12-0447-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 5   To move a file or directory to a different location, use Rename. Most target systems will allow renaming of files from one directory to another. If the target file or directory can already exist, it should be deleted first. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.a/2"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"While Rename is only guaranteed to work for name changes within a single directory, its unlikely that implementers would purposely prevent functionality present in the underlying system from working. To move a file totally portably, it's necessary to handle failure of the Rename and fall back to Copy","_","File and Delete: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.b"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["begin","\n","   Rename (Source, Target);","\n","exception","\n","   when Use","_","Error =",">","\n","      Copy","_","File (Source, Target);","\n","      Delete (Source);","\n","end;","\n"]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.c/2"}),(0,r.jsx)(d.A,{items:["AI95-00248-01"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Package Ada.Directories is new. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"inconsistencies-with-ada-2005",children:"Inconsistencies With Ada 2005"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.d/3"}),(0,r.jsx)(d.A,{items:["AI05-0231-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{children:"Correction"}),": Clarified when and which exceptions are raised for Start","_","Search, Search, Delete","_","Directory, and Rename. If an implementation followed the original incorrect wording, it might raise Use","_","Error instead of Name","_","Error for Start","_","Search and Search, Name","_","Error instead of Use","_","Error for Rename, and might have deleted a nonempty directory instead of raising Use","_","Error for Delete","_","Directory. The first two cases are very unlikely to matter in practice, and it unlikely that an implementation would have followed the latter implementation strategy, as it would be more work and would make Delete","_","Directory identical to Delete","_","Tree (which is obvious nonsense). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"incompatibilities-with-ada-2005",children:"Incompatibilities With Ada 2005"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.e/3"}),(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["A new enumeration type Name","_","Case","_","Kind and a new function Name","_","Case","_","Equivalence is added to Directories. If Directories is referenced in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"../AA-8/AA-8.4#S0235",children:"use_clause"})}),", and an entity ",(0,r.jsx)("em",{children:"E"})," with a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"../AA-3/AA-3.1#S0022",children:"defining_identifier"})})," of one of the new entities is defined in a package that is also referenced in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"../AA-8/AA-8.4#S0235",children:"use_clause"})}),", the entity ",(0,r.jsx)("em",{children:"E"})," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.f/3"}),(0,r.jsx)(d.A,{items:["AI05-0271-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{})," We now explicitly say that the behavior of Create","_","Path and Copy","_","File is unspecified when Use","_","Error is raised. Nothing has changed here, as the behavior was (implicitly) unspecified in the 2007 Amendment. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"131.g/5"}),(0,r.jsx)(d.A,{items:["AI12-0337-1","AI12-0433-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{})," Clarified the meaning of Simple","_","Name in the case that the parameter is a root directory. This was not previously described. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_A.16.1"}),"\n",(0,r.jsx)(n.h2,{id:"a161--the-package-directorieshierarchical_file_names",children:"A.16.1  The Package Directories.Hierarchical_File_Names"}),"\n",(0,r.jsx)(l.A,{children:"1/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),"\n",(0,r.jsxs)("p",{children:["The library package Directories.Hierarchical","_","File","_","Names is an optional package providing operations for file name construction and decomposition for targets with hierarchical file naming. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,r.jsx)(l.A,{children:"2/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),"\n",(0,r.jsxs)("p",{children:["If provided, the library package Directories.Hierarchical","_","File","_","Names has the following declaration:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"3/5_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["package Ada.Directories.Hierarchical","_","File","_","Names","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,r.jsx)(l.A,{children:"4/3_A.16.1"}),"\nfunction Is","_","Simple","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"5/3_A.16.1"}),"\nfunction Is","_","Root","_","Directory","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"6/3_A.16.1"}),"\nfunction Is","_","Parent","_","Directory","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"7/3_A.16.1"}),"\nfunction Is","_","Current","_","Directory","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"8/3_A.16.1"}),"\nfunction Is","_","Full","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"9/3_A.16.1"}),"\nfunction Is","_","Relative","_","Name (Name : in String) return Boolean;","\n","\n",(0,r.jsx)(l.A,{children:"10/3_A.16.1"}),"\nfunction Simple","_","Name (Name : in String) return String","\n","      renames Ada.Directories.Simple","_","Name;","\n","\n",(0,r.jsx)(l.A,{children:"11/3_A.16.1"}),"\nfunction Containing","_","Directory (Name : in String) return String","\n","      renames Ada.Directories.Containing","_","Directory;","\n","\n",(0,r.jsx)(l.A,{children:"12/3_A.16.1"}),"\nfunction Initial","_","Directory (Name : in String) return String;","\n","\n",(0,r.jsx)(l.A,{children:"13/3_A.16.1"}),"\nfunction Relative","_","Name (Name : in String) return String;","\n","\n",(0,r.jsx)(l.A,{children:"14/3_A.16.1"}),'\nfunction Compose (Directory      : in String := "";',"\n","                     Relative","_","Name  : in String;","\n",'                     Extension      : in String := "") return String;',"\n","\n",(0,r.jsx)(l.A,{children:"15/3_A.16.1"}),"\nend Ada.Directories.Hierarchical","_","File","_","Names;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"16/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1","AI05-0269-1"]}),"\n",(0,r.jsxs)("p",{children:["In addition to the operations provided in package Directories.Hierarchical","_","File","_","Names, the operations in package Directories can be used with hierarchical file names. In particular, functions Full","_","Name, Base","_","Name, and Extension provide additional capabilities for hierarchical file names.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"17/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Simple","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"18/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if Name is a simple name, and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"18.a/5_A.16.1"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Root directories are considered simple names, so this function will return True if Name represents a root. Use Is","_","Root","_","Directory if it is necessary to distinguish roots and other simple names. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"19/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Root","_","Directory","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"20/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if Name is syntactically a root (a directory that cannot be decomposed further), and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"21/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Parent","_","Directory","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"22/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if Name can be used to indicate symbolically the parent directory of any directory, and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"22.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Is","_","Parent","_","Directory","_",'Name returns True if and only if Name is ".." for both Unix and Windows\xae. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"23/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Current","_","Directory","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"24/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if Name can be used to indicate symbolically the directory itself for any directory, and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"24.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Is","_","Current","_","Directory","_",'Name returns True if and only if Name is "." for both Unix and Windows\xae. ',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"25/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Full","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"26/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if the leftmost directory part of Name is a root, and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"27/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Is","_","Relative","_","Name (Name : in String) return Boolean;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"28/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1","AI05-0269-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns True if Name allows the identification of an external file (including directories and special files) but is not a full name, and returns False otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"28.a/5_A.16.1"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Relative names include simple names other than root directories as a special case. This function returns False if the syntax of the name is incorrect. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"29/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Initial","_","Directory (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"30/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1","AI05-0248-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the leftmost directory part in Name. [That is, it returns a root directory name (for a full name), or one of a parent directory name, a current directory name, or a simple name (for a relative name).] The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"31/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["function Relative","_","Name (Name : in String) return String;","\n"]})}),"\n",(0,r.jsx)(l.A,{children:"32/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the entire file name except the Initial","_","Directory portion. The exception Name","_","Error is propagated if the string given as Name does not allow the identification of an external file (including directories and special files), or if Name has a single part (this includes if any of Is","_","Simple","_","Name, Is","_","Root","_","Directory","_","Name, Is","_","Parent","_","Directory","_","Name, or Is","_","Current","_","Directory","_","Name are True).",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"32.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"The result might be a simple name. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(l.A,{children:"33/3_A.16.1"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:['function Compose (Directory      : in String := "";',"\n","                  Relative","_","Name  : in String;","\n",'                  Extension      : in String := "") return String;',"\n"]})}),"\n",(0,r.jsx)(l.A,{children:"34/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["Returns the name of the external file with the specified Directory, Relative","_","Name, and Extension. The exception Name","_","Error is propagated if the string given as Directory is not the null string and does not allow the identification of a directory, or if Is","_","Relative","_","Name (Relative","_","Name) is False, or if the string given as Extension is not the null string and is not a possible extension, or if Extension is not the null string and Simple","_","Name (Relative","_","Name) is not a base name.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"35/3_A.16.1"}),"\n",(0,r.jsxs)("p",{class:"Indented4",children:["The result of Compose is a full name if Is","_","Full","_","Name (Directory) is True; result is a relative name otherwise.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Name","_","Error is raised by Compose if Directory is not the null string, and both Is","_","Full","_","Name and Is","_","Relative","_","Name return False. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.b/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"A common security problem is to include a parent directory name in the middle of a file name; this is often used to navigate outside of an intended root directory. We considered attempting to prevent that case by having Compose detect it and raise an exception. But the extra rules necessary were more confusing than helpful.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.c/5_A.16.1"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:['We can say more about the details of these operations by adopting the notation of a subscript to specify how many path fragments a particular result has. Then, we can abbreviate "Full Name" as "Full" and "Relative Name" as "Rel". In this notation, Unix file name "a/b" is a Rel(2), "../c/d" is a Rel(3), and "/a/b" is a Full(2). Rel(1) is equivalent to a simple name that is not a root; thus we don\'t have to describe that separately.',(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.d/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["In this notation, ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.e/3_A.16.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["\n","For N",">","1,","\n","Containing","_","Directory(Rel(N)) = Leftmost Rel(N-1),","\n","Containing","_","Directory(Full(N)) = Leftmost Full(N-1),","\n","Else if N = 1, raise Use","_","Error.","\n","  ","\n"]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.f/3_A.16.1"}),(0,r.jsx)(d.A,{items:["AI12-0337-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Similarly, ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.g/3_A.16.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["For N",">","1,","\n","Relative","_","Name(Rel(N)) = Rightmost Rel(N-1),","\n","Relative","_","Name(Full(N)) = Rightmost Full(N-1),","\n","Else if N = 1, raise Name","_","Error.","\n","  ","\n"]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.h/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Finally, for Compose (ignoring the extension here): ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.i/3_A.16.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["Compose (Directory =",">"," Full(N), Relative","_","Name =",">"," Rel(M)) =",">"," Full(N+M)","\n","Compose (Directory =",">"," Rel(N), Relative","_","Name =",">"," Rel(M)) =",">"," Rel(N+M)","\n","Name","_","Error if Relative","_","Name is a Full(M).","\n","  ","\n"]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"35.j/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["We didn't try to write wording to reflect these details of these functions. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-advice-1",children:"Implementation Advice"}),"\n",(0,r.jsx)(l.A,{children:"36/3_A.16.1"}),"\n",(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),"\n",(0,r.jsxs)("p",{children:["Directories.Hierarchical","_","File","_","Names should be provided for systems with hierarchical file naming, and should not be provided on other systems. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"36.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"Directories.Hierarchical","_","File","_","Names should be provided for systems with hierarchical file naming, and should not be provided on other systems.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"36.b/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"This package should be provided when targeting Microsoft\xae Windows\xae, Unix, Linux, and most Unix-like systems. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"37/5_A.16.1"}),(0,r.jsx)(d.A,{items:["AI05-0049-1","AI12-0442-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 1   These operations operate on file names, not external files. The files identified by these operations do not necessarily exist. Name","_","Error is raised only as specified or if the file name is malformed and cannot possibly identify a file. The result of these operations depends only on their parameters.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"38/3_A.16.1"}),(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE 2   Containing","_","Directory raises Use","_","Error if Name does not have a containing directory, including when any of Is","_","Simple","_","Name, Is","_","Root","_","Directory","_","Name, Is","_","Parent","_","Directory","_","Name, or Is","_","Current","_","Directory","_","Name are True.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"38.a/3_A.16.1"}),(0,r.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("strong",{}),"In particular, the default directory is not used to find the containing directory either when Is","_","Parent","_","Directory","_","Name or Is","_","Current","_","Directory","_","Name is True. As noted above, these functions operate purely on the syntax of the file names and do not attempt to interpret them. If interpretation is needed, Directories.Full","_","Name can be to expand any shorthands used before calling Containing","_","Directory. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"38.b/3_A.16.1"}),(0,r.jsx)(d.A,{items:["AI05-0049-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Package Ada.Directories.Hierarchical","_","File","_","Names is new. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_A.16.2"}),"\n",(0,r.jsx)(n.h2,{id:"a162--the-packages-wide_directories-and-wide_wide_directories",children:"A.16.2  The Packages Wide_Directories and Wide_Wide_Directories"}),"\n",(0,r.jsx)(l.A,{children:"1/5_A.16.2"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0021-1"]}),"\n",(0,r.jsxs)("p",{children:["The packages Wide","_","Directories and Wide","_","Wide","_","Directories provide operations for manipulating files and directories, and their names. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"static-semantics-2",children:"Static Semantics"}),"\n",(0,r.jsx)(l.A,{children:"2/5_A.16.2"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0021-1"]}),"\n",(0,r.jsxs)("p",{children:["The specification of package Wide","_","Directories is the same as for Directories (including its optional child packages Information and Hierarchical","_","File","_","Names), except that each occurrence of String is replaced by Wide","_","String. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(l.A,{children:"3/5_A.16.2"}),"\n",(0,r.jsx)(d.A,{items:["AI12-0021-1"]}),"\n",(0,r.jsxs)("p",{children:["The specification of package Wide","_","Wide","_","Directories is the same as for Directories (including its optional child packages Information and Hierarchical","_","File","_","Names), except that each occurrence of String is replaced by Wide","_","Wide","_","String. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(a.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-2012",children:"Extensions to Ada 2012"})}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(l.A,{children:"3.a/5_A.16.2"}),(0,r.jsx)(d.A,{items:["AI12-0021-1"]}),(0,r.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["These six packages are new. ",(0,r.jsx)("br",{})]})})]})]})}function f(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}}}]);