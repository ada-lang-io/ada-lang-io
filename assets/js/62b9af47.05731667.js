"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["7117"],{24741:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>s,toc:()=>l,default:()=>u,metadata:()=>t,assets:()=>d,contentTitle:()=>o});var t=JSON.parse('{"id":"learn/how-tos/creating-a-plugin-system","title":"How to create a plug-in system","description":"How to create a plug-in system","source":"@site/docs/learn/how-tos/creating-a-plugin-system.mdx","sourceDirName":"learn/how-tos","slug":"/learn/how-tos/creating-a-plugin-system","permalink":"/docs/learn/how-tos/creating-a-plugin-system","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"description":"How to create a plug-in system","keywords":["plugin","runtime","tagged"]},"sidebar":"tutorialSidebar","previous":{"title":"How-Tos","permalink":"/docs/category/how-tos"},"next":{"title":"UTF-8 encoding in GNAT","permalink":"/docs/learn/how-tos/gnat_and_utf_8"}}'),a=i(85893),r=i(50065);let s={sidebar_position:2,description:"How to create a plug-in system",keywords:["plugin","runtime","tagged"]},o="How to create a plug-in system",d={},l=[{value:"Plug-in API side",id:"plug-in-api-side",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"how-to-create-a-plug-in-system",children:"How to create a plug-in system"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:'This explanation was originally posted by Dimitry Kazakov in the Ada subreddit under the same name (minus the "system") on the 20th of January 2026. Section titles have been added for readability reasons.'})}),"\n",(0,a.jsx)(n.p,{children:"Ada is a statically typed language. Does that mean an Ada application must include everything in advance? Not at all. Ada tagged types provide an excellent support of late bindings. Here I show how to write dynamically linked plug-ins in Ada."}),"\n",(0,a.jsx)(n.p,{children:"The task is this. Let us have some base tagged type, possibly abstract."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"--\n-- This type represents greetings used in different countries and regions.\n--\n   type Greeter is abstract tagged null record;\n--\n-- The operation that returns the greeting\n--\n   function Greet (Object : Greeter) return String is abstract;\n"})}),"\n",(0,a.jsx)(n.p,{children:"An application should be able to create instances of types derived from the base."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'   type Norddeutschland_Greeter is\n      new PlugIn_API.Greeter with null record;\n   overriding\n      function Greet (Object : Norddeutschland_Greeter) return String is\n         ("Moin!");\n'})}),"\n",(0,a.jsx)(n.p,{children:"The traditional approach would be to write a series of packages containing types derived from Greeter and link them together statically or dynamically."}),"\n",(0,a.jsx)(n.h1,{id:"creating-an-interface",children:"Creating an interface"}),"\n",(0,a.jsx)(n.p,{children:"Now what if the designer of the application does not know anything of Norddeutschland_Greeter in advance. Moreover what if we want to deploy the application and add it later or never? This is where plug-ins come in question. The package implementing Norddeutschland_Greeter is placed in a dynamically linked library which is loaded on demand."}),"\n",(0,a.jsx)(n.p,{children:"The interface of the plug-in package is this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"package Plugin_API is\n\n   PlugIn_Error : exception;\n--\n-- The greeter abstract  base to  be extended by the plug-ins.  The type\n-- represents greetings used in different countries and regions.\n--\n   type Greeter is abstract tagged null record;\n--\n-- The operation that returns the greeting\n--\n   function Greet (Object : Greeter) return String is abstract;\n--\n-- This creates  a greeting object using  Name for  the region name.  It\n-- loads the corresponding plug-in if necessary.\n--\n   function Create (Name : String) return Greeter'Class;\n------------------------------------------------------------------------\n--\n-- The function of the plug-in that creates an instance\n--\n   type Factory is access function return Greeter'Class;\n--\n-- The name of the plug-in entry point to call once after loading\n--\n   PlugIn_Entry_Name : constant String := \"plugin_init\";\n--\n-- The type of the entry point\n--\n   type PlugIn_Entry_Ptr is access function return Factory\n      with Convention => C;\n\nend Plugin_API;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here we added a constructing function Create that takes the plug-in name as the argument and returns an object derived from Greeter of the type declared inside the plug-in. The rest are things for the plug-in implementation. The name of the library entry point to initialize the library and the constructing function that actually does the job."}),"\n",(0,a.jsx)(n.h1,{id:"creating-the-application",children:"Creating the application"}),"\n",(0,a.jsx)(n.p,{children:"Now the application is as simple as this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'with Ada.Text_IO;  use Ada.Text_IO;\nwith PlugIn_API;   use PlugIn_API;\n\nprocedure Plugin_Test is\n   Hello : constant Greeter\'Class := Create ("norddeutschland");\nbegin\n   Put_Line ("Norddeutschland says " & Hello.Greet);\nend Plugin_Test;\n'})}),"\n",(0,a.jsx)(n.p,{children:"Note that it knows nothing about the implementation, just the name of. The project file too refers only to the plug-in interface:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'with "plugin_api.gpr";\nproject Plugin_Test is\n   for Main         use ("plugin_test.adb");\n   for Source_Files use ("plugin_test.adb");\n   for Object_Dir   use "obj";\n   for Exec_Dir     use "bin";\nend Plugin_Test;\n'})}),"\n",(0,a.jsx)(n.p,{children:"The plug-in implementation is encapsulated into a package inside the dynamically loaded library."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'with PlugIn_API;\n\npackage Plugin_Norddeutschland is\n\n   type Norddeutschland_Greeter is\n      new PlugIn_API.Greeter with null record;\n   overriding\n      function Greet (Object : Norddeutschland_Greeter) return String is\n         ("Moin!");\n\nprivate\n   function Init return PlugIn_API.Factory with\n      Export => True, External_Name => "plugin_init";\n\nend Plugin_Norddeutschland;\n'})}),"\n",(0,a.jsx)(n.p,{children:"The package body:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"package body Plugin_Norddeutschland is\n\n   Initialized : Boolean := False;\n\n   function Constructor return PlugIn_API.Greeter'Class is\n   begin\n      return Norddeutschland_Greeter'(PlugIn_API.Greeter with null record);\n   end Constructor;\n\n   function Init return PlugIn_API.Factory is\n      procedure Do_Init;\n      pragma Import (C, Do_Init, \"plugin_norddeutschlandinit\");\n   begin\n      if not Initialized then -- Initialize library\n         Initialized := True;\n         Do_Init;\n      end if;\n      return Constructor'Access;\n   end Init;\n\nend Plugin_Norddeutschland;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The implementation is self-explanatory yet there are some less trivial parts. First, the library is initialized manually. It is necessary because if the library would use tasking automatic initialization might dead-lock. Here I show how to deal with manually initialized library. The project file is:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'with "plugin_api.gpr";\nlibrary project Plugin_Norddeutschland_Build is\n\n   for Library_Name      use "plugin_norddeutschland";\n   for Library_Kind      use "dynamic";\n   for Object_Dir        use "obj";\n   for Library_Dir       use "bin";\n   for Source_Files      use ("plugin_norddeutschland.ads", "plugin_norddeutschland.adb");\n   for Library_Auto_Init use "False";\n   for Library_Interface use ("Plugin_Norddeutschland");\nend Plugin_Norddeutschland_Build;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Take note of Library_Auto_Init and Library_Interface. The latter specifies the Ada package exposed by the library. Init from the package is the function called after the library is loaded. It checks if the library was already initialized and if not, it calls the library initialization code. The code is exposed by the builder as a C function with the name ",(0,a.jsx)(n.code,{children:"<library-name>init"}),". Once initialized it returns the constructing function back."]}),"\n",(0,a.jsx)(n.h2,{id:"plug-in-api-side",children:"Plug-in API side"}),"\n",(0,a.jsx)(n.p,{children:"On the plug-in API side we have:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"with Ada.Containers.Indefinite_Ordered_Maps;\n\npackage body Plugin_API is\n--\n-- Map plugin name -> factory function\n--\n   package Plugin_Maps is\n      new Ada.Containers.Indefinite_Ordered_Maps (String, Factory);\n\n   Loaded : Plugin_Maps.Map;\n\n   function Load (Library_File : String) return Factory is separate;\n\n   function Create (Name : String) return Greeter'Class is\n   begin\n      if not Loaded.Contains (Name) then\n         Loaded.Insert (Name, Load (Name));\n      end if;\n      return Loaded.Element (Name).all;\n   end Create;\n\nend Plugin_API;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Ada.Containers.Indefinite_Ordered_Maps is used to create a map (Loaded) name to constructing function. When not in the map it tries to load the library. The function Load is placed into a separate body to be able to have implementation dependent on the operating system. I provide ",(0,a.jsx)(n.a,{href:"https://github.com/dmitry-kazakov/How-to-create-an-Ada-plug-in",children:"here"})," Windows and Linux implementations. The plug-in project file used to build the API library has the scenario variable Target_OS to select the OS:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:'library project Plugin_API_Build is\n   type OS_Type is ("Windows", "Linux");\n   Target_OS : OS_Type := external ("Target_OS", "Windows");\n\n   for Library_Name use "plugin_api";\n   for Library_Kind use "dynamic";\n   for Object_Dir   use "obj";\n   for Library_Dir  use "bin";\n   for Source_Files use ("plugin_api.ads", "plugin_api.adb", "plugin_api-load.adb");\n   case Target_OS is\n      when "Windows" =>\n         for Source_Dirs use (".", "windows");\n      when "Linux" =>\n         for Source_Dirs use (".", "linux");\n   end case;\nend Plugin_API_Build;\n'})}),"\n",(0,a.jsx)(n.p,{children:"Finally, here is a sequence of building everything together (for Linux):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"gprbuild -XTarget_OS=Linux plugin_api_build.gpr\ngprbuild -XTarget_OS=Linux plugin_test.gpr\ngprbuild -XTarget_OS=Linux plugin_norddeutschland_build.gpr\n"})}),"\n",(0,a.jsx)(n.p,{children:"Now go to the bin subdirectory and run the test:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sh",children:"cd bin\n./plugin_test\n"})}),"\n",(0,a.jsx)(n.p,{children:"You will see:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Norddeutschland says Moin!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["That is all. The full source code can be downloaded ",(0,a.jsx)(n.a,{href:"https://github.com/dmitry-kazakov/How-to-create-an-Ada-plug-in",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h1,{id:"sources",children:"Sources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Repo: ",(0,a.jsx)(n.a,{href:"https://github.com/dmitry-kazakov/How-to-create-an-Ada-plug-in",children:"How-to-create-an-Ada-plug-in"})]}),"\n"]})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);