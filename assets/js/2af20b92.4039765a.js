"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["2945"],{139:function(e,s,i){i.r(s),i.d(s,{frontMatter:()=>l,toc:()=>j,default:()=>m,metadata:()=>n,assets:()=>x,contentTitle:()=>h});var n=JSON.parse('{"id":"arm/AA-H/AA-H.4","title":"H.4. High Integrity Restrictions","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-H/AA-H.4.mdx","sourceDirName":"arm/AA-H","slug":"/arm/AA-H/AA-H.4","permalink":"/docs/arm/AA-H/AA-H.4","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":189,"frontMatter":{"sidebar_position":189},"sidebar":"referenceManualSidebar","previous":{"title":"H.3. Reviewable Object Code","permalink":"/docs/arm/AA-H/AA-H.3"},"next":{"title":"H.5. Pragma Detect_Blocking","permalink":"/docs/arm/AA-H/AA-H.5"}}'),r=i(5893),t=i(65),a=i(3393),o=i(2315);i(8514);var c=i(1927),d=i(6470);let l={sidebar_position:189},h="H.4. High Integrity Restrictions",x={},j=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"H.4.1  Aspect No_Controlled_Parts",id:"h41--aspect-no_controlled_parts",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4}];function p(e){let s={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"h4-high-integrity-restrictions",children:"H.4. High Integrity Restrictions"})}),"\n",(0,r.jsx)(s.admonition,{type:"danger",children:(0,r.jsxs)(s.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.jsx)(s.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,r.jsx)(c.Z,{children:"1/3"}),"\n",(0,r.jsx)(d.Z,{items:["AI05-0299-1"]}),"\n",(0,r.jsxs)("p",{children:["This subclause defines restrictions that can be used with pragma Restrictions (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.12",children:"13.12"}),"); these facilitate the demonstration of program correctness by allowing tailored versions of the run-time system. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"1.a/3"}),(0,r.jsx)(d.Z,{items:["AI05-0005-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Note that the restrictions are absolute. If a partition has 100 library units and just one needs Unchecked","_","Conversion, then the pragma cannot be used to ensure the other 99 units do not use Unchecked","_","Conversion. Note also that these are restrictions on all Ada code within a partition, and therefore it might not be evident from the specification of a package whether a restriction can be imposed.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,r.jsx)(c.Z,{children:"2/2"}),"\n",(0,r.jsx)(d.Z,{items:["AI95-00347-01","AI95-00394-01"]}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"3/2"}),"\n",(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),"\n",(0,r.jsxs)("p",{children:["The following ",(0,r.jsxs)("i",{children:["restriction","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s are language defined:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"4"}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("b",{children:"Tasking-related restriction:"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"5"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Protected","_","Types "]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["There are no declarations of protected types or protected objects. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(c.Z,{children:"6"}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("b",{children:"Memory-management related restrictions:"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"7"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Allocators "]}),"\n",(0,r.jsxs)("dl",{children:[(0,r.jsxs)("dd",{children:["There are no occurrences of an ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})}),".",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"8/1"}),(0,r.jsx)(d.Z,{items:["AI95-00130"]}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"{",(0,r.jsx)("i",{children:"8652/0042"}),"}"," No","_","Local","_","Allocators "]}),(0,r.jsxs)("dd",{children:[(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"Allocator"})}),"s are prohibited in subprograms, generic subprograms, tasks, and entry bodies. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"8.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Thus ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})}),"s are permitted only in expressions whose evaluation can only be performed before the main subprogram is invoked. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"8.b/1"}),(0,r.jsx)(d.Z,{items:["AI95-00130"]}),(0,r.jsxs)(a.Z,{type:"aarm",aarm:"note",children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),"{",(0,r.jsx)("i",{children:"8652/0042"}),"}",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsx)(c.Z,{children:"8.1/3"}),"\n",(0,r.jsx)(d.Z,{items:["AI05-0152-1","AI05-0262-1"]}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Anonymous","_","Allocators "]}),"\n",(0,r.jsxs)("dl",{children:[(0,r.jsxs)("dd",{children:["There are no ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})}),"s of anonymous access types.",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"8.2/3"}),(0,r.jsx)(d.Z,{items:["AI05-0190-1"]}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Coextensions "]}),(0,r.jsxs)("dd",{children:["There are no coextensions. See ",(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.10#Subclause_3.10.2",children:"3.10.2"}),".",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"8.3/3"}),(0,r.jsx)(d.Z,{items:["AI05-0190-1"]}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Access","_","Parameter","_","Allocators "]}),(0,r.jsxs)("dd",{children:[(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"Allocator"})}),"s are not permitted as the actual parameter to an access parameter. See ",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1",children:"6.1"}),".",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"9/2"}),(0,r.jsx)("dt",{children:(0,r.jsx)("br",{})}),(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),(0,r.jsxs)("dd",{children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"10"}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"Immediate","_","Reclamation "]}),(0,r.jsxs)("dd",{children:["Except for storage occupied by objects created by ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})}),"s and not deallocated via unchecked deallocation, any storage reserved at run time for an object is immediately reclaimed when the object no longer exists. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"10.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Immediate reclamation would apply to storage created by the compiler, such as for a return value from a function whose size is not known at the call site. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"11"}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("b",{children:"Exception-related restriction:"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"12/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0344-1"]}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Exceptions "]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:[(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"Raise_statement"})}),"s and ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.2#S0305",children:"exception_handler"})}),"s are not allowed. No language-defined runtime checks are generated; however, a runtime check performed automatically by the hardware is permitted. The callable entity associated with a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.5#S0185",children:"procedural_iterator"})})," (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.5#Subclause_5.5.3",children:"5.5.3"}),") is considered to not allow exit, independent of the value of its Allows","_","Exit aspect.",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"12.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This restriction mirrors a method of working that is quite common in the safety area. The programmer is required to show that exceptions cannot be raised. Then a simplified run-time system is used without exception handling. However, some hardware checks may still be enforced. If the software check would have failed, or if the hardware check actually fails, then the execution of the program is unpredictable. There are obvious dangers in this approach, but it is similar to programming at the assembler level.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"13"}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("b",{children:"Other restrictions:"}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"14"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Floating","_","Point "]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["Uses of predefined floating point types and operations, and declarations of new floating point types, are not allowed. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"14.a/2"}),(0,r.jsx)(d.Z,{items:["AI95-00114-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The intention is to avoid the use of floating point hardware at run time, but this is expressed in language terms. It is conceivable that floating point is used implicitly in some contexts, say fixed point type conversions of high accuracy. However, the Implementation Requirements below make it clear that the restriction would apply to the \u201Crun-time system\u201D and hence not be allowed. This restriction could be used to inform a compiler that a variant of the architecture is being used which does not have floating point instructions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"15"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Fixed","_","Point "]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["Uses of predefined fixed point types and operations, and declarations of new fixed point types, are not allowed. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"15.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This restriction would have the side effect of prohibiting the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.6#S0268",children:"delay_relative_statement"})}),". As with the No","_","Floating","_","Point restriction, this might be used to avoid any question of rounding errors. Unless an Ada run-time is written in Ada, it seems hard to rule out implicit use of fixed point, since at the machine level, fixed point is virtually the same as integer arithmetic.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"16/2"}),"\n",(0,r.jsx)("dt",{children:(0,r.jsx)("br",{})}),"\n",(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),"\n",(0,r.jsxs)("dl",{children:[(0,r.jsxs)("dd",{children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"17"}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Access","_","Subprograms "]}),(0,r.jsxs)("dd",{children:["The declaration of access-to-subprogram types is not allowed. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"17.a.1/2"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Most critical applications would require some restrictions or additional validation checks on uses of access-to-subprogram types. If the application does not require the functionality, then this restriction provides a means of ensuring the design requirement has been satisfied. The same applies to several of the following restrictions, and to restriction No","_","Dependence =",">"," Ada.Unchecked","_","Conversion. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"18"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Unchecked","_","Access "]}),"\n",(0,r.jsxs)("dl",{children:[(0,r.jsxs)("dd",{children:["The Unchecked","_","Access attribute is not allowed.",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"19"}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Dispatch "]}),(0,r.jsxs)("dd",{children:["Occurrences of T'Class are not allowed, for any (tagged) subtype T.",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"20/5"}),(0,r.jsx)(d.Z,{items:["AI95-00285-01","AI12-0318-1"]}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","IO "]}),(0,r.jsxs)("dd",{children:["Semantic dependence on any of the library units Sequential","_","IO, Direct","_","IO, Text","_","IO, Wide","_","Text","_","IO, Wide","_","Wide","_","Text","_","IO, Stream","_","IO, or Directories is not allowed. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"20.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Excluding the input-output facilities of an implementation may be needed in those environments which cannot support the supplied functionality. A program in such an environment is likely to require some low level facilities or a call on a non-Ada feature.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"21"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Delay "]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:[(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.6#S0266",children:"Delay_Statement"})}),"s and semantic dependence on package Calendar are not allowed. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"21.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This implies that ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0274",children:"delay_alternative"})}),"s in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0269",children:"select_statement"})})," are prohibited.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"21.b"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["The purpose of this restriction is to avoid the need for timing facilities within the run-time system.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"22"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Recursion "]}),"\n",(0,r.jsxs)("dl",{children:[(0,r.jsxs)("dd",{children:["As part of the execution of a subprogram, the same subprogram is not invoked.",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23"}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Reentrancy "]}),(0,r.jsxs)("dd",{children:["During the execution of a subprogram by a task, no other task invokes the same subprogram.",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.1/5"}),(0,r.jsx)(d.Z,{items:["AI12-0079-3"]}),(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Unspecified","_","Globals"]}),(0,r.jsxs)("dd",{children:["No library-level entity shall have a Global aspect of Unspecified, either explicitly or by default. No library-level entity shall have a Global'Class aspect of Unspecified, explicitly or by default, if it is used as part of a dispatching call.",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.a/5"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Global'Class need not be specified on an operation if there are no dispatching calls to the operation, or if all of the dispatching calls are covered by ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-H/AA-H.7#S0366",children:"dispatching_operation_specifier"})}),"s for operations with such calls (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-H/AA-H.7",children:"H.7"}),"). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"23.2/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0079-3","AI12-0380-1"]}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Hidden","_","Indirect","_","Globals"]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["When within a context where an applicable global aspect is neither Unspecified nor ",(0,r.jsx)("b",{children:"in out all"}),", any execution within such a context does neither of the following:",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(c.Z,{children:"23.3/5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Update (or return a writable reference to) a variable that is reachable via a sequence of zero or more dereferences of access-to-object values from a parameter of a visibly access-to-constant type, from a part of a non-access-type formal parameter of mode ",(0,r.jsx)("b",{children:"in"})," (after any ",(0,r.jsx)("b",{children:"overriding"})," \u2013 see ",(0,r.jsx)("a",{href:"/docs/arm/AA-H/AA-H.7",children:"H.7"}),"), or from a global that has mode ",(0,r.jsx)("b",{children:"in"})," or is not within the applicable global variable set, unless the initial dereference is of a part of a formal parameter or global that is visibly of an access-to-variable type;",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.4/5"}),(0,r.jsxs)("li",{children:["Read (or return a readable reference to) a variable that is reachable via a sequence of zero or more dereferences of access-to-object values from a global that is not within the applicable global variable set, unless the initial dereference is of a part of a formal parameter or global that is visibly of an access-to-object type. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.b/5"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The above two rules specify that any hidden indirect references are covered by the global or formal parameter modes that apply, and are ",(0,r.jsx)("i",{children:"not"})," subject to alternative paths of access (such as aliasing) that could result in conflicts. On the other hand, any visible access-to-object parts are allowed to designate objects that are accessible via other means, and side-effects on such objects are permitted if the value is visibly of an access-to-variable type. Such effects do not need to be covered by the applicable global aspect(s), but are rather for the caller to worry about. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"23.5/5"}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["For the purposes of the above rules:",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(c.Z,{children:"23.6/5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["a part of an object is ",(0,r.jsx)("i",{children:"visibly of an access type"})," if the type of the object is declared immediately within the visible part of a package specification, and at the point of declaration of the type the part is visible and of an access type;",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.7/5"}),(0,r.jsxs)("li",{children:["a function ",(0,r.jsx)("i",{children:"returns a writable reference to V"})," if it returns a result with a part that is visibly of an access-to-variable type designating ",(0,r.jsx)("i",{children:"V"}),"; similarly, a function ",(0,r.jsx)("i",{children:"returns a readable reference to V"})," if it returns a result with a part that is visibly of an access-to-constant type designating ",(0,r.jsx)("i",{children:"V"}),";",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.8/5"}),(0,r.jsxs)("li",{children:["if an applicable global variable set includes a package name, and the collection of some pool-specific access type (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6#Subclause_7.6.1",children:"7.6.1"}),") is implicitly declared in a part of the declarative region of the package included within the global variable set, then all objects allocated from that collection are considered included within the global variable set. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsx)(c.Z,{children:"23.9/5"}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["The consequences of violating the No","_","Hidden","_","Indirect","_","Globals restriction is implementation-defined. Any aspects or other means for identifying such violations prior to or during execution are implementation-defined. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.b.1/5"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The consequences of violating No","_","Hidden","_","Indirect","_","Globals.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.c/5"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"We do not make violations automatically erroneous, because if the implementation chooses to never fully trust it, there is nothing erroneous that can happen. If an implementation chooses to trust the restriction, and performs some optimization as a result of the restriction, the implementation would define such a violation as erroneous. Such an implementation might also endeavor to detect most violations, perhaps by providing additional aspects, thereby reducing the situations which result in erroneous execution. Implementations might detect some but not all violations of the restrictions. Implementations that completely ignore the restriction should treat the restriction as an unsupported capability of ",(0,r.jsx)("a",{href:"/docs/arm/AA-H/",children:"Annex H"}),", \u201C",(0,r.jsx)("a",{href:"/docs/arm/AA-H/",children:"High Integrity Systems"}),"\u201D. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,r.jsx)(c.Z,{children:"23.10/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0020-1","AI12-0340-1"]}),"\n",(0,r.jsxs)("p",{children:["The following ",(0,r.jsxs)("i",{children:["restriction","_","parameter","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," is language defined:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"23.11/5"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"Max","_","Image","_","Length"]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["Specifies the maximum length for the result of an Image, Wide","_","Image, or Wide","_","Wide","_","Image attribute. Violation of this restriction results in the raising of Program","_","Error at the point of the invocation of an image attribute. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(s.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,r.jsx)(c.Z,{children:"23.12/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),"\n",(0,r.jsxs)("p",{children:["An implementation of this Annex shall support: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"23.13/5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["the restrictions defined in this subclause; and",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.14/5"}),(0,r.jsx)(d.Z,{items:["AI05-0189-1"]}),(0,r.jsxs)("li",{children:["the following restrictions defined in ",(0,r.jsx)("a",{href:"/docs/arm/AA-D/AA-D.7",children:"D.7"}),": No","_","Task","_","Hierarchy, No","_","Abort","_","Statement, No","_","Implicit","_","Heap","_","Allocation, No","_","Standard","_","Allocators","_","After","_","Elaboration; and",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.15/5"}),(0,r.jsx)(d.Z,{items:["AI95-00347-01"]}),(0,r.jsxs)("li",{children:["the ",(0,r.jsx)("b",{children:"pragma"})," Profile(Ravenscar); and ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.d/2"}),(0,r.jsx)(d.Z,{items:["AI95-00347-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The reference to pragma Profile(Ravenscar) is intended to show that properly restricted tasking is appropriate for use in high integrity systems. The Ada 95 Annex seemed to suggest that tasking was inappropriate for such systems. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"23.16/5"}),"\n",(0,r.jsx)("ul",{children:(0,r.jsxs)("li",{children:["the following uses of ",(0,r.jsxs)("i",{children:["restriction","_","parameter","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s defined in ",(0,r.jsx)("a",{href:"/docs/arm/AA-D/AA-D.7",children:"D.7"}),"[, which are checked prior to program execution]: ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(c.Z,{children:"23.17/5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["Max","_","Task","_","Entries =",">"," 0,",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.18/5"}),(0,r.jsxs)("li",{children:["Max","_","Asynchronous","_","Select","_","Nesting =",">"," 0, and",(0,r.jsx)("br",{})]}),(0,r.jsx)(c.Z,{children:"23.19/5"}),(0,r.jsxs)("li",{children:["Max","_","Tasks =",">"," 0. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsx)(c.Z,{children:"23.20/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0020-1","AI12-0340-1"]}),"\n",(0,r.jsxs)("p",{children:["If a Max","_","Image","_","Length restriction applies to any compilation unit in the partition, then for any subtype S, S'Image, S'Wide","_","Image, and S'Wide","_","Wide","_","Image shall be implemented within that partition without any dynamic allocation.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"23.e/5"}),(0,r.jsx)(d.Z,{items:["AI12-0340-1","AI12-0384-2"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This can be accomplished by using an object of the Text","_","Buffers.Bounded.Buffer","_","Type with the maximum characters as specified in the Max","_","Image","_","Length restriction, with a raise of Program","_","Error afterward if Text","_","Truncated (Buf) is True after the call on Put","_","Image (Buf, Arg). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"24/5"}),"\n",(0,r.jsx)(d.Z,{items:["AI05-0263-1","AI05-0272-1","AI12-0308-1"]}),"\n",(0,r.jsxs)("p",{children:["If an implementation supports ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Restrictions for a particular argument, then except for the restrictions No","_","Access","_","Subprograms, No","_","Unchecked","_","Access, No","_","Specification","_","of","_","Aspect, No","_","Use","_","of","_","Attribute, No","_","Use","_","of","_","Pragma, No","_","Dependence =",">"," Ada.Unchecked","_","Conversion, and No","_","Dependence =",">"," Ada.Unchecked","_","Deallocation, the associated restriction applies to the run-time system. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"24.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Permission is granted for the run-time system to use the specified otherwise-restricted features, since the use of these features may simplify the run-time system by allowing more of it to be written in Ada. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"24.b"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The restrictions that are applied to the partition are also applied to the run-time system. For example, if No","_","Floating","_","Point is specified, then an implementation that uses floating point for implementing the delay statement (say) would require that No","_","Floating","_","Point is only used in conjunction with No","_","Delay. It is clearly important that restrictions are effective so that Max","_","Tasks=0 does imply that tasking is not used, even implicitly (for input-output, say).",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"24.c"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["An implementation of tasking could be produced based upon a run-time system written in Ada in which the rendezvous was controlled by protected types. In this case, No","_","Protected","_","Types could only be used in conjunction with Max","_","Task","_","Entries=0. Other implementation dependencies could be envisaged.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"24.d"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["If the run-time system is not written in Ada, then the wording needs to be applied in an appropriate fashion.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"documentation-requirements",children:"Documentation Requirements"}),"\n",(0,r.jsx)(c.Z,{children:"25"}),"\n",(0,r.jsxs)("p",{children:["If a pragma Restrictions(No","_","Exceptions) is specified, the implementation shall document the effects of all constructs where language-defined checks are still performed automatically (for example, an overflow check performed by the processor). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"25.a/2"}),(0,r.jsxs)(a.Z,{type:"aarm",aarm:"note",children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"25.b/2"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{children:"Documentation Requirement: "}),"If a pragma Restrictions(No","_","Exceptions) is specified, the effects of all constructs where language-defined checks are still performed.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"25.c/2"}),(0,r.jsx)(d.Z,{items:["AI95-00114-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The documentation requirements here are quite difficult to satisfy. One method is to review the object code generated and determine the checks that are still present, either explicitly, or implicitly within the architecture. As another example from that of overflow, consider the question of dereferencing a null pointer. This could be undertaken by a memory access trap when checks are performed. When checks are suppressed via the argument No","_","Exceptions, it would not be necessary to have the memory access trap mechanism enabled.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"erroneous-execution",children:"Erroneous Execution"}),"\n",(0,r.jsx)(c.Z,{children:"26"}),"\n",(0,r.jsxs)("p",{children:["Program execution is erroneous if pragma Restrictions(No","_","Exceptions) has been specified and the conditions arise under which a generated language-defined runtime check would fail. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"26.a"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The situation here is very similar to the application of pragma Suppress. Since users are removing some of the protection the language provides, they had better be careful!",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"27"}),"\n",(0,r.jsxs)("p",{children:["Program execution is erroneous if pragma Restrictions(No","_","Recursion) has been specified and a subprogram is invoked as part of its own execution, or if pragma Restrictions(No","_","Reentrancy) has been specified and during the execution of a subprogram by a task, another task invokes the same subprogram. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"27.a/3"}),(0,r.jsx)(d.Z,{items:["AI05-0005-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"In practice, many implementations might not exploit the absence of recursion or need for reentrancy, in which case the program execution would be unaffected by the use of recursion or reentrancy, even though the program is still formally erroneous.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"27.b/2"}),(0,r.jsxs)(a.Z,{type:"aarm",aarm:"note",children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28/5"}),(0,r.jsx)(d.Z,{items:["AI95-00394-01","AI12-0440-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["NOTE   Uses of ",(0,r.jsxs)("i",{children:["restriction","_","parameter","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," No","_","Dependence defined in ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.12#Subclause_13.12.1",children:"13.12.1"}),": No","_","Dependence =",">"," Ada.Unchecked","_","Deallocation and No","_","Dependence =",">"," Ada.Unchecked","_","Conversion can be appropriate for high-integrity systems. Other uses of No","_","Dependence can also be appropriate for high-integrity systems. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.a/2"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The specific mention of these two uses is meant to replace the identifiers now banished to ",(0,r.jsx)("a",{href:"/docs/arm/AA-J/AA-J.13",children:"J.13"}),", \u201C",(0,r.jsx)("a",{href:"/docs/arm/AA-J/AA-J.13",children:"Dependence Restriction Identifiers"}),"\u201D.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.b/2"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restriction No","_","Dependence =",">"," Ada.Unchecked","_","Deallocation would be useful in those contexts in which heap storage is needed on program start-up, but need not be increased subsequently. The danger of a dangling pointer can therefore be avoided. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.c/2"}),(0,r.jsx)(d.Z,{items:["AI95-00130-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["{",(0,r.jsx)("i",{children:"8652/0042"}),"}"," No","_","Local","_","Allocators no longer prohibits generic instantiations. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.d/2"}),(0,r.jsx)(d.Z,{items:["AI95-00285-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Wide","_","Wide","_","Text","_","IO (which is new) is added to the No","_","IO restriction.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.e/3"}),(0,r.jsx)(d.Z,{items:["AI95-00347-01","AI05-0299-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["The title of this subclause was changed to match the change to the Annex title. Pragma Profile(Ravenscar) is part of this annex.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.f/2"}),(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restriction No","_","Dependence is used instead of special ",(0,r.jsxs)("i",{children:["restriction","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s. The old names are banished to Obsolescent Features (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-J/AA-J.13",children:"J.13"}),").",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.g/2"}),(0,r.jsx)(d.Z,{items:["AI95-00394-01"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["The bizarre wording \u201Capply in this Annex\u201D (which no one quite can explain the meaning of) is banished. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.h/3"}),(0,r.jsx)(d.Z,{items:["AI05-0152-1","AI05-0190-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restrictions No","_","Anonymous","_","Allocators, No","_","Coextensions, and No","_","Access","_","Parameter","_","Allocators are new. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.i/3"}),(0,r.jsx)(d.Z,{items:["AI05-0189-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["New restriction No","_","Standard","_","Allocators","_","After","_","Elaboration is added to the list of restrictions that are required by this annex.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.j/3"}),(0,r.jsx)(d.Z,{items:["AI05-0263-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{})," Ada 2005 restriction No","_","Dependence is added where needed (this was missed in Ada 2005).",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.k/3"}),(0,r.jsx)(d.Z,{items:["AI05-0272-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restrictions against individual aspects, pragmas, and attributes do not apply to the run-time system, in order that an implementation can use whatever aspects, pragmas, and attributes are needed to do the job. For instance, attempting to write a run-time system for Linux that does not use the Import aspect would be very difficult and probably is not what the user is trying to prevent anyway. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"incompatibilities-with-ada-2012",children:"Incompatibilities With Ada 2012"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.l/5"}),(0,r.jsx)(d.Z,{items:["AI12-0318-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{})," Restriction No","_","IO now excludes use of Ada.Directories. If a program using No","_","IO used Ada.Directories, it would be legal in Ada 2012 and illegal in Ada 2022. However, given the role of Ada.Directories as a support package for the other packages that are excluded by No","_","IO, it seems unlikely that any use of the restriction would use this package (and it's possible that implementations wouldn't support its use with No","_","IO anyway). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"extensions-to-ada-2012",children:"Extensions to Ada 2012"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.m/5"}),(0,r.jsx)(d.Z,{items:["AI12-0020-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restriction Max","_","Image","_","Length is new.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"28.n/5"}),(0,r.jsx)(d.Z,{items:["AI12-0079-3"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Restrictions No","_","Unspecified","_","Globals and No","_","Hidden","_","Indirect","_","Globals are new. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_H.4.1"}),"\n",(0,r.jsx)(s.h2,{id:"h41--aspect-no_controlled_parts",children:"H.4.1  Aspect No_Controlled_Parts"}),"\n",(0,r.jsx)(s.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,r.jsx)(c.Z,{children:"1/5_H.4.1"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0256-1","AI12-0403-1"]}),"\n",(0,r.jsxs)("p",{children:["For a type, the following type-related, operational aspect may be specified:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.Z,{children:"2/5_H.4.1"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"No","_","Controlled","_","Parts"]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["The type of this aspect is Boolean. If True, the type and any descendants shall not have any controlled parts. If specified, the value of the expression shall be static. If not specified, the value of this aspect is False.",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"2.a/5_H.4.1"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{children:"Aspect Description for "}),(0,r.jsxs)("b",{children:["No","_","Controlled","_","Parts: "]}),"A specification that a type and its descendants do not have controlled parts.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"3/5_H.4.1"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0256-1"]}),"\n",(0,r.jsxs)("p",{children:["The No","_","Controlled","_","Parts aspect is nonoverridable (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"}),").",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"3.a/5_H.4.1"}),(0,r.jsx)(d.Z,{items:["AI12-0407-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Since this is a Boolean-valued aspect, the blanket restrictions defined by ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#Subclause_13.1.1",children:"13.1.1"})," apply to the specification of Boolean-valued aspects on descendants of types with such aspects. But we still need rules about inheritance from progenitors and about hiding the aspect; it would be too painful to repeat those rules here (and have future maintenance fixes not get applied to this aspect). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,r.jsx)(c.Z,{children:"4/5_H.4.1"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0256-1","AI12-0407-1"]}),"\n",(0,r.jsxs)("p",{children:["If No","_","Controlled","_","Parts is True for a type, no component of the type shall have a controlled part nor shall the type itself be controlled. For the purposes of this rule, a type has a controlled part if its full type has a controlled part; this is applied recursively. In addition to the places where Legality Rules normally apply (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3",children:"12.3"}),"), this rule also applies in the private part of an instance of a generic unit.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"4.a/5_H.4.1"}),(0,r.jsx)(d.Z,{items:["AI12-0407-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This check breaks privacy by looking at the full definition of all of the types involved. This is more like a representation aspect than an operational aspect, but representation aspects are not allowed on partial views and we need this aspect to be visible to clients. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:"5/5_H.4.1"}),"\n",(0,r.jsx)(d.Z,{items:["AI12-0256-1","AI12-0407-1"]}),"\n",(0,r.jsxs)("p",{children:["When enforcing the above rule within a generic body ",(0,r.jsx)("i",{children:"G"})," or within the body of a generic unit declared within the declarative region of generic unit ",(0,r.jsx)("i",{children:"G"}),", a generic formal private type of ",(0,r.jsx)("i",{children:"G"})," and a generic formal derived type of ",(0,r.jsx)("i",{children:"G"})," whose ancestor is a tagged type whose No","_","Controlled","_","Parts aspect is False are considered to have a controlled part.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"5.a/5_H.4.1"}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This is a typical generic assume-the-worst rule. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"5.b/5_H.4.1"}),(0,r.jsx)(d.Z,{items:["AI12-0407-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"If the ancestor of the generic derived type is class-wide, the aspect in question belongs to the specific type associated with the class-wide type. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsx)(s.h4,{id:"extensions-to-ada-2012-1",children:"Extensions to Ada 2012"})}),"\n",(0,r.jsxs)(o.Z,{children:[(0,r.jsx)(c.Z,{children:"5.c/5_H.4.1"}),(0,r.jsx)(d.Z,{items:["AI12-0256-1","AI12-0407-1"]}),(0,r.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Aspect No","_","Controlled","_","Parts is new. ",(0,r.jsx)("br",{})]})})]})]})}function m(e={}){let{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);