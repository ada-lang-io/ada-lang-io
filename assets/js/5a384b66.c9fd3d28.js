"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["2603"],{5938:function(e,n,i){i.r(n),i.d(n,{frontMatter:()=>s,toc:()=>d,default:()=>h,metadata:()=>r,assets:()=>o,contentTitle:()=>l});var r=JSON.parse('{"id":"style-guide/s5/05","title":"5.5 Expressions","description":"Properly coded expressions can enhance the readability and","source":"@site/docs/style-guide/s5/05.mdx","sourceDirName":"style-guide/s5","slug":"/style-guide/s5/05","permalink":"/docs/style-guide/s5/05","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"5.5 Expressions"},"sidebar":"styleGuideSidebar","previous":{"title":"5.4 Data Structures","permalink":"/docs/style-guide/s5/04"},"next":{"title":"5.6 Statements","permalink":"/docs/style-guide/s5/06"}}'),t=i(5893),a=i(65);let s={title:"5.5 Expressions"},l=void 0,o={},d=[{value:"Range Values",id:"range-values",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"caution",id:"caution",level:4},{value:"Array Attributes",id:"array-attributes",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Parenthetical Expressions",id:"parenthetical-expressions",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Positive Forms of Logic",id:"positive-forms-of-logic",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Short Circuit Forms of the Logical Operators",id:"short-circuit-forms-of-the-logical-operators",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"notes",id:"notes",level:4},{value:"Accuracy of Operations With Real Operands",id:"accuracy-of-operations-with-real-operands",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-1",level:4},{value:"exceptions",id:"exceptions-1",level:4}];function c(e){let n={code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Properly coded expressions can enhance the readability and\nunderstandability of a program. Poorly coded expressions can turn a\nprogram into a maintainer's nightmare."}),"\n",(0,t.jsx)(n.h3,{id:"range-values",children:"Range Values"}),"\n",(0,t.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"'First"})," or ",(0,t.jsx)(n.code,{children:"'Last"})," instead of numeric literals to represent the\nfirst or last values of a range."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"'Range"})," or the subtype name of the range instead of ",(0,t.jsx)(n.code,{children:"'First .. 'Last"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"type Temperature      is range All_Time_Low .. All_Time_High;\ntype Weather_Stations is range            1 ..  Max_Stations;\nCurrent_Temperature : Temperature := 60;\nOffset              : Temperature;\n...\nfor I in Weather_Stations loop\nOffset := Current_Temperature - Temperature'First;\n...\nend loop;"}),"\n",(0,t.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, it is better to use ",(0,t.jsx)(n.code,{children:"Weather_Stations"})," in the\n",(0,t.jsx)(n.code,{children:"for"})," loop than to use ",(0,t.jsx)(n.code,{children:"Weather_Stations'First"})," ",(0,t.jsx)(n.code,{children:".. Weather_Stations'Last"})," or ",(0,t.jsx)(n.code,{children:"1 .. Max_Stations"})," because it is clearer,\nless error-prone, and less dependent on the definition of the type\n",(0,t.jsx)(n.code,{children:"Weather_Stations"}),". Similarly, it is better to use ",(0,t.jsx)(n.code,{children:"Temperature'First"}),"\nin the offset calculation than to use ",(0,t.jsx)(n.code,{children:"All_Time_Low"})," because the code\nwill still be correct if the definition of the subtype ",(0,t.jsx)(n.code,{children:"Temperature"})," is\nchanged. This enhances program reliability."]}),"\n",(0,t.jsx)(n.h4,{id:"caution",children:"caution"}),"\n",(0,t.jsx)(n.p,{children:"When you implicitly specify ranges and attributes like this, be careful\nthat you use the correct subtype name. It is easy to refer to a very\nlarge range without realizing it. For example, given the declarations:"}),"\n",(0,t.jsx)(n.p,{children:"type    Large_Range is new Integer;\nsubtype Small_Range is Large_Range range 1 .. 10;"}),"\n",(0,t.jsx)(n.p,{children:"type Large_Array is array (Large_Range) of Integer;\ntype Small_Array is array (Small_Range) of Integer;"}),"\n",(0,t.jsx)(n.p,{children:"then the first declaration below works fine, but the second one is\nprobably an accident and raises an exception on most machines because it\nis requesting a huge array (indexed from the smallest integer to the\nlargest one):"}),"\n",(0,t.jsx)(n.p,{children:"Array_1 : Small_Array;\nArray_2 : Large_Array;"}),"\n",(0,t.jsx)(n.h3,{id:"array-attributes",children:"Array Attributes"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use array attributes ",(0,t.jsx)(n.code,{children:"'First"}),", ",(0,t.jsx)(n.code,{children:"'Last"}),", or ",(0,t.jsx)(n.code,{children:"'Length"})," instead of\nnumeric literals for accessing arrays."]}),"\n",(0,t.jsxs)(n.li,{children:["Use the ",(0,t.jsx)(n.code,{children:"'Range"})," of the array instead of the name of the index\nsubtype to express a range."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"'Range"})," instead of ",(0,t.jsx)(n.code,{children:"'First .. 'Last"})," to express a range."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"subtype Name_String is String (1 .. Name_Length);\nFile_Path : Name_String := (others => ' ');\n...\nfor I in File_Path'Range loop\n...\nend loop;"}),"\n",(0,t.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, it is better to use ",(0,t.jsx)(n.code,{children:"Name_String'Range"})," in the\n",(0,t.jsx)(n.code,{children:"for"})," loop than to use ",(0,t.jsx)(n.code,{children:"Name_String_Size"}),", ",(0,t.jsx)(n.code,{children:"Name_String'First .. Name_String'Last"}),", or ",(0,t.jsx)(n.code,{children:"1 .. 30"})," because it is clearer, less error-prone,\nand less dependent on the definitions of ",(0,t.jsx)(n.code,{children:"Name_String"})," and\n",(0,t.jsx)(n.code,{children:"Name_String_Size"}),". If ",(0,t.jsx)(n.code,{children:"Name_String"})," is changed to have a different\nindex type or if the bounds of the array are changed, this will still\nwork correctly. This enhances program reliability."]}),"\n",(0,t.jsx)(n.h3,{id:"parenthetical-expressions",children:"Parenthetical Expressions"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use parentheses to specify the order of subexpression evaluation to\nclarify expressions (NASA 1987 )."}),"\n",(0,t.jsx)(n.li,{children:"Use parentheses to specify the order of evaluation for\nsubexpressions whose correctness depends on left to right\nevaluation."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-2",children:"example"}),"\n",(0,t.jsxs)(n.p,{children:["(1.5 * X**2)/A - (6.5",(0,t.jsx)(n.em,{children:"X + 47.0)\n2"}),"I + 4",(0,t.jsx)(n.em,{children:"Y + 8"}),"Z + C"]}),"\n",(0,t.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"The Ada rules of operator precedence are defined in the Ada Reference\nManual (1995, \xa74.5) and follow the same commonly accepted precedence of\nalgebraic operators. The strong typing facility in Ada combined with the\ncommon precedence rules make many parentheses unnecessary. However, when\nan uncommon combination of operators occurs, it may be helpful to add\nparentheses even when the precedence rules apply. The expression:"}),"\n",(0,t.jsx)(n.p,{children:"5 + ((Y ** 3) mod 10)"}),"\n",(0,t.jsx)(n.p,{children:"is clearer, and equivalent to:"}),"\n",(0,t.jsx)(n.p,{children:"5 + Y**3 mod 10"}),"\n",(0,t.jsx)(n.p,{children:"The rules of evaluation do specify left to right evaluation for\noperators with the same precedence level. However, it is the most\ncommonly overlooked rule of evaluation when checking expressions for\ncorrectness."}),"\n",(0,t.jsx)(n.h3,{id:"positive-forms-of-logic",children:"Positive Forms of Logic"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-3",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Avoid names and constructs that rely on the use of negatives."}),"\n",(0,t.jsx)(n.li,{children:"Choose names of flags so they represent states that can be used in\npositive form."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-3",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"Use:"}),"\n",(0,t.jsx)(n.p,{children:"if Operator_Missing then"}),"\n",(0,t.jsx)(n.p,{children:"rather than either:"}),"\n",(0,t.jsx)(n.p,{children:"if not Operator_Found then"}),"\n",(0,t.jsx)(n.p,{children:"or:"}),"\n",(0,t.jsx)(n.p,{children:"if not Operator_Missing then"}),"\n",(0,t.jsx)(n.h4,{id:"rationale-3",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"Relational expressions can be more readable and understandable when\nstated in a positive form. As an aid in choosing the name, consider that\nthe most frequently used branch in a conditional construct should be\nencountered first."}),"\n",(0,t.jsx)(n.h4,{id:"exceptions",children:"exceptions"}),"\n",(0,t.jsx)(n.p,{children:"There are cases in which the negative form is unavoidable. If the\nrelational expression better reflects what is going on in the code, then\ninverting the test to adhere to this guideline is not recommended."}),"\n",(0,t.jsx)(n.h3,{id:"short-circuit-forms-of-the-logical-operators",children:"Short Circuit Forms of the Logical Operators"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-4",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use short-circuit forms of the logical operators to specify the\norder of conditions when the failure of one condition means that the\nother condition will raise an exception."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-4",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"Use:"}),"\n",(0,t.jsx)(n.p,{children:"if Y /= 0 or else (X/Y) /= 10 then"}),"\n",(0,t.jsx)(n.p,{children:"or:"}),"\n",(0,t.jsx)(n.p,{children:"if Y /= 0 then\nif (X/Y) /= 10 then"}),"\n",(0,t.jsx)(n.p,{children:"rather than either:"}),"\n",(0,t.jsx)(n.p,{children:"if Y /= 0 and (X/Y) /= 10 then"}),"\n",(0,t.jsx)(n.p,{children:"or:"}),"\n",(0,t.jsx)(n.p,{children:"if (X/Y) /= 10 then"}),"\n",(0,t.jsxs)(n.p,{children:["to avoid ",(0,t.jsx)(n.code,{children:"Constraint_Error."})]}),"\n",(0,t.jsx)(n.p,{children:"Use:"}),"\n",(0,t.jsx)(n.p,{children:"if Target /= null and then Target.Distance < Threshold then"}),"\n",(0,t.jsx)(n.p,{children:"rather than:"}),"\n",(0,t.jsx)(n.p,{children:"if Target.Distance < Threshold then"}),"\n",(0,t.jsx)(n.p,{children:"to avoid referencing a field in a nonexistent object."}),"\n",(0,t.jsx)(n.h4,{id:"rationale-4",children:"rationale"}),"\n",(0,t.jsxs)(n.p,{children:["The use of short-circuit control forms prevents a class of\ndata-dependent errors or exceptions that can occur as a result of\nexpression evaluation. The short-circuit forms guarantee an order of\nevaluation and an ",(0,t.jsx)(n.code,{children:"exit"})," from the sequence of relational expressions as\nsoon as the expression's result can be determined."]}),"\n",(0,t.jsxs)(n.p,{children:["In the absence of short-circuit forms, Ada does not provide a guarantee\nof the order of expression evaluation, nor does the language guarantee\nthat evaluation of a relational expression is abandoned when it becomes\nclear that it evaluates to ",(0,t.jsx)(n.code,{children:"False"})," (for ",(0,t.jsx)(n.code,{children:"and"}),") or ",(0,t.jsx)(n.code,{children:"True"})," (for ",(0,t.jsx)(n.code,{children:"or"}),")."]}),"\n",(0,t.jsx)(n.h4,{id:"notes",children:"notes"}),"\n",(0,t.jsx)(n.p,{children:"If it is important that all parts of a given expression always be\nevaluated, the expression probably violates Guideline 4.1.4 , which\nlimits side-effects in functions."}),"\n",(0,t.jsx)(n.h3,{id:"accuracy-of-operations-with-real-operands",children:"Accuracy of Operations With Real Operands"}),"\n",(0,t.jsx)(n.h4,{id:"guideline-5",children:"guideline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"<="})," and ",(0,t.jsx)(n.code,{children:">="})," in relational expressions with real operands\ninstead of ",(0,t.jsx)(n.code,{children:"="}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-5",children:"example"}),"\n",(0,t.jsx)(n.p,{children:"Current_Temperature   : Temperature :=       0.0;\nTemperature_Increment : Temperature := 1.0 / 3.0;\nMaximum_Temperature   : constant    :=     100.0;\n...\nloop\n...\nCurrent_Temperature :=\nCurrent_Temperature + Temperature_Increment;\n...\nexit when Current_Temperature >= Maximum_Temperature;\n...\nend loop;"}),"\n",(0,t.jsx)(n.h4,{id:"rationale-5",children:"rationale"}),"\n",(0,t.jsx)(n.p,{children:"Fixed- and floating-point values, even if derived from similar\nexpressions, may not be exactly equal. The imprecise, finite\nrepresentations of real numbers in hardware always have round-off errors\nso that any variation in the construction path or history of two real\nnumbers has the potential for resulting in different numbers, even when\nthe paths or histories are mathematically equivalent."}),"\n",(0,t.jsxs)(n.p,{children:["The Ada definition of model intervals also means that the use of ",(0,t.jsx)(n.code,{children:"<="})," is\nmore portable than either ",(0,t.jsx)(n.code,{children:"<"})," or ",(0,t.jsx)(n.code,{children:"="}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"notes-1",children:"notes"}),"\n",(0,t.jsx)(n.p,{children:"Floating-point arithmetic is treated in Guideline 7.2.7 ."}),"\n",(0,t.jsx)(n.h4,{id:"exceptions-1",children:"exceptions"}),"\n",(0,t.jsxs)(n.p,{children:["If your application must test for an exact value of a real number (e.g.,\ntesting the precision of the arithmetic on a certain machine), then the\n",(0,t.jsx)(n.code,{children:"="})," would have to be used. But never use ",(0,t.jsx)(n.code,{children:"="})," on real operands as a\ncondition to exit a loop ."]})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);