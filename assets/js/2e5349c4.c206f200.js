"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["2637"],{8128:function(e,s,n){n.r(s),n.d(s,{frontMatter:()=>h,toc:()=>j,default:()=>p,metadata:()=>a,assets:()=>m,contentTitle:()=>x});var a=JSON.parse('{"id":"arm/AA-13/AA-13.8","title":"13.8. Machine Code Insertions","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-13/AA-13.8.mdx","sourceDirName":"arm/AA-13","slug":"/arm/AA-13/AA-13.8","permalink":"/docs/arm/AA-13/AA-13.8","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":112,"frontMatter":{"sidebar_position":112},"sidebar":"referenceManualSidebar","previous":{"title":"13.7. The Package System","permalink":"/docs/arm/AA-13/AA-13.7"},"next":{"title":"13.9. Unchecked Type Conversions","permalink":"/docs/arm/AA-13/AA-13.9"}}'),r=n(5893),i=n(65),d=n(3393),c=n(2315),o=n(8514),t=n(1927),l=n(6470);let h={sidebar_position:112},x="13.8. Machine Code Insertions",m={},j=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4}];function A(e){let s={a:"a",admonition:"admonition",h1:"h1",h4:"h4",header:"header",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"138-machine-code-insertions",children:"13.8. Machine Code Insertions"})}),"\n",(0,r.jsx)(s.admonition,{type:"danger",children:(0,r.jsxs)(s.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.jsx)(s.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,r.jsx)(t.Z,{children:"1"}),"\n",(0,r.jsxs)("p",{children:["[ A machine code insertion can be achieved by a call to a subprogram whose ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," contains ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s.] ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(s.h4,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(t.Z,{children:"2"}),"\n",(0,r.jsx)(o.Z,{children:(0,r.jsxs)(s.p,{children:[(0,r.jsxs)("code",{children:["code","_","statement"]}),(0,r.jsx)("a",{id:"S0357"}),(0,r.jsx)("code",{children:" ::= "}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})}),";",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsx)(t.Z,{children:"3"}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," is only allowed in the ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-11/AA-11.2#S0304",children:["handled","_","sequence","_","of","_","statements"]})})," of a ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})}),". If a ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})})," contains any ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:["code","_","statement"]})}),"s, then within this ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})})," the only allowed form of ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0167",children:"statement"})})," is a ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:["code","_","statement"]})})," (labeled or not), the only allowed ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.11#S0087",children:["declarative","_","item"]})}),"s are ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:["use","_","clause"]})}),"s, and no ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-11/AA-11.2#S0305",children:["exception","_","handler"]})})," is allowed (",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),"s and ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})}),"s are allowed as usual). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(s.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,r.jsx)(t.Z,{children:"4"}),"\n",(0,r.jsxs)("p",{children:["The ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," is expected to be of any type. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(s.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,r.jsx)(t.Z,{children:"5"}),"\n",(0,r.jsxs)("p",{children:["The ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," shall be of a type declared in package System.Machine","_","Code. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"5.a"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"This includes types declared in children of System.Machine","_","Code. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(t.Z,{children:"6"}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," shall appear only within the scope of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0294",children:"with_clause"})})," that mentions package System.Machine","_","Code. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"6.a"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"Note that this is not a note; without this rule, it would be possible to write machine code in compilation units which depend on System.Machine","_","Code only indirectly. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,r.jsx)(t.Z,{children:"7"}),"\n",(0,r.jsxs)("p",{children:["The contents of the library package System.Machine","_","Code (if provided) are implementation defined. The meaning of ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s is implementation defined. [Typically, each ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," represents a machine instruction or assembly directive.] ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"7.a"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"For example, an instruction might be a record with an Op","_","Code component and other components for the operands. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"7.b"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The contents of the visible part of package System.Machine","_","Code, and the meaning of ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,r.jsx)(t.Z,{children:"8"}),"\n",(0,r.jsxs)("p",{children:["An implementation may place restrictions on ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s. An implementation is not required to provide package System.Machine","_","Code. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"9/5"}),(0,r.jsx)(l.Z,{items:["AI12-0440-1"]}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["NOTE 1   An implementation can provide implementation-defined pragmas specifying register conventions and calling conventions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"10/2"}),(0,r.jsx)(l.Z,{items:["AI95-00318-02"]}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["NOTE 2   Machine code functions are exempt from the rule that a return statement is required. In fact, return statements are forbidden, since only ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s are allowed. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"10.a"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(s.p,{children:[(0,r.jsx)("b",{}),"The idea is that the author of a machine code subprogram knows the calling conventions, and refers to parameters and results accordingly. The implementation should document where to put the result of a machine code function, for example, \u201CScalar results are returned in register 0\u201D. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"11"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["NOTE 3   Intrinsic subprograms (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.3#Subclause_6.3.1",children:"6.3.1"}),", \u201C",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.3#Subclause_6.3.1",children:"Conformance Rules"}),"\u201D) can also be used to achieve machine code insertions. Interface to assembly language can be achieved using the features in ",(0,r.jsx)("a",{href:"/docs/arm/AA-B/",children:"Annex B"}),", \u201C",(0,r.jsx)("a",{href:"/docs/arm/AA-B/",children:"Interface to Other Languages"}),"\u201D. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(s.h4,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(t.Z,{children:"12"}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("i",{children:"Example of a code statement:"})," ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(t.Z,{children:"13/3"}),"\n",(0,r.jsx)(l.Z,{items:["AI05-0229-1"]}),"\n",(0,r.jsx)(o.Z,{language:"ada",children:(0,r.jsxs)(s.p,{children:["M : Mask;","\n","procedure Set","_","Mask","\n","  with Inline;","\n","\n",(0,r.jsx)(t.Z,{children:"14"}),"\nprocedure Set","_","Mask is","\n","  use System.Machine","_","Code; -- assume \u201Cwith System.Machine","_","Code;\u201D appears somewhere above","\n","begin","\n","  SI","_","Format'(Code =",">"," SSM, B =",">"," M'Base","_","Reg, D =",">"," M'Disp);","\n","  --  Base","_","Reg and Disp are implementation-defined attributes","\n","end Set","_","Mask;","\n"]})}),"\n",(0,r.jsx)(c.Z,{children:(0,r.jsx)(s.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"14.a"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["Machine code functions are allowed in Ada 95; in Ada 83, only procedures were allowed. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.Z,{children:(0,r.jsx)(s.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,r.jsxs)(c.Z,{children:[(0,r.jsx)(t.Z,{children:"14.b"}),(0,r.jsx)(d.Z,{type:"aarm",aarm:"note",children:(0,r.jsxs)(s.p,{children:["The syntax for ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," is changed to say \u201C",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})}),"\u201D instead of \u201C",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),"'",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.3#S0107",children:"record_aggregate"})}),"\u201D. Requiring the type of each instruction to be a record type is overspecification. ",(0,r.jsx)("br",{})]})})]})]})}function p(e={}){let{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(A,{...e})}):A(e)}}}]);