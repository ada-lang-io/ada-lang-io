"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[678],{5191:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"style-guide/s5/08","title":"5.8 Using exceptions","description":"Ada exceptions are a reliability-enhancing language feature designed to","source":"@site/docs/style-guide/s5/08.mdx","sourceDirName":"style-guide/s5","slug":"/style-guide/s5/08","permalink":"/docs/style-guide/s5/08","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"5.8 Using exceptions"},"sidebar":"styleGuideSidebar","previous":{"title":"5.7 Visibility","permalink":"/docs/style-guide/s5/07"},"next":{"title":"5.9 Erroneous execution and bounded errors","permalink":"/docs/style-guide/s5/09"}}');var o=t(4848),a=t(8453);const r={title:"5.8 Using exceptions"},s=void 0,d={},l=[{value:"Handling Versus Avoiding Exceptions",id:"handling-versus-avoiding-exceptions",level:3},{value:"guideline",id:"guideline",level:4},{value:"rationale",id:"rationale",level:4},{value:"Handlers for Others",id:"handlers-for-others",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Propagation",id:"propagation",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Localizing the Cause of an Exception",id:"localizing-the-cause-of-an-exception",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-1",level:4}];function c(e){const n={a:"a",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Ada exceptions are a reliability-enhancing language feature designed to\nhelp specify program behavior in the presence of errors or unexpected\nevents. Exceptions are not intended to provide a general purpose control\nconstruct. Further, liberal use of exceptions should not be considered\nsufficient for providing full software fault tolerance (Melliar-Smith\nand Randell 1987)."}),"\n",(0,o.jsx)(n.p,{children:"This section addresses the issues of how and when to avoid raising\nexceptions, how and where to handle them, and whether to propagate them.\nInformation on how to use exceptions as part of the interface to a unit\nincludes what exceptions to declare and raise and under what conditions\nto raise them. Other issues are addressed in the guidelines in Sections\n4.3 and 7.5."}),"\n",(0,o.jsx)(n.h3,{id:"handling-versus-avoiding-exceptions",children:"Handling Versus Avoiding Exceptions"}),"\n",(0,o.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When it is easy and efficient to do so, avoid causing exceptions to\nbe raised."}),"\n",(0,o.jsx)(n.li,{children:"Provide handlers for exceptions that cannot be avoided."}),"\n",(0,o.jsx)(n.li,{children:"Use exception handlers to enhance readability by separating fault\nhandling from normal execution."}),"\n",(0,o.jsxs)(n.li,{children:["Do not use exceptions and exception handlers as ",(0,o.jsx)(n.code,{children:"goto"})," statements."]}),"\n",(0,o.jsx)(n.li,{children:"Do not evaluate the value of an object (or a part of an object) that\nhas become abnormal because of the failure of a language-defined\ncheck."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,o.jsxs)(n.p,{children:["In many cases, it is possible to detect easily and efficiently that an\noperation you are about to perform would raise an exception. In such a\ncase, it is a good idea to check rather than allowing the exception to\nbe raised and handling it with an exception handler. For example, check\neach pointer for ",(0,o.jsx)(n.code,{children:"null"})," when traversing a linked list of records\nconnected by pointers. Also, test an integer for 0 before dividing by\nit, and call an interrogative function ",(0,o.jsx)(n.code,{children:"Stack_Is_Empty"})," before invoking\nthe ",(0,o.jsx)(n.code,{children:"pop"})," procedure of a stack package. Such tests are appropriate when\nthey can be performed easily and efficiently as a natural part of the\nalgorithm being implemented."]}),"\n",(0,o.jsxs)(n.p,{children:["However, error detection in advance is not always so simple. There are\ncases where such a test is too expensive or too unreliable. In such\ncases, it is better to attempt the operation within the scope of an\nexception handler so that the exception is handled if it is raised. For\nexample, in the case of a linked list implementation of a list, it is\nvery inefficient to call a function ",(0,o.jsx)(n.code,{children:"Entry_Exists"})," before each call to\nthe procedure ",(0,o.jsx)(n.code,{children:"Modify_Entry"})," simply to avoid raising the exception\n",(0,o.jsx)(n.code,{children:"Entry_Not_Found"}),". It takes as much time to search the list to avoid the\nexception as it takes to search the list to perform the update.\nSimilarly, it is much easier to attempt a division by a real number\nwithin the scope of an exception handler to handle numeric overflow than\nto test, in advance, whether the dividend is too large or the divisor\ntoo small for the quotient to be representable on the machine."]}),"\n",(0,o.jsx)(n.p,{children:"In concurrent situations, tests done in advance can also be unreliable.\nFor example, if you want to modify an existing file on a multiuser\nsystem, it is safer to attempt to do so within the scope of an exception\nhandler than to test in advance whether the file exists, whether it is\nprotected, whether there is room in the file system for the file to be\nenlarged, etc. Even if you tested for all possible error conditions,\nthere is no guarantee that nothing would change after the test and\nbefore the modification operation. You still need the exception\nhandlers, so the advance testing serves no purpose."}),"\n",(0,o.jsxs)(n.p,{children:["Whenever such a case does not apply, normal and predictable events\nshould be handled by the code without the abnormal transfer of control\nrepresented by an exception. When fault handling and only fault handling\ncode is included in exception handlers, the separation makes the code\neasier to read. The reader can skip all the exception handlers and still\nunderstand the normal flow of control of the code. For this reason,\nexceptions should never be raised and handled within the same unit, as a\nform of a ",(0,o.jsx)(n.code,{children:"goto"})," statement to exit from a ",(0,o.jsx)(n.code,{children:"loop"}),",",(0,o.jsx)(n.code,{children:"if"}),", ",(0,o.jsx)(n.code,{children:"case"}),", or\n",(0,o.jsx)(n.code,{children:"block"}),"statement."]}),"\n",(0,o.jsxs)(n.p,{children:["Evaluating an abnormal object results in erroneous execution (",(0,o.jsx)(n.a,{href:"http://www.adahome.com/rm95/rm9x-toc-13-09-01.html",children:"Ada\nReference Manual 1995,\n\xa713.9.1"}),"). The\nfailure of a language-defined check raises an exception. In the\ncorresponding exception handler, you want to perform appropriate cleanup\nactions, including logging the error (see the discussion on exception\noccurrences in Guideline 5.8.2) and/or reraising the exception.\nEvaluating the object that put you into the exception handling code will\nlead to erroneous execution, where you do not know whether your\nexception handler has executed completely or correctly. See also\nGuideline 5.9.1, which discusses abnormal objects in the context of\n",(0,o.jsx)(n.code,{children:"Ada.Unchecked_Conversion"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"handlers-for-others",children:"Handlers for Others"}),"\n",(0,o.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When writing an exception handler for ",(0,o.jsx)(n.code,{children:"others"}),", capture and return\nadditional information about the exception through the\n",(0,o.jsx)(n.code,{children:"Exception_Name"}),", ",(0,o.jsx)(n.code,{children:"Exception_Message"}),", or ",(0,o.jsx)(n.code,{children:"Exception_Information"}),"\nsubprograms declared in the predefined package ",(0,o.jsx)(n.code,{children:"Ada.Exceptions"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Use ",(0,o.jsx)(n.code,{children:"others"})," only to catch exceptions you cannot enumerate\nexplicitly, preferably only to flag a potential abort."]}),"\n",(0,o.jsxs)(n.li,{children:["During development, trap ",(0,o.jsx)(n.code,{children:"others"}),", capture the exception being\nhandled, and consider adding an explicit handler for that exception."]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,o.jsx)(n.p,{children:"The following simplified example gives the user one chance to enter an\ninteger in the range 1 to 3. In the event of an error, it provides\ninformation back to the user. For an integer value that is outside the\nexpected range, the function reports the name of the exception. For any\nother error, the function provides more complete traceback information.\nThe amount of traceback information is implementation dependent."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ada",children:'with Ada.Exceptions;\nwith Ada.Text_IO;\nwith Ada.Integer_Text_IO;\nfunction Valid_Choice return Positive is\n   subtype Choice_Range is Positive range 1..3;\n\n   Choice : Choice_Range;\nbegin\n   Ada.Text_IO.Put ("Please enter your choice: 1, 2, or 3: ");\n   Ada.Integer_Text_IO.Get (Choice);\n   if Choice in Choice_Range then   -- else garbage returned\n      return Choice;\n   end if;\n   when Out_of_Bounds : Constraint_Error =>\n      Ada.Text_IO.Put_Line ("Input choice not in range.");\n      Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Name (Out_of_Bounds));\n      Ada.Text_IO.Skip_Line;\n   when The_Error : others =>\n      Ada.Text_IO.Put_Line ("Unexpected error.");\n      Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Information (The_Error));\n      Ada.Text_IO.Skip_Line;\nend Valid_Choice;\n'})}),"\n",(0,o.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,o.jsxs)(n.p,{children:["The predefined package ",(0,o.jsx)(n.code,{children:"Ada.Exceptions"})," allows you to log an exception,\nincluding its name and traceback information. When writing a handler for\n",(0,o.jsx)(n.code,{children:"others"}),", you should provide information about the exception to\nfacilitate debugging. Because you can access information about an\nexception occurrence, you can save information suitable for later\nanalysis in a standard way. By using exception occurrences, you can\nidentify the particular exception and either log the details or take\ncorrective action."]}),"\n",(0,o.jsxs)(n.p,{children:["Providing a handler for ",(0,o.jsx)(n.code,{children:"others"}),' allows you to follow the other\nguidelines in this section. It affords a place to catch and convert\ntruly unexpected exceptions that were not caught by the explicit\nhandlers. While it may be possible to provide "fire walls" against\nunexpected exceptions being propagated without providing handlers in\nevery block, you can convert the unexpected exceptions as soon as they\narise. The ',(0,o.jsx)(n.code,{children:"others"})," handler cannot discriminate between different\nexceptions, and, as a result, any such handler must treat the exception\nas a disaster. Even such a disaster can still be converted into a\nuser-defined exception at that point. Because a handler for ",(0,o.jsx)(n.code,{children:"others"}),"\ncatches any exception not otherwise handled explicitly, one placed in\nthe frame of a task or of the main subprogram affords the opportunity to\nperform final cleanup and to shut down cleanly."]}),"\n",(0,o.jsxs)(n.p,{children:["Programming a handler for ",(0,o.jsx)(n.code,{children:"others"})," requires caution. You should name it\nin the handler (e.g., ",(0,o.jsx)(n.code,{children:"Error : others;"}),") to discriminate either which\nexception was actually raised or precisely where it was raised. In\ngeneral, the ",(0,o.jsx)(n.code,{children:"others"}),' handler cannot make any assumptions about what can\nbe or even what needs to be "fixed."']}),"\n",(0,o.jsxs)(n.p,{children:["The use of handlers for ",(0,o.jsx)(n.code,{children:"others"})," during development, when exception\noccurrences can be expected to be frequent, can hinder debugging unless\nyou take advantage of the facilities in ",(0,o.jsx)(n.code,{children:"Ada.Exceptions"}),". It is much\nmore informative to the developer to see a traceback with the actual\nexception information as captured by the ",(0,o.jsx)(n.code,{children:"Ada.Exceptions"})," subprograms.\nWriting a handler without these subprograms limits the amount of error\ninformation you may see. For example, you may only see the converted\nexception in a traceback that does not list the point where the original\nexception was raised."]}),"\n",(0,o.jsx)(n.h4,{id:"notes",children:"notes"}),"\n",(0,o.jsxs)(n.p,{children:["It is possible, but not recommended, to use ",(0,o.jsx)(n.code,{children:"Exception_Id"})," to\ndistinguish between different exceptions in an ",(0,o.jsx)(n.code,{children:"others"})," handler. The\ntype ",(0,o.jsx)(n.code,{children:"Exception_Id"})," is implementation defined. Manipulating values of\ntype ",(0,o.jsx)(n.code,{children:"Exception_Id"})," reduces the portability of your program and makes it\nharder to understand."]}),"\n",(0,o.jsx)(n.h3,{id:"propagation",children:"Propagation"}),"\n",(0,o.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Handle all exceptions, both user and predefined ."}),"\n",(0,o.jsx)(n.li,{children:"For every exception that might be raised, provide a handler in\nsuitable frames to protect against undesired propagation outside the\nabstraction ."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,o.jsxs)(n.p,{children:["The statement that ",(0,o.jsx)(n.em,{children:'"it can never happen"'}),' is not an acceptable\nprogramming approach. You must assume it can happen and be in control\nwhen it does. You should provide defensive code routines for the "cannot\nget here" conditions.']}),"\n",(0,o.jsx)(n.p,{children:"Some existing advice calls for catching and propagating any exception to\nthe calling unit. This advice can stop a program. You should catch the\nexception and propagate it or a substitute only if your handler is at\nthe wrong abstraction level to effect recovery. Effecting recovery can\nbe difficult, but the alternative is a program that does not meet its\nspecification."}),"\n",(0,o.jsx)(n.p,{children:"Making an explicit request for termination implies that your code is in\ncontrol of the situation and has determined that to be the only safe\ncourse of action. Being in control affords opportunities to shut down in\na controlled manner (clean up loose ends, close files, release surfaces\nto manual control, sound alarms) and implies that all available\nprogrammed attempts at recovery have been made."}),"\n",(0,o.jsx)(n.h3,{id:"localizing-the-cause-of-an-exception",children:"Localizing the Cause of an Exception"}),"\n",(0,o.jsx)(n.h4,{id:"guideline-3",children:"guideline"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Do not rely on being able to identify the fault-raising, predefined,\nor implementation-defined exceptions."}),"\n",(0,o.jsxs)(n.li,{children:["Use the facilities defined in ",(0,o.jsx)(n.code,{children:"Ada.Exceptions"})," to capture as much\ninformation as possible about an exception."]}),"\n",(0,o.jsx)(n.li,{children:"Use blocks to associate localized sections of code with their own\nexception handlers."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,o.jsx)(n.p,{children:"See Guideline 5.6.9."}),"\n",(0,o.jsx)(n.h4,{id:"rationale-3",children:"rationale"}),"\n",(0,o.jsx)(n.p,{children:"In an exception handler, it is very difficult to determine exactly which\nstatement and which operation within that statement raised an exception,\nparticularly the predefined and implementation-defined exceptions. The\npredefined and implementation-defined exceptions are candidates for\nconversion and propagation to higher abstraction levels for handling\nthere. User-defined exceptions, being more closely associated with the\napplication, are better candidates for recovery within handlers."}),"\n",(0,o.jsx)(n.p,{children:"User-defined exceptions can also be difficult to localize. Associating\nhandlers with small blocks of code helps to narrow the possibilities,\nmaking it easier to program recovery actions. The placement of handlers\nin small blocks within a subprogram or task body also allows resumption\nof the subprogram or task after the recovery actions. If you do not\nhandle exceptions within blocks, the only action available to the\nhandlers is to shut down the task or subprogram as prescribed in\nGuideline 5.8.3."}),"\n",(0,o.jsx)(n.p,{children:"As discussed in Guideline 5.8.2, you can log run-time system information\nabout the exception. You can also attach a message to the exception.\nDuring code development, debugging, and maintenance, this information\nshould be useful to localize the cause of the exception."}),"\n",(0,o.jsx)(n.h4,{id:"notes-1",children:"notes"}),"\n",(0,o.jsx)(n.p,{children:"The optimal size for the sections of code you choose to protect by a\nblock and its exception handlers is very application-dependent. Too\nsmall a granularity forces you to expend more effort in programming for\nabnormal actions than for the normal algorithm. Too large a granularity\nreintroduces the problems of determining what went wrong and of resuming\nnormal flow."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);