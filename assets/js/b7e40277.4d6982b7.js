"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7161],{24416:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"style-guide/s9/06","title":"9.6 Summary","description":"tagged type hierarchies","source":"@site/docs/style-guide/s9/06.mdx","sourceDirName":"style-guide/s9","slug":"/style-guide/s9/06","permalink":"/docs/style-guide/s9/06","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"9.6 Summary"},"sidebar":"styleGuideSidebar","previous":{"title":"9.5 Multiple Inheritance","permalink":"/docs/style-guide/s9/05"},"next":{"title":"10. Improving Performance","permalink":"/docs/style-guide/s10/"}}');var a=n(74848),r=n(28453);const s={title:"9.6 Summary"},o=void 0,d={},l=[{value:"tagged type hierarchies",id:"tagged-type-hierarchies",level:3},{value:"tagged type operations",id:"tagged-type-operations",level:3},{value:"managing visibility",id:"managing-visibility",level:3},{value:"multiple inheritance",id:"multiple-inheritance",level:3}];function c(e){const i={a:"a",admonition:"admonition",h3:"h3",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h3,{id:"tagged-type-hierarchies",children:"tagged type hierarchies"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Consider using type extension when designing an is-a\n(generalization/specialization) hierarchy."}),"\n",(0,a.jsx)(i.li,{children:"Use tagged types to preserve a common interface across differing\nimplementations (Taft 1995a)."}),"\n",(0,a.jsx)(i.li,{children:"When defining a tagged type in a package, consider including a\ndefinition of a general access type to the corresponding class-wide\ntype."}),"\n",(0,a.jsx)(i.li,{children:"In general, define only one tagged type per package."}),"\n",(0,a.jsx)(i.li,{children:"The implementation of the dispatching operations of each type in a\nderivation class rooted in a tagged type T should conform to the\nexpected semantics of the corresponding dispatching operations of\nthe class-wide type T'Class."}),"\n",(0,a.jsx)(i.li,{children:'Consider using a controlled type whenever a type allocates resources\nthat must be deallocated or otherwise "cleaned up" on destruction or\noverwriting.'}),"\n",(0,a.jsx)(i.li,{children:'Use a derivation from a controlled type in preference to providing\nan explicit "cleanup" operation that must be called by clients of\nthe type.'}),"\n",(0,a.jsx)(i.li,{children:"When overriding the adjustment and finalization procedures derived\nfrom controlled types, define the finalization procedure to undo the\neffects of the adjustment procedure."}),"\n",(0,a.jsx)(i.li,{children:"Derived type initialization procedures should call the\ninitialization procedure of their parent as part of their\ntype-specific initialization."}),"\n",(0,a.jsx)(i.li,{children:"Derived type finalization procedures should call the finalization\nprocedure of their parent as part of their type-specific\nfinalization."}),"\n",(0,a.jsx)(i.li,{children:"Consider deriving a data structure's components rather than the\nenclosing data structure from a controlled type."}),"\n",(0,a.jsx)(i.li,{children:"Consider using abstract types and operations in creating\nclassification schemes, for example, a taxonomy, in which only the\nleaf objects will be meaningful in the application."}),"\n",(0,a.jsx)(i.li,{children:"Consider declaring root types and internal nodes in a type tree as\nabstract."}),"\n",(0,a.jsx)(i.li,{children:"Consider using abstract types for generic formal derived types."}),"\n",(0,a.jsx)(i.li,{children:"Consider using abstract types to develop different implementations\nof a single abstraction."}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"tagged-type-operations",children:"tagged type operations"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:'Consider declaring a primitive abstract operation based on the\nabsence of a meaningful "default" behavior.'}),"\n",(0,a.jsx)(i.li,{children:'Consider declaring a primitive nonabstract operation based on the\npresence of a meaningful "default" behavior.'}),"\n",(0,a.jsx)(i.li,{children:"When overriding an operation, the overriding subprogram should not\nraise exceptions that are not known to the users of the overridden\nsubprogram."}),"\n",(0,a.jsx)(i.li,{children:'If redispatching is used in the implementation of the operations of\na type, with the specific intent that some of the redispatched-to\noperations be overridden by specializations for the derived types,\nthen document this intent clearly in the specification as part of\nthe "interface" of a parent type with its derived types.'}),"\n",(0,a.jsx)(i.li,{children:"When redispatching is used (for any reason) in the implementation of\na primitive operation of a tagged type, then document (in some\nproject-consistent way) this use in the body of the operation\nsubprogram so that it can be easily found during maintenance."}),"\n",(0,a.jsx)(i.li,{children:"Consider using a class-wide operation (i.e., an operation with\nparameter[s] of a class-wide type) when an operation can be\nwritten, compiled, and tested without knowing all the possible\ndescendants of a given tagged type (Barnes 1996)."}),"\n",(0,a.jsx)(i.li,{children:"Consider using a class-wide operation when you do not want an\noperation to be inherited and/or overridden."}),"\n",(0,a.jsx)(i.li,{children:"Avoid declaring a constructor as a primitive abstract operation."}),"\n",(0,a.jsx)(i.li,{children:"Use a primitive abstract operation to declare an initialization\nfunction or constructor only when objects of the inheriting derived\ntypes will not require additional parameters for initialization."}),"\n",(0,a.jsx)(i.li,{children:"Consider using access discriminants to provide parameters to default\ninitialization."}),"\n",(0,a.jsx)(i.li,{children:"Use constructors for explicit initialization."}),"\n",(0,a.jsx)(i.li,{children:"Consider splitting the initialization and construction of an object."}),"\n",(0,a.jsx)(i.li,{children:"Consider declaring a constructor operation in a child package."}),"\n",(0,a.jsx)(i.li,{children:"Consider declaring a constructor operation to return an access value\nto the constructed object (Dewar 1995)."}),"\n",(0,a.jsx)(i.li,{children:'When you redefine the "=" operator on a tagged type, make sure that\nit has the expected behavior in extensions of this type and override\nit if necessary.'}),"\n",(0,a.jsx)(i.li,{children:"Consider using class-wide programming to provide run-time, dynamic\npolymorphism when constructing larger, reusable, extensible\nframeworks."}),"\n",(0,a.jsx)(i.li,{children:"When possible, use class-wide programming rather than variant\nrecords."}),"\n",(0,a.jsx)(i.li,{children:"Use class-wide programming to provide a consistent interface across\nthe set of types in the tagged type hierarchy (i.e., class)."}),"\n",(0,a.jsx)(i.li,{children:"Consider using generics to define a new type in terms of an existing\ntype, either as an extension or as a container, collection, or\ncomposite data structure."}),"\n",(0,a.jsx)(i.li,{children:"Avoid using type extensions for parameterized abstractions when\ngenerics provide a more appropriate mechanism."}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"managing-visibility",children:"managing visibility"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Consider giving derived tagged types the same visibility to the\nparent type as other clients of the parent."}),"\n",(0,a.jsx)(i.li,{children:"Define a derived tagged type in a child of the package that defines\nthe base type if the implementation of the derived type requires\ngreater visibility into the implementation of the base type than\nother clients of the base type require."}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"multiple-inheritance",children:"multiple inheritance"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Consider using type composition for implementation, as opposed to\ninterface, inheritance."}),"\n",(0,a.jsx)(i.li,{children:'Consider using a generic to "mix in" functionality to a derivative\nof some core abstraction.'}),"\n",(0,a.jsx)(i.li,{children:'Consider using access discriminants to support "full" multiple\ninheritance where an object must be referenceable as an entity of\ntwo or more distinct unrelated abstractions.'}),"\n"]}),"\n",(0,a.jsx)(i.admonition,{type:"note",children:(0,a.jsxs)(i.p,{children:['This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.jsx)(i.a,{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide",children:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),", which is\nlicensed under the\n",(0,a.jsx)(i.a,{href:"https://creativecommons.org/licenses/by-sa/3.0/",children:"Creative Commons Attribution-ShareAlike License"}),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work."]})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);