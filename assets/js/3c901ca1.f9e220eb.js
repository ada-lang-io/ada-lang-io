"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3908],{50407:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>x,contentTitle:()=>A,default:()=>p,frontMatter:()=>h,metadata:()=>s,toc:()=>j});const s=JSON.parse('{"id":"arm/AA-6/AA-6.6","title":"6.6 Overloading of Operators","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-6/AA-6.6.mdx","sourceDirName":"arm/AA-6","slug":"/arm/AA-6/AA-6.6","permalink":"/docs/arm/AA-6/AA-6.6","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":56,"frontMatter":{"sidebar_position":56},"sidebar":"referenceManualSidebar","previous":{"title":"6.5 Return Statements","permalink":"/docs/arm/AA-6/AA-6.5"},"next":{"title":"6.7 Null Procedures","permalink":"/docs/arm/AA-6/AA-6.7"}}');var a=n(74848),i=n(28453),o=n(13842),t=n(91435),d=n(21432),c=n(79162),l=n(34421);const h={sidebar_position:56},A="6.6 Overloading of Operators",x={},j=[{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}];function m(e){const r={a:"a",admonition:"admonition",h1:"h1",h4:"h4",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"66-overloading-of-operators",children:"6.6 Overloading of Operators"})}),"\n",(0,a.jsx)(r.admonition,{type:"danger",children:(0,a.jsxs)(r.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.jsx)(r.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,a.jsx)(c.A,{children:"1"}),"\n",(0,a.jsxs)("p",{children:["An ",(0,a.jsx)("em",{children:"operator"})," is a function whose ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0199",children:"designator"})})," is an ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0202",children:"operator_symbol"})}),". [Operators, like other functions, may be overloaded.] ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,a.jsx)(c.A,{children:"2"}),"\n",(0,a.jsxs)("p",{children:["Each use of a unary or binary operator is equivalent to a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.4#S0218",children:"function_call"})})," with ",(0,a.jsxs)("em",{children:["function","_"]}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," being the corresponding ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0202",children:"operator_symbol"})}),", and with (respectively) one or two positional actual parameters being the operand(s) of the operator (in order). ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"2.a/5"}),(0,a.jsx)(l.A,{items:["AI05-0299-1","AI12-0449-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(r.p,{children:[(0,a.jsx)("strong",{children:"To be honest: "}),"We also use the term operator (in Clause ",(0,a.jsx)("a",{href:"/docs/arm/AA-4/",children:"4"})," and in ",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1",children:"6.1"}),") to refer to one of the syntactic categories defined in ",(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5",children:"4.5"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5",children:"Operators and Expression Evaluation"}),"\u201d whose names end with \u201c","_","operator:\u201d ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0142",children:["logical","_","operator"]})}),", ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0143",children:["relational","_","operator"]})}),", ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0144",children:["binary","_","adding","_","operator"]})}),", ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0145",children:["unary","_","adding","_","operator"]})}),", ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0146",children:["multiplying","_","operator"]})}),", and ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-4/AA-4.5#S0147",children:["highest","_","precedence","_","operator"]})}),". ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"2.b/3"}),(0,a.jsx)(l.A,{items:["AI05-0005-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(r.p,{children:[(0,a.jsx)("strong",{}),"This equivalence extends to uses of ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.4#S0218",children:"function_call"})})," in most other language rules. However, as often happens, the equivalence is not perfect, as operator calls are not a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),", while a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.4#S0218",children:"function_call"})})," is a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),". Thus, operator calls cannot be used in contexts that require a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," (such as a rename of an object). A direct fix for this problem would be very disruptive, and thus we have not done that. However, qualifying an operator call can be used as a workaround in contexts that require a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})}),". ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(r.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,a.jsx)(c.A,{children:"3/3"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0143-1"]}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0196",children:"subprogram_specification"})})," of a unary or binary operator shall have one or two parameters, respectively. The parameters shall be of mode ",(0,a.jsx)("strong",{children:"in"}),". A generic function instantiation whose ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0199",children:"designator"})})," is an ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0202",children:"operator_symbol"})})," is only allowed if the specification of the generic function has the corresponding number of parameters, and they are all of mode ",(0,a.jsx)("strong",{children:"in"}),".",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(c.A,{children:"4"}),"\n",(0,a.jsxs)("p",{children:[(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.7#S0063",children:"Default_expression"})}),"s are not allowed for the parameters of an operator (whether the operator is declared with an explicit ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#S0196",children:"subprogram_specification"})})," or by a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),").",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(c.A,{children:"5"}),"\n",(0,a.jsxs)("p",{children:['An explicit declaration of "/=" shall not have a result type of the predefined type Boolean. ',(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,a.jsx)(c.A,{children:"6/3"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0128-1"]}),"\n",(0,a.jsxs)("p",{children:['An explicit declaration of "=" whose result type is Boolean implicitly declares an operator "/=" that gives the complementary result. ',(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"6.a/3"}),(0,a.jsx)(l.A,{items:["AI05-0128-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(r.p,{children:[(0,a.jsx)("strong",{}),'A "/=" defined by this rule is considered user-defined, which means that it will be inherited by a derived type. \u201cUser-defined\u201d means \u201cnot language-defined\u201d for the purposes of inheritance, that is anything other than predefined operators. ',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"7/5"}),(0,a.jsx)(l.A,{items:["AI12-0440-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(r.p,{children:['NOTE   The operators "+" and "\u2013" are both unary and binary operators, and hence can be overloaded with both one- and two-parameter functions. ',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(r.h4,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(c.A,{children:"8"}),"\n",(0,a.jsxs)("p",{children:[(0,a.jsx)("em",{children:"Examples of user-defined operators:"})," ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(c.A,{children:"9"}),"\n",(0,a.jsx)(d.A,{language:"ada",children:(0,a.jsxs)(r.p,{children:['function "+" (Left, Right : Matrix) return Matrix;',"\n",'function "+" (Left, Right : Vector) return Vector;',"\n","\n","--  assuming that A, B, and C are of the type Vector","\n","--  the following two statements are equivalent:","\n","\n","A := B + C;","\n",'A := "+"(B, C);',"\n"]})}),"\n",(0,a.jsx)(t.A,{children:(0,a.jsx)(r.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"9.a"}),(0,a.jsx)(o.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(r.p,{children:['Explicit declarations of "=" are now permitted for any combination of parameter and result types.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"9.b"}),(0,a.jsx)(o.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(r.p,{children:['Explicit declarations of "/=" are now permitted, so long as the result type is not Boolean. ',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(t.A,{children:(0,a.jsx)(r.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"9.c/3"}),(0,a.jsx)(l.A,{items:["AI05-0128-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"correction",children:(0,a.jsxs)(r.p,{children:[(0,a.jsx)("strong",{}),' Corrected the wording so that only explicit declarations of "=" cause an implicit declaration of "/="; otherwise, we could get multiple implicit definitions of "/=" without an obvious way to chose between them.',(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(t.A,{children:[(0,a.jsx)(c.A,{children:"9.d/3"}),(0,a.jsx)(l.A,{items:["AI05-0143-1"]}),(0,a.jsx)(o.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(r.p,{children:["Added wording so that operators only allow parameters of mode ",(0,a.jsx)("strong",{children:"in"}),". This was made necessary by the elimination elsewhere of the restriction that function parameters be only of mode ",(0,a.jsx)("strong",{children:"in"}),". ",(0,a.jsx)("br",{})]})})]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);