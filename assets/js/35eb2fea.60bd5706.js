"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["3753"],{5647:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>r,toc:()=>d,default:()=>h,metadata:()=>a,assets:()=>l,contentTitle:()=>s});var a=JSON.parse('{"id":"style-guide/s6/02","title":"6.2 Communication","description":"The need for tasks to communicate gives rise to most of the problems","source":"@site/docs/style-guide/s6/02.mdx","sourceDirName":"style-guide/s6","slug":"/style-guide/s6/02","permalink":"/docs/style-guide/s6/02","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"6.2 Communication"},"sidebar":"styleGuideSidebar","previous":{"title":"6.1 Concurrency Options","permalink":"/docs/style-guide/s6/01"},"next":{"title":"6.3 Termination","permalink":"/docs/style-guide/s6/03"}}'),i=t(5893),o=t(65);let r={title:"6.2 Communication"},s=void 0,l={},d=[{value:"Efficient Task Communication",id:"efficient-task-communication",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Defensive Task Communication",id:"defensive-task-communication",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes-1",level:4},{value:"Attributes &#39;Count, &#39;Callable, and &#39;Terminated",id:"attributes-count-callable-and-terminated",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Unprotected Shared Variables",id:"unprotected-shared-variables",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Selective Accepts and Entry Calls",id:"selective-accepts-and-entry-calls",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Communication Complexity",id:"communication-complexity",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4}];function c(e){let n={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The need for tasks to communicate gives rise to most of the problems\nthat make concurrent programming so difficult. Used properly, Ada's\nintertask communication features can improve the reliability of\nconcurrent programs; used thoughtlessly, they can introduce subtle\nerrors that can be difficult to detect and correct."}),"\n",(0,i.jsx)(n.h3,{id:"efficient-task-communication",children:"Efficient Task Communication"}),"\n",(0,i.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimize the work performed during a rendezvous."}),"\n",(0,i.jsx)(n.li,{children:"Minimize the work performed in the selective accept loop of a task."}),"\n",(0,i.jsx)(n.li,{children:"Consider using protected objects for data synchronization and\ncommunication."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"In the following example, the statements in the accept body are\nperformed as part of the execution of both the caller task and the task\nServer, which contains Operation and Operation2. The statements after\nthe accept body are executed before Server can accept additional calls\nto Operation or Operation2."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"   ...\n   loop\n      select\n         accept Operation do\n            -- These statements are executed during rendezvous.\n            -- Both caller and server are blocked during this time.\n            ...\n         end Operation;\n         ...\n         -- These statements are not executed during rendezvous.\n         -- The execution of these statements increases the time required\n         --   to get back to the accept and might be a candidate for another task.\n\n      or\n         accept Operation_2 do\n            -- These statements are executed during rendezvous.\n            -- Both caller and server are blocked during this time.\n            ...\n         end Operation_2;\n      end select;\n      -- These statements are also not executed during rendezvous,\n      -- The execution of these statements increases the time required\n      --   to get back to the accept and might be a candidate for another task.\n\n   end loop;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"To minimize the time required to rendezvous, only work that needs to be\nperformed during a rendezvous, such as saving or generating parameters,\nshould be allowed in the accept bodies."}),"\n",(0,i.jsx)(n.p,{children:"When work is removed from the accept body and placed later in the\nselective accept loop, the additional work might still suspend the\ncaller task. If the caller task calls entry Operation again before the\nserver task completes its additional work, the caller is delayed until\nthe server completes the additional work. If the potential delay is\nunacceptable and the additional work does not need to be completed\nbefore the next service of the caller task, the additional work can form\nthe basis of a new task that will not block the caller task."}),"\n",(0,i.jsx)(n.p,{children:"Operations on protected objects incur less execution overhead than tasks\nand are more efficient for data synchronization and communication than\nthe rendezvous. You must design protected operations to be bounded,\nshort, and not potentially blocking."}),"\n",(0,i.jsx)(n.h4,{id:"notes",children:"notes"}),"\n",(0,i.jsx)(n.p,{children:"In some cases, additional functions can be added to a task. For example,\na task controlling a communication device might be responsible for a\nperiodic function to ensure that the device is operating correctly. This\ntype of addition should be done with care, realizing that the response\ntime of the task might be impacted (see the above rationale)."}),"\n",(0,i.jsx)(n.p,{children:"Minimizing the work performed during a rendezvous or selective accept\nloop of a task can increase the rate of execution only when it results\nin additional overlaps in processing between the caller and callee or\nwhen other tasks can be scheduled due to the shorter period of\nexecution. Therefore, the largest increases in execution rates will be\nseen in multiprocessor environments. In single-processor environments,\nthe increased execution rate will not be as significant and there might\neven be a small net loss. The guideline is still applicable, however, if\nthe application could ever be ported to a multiprocessor environment."}),"\n",(0,i.jsx)(n.h3,{id:"defensive-task-communication",children:"Defensive Task Communication"}),"\n",(0,i.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Provide a handler for exception Program_Error whenever you cannot\navoid a selective accept statement whose alternatives can all be\nclosed (Honeywell 1986)."}),"\n",(0,i.jsx)(n.li,{children:"Make systematic use of handlers for Tasking_Error."}),"\n",(0,i.jsx)(n.li,{children:"Be prepared to handle exceptions during a rendezvous ."}),"\n",(0,i.jsx)(n.li,{children:"Consider using a when others exception handler."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"This block allows recovery from exceptions raised while attempting to\ncommunicate a command to another task:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"Accelerate:\n   begin\n      Throttle.Increase(Step);\n   exception\n      when Tasking_Error     =>     ...\n      when Constraint_Error  =>     ...\n      when Throttle_Too_Wide =>     ...\n      ...\n   end Accelerate;\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this select statement, if all the guards happen to be closed, the\nprogram can continue by executing the else part. There is no need for a\nhandler for Program_Error. Other exceptions can still be raised while\nevaluating the guards or attempting to communicate. You will also need\nto include an exception handler in the task Throttle so that it can\ncontinue to execute after an exception is raised during the rendezvous:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"...\nGuarded:\n   begin\n      select\n         when Condition_1 =>\n            accept Entry_1;\n      or\n         when Condition_2 =>\n            accept Entry_2;\n      else  -- all alternatives closed\n         ...\n      end select;\n   exception\n      when Constraint_Error =>\n         ...\n   end Guarded;\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this select statement, if all the guards happen to be closed,\nexception Program_Error will be raised. Other exceptions can still be\nraised while evaluating the guards or attempting to communicate:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"Guarded:\n   begin\n      select\n         when Condition_1 =>\n            accept Entry_1;\n      or\n         when Condition_2 =>\n            delay Fraction_Of_A_Second;\n      end select;\n   exception\n      when Program_Error     =>  ...\n      when Constraint_Error  =>  ...\n   end Guarded;\n...\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"The exception Program_Error is raised if a selective accept statement\n(select statement containing accepts) is reached, all of whose\nalternatives are closed (i.e., the guards evaluate to False and there\nare no alternatives without guards), unless there is an else part. When\nall alternatives are closed, the task can never again progress, so there\nis by definition an error in its programming. You must be prepared to\nhandle this error should it occur."}),"\n",(0,i.jsx)(n.p,{children:"Because an else part cannot have a guard, it can never be closed off as\nan alternative action; thus, its presence prevents Program_Error.\nHowever, an else part, a delay alternative, and a terminate alternative\nare all mutually exclusive, so you will not always be able to provide an\nelse part. In these cases, you must be prepared to handle\nProgram_Error."}),"\n",(0,i.jsx)(n.p,{children:"The exception Tasking_Error can be raised in the calling task whenever\nit attempts to communicate. There are many situations permitting this.\nFew of them are preventable by the calling task."}),"\n",(0,i.jsx)(n.p,{children:"If an exception is raised during a rendezvous and not handled in the\naccept statement, it is propagated to both tasks and must be handled in\ntwo places (see Guideline 5.8). The handling of the others exception can\nbe used to avoid propagating unexpected exceptions to callers (when this\nis the desired effect) and to localize the logic for dealing with\nunexpected exceptions in the rendezvous. After handling, an unknown\nexception should normally be raised again because the final decision of\nhow to deal with it might need to be made at the outermost scope of the\ntask body."}),"\n",(0,i.jsx)(n.h4,{id:"notes-1",children:"notes"}),"\n",(0,i.jsx)(n.p,{children:"There are other ways to prevent Program_Error at a selective accept.\nThese involve leaving at least one alternative unguarded or proving that\nat least one guard will evaluate True under all circumstances. The point\nhere is that you or your successors will make mistakes in trying to do\nthis, so you should prepare to handle the inevitable exception."}),"\n",(0,i.jsx)(n.h3,{id:"attributes-count-callable-and-terminated",children:"Attributes 'Count, 'Callable, and 'Terminated"}),"\n",(0,i.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Do not depend on the values of the task attributes 'Callable or\n'Terminated ( Nissen and Wallis 1984)."}),"\n",(0,i.jsx)(n.li,{children:"Do not depend on attributes to avoid Tasking_Error on an entry\ncall."}),"\n",(0,i.jsx)(n.li,{children:"For tasks, do not depend on the value of the entry attribute 'Count."}),"\n",(0,i.jsx)(n.li,{children:"Using the 'Count attribute with protected entries is more reliable\nthan using the 'Count attribute with task entries."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-2",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"In the following examples, Dispatch'Callable is a Boolean expression,\nindicating whether a call can be made to the task Intercept without\nraising the exception Tasking_Error. Dispatch'Count indicates the\nnumber of callers currently waiting at entry Transmit.\nDispatch'Terminated is a Boolean expression, indicating whether the task\nDispatch is in a terminated state."}),"\n",(0,i.jsx)(n.p,{children:"This task is badly programmed because it relies upon the values of the\n'Count attributes not changing between evaluating and acting upon them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"---------------------------------------------------------------------\ntask body Dispatch is\n...\n   select\n      when Transmit'Count > 0 and Receive'Count = 0 =>\n         accept Transmit;\n         ...\n   or\n      accept Receive;\n      ...\n   end select;\n...\nend Dispatch;\n---------------------------------------------------------------------\n"})}),"\n",(0,i.jsx)(n.p,{children:"If the following code is preempted between evaluating the condition and\ninitiating the call, the assumption that the task is still callable\nmight no longer be valid:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"...\nif Dispatch'Callable then\n   Dispatch.Receive;\nend if;\n...\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"Attributes 'Callable, 'Terminated, and 'Count are all subject to race\nconditions. Between the time you reference an attribute and the time you\ntake action, the value of the attribute might change. Attributes\n'Callable and 'Terminated convey reliable information once they become\nFalse and True, respectively. If 'Callable is False, you can expect the\ncallable state to remain constant. If 'Terminated is True, you can\nexpect the task to remain terminated. Otherwise, 'Terminated and\n'Callable can change between the time your code tests them and the time\nit responds to the result."}),"\n",(0,i.jsx)(n.p,{children:"The Ada Reference Manual (1995, \xa79.9) itself warns about the\nasynchronous increase and decrease of the value of 'Count. A task can be\nremoved from an entry queue due to execution of an abort statement as\nwell as expiration of a timed entry call. The use of this attribute in\nguards of a selective accept statement might result in the opening of\nalternatives that should not be opened under a changed value of 'Count."}),"\n",(0,i.jsx)(n.p,{children:"The value of the attribute 'Count is stable for protected units because\nany change to an entry queue is itself a protected action, which will\nnot occur while any other protected action is already proceeding.\nNevertheless, when you use 'Count within an entry barrier of a protected\nunit, you should remember that the condition of the barrier is evaluated\nboth before and after queueing a given caller."}),"\n",(0,i.jsx)(n.h3,{id:"unprotected-shared-variables",children:"Unprotected Shared Variables"}),"\n",(0,i.jsx)(n.h4,{id:"guideline-3",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use calls on protected subprograms or entries to pass data between\ntasks rather than unprotected shared variables."}),"\n",(0,i.jsx)(n.li,{children:"Do not use unprotected shared variables as a task synchronization\ndevice."}),"\n",(0,i.jsx)(n.li,{children:"Do not reference nonlocal variables in a guard ."}),"\n",(0,i.jsx)(n.li,{children:"If an unprotected shared variable is necessary, use the pragma\nVolatile or Atomic."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-3",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"This code will either print the same line more than once, fail to print\nsome lines, or print garbled lines (part of one line followed by part of\nanother) nondeterministically. This is because there is no\nsynchronization or mutual exclusion between the task that reads a\ncommand and the one that acts on it. Without knowledge about their\nrelative scheduling, the actual results cannot be predicted:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"-----------------------------------------------------------------------\ntask body Line_Printer_Driver is\n   ...\nbegin\n   loop\n      Current_Line := Line_Buffer;\n      -- send to device\n   end loop;\nend Line_Printer_Driver;\n-----------------------------------------------------------------------\ntask body Spool_Server is\n   ...\nbegin\n   loop\n      Disk_Read (Spool_File, Line_Buffer);\n   end loop;\nend Spool_Server;\n-----------------------------------------------------------------------\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following example shows a vending machine that dispenses the amount\nrequested into an appropriately sized container. The guards reference\nthe global variables Num_Requested and Item_Count, leading to a\npotential problem in the wrong amount being dispensed into an\ninappropriately sized container:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:'Num_Requested : Natural;\nItem_Count    : Natural := 1000;\ntask type Request_Manager (Personal_Limit : Natural := 1) is\n   entry Make_Request (Num : Natural);\n   entry Get_Container;\n   entry Dispense;\nend Request_Manager;\n\ntask body Request_Manager is\nbegin\n   loop\n      select\n         accept Make_Request (Num : Natural) do\n            Num_Requested := Num;\n         end Make_Request;\n      or\n         when Num_Requested < Item_Count =>\n            accept Get_Container;\n            ...\n      or\n         when Num_Requested < Item_Count =>\n            accept Dispense do\n               if Num_Requested <= Personal_Limit then\n                  Ada.Text_IO.Put_Line ("Please pick up items.");\n               else\n                  Ada.Text_IO.Put_Line ("Sorry! Requesting too many items.");\n               end if;\n            end Dispense;\n      end select;\n   end loop;\nend Request_Manager;\nR1 : Request_Manager (Personal_Limit => 10);\nR2 : Request_Manager (Personal_Limit => 2);\n'})}),"\n",(0,i.jsx)(n.p,{children:"The interleaving of the execution of R1 and R2 can lead to\nNum_Requested being changed before the entry call to Dispense is\naccepted. Thus, R1 might receive fewer items than requested or R2's\nrequest might be bounced because the request manager thinks that what R2\nis requesting exceeds R2's personal limit. By using the local variable,\nyou will dispense the correct amount. Furthermore, by using the pragma\nVolatile (Ada Reference Manual 1995, \xa7C.6), you ensure that the\nItem_Count is reevaluated when the guards are evaluated. Given that the\nvariable Item_Count is not updated in this task body, the compiler\nmight otherwise have optimized the code and not generated code to\nreevaluate Item_Count every time it is read:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"Item_Count : Natural := 1000;\npragma Volatile (Item_Count);\ntask body Request_Manager is\n   Local_Num_Requested : Natural := 0;\nbegin\n   loop\n      select\n         accept Make_Request (Num : Natural) do\n            Local_Num_Requested := Num;\n         end Make_Request;\n      or\n         when Local_Num_Requested <= Personal_Limit =>\n            accept Get_Container;\n            ...\n      or\n         when Local_Num_Requested < Item_Count =>\n            accept Dispense do\n               ... -- output appropriate message if couldn't service request\n            end Dispense;\n            Item_Count := Item_Count - Local_Num_Requested;\n      end select;\n   end loop;\nend Request_Manager;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale-3",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"There are many techniques for protecting and synchronizing data access.\nYou must program most of them yourself to use them. It is difficult to\nwrite a program that shares unprotected data correctly. If it is not\ndone correctly, the reliability of the program suffers."}),"\n",(0,i.jsx)(n.p,{children:"Ada provides protected objects that encapsulate and provide synchronized\naccess to protected data that is shared between tasks. Protected objects\nare expected to provide better performance than the rendezvous that\nusually requires introduction of an additional task to manage the shared\ndata. The use of unprotected shared variables is more error-prone than\nthe protected objects or rendezvous because the programmer must ensure\nthat the unprotected shared variables are independently addressable and\nthat the actions of reading or updating the same unprotected shared\nvariable are sequential (Ada Reference Manual 1995, \xa79.10; Rationale\n1995, \xa7II.9)."}),"\n",(0,i.jsx)(n.p,{children:"The first example above has a race condition requiring perfect\ninterleaving of execution. This code can be made more reliable by\nintroducing a flag that is set by Spool_Server and reset by\nLine_Printer_Driver. An if (condition flag) then delay ... else would\nbe added to each task loop in order to ensure that the interleaving is\nsatisfied. However, notice that this approach requires a delay and the\nassociated rescheduling. Presumably, this rescheduling overhead is what\nis being avoided by not using the rendezvous."}),"\n",(0,i.jsx)(n.p,{children:"You might need to use an object in shared memory to communicate data\nbetween (Rationale 1995, \xa7C.5):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ada tasks"}),"\n",(0,i.jsx)(n.li,{children:"An Ada program and concurrent non-Ada processes"}),"\n",(0,i.jsx)(n.li,{children:"An Ada program and hardware devices"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If your environment supports the Systems Programming Annex (Ada\nReference Manual 1995, Annex C), you should indicate whether loads and\nstores to the shared object must be indivisible. If you specify the\npragma Atomic, make sure that the object meets the underlying hardware\nrequirements for size and alignment. Multiple tasks sharing the\npredefined random number generator and certain input/output subprograms\ncan lead to problems with unprotected updates to shared state. The Ada\nReference Manual (1995, \xa7A.5.2) points out the need for tasks to\nsynchronize their access to the random number generators (packages\nAda.Numerics.Float_Random and Ada.Numerics.Discrete_Random). See\nGuideline 7.7.5 for the I/O issue."}),"\n",(0,i.jsx)(n.h3,{id:"selective-accepts-and-entry-calls",children:"Selective Accepts and Entry Calls"}),"\n",(0,i.jsx)(n.h4,{id:"guideline-4",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use caution with conditional entry calls to task entries."}),"\n",(0,i.jsx)(n.li,{children:"Use caution with selective accept with else parts."}),"\n",(0,i.jsx)(n.li,{children:"Do not depend upon a particular delay in timed entry calls to task\nentries."}),"\n",(0,i.jsx)(n.li,{children:"Do not depend upon a particular delay in selective accepts with\ndelay alternatives."}),"\n",(0,i.jsx)(n.li,{children:"Consider using protected objects instead of the rendezvous for\ndata-oriented synchronization."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-4",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"The conditional entry call in the following code results in a potential\nrace condition that might degenerate into a busy waiting loop (i.e.,\nperform the same calculation over and over). The task Current_Position\ncontaining entry Request_New_Coordinates might never execute if the\nloop-containing task (shown in the following code fragment) has a higher\npriority than Current_Position because it does not release the\nprocessing resource:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"task body Calculate_Flightpath is\nbegin\n   ...\n   loop\n\n      select\n         Current_Position.Request_New_Coordinates (X, Y);\n         -- calculate projected location based on new coordinates\n         ...\n\n      else\n         -- calculate projected location based on last locations\n         ...\n      end select;\n\n   end loop;\n   ...\nend Calculate_Flightpath;\n"})}),"\n",(0,i.jsx)(n.p,{children:"The addition of a delay, as shown, may allow Current_Position to\nexecute until it reaches an accept for Request_New_Coordinates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"task body Calculate_Flightpath is\nbegin\n   ...\n   loop\n\n      select\n         Current_Position.Request_New_Coordinates(X, Y);\n         -- calculate projected location based on new coordinates\n         ...\n\n      else\n         -- calculate projected location based on last locations\n         ...\n\n         delay until Time_To_Execute;\n         Time_To_Execute := Time_To_Execute + Period;\n      end select;\n\n   end loop;\n   ...\nend Calculate_Flightpath;\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following selective accept with else again does not degenerate into\na busy wait loop only because of the addition of a delay statement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"task body Buffer_Messages is\n\n   ...\n\nbegin\n\n   ...\n\n   loop\n      delay until Time_To_Execute;\n\n      select\n         accept Get_New_Message (Message : in     String) do\n            -- copy message to parameters\n            ...\n         end Get_New_Message;\n      else  -- Don't wait for rendezvous\n         -- perform built in test Functions\n         ...\n      end select;\n\n      Time_To_Execute := Time_To_Execute + Period;\n   end loop;\n\n   ...\n\nend Buffer_Messages;\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following timed entry call might be considered an unacceptable\nimplementation if lost communications with the reactor for over 25\nmilliseconds results in a critical situation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"task body Monitor_Reactor is\n   ...\nbegin\n   ...\n   loop\n\n      select\n         Reactor.Status(OK);\n\n      or\n         delay 0.025;\n         -- lost communication for more that 25 milliseconds\n         Emergency_Shutdown;\n      end select;\n\n      -- process reactor status\n      ...\n   end loop;\n   ...\nend Monitor_Reactor;\n"})}),"\n",(0,i.jsx)(n.p,{children:'In the following "selective accept with delay" example, the accuracy of\nthe coordinate calculation function is bounded by time. For example, the\nrequired accuracy cannot be obtained unless Period is within + or -\n0.005 seconds. This period cannot be guaranteed because of the\ninaccuracy of the delay statement:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"task body Current_Position is\nbegin\n   ...\n   loop\n\n      select\n         accept Request_New_Coordinates (X :    out Integer;\n                                         Y :    out Integer) do\n            -- copy coordinates to parameters\n            ...\n         end Request_New_Coordinates;\n\n      or\n         delay until Time_To_Execute;\n      end select;\n\n      Time_To_Execute := Time_To_Execute + Period;\n      -- Read Sensors\n      -- execute coordinate transformations\n   end loop;\n   ...\nend Current_Position;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale-4",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"Use of these constructs always poses a risk of race conditions. Using\nthem in loops, particularly with poorly chosen task priorities , can\nhave the effect of busy waiting."}),"\n",(0,i.jsx)(n.p,{children:'These constructs are very much implementation dependent. For conditional\nentry calls and selective accepts with else parts, the Ada Reference\nManual (1995, \xa79.7) does not define "immediately." For timed entry calls\nand selective accepts with delay alternatives, implementors might have\nideas of time that differ from each other and from your own. Like the\ndelay statement, the delay alternative on the select construct might\nwait longer than the time required (see Guideline 6.1.7).'}),"\n",(0,i.jsx)(n.p,{children:"Protected objects offer an efficient means for providing data-oriented\nsynchronization. Operations on protected objects incur less execution\noverhead than tasks and are more efficient for data synchronization and\ncommunication than the rendezvous. See Guideline 6.1.1 for an example of\nthis use of protected objects."}),"\n",(0,i.jsx)(n.h3,{id:"communication-complexity",children:"Communication Complexity"}),"\n",(0,i.jsx)(n.h4,{id:"guideline-5",children:"guideline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimize the number of accept and select statements per task ."}),"\n",(0,i.jsx)(n.li,{children:"Minimize the number of accept statements per entry."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"example-5",children:"example"}),"\n",(0,i.jsx)(n.p,{children:"Use:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"accept A;\nif Mode_1 then\n   -- do one thing\nelse  -- Mode_2\n   -- do something different\nend if;\n"})}),"\n",(0,i.jsx)(n.p,{children:"rather than:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ada",children:"if Mode_1 then\n   accept A;\n   -- do one thing\nelse  -- Mode_2\n   accept A;\n   -- do something different\nend if;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"rationale-5",children:"rationale"}),"\n",(0,i.jsx)(n.p,{children:"This guideline reduces conceptual complexity. Only entries necessary to\nunderstand externally observable task behavior should be introduced. If\nthere are several different accept and select statements that do not\nmodify task behavior in a way important to the user of the task, there\nis unnecessary complexity introduced by the proliferation of\nselect/accept statements. Externally observable behavior important to\nthe task user includes task timing behavior, task rendezvous initiated\nby the entry calls, prioritization of entries, or data updates (where\ndata is shared between tasks)."}),"\n",(0,i.jsx)(n.h4,{id:"notes-2",children:"notes"}),"\n",(0,i.jsx)(n.p,{children:"Sanden (1994) argues that you need to trade off the complexity of the\nguards associated with the accept statements against the number of\nselect/accept statements. Sanden (1994) shows an example of a queue\ncontroller for bank tellers where there are two modes, open and closed.\nYou can implement this scenario with one loop and two select statements,\none for the open mode and the other for the closed mode. Although you\nare using more select/accept statements, Sanden (1994) argues that the\nresulting program is easier to understand and verify."})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);