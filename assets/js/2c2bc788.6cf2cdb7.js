"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2415],{85852:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>f,contentTitle:()=>h,default:()=>g,frontMatter:()=>u,metadata:()=>m,toc:()=>b});var n=a(91716),i=Object.defineProperty,s=Object.defineProperties,o=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,c=(e,t,a)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,p=(e,t)=>{for(var a in t||(t={}))l.call(t,a)&&c(e,a,t[a]);if(r)for(var a of r(t))d.call(t,a)&&c(e,a,t[a]);return e};const u={title:"8. Reusability",sidebar_position:8},h=void 0,m={unversionedId:"style-guide/s8/s8",id:"style-guide/s8/s8",title:"8. Reusability",description:"Reusability is the extent to which code can be used in different",source:"@site/docs/style-guide/s8/s8.mdx",sourceDirName:"style-guide/s8",slug:"/style-guide/s8/",permalink:"/docs/style-guide/s8/",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"8. Reusability",sidebar_position:8},sidebar:"styleGuideSidebar",previous:{title:"7.7 Summary",permalink:"/docs/style-guide/s7/07"},next:{title:"8.1 Understanding and Clarity",permalink:"/docs/style-guide/s8/01"}},f={},b=[],y={toc:b};function g(e){var t,a=e,{components:i}=a,c=((e,t)=>{var a={};for(var n in e)l.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&r)for(var n of r(e))t.indexOf(n)<0&&d.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=p(p({},y),c),s(t,o({components:i,mdxType:"MDXLayout"}))),(0,n.kt)("p",null,"Reusability is the extent to which code can be used in different\napplications with minimal change. As code is reused in a new\napplication, that new application partially inherits the attributes of\nthat code. If the code is maintainable, the application is more\nmaintainable. If it is portable, then the application is more portable.\nSo this chapter's guidelines are most useful when all of the other\nguidelines in this book are also applied. Several guidelines are\ndirected at the issue of maintainability. Maintainable code is easy to\nchange to meet new or changing requirements. Maintainability plays a\nspecial role in reuse. When attempts are made to reuse code, it is often\nnecessary to change it to suit the new application. If the code cannot\nbe changed easily, it is less likely to be reused."),(0,n.kt)("p",null,"There are many issues involved in software reuse: whether to reuse\nparts, how to store and retrieve reusable parts in a library, how to\ncertify parts, how to maximize the economic value of reuse, how to\nprovide incentives to engineers and entire companies to reuse parts\nrather than reinvent them, and so on. This chapter ignores these\nmanagerial, economic, and logistic issues to focus on the single\ntechnical issue of how to write software parts in Ada to increase reuse\npotential. The other issues are just as important but are outside of the\nscope of this book."),(0,n.kt)("p",null,"One of the design goals of Ada was to facilitate the creation and use of\nreusable parts to improve productivity. To this end, Ada provides\nfeatures to develop reusable parts and to adapt them once they are\navailable. Packages, visibility control, and separate compilation\nsupport modularity and information hiding (see guidelines in Sections\n4.1, 4.2, 5.3, and 5.7). This allows the separation of\napplication-specific parts of the code, maximizes the general purpose\nparts suitable for reuse, and allows the isolation of design decisions\nwithin modules, facilitating change. The Ada type system supports\nlocalization of data definitions so that consistent changes are easy to\nmake. The Ada inheritance features support type extension so that data\ndefinitions and interfaces may be customized for an application. Generic\nunits directly support the development of general purpose, adaptable\ncode that can be instantiated to perform specific functions. The Ada 95\nimprovements for object-oriented techniques and abstraction support all\nof the above goals. Using these features carefully and in conformance to\nthe guidelines in this book, produces code that is more likely to be\nreusable."),(0,n.kt)("p",null,"Reusable code is developed in many ways. Code may be scavenged from a\nprevious project. A reusable library of code may be developed from\nscratch for a particularly well-understood domain, such as a math\nlibrary. Reusable code may be developed as an intentional byproduct of a\nspecific application. Reusable code may be developed a certain way\nbecause a design method requires it. These guidelines are intended to\napply in all of these situations."),(0,n.kt)("p",null,"The experienced programmer recognizes that software reuse is much more a\nrequirements and design issue than a coding issue. The guidelines in\nthis section are intended to work within an overall method for\ndeveloping reusable code. This section will not deal with artifacts of\ndesign, testing, etc. Some research into reuse issues related\nspecifically to the Ada language can be found in AIRMICS (1990), Edwards\n(1990), and Wheeler (1992)."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Regardless of development method, experience indicates that reusable\ncode has certain characteristics, and this chapter makes the\nfollowing assumptions:"),(0,n.kt)("li",{parentName:"ul"},"Reusable parts must be understandable. A reusable part should be a\nmodel of clarity. The requirements for commenting reusable parts are\neven more stringent than those for parts specific to a particular\napplication."),(0,n.kt)("li",{parentName:"ul"},"Reusable parts must be of the highest possible quality. They must be\ncorrect, reliable, and robust. An error or weakness in a reusable\npart may have far-reaching consequences, and it is important that\nother programmers can have a high degree of confidence in any parts\noffered for reuse."),(0,n.kt)("li",{parentName:"ul"},"Reusable parts must be adaptable. To maximize its reuse potential, a\nreusable part must be able to adapt to the needs of a wide variety\nof users."),(0,n.kt)("li",{parentName:"ul"},"Reusable parts should be independent. It should be possible to reuse\na single part without also adopting many other parts that are\napparently unrelated.")),(0,n.kt)("p",null,"In addition to these criteria, a reusable part must be easier to reuse\nthan to reinvent, must be efficient, and must be portable. If it takes\nmore effort to reuse a part than to create one from scratch or if the\nreused part is simply not efficient enough, reuse does not occur as\nreadily. For guidelines on portability, see Chapter 7. This chapter\nshould not be read in isolation. In many respects, a well-written,\nreusable component is simply an extreme example of a well-written\ncomponent. All of the guidelines in the previous chapters and in Chapter\n9 apply to reusable components as well as components specific to a\nsingle application. As experience increases with the 1995 revision to\nthe Ada standard, new guidelines may emerge while others may change. The\nguidelines listed here apply specifically to reusable components."),(0,n.kt)("p",null,'Guidelines in this chapter are frequently worded "consider . . ."\nbecause hard and fast rules cannot apply in all situations. The specific\nchoice you can make in a given situation involves design tradeoffs. The\nrationale for these guidelines is intended to give you insight into some\nof these tradeoffs.'))}g.isMDXComponent=!0}}]);