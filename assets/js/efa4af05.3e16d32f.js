"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1385],{5091:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>x,default:()=>m,frontMatter:()=>h,metadata:()=>i,toc:()=>A});const i=JSON.parse('{"id":"arm/AA-11/AA-11.4","title":"11.4. Exception Handling","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-11/AA-11.4.mdx","sourceDirName":"arm/AA-11","slug":"/arm/AA-11/AA-11.4","permalink":"/docs/arm/AA-11/AA-11.4","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":92,"frontMatter":{"sidebar_position":92},"sidebar":"referenceManualSidebar","previous":{"title":"11.3. Raise Statements and Raise Expressions","permalink":"/docs/arm/AA-11/AA-11.3"},"next":{"title":"11.5. Suppressing Checks","permalink":"/docs/arm/AA-11/AA-11.5"}}');var r=s(4848),a=s(8453),t=s(3204),c=s(4220),o=s(8069),d=s(8011),l=s(6465);const h={sidebar_position:92},x="11.4. Exception Handling",p={},A=[{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"11.4.1  The Package Exceptions",id:"1141--the-package-exceptions",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"11.4.2  Pragmas Assert and Assertion_Policy",id:"1142--pragmas-assert-and-assertion_policy",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"11.4.3  Example of Exception Handling",id:"1143--example-of-exception-handling",level:2},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4}];function j(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"114-exception-handling",children:"11.4. Exception Handling"})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.jsx)(n.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,r.jsx)(d.A,{children:"1"}),"\n",(0,r.jsxs)("p",{children:["[When an exception occurrence is raised, normal program execution is abandoned and control is transferred to an applicable ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.2#S0305",children:"exception_handler"})}),", if any. To ",(0,r.jsx)("i",{children:"handle"})," an exception occurrence is to respond to the exceptional event. To ",(0,r.jsx)("i",{children:"propagate"})," an exception occurrence is to raise it again in another context; that is, to fail to respond to the exceptional event in the present context.] ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"1.a"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"In other words, if the execution of a given construct raises an exception, but does not handle it, the exception is propagated to an enclosing execution (except in the case of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0248",children:"task_body"})}),").",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"1.b/1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Propagation involves re-raising the same exception occurrence. For example, calling an entry of an uncallable task raises Tasking","_","Error; this is not propagation. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,r.jsx)(d.A,{children:"2"}),"\n",(0,r.jsxs)("p",{children:["Within a given task, if the execution of construct ",(0,r.jsx)("i",{children:"a"})," is defined by this document to consist (in part) of the execution of construct ",(0,r.jsx)("i",{children:"b"}),", then while ",(0,r.jsx)("i",{children:"b"})," is executing, the execution of ",(0,r.jsx)("i",{children:"a"})," is said to ",(0,r.jsx)("i",{children:"dynamically enclose"})," the execution of ",(0,r.jsx)("i",{children:"b"}),". The ",(0,r.jsx)("i",{children:"innermost dynamically enclosing"})," execution of a given execution is the dynamically enclosing execution that started most recently. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"2.a"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"If the execution of ",(0,r.jsx)("i",{children:"a"})," dynamically encloses that of ",(0,r.jsx)("i",{children:"b"}),", then we also say that the execution of ",(0,r.jsx)("i",{children:"b"})," is ",(0,r.jsx)("i",{children:"included in"})," the execution of ",(0,r.jsx)("i",{children:"a"}),". ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"2.b"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Examples: The execution of an ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.3#S0175",children:"if_statement"})})," dynamically encloses the evaluation of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5#S0150",children:"condition"})})," after the ",(0,r.jsx)("b",{children:"if"})," (during that evaluation). (Recall that \u201cexecution\u201d includes both \u201celaboration\u201d and \u201cevaluation\u201d, as well as other executions.) The evaluation of a function call dynamically encloses the execution of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," of the function ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.11#S0089",children:"body"})})," (during that execution). Note that, due to recursion, several simultaneous executions of the same construct can be occurring at once during the execution of a particular task.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"2.c"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Dynamically enclosing is not defined across task boundaries; a task's execution does not include the execution of any other tasks.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"2.d"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Dynamically enclosing is only defined for executions that are occurring at a given moment in time; if an ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.3#S0175",children:"if_statement"})})," is currently executing the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," after ",(0,r.jsx)("b",{children:"then"}),", then the evaluation of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.5#S0150",children:"condition"})})," is no longer dynamically enclosed by the execution of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.3#S0175",children:"if_statement"})})," (or anything else). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"3"}),"\n",(0,r.jsxs)("p",{children:["When an exception occurrence is raised by the execution of a given construct, the rest of the execution of that construct is ",(0,r.jsx)("i",{children:"abandoned"}),"; that is, any portions of the execution that have not yet taken place are not performed. The construct is first completed, and then left, as explained in ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6#Subclause_7.6.1",children:"7.6.1"}),". Then: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"4"}),"\n",(0,r.jsx)("ul",{children:(0,r.jsxs)("li",{children:["If the construct is a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0248",children:"task_body"})}),", the exception does not propagate further; ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"4.a"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"When an exception is raised by the execution of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0248",children:"task_body"})}),", there is no dynamically enclosing execution, so the exception does not propagate any further. If the exception occurred during the activation of the task, then the activator raises Tasking","_","Error, as explained in ",(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.2",children:"9.2"}),", \u201c",(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.2",children:"Task Execution - Task Activation"}),"\u201d, but we don't define that as propagation; it's a special rule. Otherwise (the exception occurred during the execution of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.2#S0304",children:"handled_sequence_of_statements"})})," of the task), the task silently disappears. Thus, abnormal termination of tasks is not always considered to be an error. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"5"}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["If the construct is the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.2#S0304",children:"handled_sequence_of_statements"})})," that has a handler with a choice covering the exception, the occurrence is handled by that handler;",(0,r.jsx)("br",{})]}),(0,r.jsx)(d.A,{children:"6"}),(0,r.jsxs)("li",{children:["Otherwise, the occurrence is ",(0,r.jsx)("i",{children:"propagated"})," to the innermost dynamically enclosing execution, which means that the occurrence is raised again in that context. ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"6.a"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"As shorthands, we refer to the ",(0,r.jsx)("i",{children:"propagation of an exception"}),", and the ",(0,r.jsx)("i",{children:"propagation by a construct"}),", if the execution of the construct propagates an exception occurrence. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"7"}),"\n",(0,r.jsxs)("p",{children:["When an occurrence is ",(0,r.jsx)("i",{children:"handled"})," by a given handler, the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.2#S0306",children:"choice_parameter_specification"})}),", if any, is first elaborated, which creates the choice parameter and initializes it to the occurrence. Then, the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," of the handler is executed; this execution replaces the abandoned portion of the execution of the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})}),". ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"7.a/2"}),(0,r.jsx)(l.A,{items:["AI95-00318-02"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This \u201creplacement\u201d semantics implies that the handler can do pretty much anything the abandoned sequence could do; for example, in a function, the handler can execute a return statement that applies to the function. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"7.b"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The rules for exceptions raised in library units, main subprograms and partitions follow from the normal rules, plus the semantics of the environment task described in Clause ",(0,r.jsx)("a",{href:"/docs/arm/AA-10/",children:"10"})," (for example, the environment task of a partition elaborates library units and calls the main subprogram). If an exception is propagated by the main subprogram, it is propagated to the environment task, which then terminates abnormally, causing the partition to terminate abnormally. Although abnormal termination of tasks is not necessarily an error, abnormal termination of a partition due to an exception ",(0,r.jsx)("i",{children:"is"})," an error. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"7.c/5"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"Term entry: "}),(0,r.jsx)("b",{children:"handle an exception"})," \u2014 perform some actions in response to the arising of an exception",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"8/5"}),(0,r.jsx)(l.A,{items:["AI12-0451-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE   Exceptions raised in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.11#S0086",children:"declarative_part"})})," of a body are not handled by the handlers of the ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-11/AA-11.2#S0304",children:["handled","_","sequence","_","of","_","statements"]})})," of that body. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_11.4.1"}),"\n",(0,r.jsx)(n.h2,{id:"1141--the-package-exceptions",children:"11.4.1  The Package Exceptions"}),"\n",(0,r.jsx)(n.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,r.jsx)(d.A,{children:"1_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["The following language-defined library package exists: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"2/5_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00362-01","AI95-00400-01","AI95-00438-01","AI12-0241-1","AI12-0302-1","AI12-0399-1"]}),"\n",(0,r.jsxs)(o.A,{language:"ada",children:[(0,r.jsxs)(n.p,{children:["with Ada.Streams;","\n","package Ada.Exceptions ","\n","    with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","    type Exception","_","Id is private","\n","        with Preelaborable","_","Initialization;","\n","    Null","_","Id : constant Exception","_","Id;","\n","    function Exception","_","Name(Id : Exception","_","Id) return String;","\n","    function Wide","_","Exception","_","Name(Id : Exception","_","Id) return Wide","_","String;","\n","    function Wide","_","Wide","_","Exception","_","Name(Id : Exception","_","Id)","\n","        return Wide","_","Wide","_","String;","\n","\n",(0,r.jsx)(d.A,{children:"3/5_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00362-01","AI12-0399-1"]}),(0,r.jsxs)(n.p,{children:["type Exception","_","Occurrence is limited private","\n","        with Preelaborable","_","Initialization;","\n","    type Exception","_","Occurrence","_","Access is access all Exception","_","Occurrence;","\n","    Null","_","Occurrence : constant Exception","_","Occurrence;","\n","\n",(0,r.jsx)(d.A,{children:"4/3_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00329-01","AI05-0229-1"]}),(0,r.jsxs)(n.p,{children:["procedure Raise","_","Exception(E : in Exception","_","Id;","\n",'                              Message : in String := "")',"\n","        with No","_","Return;","\n","    function Exception","_","Message(X : Exception","_","Occurrence) return String;","\n","    procedure Reraise","_","Occurrence(X : in Exception","_","Occurrence);","\n","\n",(0,r.jsx)(d.A,{children:"5/2_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00400-01"]}),(0,r.jsxs)(n.p,{children:["function Exception","_","Identity(X : Exception","_","Occurrence)","\n","                                return Exception","_","Id;","\n","    function Exception","_","Name(X : Exception","_","Occurrence) return String;","\n","        -- Same as Exception","_","Name(Exception","_","Identity(X)).","\n","    function Wide","_","Exception","_","Name(X : Exception","_","Occurrence)","\n","        return Wide","_","String;","\n","        -- Same as Wide","_","Exception","_","Name(Exception","_","Identity(X)).","\n","    function Wide","_","Wide","_","Exception","_","Name(X : Exception","_","Occurrence)","\n","        return Wide","_","Wide","_","String;","\n","        -- Same as Wide","_","Wide","_","Exception","_","Name(Exception","_","Identity(X)).","\n","    function Exception","_","Information(X : Exception","_","Occurrence) return String;","\n","\n",(0,r.jsx)(d.A,{children:"6/2_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00438-01"]}),(0,r.jsxs)(n.p,{children:["procedure Save","_","Occurrence(Target : out Exception","_","Occurrence;","\n","                              Source : in Exception","_","Occurrence);","\n","    function Save","_","Occurrence(Source : Exception","_","Occurrence)","\n","                             return Exception","_","Occurrence","_","Access;","\n","\n",(0,r.jsx)(d.A,{children:"6.1/2_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00438-01"]}),(0,r.jsxs)(n.p,{children:["procedure Read","_","Exception","_","Occurrence","\n","       (Stream : not null access Ada.Streams.Root","_","Stream","_","Type'Class;","\n","        Item   : out Exception","_","Occurrence);","\n","    procedure Write","_","Exception","_","Occurrence","\n","       (Stream : not null access Ada.Streams.Root","_","Stream","_","Type'Class;","\n","        Item   : in Exception","_","Occurrence);","\n","\n",(0,r.jsx)(d.A,{children:"6.2/2_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00438-01"]}),(0,r.jsxs)(n.p,{children:["for Exception","_","Occurrence'Read use Read","_","Exception","_","Occurrence;","\n","    for Exception","_","Occurrence'Write use Write","_","Exception","_","Occurrence;","\n","\n",(0,r.jsx)(d.A,{children:"6.3/2_11.4.1"})]}),(0,r.jsx)(l.A,{items:["AI95-00438-01"]}),(0,r.jsxs)(n.p,{children:["private","\n","   ... -- not specified by the language","\n","end Ada.Exceptions;","\n"]})]}),"\n",(0,r.jsx)(d.A,{children:"7_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["Each distinct exception is represented by a distinct value of type Exception","_","Id. Null","_","Id does not represent any exception, and is the default initial value of type Exception","_","Id. Each occurrence of an exception is represented by a value of type Exception","_","Occurrence. Null","_","Occurrence does not represent any exception occurrence, and is the default initial value of type Exception","_","Occurrence.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"8/1_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["For a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," E that denotes an exception, the following attribute is defined: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"9_11.4.1"}),"\n",(0,r.jsxs)("dt",{children:[(0,r.jsx)("br",{}),"E'Identity"]}),"\n",(0,r.jsx)("dl",{children:(0,r.jsxs)("dd",{children:["E'Identity returns the unique identity of the exception. The type of this attribute is Exception","_","Id. ",(0,r.jsx)("br",{})]})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"9.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"In a distributed program, the identity is unique across an entire program, not just across a single partition. Exception propagation works properly across RPC's. An exception can be propagated from one partition to another, and then back to the first, where its identity is known. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"10/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00361-01"]}),"\n",(0,r.jsxs)("p",{children:["Raise","_","Exception raises a new occurrence of the identified exception.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"10.1/4_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00361-01","AI95-00378-01","AI05-0043-1","AI05-0248-1","AI12-0022-1","AI12-0152-1"]}),"\n",(0,r.jsxs)("p",{children:["Exception","_","Message returns the message associated with the given Exception","_","Occurrence. For an occurrence raised by a call to Raise","_","Exception, the message is the Message parameter passed to Raise","_","Exception. For the occurrence raised by a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})})," or ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0309",children:"raise_expression"})})," with an ",(0,r.jsxs)("i",{children:["exception","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," and a ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," or ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0138",children:"simple_expression"})}),", the message is the ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," or ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0138",children:"simple_expression"})}),". For the occurrence raised by a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})})," or ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0309",children:"raise_expression"})})," with an ",(0,r.jsxs)("i",{children:["exception","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0091",children:"name"})})," but without a ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," or ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0138",children:"simple_expression"})}),", the message is a string giving implementation-defined information about the exception occurrence. For an occurrence originally raised in some other manner (including by the failure of a language-defined check), the message is an unspecified string. In all cases, Exception","_","Message returns a string with lower bound 1. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The information returned by Exception","_","Message.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.a.1/3_11.4.1"}),(0,r.jsx)(l.A,{items:["AI05-0043-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"There is  about the contents of this string for language-defined checks. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.b_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Given an exception E, the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})}),": ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.c_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["raise E;","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.d_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["is equivalent to this call to Raise","_","Exception: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.e_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["Raise","_","Exception(E'Identity, Message =",">"," implementation-defined-string);","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.e.1/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00361-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Similarly, the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})}),": ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.e.2/2_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:['raise E with "some information";',"\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.e.3/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["is equivalent to this call to Raise","_","Exception: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.e.4/2_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["Raise","_","Exception(E'Identity, Message =",">",' "some information");',"\n"]})})]}),"\n",(0,r.jsx)(d.A,{children:"10.2/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00361-01"]}),"\n",(0,r.jsxs)("p",{children:["Reraise","_","Occurrence reraises the specified exception occurrence.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.f_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The following handler: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.g_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["when others =",">","\n","    Cleanup;","\n","    raise;","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.h_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["is equivalent to this one: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.i_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["when X : others =",">","\n","    Cleanup;","\n","    Reraise","_","Occurrence(X);","\n"]})})]}),"\n",(0,r.jsx)(d.A,{children:"11_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["Exception","_","Identity returns the identity of the exception of the occurrence.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"12/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00400-01"]}),"\n",(0,r.jsxs)("p",{children:["The Wide","_","Wide","_","Exception","_","Name functions return the full expanded name of the exception, in upper case, starting with a root library unit. For an exception declared immediately within package Standard, the ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:["defining","_","identifier"]})})," is returned. The result is implementation defined if the exception is declared within an unnamed ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.6#S0191",children:"block_statement"})}),". ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"12.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"See the Implementation Permission below. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"12.b_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"This name, as well as each ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," of it, does not denote a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-8/AA-8.5#S0238",children:"renaming_declaration"})}),". ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"12.c/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The result of Exceptions.Wide","_","Wide","_","Exception","_","Name for exceptions declared within an unnamed ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.6#S0191",children:"block_statement"})}),".",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"12.d_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Note that we're talking about the name of the exception, not the name of the occurrence. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"12.1/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00400-01"]}),"\n",(0,r.jsxs)("p",{children:["The Exception","_","Name functions (respectively, Wide","_","Exception","_","Name) return the same sequence of graphic characters as that defined for Wide","_","Wide","_","Exception","_","Name, if all the graphic characters are defined in Character (respectively, Wide","_","Character); otherwise, the sequence of characters is implementation defined, but no shorter than that returned by Wide","_","Wide","_","Exception","_","Name for the same value of the argument. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"12.e/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The sequence of characters of the value returned by Exceptions.Exception","_","Name (respectively, Exceptions.Wide","_","Exception","_","Name) when some of the graphic characters of Exceptions.Wide","_","Wide","_","Exception","_","Name are not defined in Character (respectively, Wide","_","Character).",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"12.2/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00378-01","AI95-00417-01"]}),"\n",(0,r.jsxs)("p",{children:["The string returned by the Exception","_","Name, Wide","_","Exception","_","Name, and Wide","_","Wide","_","Exception","_","Name functions has lower bound 1.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"13/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00378-01"]}),"\n",(0,r.jsxs)("p",{children:["Exception","_","Information returns implementation-defined information about the exception occurrence. The returned string has lower bound 1. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"13.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The information returned by Exception","_","Information.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"14/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00241-01","AI95-00446-01"]}),"\n",(0,r.jsxs)("p",{children:["Reraise","_","Occurrence has no effect in the case of Null","_","Occurrence. Raise","_","Exception and Exception","_","Name raise Constraint","_","Error for a Null","_","Id. Exception","_","Message, Exception","_","Name, and Exception","_","Information raise Constraint","_","Error for a Null","_","Occurrence. Exception","_","Identity applied to Null","_","Occurrence returns Null","_","Id.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"14.a.1/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00241-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Null","_","Occurrence can be tested for by comparing Exception","_","Identity(Occurrence) to Null","_","Id. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"14.a.2/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00446-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Raise","_","Exception was changed so that it always raises an exception and thus can be a No","_","Return procedure. A similar change was not made for Reraise","_","Occurrence, as doing so was determined to be a significant incompatibility. It is not unusual to pass an Exception","_","Occurrence to other code to delay raising it. If there was no exception, passing Null","_","Occurrence works fine (nothing is raised). Moreover, as there is no test for Null","_","Occurrence in Ada 95, this is the only way to write such code without using additional flags. Breaking this sort of code is unacceptable. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"15_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["The Save","_","Occurrence procedure copies the Source to the Target. The Save","_","Occurrence function uses an ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.8#S0164",children:"allocator"})})," of type Exception","_","Occurrence","_","Access to create a new object, copies the Source to this new object, and returns an access value designating this new object; [the result may be deallocated using an instance of Unchecked","_","Deallocation.] ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"15.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"It's OK to pass Null","_","Occurrence to the Save","_","Occurrence subprograms; they don't raise an exception, but simply save the Null","_","Occurrence. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"15.1/2_11.4.1"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00438-01"]}),"\n",(0,r.jsxs)("p",{children:["Write","_","Exception","_","Occurrence writes a representation of an exception occurrence to a stream; Read","_","Exception","_","Occurrence reconstructs an exception occurrence from a stream (including one written in a different partition). ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"15.b/5_11.4.1"}),(0,r.jsx)(l.A,{items:["AI12-0005-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"These routines are used to define the stream attributes (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.13#Subclause_13.13.2",children:"13.13.2"}),") for Exception","_","Occurrence.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"15.c/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The identity of the exception, as well as the Exception","_","Name and Exception","_","Message, have to be preserved across partitions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"15.d/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The string returned by Exception","_","Name or Exception","_","Message on the result of calling the Read attribute on a given stream has to be the same as the value returned by calling the corresponding function on the exception occurrence that was written into the stream with the Write attribute. The string returned by Exception","_","Information need not be the same, since it is implementation defined anyway. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"15.e/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This is important for supporting writing exception occurrences to external files for post-mortem analysis, as well as propagating exceptions across remote subprogram calls in a distributed system (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-E/AA-E.4",children:"E.4"}),"). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("i",{children:"Paragraph 16 was deleted."})," ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,r.jsx)(d.A,{children:"17_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["An implementation of Exception","_","Name in a space-constrained environment may return the ",(0,r.jsx)("code",{children:(0,r.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:["defining","_","identifier"]})})," instead of the full expanded name.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"18_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["The string returned by Exception","_","Message may be truncated (to no less than 200 characters) by the Save","_","Occurrence procedure [(not the function)], the Reraise","_","Occurrence procedure, and the re-raise statement. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"18.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The reason for allowing truncation is to ease implementations. The reason for choosing the number 200 is that this is the minimum source line length that implementations have to support, and this feature seems vaguely related since it's usually a \u201cone-liner\u201d. Note that an implementation is allowed to do this truncation even if it supports arbitrarily long lines. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-advice",children:"Implementation Advice"}),"\n",(0,r.jsx)(d.A,{children:"19_11.4.1"}),"\n",(0,r.jsxs)("p",{children:["Exception","_","Message (by default) and Exception","_","Information should produce information useful for debugging. Exception","_","Message should be short (about one line), whereas Exception","_","Information can be long. Exception","_","Message should not include the Exception","_","Name. Exception","_","Information should include both the Exception","_","Name and the Exception","_","Message.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.a.1/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Exception","_","Information should provide information useful for debugging, and should include the Exception","_","Name and Exception","_","Message.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.a.2/2_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-advice",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Exception","_","Message by default should be short, provide information useful for debugging, and should not include the Exception","_","Name.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"It may seem strange to define two subprograms whose semantics is implementation defined. The idea is that a program can print out debugging/error-logging information in a portable way. The program is portable in the sense that it will work in any implementation; it might print out different information, but the presumption is that the information printed out is appropriate for debugging/error analysis on that system. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.b_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"As an example, Exception","_","Information might include information identifying the location where the exception occurred, and, for predefined exceptions, the specific kind of language-defined check that failed. There is an implementation trade-off here, between how much information is represented in an Exception","_","Occurrence, and how much can be passed through a re-raise.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.c_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The string returned should be in a form suitable for printing to an error log file. This means that it might need to contain line-termination control characters with implementation-defined I/O semantics. The string should neither start nor end with a newline.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.d_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["If an implementation chooses to provide additional functionality related to exceptions and their occurrences, it should do so by providing one or more children of Ada.Exceptions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.e_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Note that exceptions behave as if declared at library level; there is no \u201cnatural scope\u201d for an exception; an exception always exists. Hence, there is no harm in saving an exception occurrence in a data structure, and reraising it later. The reraise has to occur as part of the same program execution, so saving an exception occurrence in a file, reading it back in from a different program execution, and then reraising it is not required to work. This is similar to I/O of access types. Note that it is possible to use RPC to propagate exceptions across partitions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.f_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Here's one way to implement Exception","_","Occurrence in the private part of the package. Using this method, an implementation need store only the actual number of characters in exception messages. If the user always uses small messages, then exception occurrences can be small. If the user never uses messages, then exception occurrences can be smaller still: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.g_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type Exception","_","Occurrence(Message","_","Length : Natural := 200) is","\n","    limited record","\n","        Id : Exception","_","Id;","\n","        Message : String(1..Message","_","Length);","\n","    end record;","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.h_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["At the point where an exception is raised, an Exception","_","Occurrence can be allocated on the stack with exactly the right amount of space for the message \u2014 none for an empty message. This is just like declaring a constrained object of the type: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.i_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["Temp : Exception","_","Occurrence(10); -- for a 10-character message","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.j_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["After finding the appropriate handler, the stack can be cut back, and the Temp copied to the right place. This is similar to returning an unknown-sized object from a function. It is not necessary to allocate the maximum possible size for every Exception","_","Occurrence. If, however, the user declares an Exception","_","Occurrence object, the discriminant will be permanently set to 200. The Save","_","Occurrence procedure would then truncate the Exception","_","Message. Thus, nothing is lost until the user tries to save the occurrence. If the user is willing to pay the cost of heap allocation, the Save","_","Occurrence function can be used instead.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.k_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Note that any arbitrary-sized implementation-defined Exception","_","Information can be handled in a similar way. For example, if the Exception","_","Occurrence includes a stack traceback, a discriminant can control the number of stack frames stored. The traceback would be truncated or entirely deleted by the Save","_","Occurrence procedure \u2014 as the implementation sees fit.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.l_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["If the internal representation involves pointers to data structures that might disappear, it would behoove the implementation to implement it as a controlled type, so that assignment can either copy the data structures or else null out the pointers. Alternatively, if the data structures being pointed at are in a task control block, the implementation could keep a unique sequence number for each task, so it could tell when a task's data structures no longer exist.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.m_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Using the above method, heap space is never allocated unless the user calls the Save","_","Occurrence function.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.n_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["An alternative implementation would be to store the message strings on the heap when the exception is raised. (It could be the global heap, or it could be a special heap just for this purpose \u2014 it doesn't matter.)  This representation would be used only for choice parameters. For normal user-defined exception occurrences, the Save","_","Occurrence procedure would copy the message string into the occurrence itself, truncating as necessary. Thus, in this implementation, Exception","_","Occurrence would be implemented as a variant record: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.o_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["type Exception","_","Occurrence","_","Kind is (Normal, As","_","Choice","_","Param);","\n","\n",(0,r.jsx)(d.A,{children:"19.p_11.4.1"}),"\ntype Exception","_","Occurrence(Kind : Exception","_","Occurrence","_","Kind := Normal) is","\n","    limited record","\n","        case Kind is","\n","            when Normal =",">","\n","                ... -- space for 200 characters","\n","            when As","_","Choice","_","Param =",">","\n","                ... -- pointer to heap string","\n","        end case;","\n","    end record;","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.q_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Exception","_","Occurrences created by the run-time system during exception raising would be As","_","Choice","_","Param. User-declared ones would be Normal \u2014 the user cannot see the discriminant, and so cannot set it to As","_","Choice","_","Param. The strings in the heap would be freed upon completion of the handler.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.r_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["This alternative implementation corresponds to a heap-based implementation of functions returning unknown-sized results.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.s_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["One possible implementation of Reraise","_","Occurrence is as follows: ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.t_11.4.1"}),(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["procedure Reraise","_","Occurrence(X : in Exception","_","Occurrence) is","\n","begin","\n","    Raise","_","Exception(Identity(X), Exception","_","Message(X));","\n","end Reraise","_","Occurrence;","\n"]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.u_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["However, some implementations may wish to retain more information across a re-raise \u2014 a stack traceback, for example. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.v_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Note that Exception","_","Occurrence is a definite subtype. Hence, values of type Exception","_","Occurrence may be written to an error log for later analysis, or may be passed to subprograms for immediate error analysis. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"19.w/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00400-01"]}),(0,r.jsxs)(t.A,{type:"aarm",aarm:"note",children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20/5_11.4.1"}),(0,r.jsx)(l.A,{items:["AI12-0021-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE   UTF-8 encoding (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-A/AA-A.4#Subclause_A.4.11",children:"A.4.11"}),") can be used to represent non-ASCII characters in exception messages. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.a_11.4.1"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The Identity attribute of exceptions is new, as is the package Exceptions. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"inconsistencies-with-ada-95",children:"Inconsistencies With Ada 95"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.b/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00241-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"Amendment "})," Exception","_","Identity of an Exception","_","Occurrence now is defined to return Null","_","Id for Null","_","Occurrence, rather than raising Constraint","_","Error. This provides a simple way to test for Null","_","Occurrence. We expect that programs that need Constraint","_","Error raised will be very rare; they can be easily fixed by explicitly testing for Null","_","Id or by using Exception","_","Name instead.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.c/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00378-01","AI95-00417-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"Amendment "})," We now define the lower bound of the string returned from [[Wide","_","]Wide","_","]Exception","_","Name, Exception","_","Message, and Exception","_","Information. This makes working with the returned string easier, and is consistent with many other string-returning functions in Ada. This is technically an inconsistency; if a program depended on some other lower bound for the string returned from one of these functions, it could fail when compiled with Ada 2005. Such code is not portable even between Ada 95 implementations, so it should be very rare.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.d/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00446-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"Amendment "})," Raise","_","Exception now raises Constraint","_","Error if passed Null","_","Id. This means that it always raises an exception, and thus we can apply pragma No","_","Return to it. We expect that programs that call Raise","_","Exception with Null","_","Id will be rare, and programs that do that and expect no exception to be raised will be rarer; such programs can be easily fixed by explicitly testing for Null","_","Id before calling Raise","_","Exception. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"incompatibilities-with-ada-95",children:"Incompatibilities With Ada 95"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.e/3_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00400-01","AI95-00438-01","AI05-0005-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Functions Wide","_","Exception","_","Name and Wide","_","Wide","_","Exception","_","Name, and procedures Read","_","Exception","_","Occurrence and Write","_","Exception","_","Occurrence are added to Exceptions. If Exceptions is referenced in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", and an entity ",(0,r.jsx)("i",{children:"E"})," with the same ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," as a new entity in Exceptions is defined in a package that is also referenced in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", the entity ",(0,r.jsx)("i",{children:"E"})," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.f/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00362-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The package Exceptions is preelaborated, and types Exception","_","Id and Exception","_","Occurrence have preelaborable initialization, allowing this package to be used in preelaborated units. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.g/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00361-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The meaning of Exception","_","Message is reworded to reflect that the string can come from a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})})," as well as a call of Raise","_","Exception.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.h/2_11.4.1"}),(0,r.jsx)(l.A,{items:["AI95-00400-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Added Wide","_","Exception","_","Name and Wide","_","Wide","_","Exception","_","Name because identifiers can now contain characters outside of Latin-1. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"20.i/3_11.4.1"}),(0,r.jsx)(l.A,{items:["AI05-0043-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{})," Added explicit wording that the exception message for language-defined checks is unspecified. The old wording appeared inclusive, but it was not. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_11.4.2"}),"\n",(0,r.jsx)(n.h2,{id:"1142--pragmas-assert-and-assertion_policy",children:"11.4.2  Pragmas Assert and Assertion_Policy"}),"\n",(0,r.jsx)(d.A,{children:"1/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0274-1"]}),"\n",(0,r.jsxs)("p",{children:["Pragma Assert is used to assert the truth of a boolean expression at a point within a sequence of declarations or statements.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"1.1/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0274-1","AI12-0265-1"]}),"\n",(0,r.jsxs)("p",{children:["Assert pragmas, subtype predicates (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.4",children:"3.2.4"}),"), preconditions and postconditions (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"6.1.1"}),"), type invariants (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#Subclause_7.3.2",children:"7.3.2"}),"), and default initial conditions (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#Subclause_7.3.3",children:"7.3.3"}),") are collectively referred to as ",(0,r.jsx)("i",{children:"assertions"}),"; their boolean expressions are referred to as ",(0,r.jsx)("i",{children:"assertion expressions"}),".",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"1.a/5_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"Term entry: "}),(0,r.jsx)("b",{children:"assertion"})," \u2014 boolean expression that is expected to be True at run time at certain specified places",(0,r.jsx)("br",{}),"Note: Certain pragmas and aspects define various kinds of assertions.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"1.2/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0274-1"]}),"\n",(0,r.jsxs)("p",{children:["Pragma Assertion","_","Policy is used to control whether assertions are to be ignored by the implementation, checked at run time, or handled in some implementation-defined manner. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(d.A,{children:"2/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["The form of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert is as follows: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"3/2_11.4.2"}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["  ",(0,r.jsx)("b",{children:"pragma"})," Assert([Check =",">","] ",(0,r.jsxs)("i",{children:["boolean","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),"[, [Message =",">","] ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),"]);",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"4/2_11.4.2"}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert is allowed at the place where a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.11#S0087",children:"declarative_item"})})," or a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0167",children:"statement"})})," is allowed.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"5/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["The form of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy is as follows: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"6/2_11.4.2"}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["  ",(0,r.jsx)("b",{children:"pragma"})," Assertion","_","Policy(",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),");",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"6.1/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["  ",(0,r.jsx)("b",{children:"pragma"})," Assertion","_","Policy(",(0,r.jsx)("br",{}),"         ",(0,r.jsxs)("i",{children:["assertion","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})})," =",">"," ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),(0,r.jsx)("br",{}),"     ","{",", ",(0,r.jsxs)("i",{children:["assertion","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})})," =",">"," ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"}",");",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"7/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{class:"Indented2",children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy is allowed only immediately within a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.11#S0086",children:"declarative_part"})}),", immediately within a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})}),", or as a configuration pragma.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,r.jsx)(d.A,{children:"8/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["The expected type for the ",(0,r.jsxs)("i",{children:["boolean","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert is any boolean type. The expected type for the ",(0,r.jsxs)("i",{children:["string","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert is type String. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"8.a/2_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"We allow any boolean type to be like ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.3#S0175",children:"if_statement"})}),"s and other conditionals; we only allow String for the message in order to match ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0308",children:"raise_statement"})}),"s. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,r.jsx)(d.A,{children:"9/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0290-1","AI12-0265-1","AI12-0396-1"]}),"\n",(0,r.jsxs)("p",{children:["The ",(0,r.jsxs)("i",{children:["assertion","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})})," of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy shall identify an ",(0,r.jsx)("i",{children:"assertion aspect"}),", namely one of Assert, Static","_","Predicate, Dynamic","_","Predicate, Pre, Pre'Class, Post, Post'Class, Type","_","Invariant, Type","_","Invariant'Class, Default","_","Initial","_","Condition, or some implementation-defined (assertion) ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})}),". The ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," shall be either Check, Ignore, or some implementation-defined ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),". ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"9.a/3_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"Implementation-defined ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),"s and ",(0,r.jsxs)("i",{children:["assertion","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})}),"s allowed in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"9.b/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0396-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"\u201cAssert\u201d is considered an \u201cassertion aspect\u201d for the purposes of this rule, even though there is no sort of entity that has an Assert aspect. It can only be specified using an Assert pragma, and applies to a particular point in the execution of a logical thread of control. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,r.jsx)(d.A,{children:"10/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy determines for each assertion aspect named in the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0020",children:"pragma_argument_association"})}),"s whether assertions of the given aspect are to be enforced by a runtime check. The ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," Check requires that assertion expressions of the given aspect be checked that they evaluate to True at the points specified for the given aspect; the ",(0,r.jsxs)("i",{children:["policy","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})})," Ignore requires that the assertion expression not be evaluated at these points, and the runtime checks not be performed. [Note that for subtype predicate aspects (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.4",children:"3.2.4"}),"), even when the applicable Assertion","_","Policy is Ignore, the predicate will still be evaluated as part of membership tests and Valid ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0100",children:"attribute_reference"})}),"s, and if static, will still have an effect on loop iteration over the subtype, and the selection of ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-5/AA-5.4#S0177",children:"case_statement_alternative"})}),"s and ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.8#S0072",children:"variant"})}),"s.]",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"10.1/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["If no ",(0,r.jsxs)("i",{children:["assertion","_"]}),(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.1#S0347",children:"aspect_mark"})}),"s are specified in the pragma, the specified policy applies to all assertion aspects.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"10.2/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1","AI12-0396-1"]}),"\n",(0,r.jsxs)("p",{children:["A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy applies to the named assertion aspects in a specific region, and applies to all assertion expressions associated with those aspects specified in that region. A ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy given in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.11#S0086",children:"declarative_part"})})," or immediately within a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.1#S0230",children:"package_specification"})})," applies from the place of the pragma to the end of the innermost enclosing declarative region. The region for a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy given as a configuration pragma is the declarative region for the entire compilation unit (or units) to which it applies.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"10.3/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["If a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy applies to a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),", then the ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy applies to the entire instance.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.a.1/3_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This means that an Assertion","_","Policy pragma that occurs in a scope enclosing the declaration of a generic unit but not also enclosing the declaration of a given instance of that generic unit will not apply to assertion expressions occurring within the given instance. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"10.4/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["If multiple Assertion","_","Policy pragmas apply to a given construct for a given assertion aspect, the assertion policy is determined by the one in the innermost enclosing region of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assertion","_","Policy specifying a policy for the assertion aspect. If no such Assertion","_","Policy pragma exists, the policy is implementation defined.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"10.a/2_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"implementation-defined",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The default assertion policy.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"11/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["The following language-defined library package exists:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"12/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0414-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["package Ada.Assertions","\n","    with Pure is","\n","\n",(0,r.jsx)(d.A,{children:"13/2_11.4.2"}),"\nAssertion","_","Error : exception;","\n","\n",(0,r.jsx)(d.A,{children:"14/2_11.4.2"}),"\nprocedure Assert(Check : in Boolean);","\n","   procedure Assert(Check : in Boolean; Message : in String);","\n","\n",(0,r.jsx)(d.A,{children:"15/2_11.4.2"}),"\nend Ada.Assertions;","\n"]})}),"\n",(0,r.jsx)(d.A,{children:"16/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["A compilation unit containing a check for an assertion (including a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert) has a semantic dependence on the Assertions library unit.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"17/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:[(0,r.jsx)("i",{children:"This paragraph was deleted."}),(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"dynamic-semantics-1",children:"Dynamic Semantics"}),"\n",(0,r.jsx)(d.A,{children:"18/3_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01","AI05-0290-1"]}),"\n",(0,r.jsxs)("p",{children:["If performing checks is required by the Assert assertion policy in effect at the place of a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert, the elaboration of the pragma consists of evaluating the boolean expression, and if the result is False, evaluating the Message argument, if any, and raising the exception Assertions.Assertion","_","Error, with a message if the Message argument is provided.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"19/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["Calling the procedure Assertions.Assert without a Message parameter is equivalent to:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"20/2_11.4.2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["if Check = False then","\n","   raise Ada.Assertions.Assertion","_","Error;","\n","end if;","\n"]})}),"\n",(0,r.jsx)(d.A,{children:"21/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["Calling the procedure Assertions.Assert with a Message parameter is equivalent to:",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"22/2_11.4.2"}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["if Check = False then","\n","   raise Ada.Assertions.Assertion","_","Error with Message;","\n","end if;","\n"]})}),"\n",(0,r.jsx)(d.A,{children:"23/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["The procedures Assertions.Assert have these effects independently of the assertion policy in effect.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"bounded-run-time-errors",children:"Bounded (Run-Time) Errors"}),"\n",(0,r.jsx)(d.A,{children:"23.1/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0274-1","AI12-0439-1"]}),"\n",(0,r.jsxs)("p",{children:["It is a bounded error to invoke a potentially blocking operation (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#Subclause_9.5.1",children:"9.5.1"}),") during the evaluation of an assertion expression associated with a call on, or return from, a protected operation. If the bounded error is detected, Program","_","Error is raised. If not detected, execution proceeds normally, but if it is invoked within a protected action, it can result in deadlock or a (nested) protected action. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,r.jsx)(d.A,{children:"23.2/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0179-1","AI12-0265-1"]}),"\n",(0,r.jsxs)("p",{children:["Any postcondition expression, type invariant expression, or default initial condition expression occurring in the specification of a language-defined unit is enabled (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"6.1.1"}),", ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#Subclause_7.3.2",children:"7.3.2"}),", and ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#Subclause_7.3.3",children:"7.3.3"}),").",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"23.a/5_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The Assertion","_","Policy does not have an effect on such postconditions, invariants, and default initial conditions. This has no execution impact since such assertions shouldn't fail anyway (see the next rule). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"23.3/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0179-1","AI12-0265-1"]}),"\n",(0,r.jsxs)("p",{children:["The evaluation of any such postcondition, type invariant, or default initial condition expression shall either yield True or propagate an exception from a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0309",children:"raise_expression"})})," that appears within the assertion expression.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"23.b/5_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"In other words, evaluating such an assertion expression will not return a result of False, nor will it propagate an exception other than by evaluating a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.3#S0309",children:"raise_expression"})})," which is syntactically all or part of the assertion expression. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"23.c/5_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{children:"To be honest: "}),"Evaluation of any expression might raise Storage","_","Error. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"23.d/5_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This allows the Reference Manual to express semantic requirements as postconditions, invariants, or default initial conditions (which are invariably clearer than English prose would be) while keeping it clear that failing the assertion check (or any other run time check) is not conforming behavior. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"23.4/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0112-1"]}),"\n",(0,r.jsxs)("p",{children:["Any precondition expression occurring in the specification of a language-defined unit is enabled (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-6/AA-6.1#Subclause_6.1.1",children:"6.1.1"}),") unless suppressed (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-11/AA-11.5",children:"11.5"}),"). Similarly, any predicate checks for a subtype occurring in the specification of a language-defined unit are enabled (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#Subclause_3.2.4",children:"3.2.4"}),") unless suppressed.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"23.e/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0005-1","AI12-0112-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This allows the Reference Manual to express runtime requirements on the client of a language-defined unit as preconditions or predicates (which are clearer than English prose would be). Some such requirements can be suppressed with pragma Suppress. Ada 2012 and earlier versions did not provide a mechanism to suppress such code. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"implementation-permissions-1",children:"Implementation Permissions"}),"\n",(0,r.jsx)(d.A,{children:"24/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["Assertion","_","Error may be declared by renaming an implementation-defined exception from another package. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"24.a/2_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This permission is intended to allow implementations which had an implementation-defined Assert pragma to continue to use their originally defined exception. Without this permission, such an implementation would be incorrect, as Exception","_","Name would return the wrong name. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"25/2_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),"\n",(0,r.jsxs)("p",{children:["Implementations may define their own assertion policies.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"26/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0274-1","AI12-0445-1"]}),"\n",(0,r.jsxs)("p",{children:["If the result of a function call in an assertion is not used to determine the value of the assertion expression, an implementation is permitted to omit the function call. [This permission applies even if the function has side effects.]",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"27/5_11.4.2"}),"\n",(0,r.jsx)(l.A,{items:["AI05-0274-1","AI12-0444-1"]}),"\n",(0,r.jsxs)("p",{children:["An implementation may disallow the specification of an assertion expression if the evaluation of the expression has a side effect such that an immediate reevaluation of the expression can produce a different value. Similarly, an implementation may disallow the specification of an assertion expression that is checked as part of a call on or return from a callable entity ",(0,r.jsx)("i",{children:"C"}),", if the evaluation of the expression has a side effect such that the evaluation of some other assertion expression associated with the same call of (or return from) ",(0,r.jsx)("i",{children:"C"})," can produce a different value than in the case when the first expression had not been evaluated. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"27.a/3_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"ramification",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This allows an implementation to reject such assertions. To maximize portability, assertions should not include expressions that contain these sorts of side effects. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"27.b/3_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"discussion",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The intended effect of the second part of the rule (the part starting with \u201cSimilarly\u201d) is that an evaluation of the involved assertion expressions (subtype predicates, type invariants, preconditions and postconditions) in any order yields identical results.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"27.c/3_11.4.2"}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The rule is intended to apply to all of the assertion expressions that are evaluated at the start of call (and similarly for the assertion expressions that are evaluated during the return from a call), but not other assertions actually given in the body, nor between the assertions checked at the start and end of the call. Specifically, a side effect that alters a variable in a function called from a precondition expression that changes the result of a postcondition expression of the same subprogram does ",(0,r.jsx)("i",{children:"not"})," trigger these rules unless it also changes the value of a reevaluation of the precondition expression. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(n.h4,{id:"language-design-principles",children:"Language Design Principles"}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"27.d/4_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0005-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Our intent is that any assertion expression that violates this Implementation Permission is considered pathological. We definitely want compilers to be able to assume that if you evaluate an assertion expression once and it is True, you don't need to evaluate it again if all you are doing in the meantime is evaluating assertion expressions. We were unable to find wording that had this effect that didn't throw out important other cases (logging, memo functions), so we settled for a strong warning that compilers can reject such pathologies. Perhaps in a future version of Ada we'll be able to tighten this up. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI95-00286-01","AI12-0442-1","AI12-0447-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["NOTE   Normally, the boolean expression in a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert should not call functions that have significant side effects when the result of the expression is True, so that the particular assertion policy in effect will not affect normal operation of the program. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-95-1",children:"Extensions to Ada 95"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.a/2_11.4.2"}),(0,r.jsx)(l.A,{items:["AI95-00286-01"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Pragmas Assert and Assertion","_","Policy, and package Assertions are new. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"incompatibilities-with-ada-2005",children:"Incompatibilities With Ada 2005"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.b/3_11.4.2"}),(0,r.jsx)(l.A,{items:["AI05-0274-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["There now is an Implementation Permission to reject an assertion expression that calls a function that has a side effect such that an immediate reevalution of the expression could produce a different value. This means that a ",(0,r.jsx)("code",{children:(0,r.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})})," Assert that works in Ada 2005 might be illegal in Ada 2012 in the unlikely event that the compiler detected such an error. This should be unlikely to occur in practice and it is considered a good thing, as the original expression was tricky and probably was not portable (as order of evaluation is unspecified within an expression). Moreover, no compiler is ",(0,r.jsx)("i",{children:"required"})," to reject such expressions, so there is no need for any compiler to change behavior. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.c/3_11.4.2"}),(0,r.jsx)(l.A,{items:["AI05-0290-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Assertion","_","Policy pragmas are now allowed in more places and can specify behavior for individual kinds of assertions. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.d/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0112-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Added wording that preconditions and predicates given on language-defined units are always checked unless suppressed (that is, they act like language-defined checks). This is not considered an inconsistency, since there are no such preconditions or predicates in Ada 2012.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.e/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0179-1","AI12-0265-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{})," Added wording that postconditions, type invariants, and default initial conditions given on language-defined units cannot fail. This is not considered an inconsistency, since there are no such postconditions, invariants, or default initial conditions in Ada 2012.",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.f/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0265-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["Added default initial conditions to the kinds of assertions (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-7/AA-7.3#Subclause_7.3.3",children:"7.3.3"}),").",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"28.g/5_11.4.2"}),(0,r.jsx)(l.A,{items:["AI12-0396-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"correction",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{})," Added a definition of assertion aspects, used in some freezing rules (see ",(0,r.jsx)("a",{href:"/docs/arm/AA-13/AA-13.14",children:"13.14"}),"). ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)("a",{id:"Subclause_11.4.3"}),"\n",(0,r.jsx)(n.h2,{id:"1143--example-of-exception-handling",children:"11.4.3  Example of Exception Handling"}),"\n",(0,r.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(d.A,{children:"1/5_11.4.3"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0440-1"]}),"\n",(0,r.jsxs)("p",{children:["Exception handling can be used to separate the detection of an error from the response to that error: ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(d.A,{children:"2/5_11.4.3"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00433-01","AI12-0178-1"]}),"\n",(0,r.jsxs)(o.A,{language:"ada",children:[(0,r.jsxs)(n.p,{children:["package File","_","System is","\n","    type Data","_","Type is ...;","\n","    type File","_","Handle is limited private;","\n","\n",(0,r.jsx)(d.A,{children:"3_11.4.3"}),"\nFile","_","Not","_","Found : exception;","\n","    procedure Open(F : in out File","_","Handle; Name : String);","\n","        -- raises File","_","Not","_","Found if named file does not exist","\n","\n",(0,r.jsx)(d.A,{children:"4_11.4.3"}),"\nEnd","_","Of","_","File : exception;","\n","    procedure Read(F : in out File","_","Handle; Data : out Data","_","Type);","\n","        -- raises End","_","Of","_","File if the file is not open","\n","\n",(0,r.jsx)(d.A,{children:"5/5_11.4.3"})]}),(0,r.jsx)(l.A,{items:["AI12-0178-1"]}),(0,r.jsxs)(n.p,{children:["...","\n","private","\n","    ...","\n","end File","_","System;","\n"]})]}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"5.a/5_11.4.3"}),(0,r.jsx)(l.A,{items:["AI12-0178-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"The first ... provides a place for Close to be declared, and the second ... provides a place for File","_","Handle to be completed. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"5.1/5_11.4.3"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0178-1"]}),"\n",(0,r.jsx)(o.A,{language:"ada",children:(0,r.jsxs)(n.p,{children:["package body File","_","System is","\n","    ...","\n"]})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"5.b/5_11.4.3"}),(0,r.jsx)(l.A,{items:["AI12-0178-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"reason",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("b",{}),"This ... provides a place for File","_","Exists and the body of Close to be declared. ",(0,r.jsx)("br",{})]})})]}),"\n",(0,r.jsx)(d.A,{children:"6/5_11.4.3"}),"\n",(0,r.jsx)(l.A,{items:["AI95-00433-01","AI12-0178-1"]}),"\n",(0,r.jsxs)(o.A,{language:"ada",children:[(0,r.jsxs)(n.p,{children:["procedure Open(F : in out File","_","Handle; Name : String) is","\n","    begin","\n","        if File","_","Exists(Name) then","\n","            ...","\n","        else","\n","            raise File","_","Not","_",'Found with "File not found: " & Name & ".";',"\n","        end if;","\n","    end Open;","\n","\n",(0,r.jsx)(d.A,{children:"7_11.4.3"}),"\nprocedure Read(F : in out File","_","Handle; Data : out Data","_","Type) is","\n","    begin","\n","        if F.Current","_","Position ","<","= F.Last","_","Position then","\n","            ...","\n","        else","\n","            raise End","_","Of","_","File;","\n","        end if;","\n","    end Read;","\n","\n",(0,r.jsx)(d.A,{children:"8_11.4.3"}),"\n...","\n","\n",(0,r.jsx)(d.A,{children:"9_11.4.3"}),"\nend File","_","System;","\n","\n",(0,r.jsx)(d.A,{children:"10/5_11.4.3"})]}),(0,r.jsx)(l.A,{items:["AI12-0178-1"]}),(0,r.jsxs)(n.p,{children:["with Ada.Text","_","IO;","\n","with Ada.Exceptions;","\n","with File","_","System; use File","_","System;","\n","use Ada;","\n","procedure Main is","\n","    Verbosity","_","Desired : Boolean := ...;","\n","begin","\n","    ... -- call operations in File","_","System","\n","exception","\n","    when End","_","Of","_","File =",">","\n","        Close(Some","_","File);","\n","    when Not","_","Found","_","Error : File","_","Not","_","Found =",">","\n","        Text","_","IO.Put","_","Line(Exceptions.Exception","_","Message(Not","_","Found","_","Error));","\n","    when The","_","Error : others =",">","\n","        Text","_","IO.Put","_",'Line("Unknown error:");',"\n","        if Verbosity","_","Desired then","\n","            Text","_","IO.Put","_","Line(Exceptions.Exception","_","Information(The","_","Error));","\n","        else","\n","            Text","_","IO.Put","_","Line(Exceptions.Exception","_","Name(The","_","Error));","\n","            Text","_","IO.Put","_","Line(Exceptions.Exception","_","Message(The","_","Error));","\n","        end if;","\n","        raise;","\n","end Main;","\n"]})]}),"\n",(0,r.jsx)(d.A,{children:"11/5_11.4.3"}),"\n",(0,r.jsx)(l.A,{items:["AI12-0440-1"]}),"\n",(0,r.jsxs)("p",{children:["In the above example, the File","_","System package contains information about detecting certain exceptional situations, but it does not specify how to handle those situations. Procedure Main specifies how to handle them; other clients of File","_","System can have different handlers, even though the exceptional situations arise from the same basic causes. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(c.A,{children:(0,r.jsx)(n.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,r.jsxs)(c.A,{children:[(0,r.jsx)(d.A,{children:"11.a/3_11.4.3"}),(0,r.jsx)(l.A,{items:["AI05-0299-1"]}),(0,r.jsx)(t.A,{type:"aarm",aarm:"note",children:(0,r.jsxs)(n.p,{children:["The sections labeled \u201cExceptions Raised During ...\u201d are subsumed by this subclause, and by parts of Clause ",(0,r.jsx)("a",{href:"/docs/arm/AA-9/",children:"9"}),". ",(0,r.jsx)("br",{})]})})]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}}}]);