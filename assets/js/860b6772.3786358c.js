"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8137],{15854:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>h,default:()=>A,frontMatter:()=>c,metadata:()=>x,toc:()=>m});var i=n(74848),a=n(28453),s=n(13842),r=n(91435),o=n(21432),l=n(79162),d=n(34421);const c={sidebar_position:153},h="C.7 Task Information",x={id:"arm/AA-C/AA-C.7",title:"C.7 Task Information",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-C/AA-C.7.mdx",sourceDirName:"arm/AA-C",slug:"/arm/AA-C/AA-C.7",permalink:"/docs/arm/AA-C/AA-C.7",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:153,frontMatter:{sidebar_position:153},sidebar:"referenceManualSidebar",previous:{title:"C.6 Shared Variable Control",permalink:"/docs/arm/AA-C/AA-C.6"},next:{title:"Annex D Real-Time Systems",permalink:"/docs/arm/AA-D/"}},u={},m=[{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"C.7.1  The Package Task_Identification",id:"c71--the-package-task_identification",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"C.7.2  The Package Task_Attributes",id:"c72--the-package-task_attributes",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Documentation Requirements",id:"documentation-requirements-1",level:4},{value:"Metrics",id:"metrics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"C.7.3  The Package Task_Termination",id:"c73--the-package-task_termination",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Erroneous Execution",id:"erroneous-execution-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}];function j(e){const t={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"c7-task-information",children:"C.7 Task Information"}),"\n",(0,i.jsx)(t.admonition,{type:"danger",children:(0,i.jsxs)(t.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,i.jsx)(t.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,i.jsx)(l.A,{children:"1/3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0299-1"]}),"\n",(0,i.jsxs)("p",{children:["[This subclause describes operations and attributes that can be used to obtain the identity of a task. In addition, a package that associates user-defined information with a task is defined. Finally, a package that associates termination procedures with a task or set of tasks is defined.] ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"1.a/3"}),(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0299-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["The title and text here were updated to reflect the addition of task termination procedures to this subclause. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)("a",{id:"Subclause_C.7.1"}),"\n",(0,i.jsx)(t.h2,{id:"c71--the-package-task_identification",children:"C.7.1  The Package Task_Identification"}),"\n",(0,i.jsx)(t.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,i.jsx)(l.A,{children:"1_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["The following language-defined library package exists: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"2/5_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00362-01","AI12-0241-1","AI12-0302-1","AI12-0399-1"]}),"\n",(0,i.jsxs)(o.A,{language:"ada",children:[(0,i.jsxs)(t.p,{children:["package Ada.Task","_","Identification","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","   type Task","_","Id is private","\n","      with Preelaborable","_","Initialization;","\n","   Null","_","Task","_","Id : constant Task","_","Id;","\n",'   function  "=" (Left, Right : Task',"_","Id) return Boolean;","\n","\n",(0,i.jsx)(l.A,{children:"3/5_C.7.1"})]}),(0,i.jsx)(d.A,{items:["AI95-00101-01","AI05-0189-1","AI12-0241-1"]}),(0,i.jsxs)(t.p,{children:["{","8652/0070","}","    function  Image                  (T : Task","_","Id) return String;","\n","   function  Current","_","Task     return Task","_","Id;","\n","   function  Environment","_","Task return Task","_","Id;","\n","   procedure Abort","_","Task             (T : in Task","_","Id)","\n","      with Nonblocking =",">"," False;","\n","\n",(0,i.jsx)(l.A,{children:"4/3_C.7.1"})]}),(0,i.jsx)(d.A,{items:["AI05-0189-1"]}),(0,i.jsxs)(t.p,{children:["function  Is","_","Terminated          (T : Task","_","Id) return Boolean;","\n","   function  Is","_","Callable            (T : Task","_","Id) return Boolean;","\n","   function  Activation","_","Is","_","Complete (T : Task","_","Id) return Boolean;","\n","private","\n","   ... -- not specified by the language","\n","end Ada.Task","_","Identification;","\n"]})]}),"\n",(0,i.jsx)(t.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,i.jsx)(l.A,{children:"5_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["A value of the type Task","_","Id identifies an existent task. The constant Null","_","Task","_","Id does not identify any task. Each object of the type Task","_","Id is default initialized to the value of Null","_","Task","_","Id.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"6_C.7.1"}),"\n",(0,i.jsxs)("p",{children:['The function "=" returns True if and only if Left and Right identify the same task or both have the value Null',"_","Task","_","Id.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"7_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["The function Image returns an implementation-defined string that identifies T. If T equals Null","_","Task","_","Id, Image returns an empty string. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"7.a_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"The result of the Task","_","Identification.Image attribute.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"8_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["The function Current","_","Task returns a value that identifies the calling task.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"8.a.1/5_C.7.1"}),(0,i.jsx)(d.A,{items:["AI12-0005-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"The logical threads of control associated with the execution of a given parallel construct all execute as part of the execution of one task (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-9/",children:"9"}),", \u201c",(0,i.jsx)("a",{href:"/docs/arm/AA-9/",children:"Tasks and Synchronization"}),"\u201d). Thus, the result returned by a call to Task","_","Identification.Current","_","Task is independent of whether the call takes place during the execution of a parallel construct. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"8.1/3_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI05-0189-1"]}),"\n",(0,i.jsxs)("p",{children:["The function Environment","_","Task returns a value that identifies the environment task.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"9/5_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0454-1"]}),"\n",(0,i.jsxs)("p",{children:["The effect of Abort","_","Task is the same as the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.8#S0284",children:"abort_statement"})})," for the task identified by T. [In addition, if T identifies the environment task, the entire partition is aborted, see ",(0,i.jsx)("a",{href:"/docs/arm/AA-E/AA-E.1",children:"E.1"}),".]",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"10_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["The functions Is","_","Terminated and Is","_","Callable return the value of the corresponding attribute of the task identified by T. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"10.a.1/1_C.7.1"}),(0,i.jsx)(d.A,{items:["AI95-00206-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"{",(0,i.jsx)("em",{children:"8652/0115"}),"}"," These routines can be called with an argument identifying the environment task. Is","_","Terminated will always be False for such a call, but Is","_","Callable (usually True) could be False if the environment task is waiting for the termination of dependent tasks. Thus, a dependent task can use Is","_","Callable to determine if the main subprogram has completed. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"10.1/3_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI05-0189-1"]}),"\n",(0,i.jsxs)("p",{children:["The function Activation","_","Is","_","Complete returns True if the task identified by T has completed its activation (whether successfully or not). It returns False otherwise. If T identifies the environment task, Activation","_","Is","_","Complete returns True after the elaboration of the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0287",children:"library_item"})}),"s of the partition has completed.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"11_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["For a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," T that is of a task type [(after any implicit dereference)], the following attribute is defined: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"12_C.7.1"}),"\n",(0,i.jsxs)("dt",{children:[(0,i.jsx)("br",{}),"T'Identity"]}),"\n",(0,i.jsx)("dl",{children:(0,i.jsxs)("dd",{children:["Yields a value of the type Task","_","Id that identifies the task denoted by T.",(0,i.jsx)("br",{})]})}),"\n",(0,i.jsx)(l.A,{children:"13_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["For a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0093",children:"prefix"})})," E that denotes an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0257",children:"entry_declaration"})}),", the following attribute is defined: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"14/3_C.7.1"}),"\n",(0,i.jsxs)("dt",{children:[(0,i.jsx)("br",{}),"E'Caller"]}),"\n",(0,i.jsx)(d.A,{items:["AI05-0262-1"]}),"\n",(0,i.jsx)("dl",{children:(0,i.jsxs)("dd",{children:["Yields a value of the type Task","_","Id that identifies the task whose call is now being serviced. Use of this attribute is allowed only inside an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0258",children:"accept_statement"})}),", or ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0260",children:"entry_body"})})," after the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0262",children:"entry_barrier"})}),", corresponding to the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0257",children:"entry_declaration"})})," denoted by E. ",(0,i.jsx)("br",{})]})}),"\n",(0,i.jsx)(l.A,{children:"15/5_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0231-1"]}),"\n",(0,i.jsxs)("p",{children:["Program","_","Error is raised if a value of Null","_","Task","_","Id is passed as a parameter to Abort","_","Task, Activation","_","Is","_","Complete, Is","_","Terminated, and Is","_","Callable.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"16/5_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0241-1"]}),"\n",(0,i.jsxs)("p",{children:[(0,i.jsx)("em",{children:"This paragraph was deleted."}),(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"bounded-run-time-errors",children:"Bounded (Run-Time) Errors"}),"\n",(0,i.jsx)(l.A,{children:"17/3_C.7.1"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00237-01","AI05-0004-1"]}),"\n",(0,i.jsxs)("p",{children:["It is a bounded error to call the Current","_","Task function from an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0260",children:"entry_body"})}),", interrupt handler, or finalization of a task attribute. Program","_","Error is raised, or an implementation-defined value of the type Task","_","Id is returned. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"17.a/2_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"The value of Current","_","Task when in a protected entry, interrupt handler, or finalization of a task attribute.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"17.b_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This value could be Null","_","Task","_","Id, or the ID of some user task, or that of an internal task created by the implementation. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"17.c/2_C.7.1"}),(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"An entry barrier is syntactically part of an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0260",children:"entry_body"})}),", so a call to Current","_","Task from an entry barrier is also covered by this rule. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"erroneous-execution",children:"Erroneous Execution"}),"\n",(0,i.jsx)(l.A,{children:"18_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["If a value of Task","_","Id is passed as a parameter to any of the operations declared in this package (or any language-defined child of this package), and the corresponding task object no longer exists, the execution of the program is erroneous. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"documentation-requirements",children:"Documentation Requirements"}),"\n",(0,i.jsx)(l.A,{children:"19_C.7.1"}),"\n",(0,i.jsxs)("p",{children:["The implementation shall document the effect of calling Current","_","Task from an entry body or interrupt handler. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"19.a/2_C.7.1"}),(0,i.jsxs)(s.A,{type:"aarm",aarm:"note",children:[(0,i.jsx)("em",{children:"This paragraph was deleted."}),(0,i.jsx)("br",{})]})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"19.b/2_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{children:"Documentation Requirement: "}),"The effect of calling Current","_","Task from an entry body or interrupt handler.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"20_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["NOTE 1   This package is intended for use in writing user-defined task scheduling packages and constructing server tasks. Current","_","Task can be used in conjunction with other operations requiring a task as an argument such as Set","_","Priority (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-D/AA-D.5",children:"D.5"}),").",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21_C.7.1"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["NOTE 2   The function Current","_","Task and the attribute Caller can return a Task","_","Id value that identifies the environment task.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21.a/2_C.7.1"}),(0,i.jsx)(d.A,{items:["AI95-00362-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["Task","_","Identification is now preelaborated, so it can be used in preelaborated units. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"wording-changes-from-ada-95-1",children:"Wording Changes from Ada 95"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21.b/2_C.7.1"}),(0,i.jsx)(d.A,{items:["AI95-00101-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["{",(0,i.jsx)("em",{children:"8652/0070"}),"}"," ",(0,i.jsx)("strong",{children:"Corrigendum:"})," Corrected the mode of the parameter to Abort","_","Task to ",(0,i.jsx)("strong",{children:"in"}),".",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21.c/2_C.7.1"}),(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["Corrected the wording to include finalization of a task attribute in the bounded error case; we don't want to specify which task does these operations. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"incompatibilities-with-ada-2005",children:"Incompatibilities With Ada 2005"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21.d/3_C.7.1"}),(0,i.jsx)(d.A,{items:["AI05-0189-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["Functions Environment","_","Task and Activation","_","Is","_","Complete are added to Task","_","Identification. If Task","_","Identification is referenced in a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", and an entity ",(0,i.jsx)("em",{children:"E"})," with a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," of Environment","_","Task or Activation","_","Is","_","Complete is defined in a package that is also referenced in a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", the entity ",(0,i.jsx)("em",{children:"E"})," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"21.e/5_C.7.1"}),(0,i.jsx)(d.A,{items:["AI12-0231-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"correction",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{})," Defined what happens if Null","_","Task","_","Id is passed to Activation","_","Is","_","Complete. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)("a",{id:"Subclause_C.7.2"}),"\n",(0,i.jsx)(t.h2,{id:"c72--the-package-task_attributes",children:"C.7.2  The Package Task_Attributes"}),"\n",(0,i.jsx)(t.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,i.jsx)(l.A,{children:"1_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The following language-defined generic library package exists: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"2/5_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,i.jsx)(o.A,{language:"ada",children:(0,i.jsxs)(t.p,{children:["with Ada.Task","_","Identification; use Ada.Task","_","Identification;","\n","generic","\n","   type Attribute is private;","\n","   Initial","_","Value : in Attribute;","\n","package Ada.Task","_","Attributes","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,i.jsx)(l.A,{children:"3_C.7.2"}),"\ntype Attribute","_","Handle is access all Attribute;","\n","\n",(0,i.jsx)(l.A,{children:"4_C.7.2"}),"\nfunction Value(T : Task","_","Id := Current","_","Task)","\n","     return Attribute;","\n","\n",(0,i.jsx)(l.A,{children:"5_C.7.2"}),"\nfunction Reference(T : Task","_","Id := Current","_","Task)","\n","     return Attribute","_","Handle;","\n","\n",(0,i.jsx)(l.A,{children:"6_C.7.2"}),"\nprocedure Set","_","Value(Val : in Attribute;","\n","                       T : in Task","_","Id := Current","_","Task);","\n","   procedure Reinitialize(T : in Task","_","Id := Current","_","Task);","\n","\n",(0,i.jsx)(l.A,{children:"7_C.7.2"}),"\nend Ada.Task","_","Attributes;","\n"]})}),"\n",(0,i.jsx)(t.h4,{id:"dynamic-semantics-1",children:"Dynamic Semantics"}),"\n",(0,i.jsx)(l.A,{children:"8_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["When an instance of Task","_","Attributes is elaborated in a given active partition, an object of the actual type corresponding to the formal type Attribute is implicitly created for each task (of that partition) that exists and is not yet terminated. This object acts as a user-defined attribute of the task. A task created previously in the partition and not yet terminated has this attribute from that point on. Each task subsequently created in the partition will have this attribute when created. In all these cases, the initial value of the given attribute is Initial","_","Value.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"9_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The Value operation returns the value of the corresponding attribute of T.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"10_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The Reference operation returns an access value that designates the corresponding attribute of T.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"11_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The Set","_","Value operation performs any finalization on the old value of the attribute of T and assigns Val to that attribute (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-5/AA-5.2",children:"5.2"})," and ",(0,i.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6",children:"7.6"}),").",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"12_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The effect of the Reinitialize operation is the same as Set","_","Value where the Val parameter is replaced with Initial","_","Value. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"12.a_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"In most cases, the attribute memory can be reclaimed at this point. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"13_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["For all the operations declared in this package, Tasking","_","Error is raised if the task identified by T is terminated. Program","_","Error is raised if the value of T is Null","_","Task","_","Id.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"13.1/2_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),"\n",(0,i.jsxs)("p",{children:["After a task has terminated, all of its attributes are finalized, unless they have been finalized earlier. When the master of an instantiation of Ada.Task","_","Attributes is finalized, the corresponding attribute of each task is finalized, unless it has been finalized earlier. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"13.a/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This is necessary so that a task attribute does not outlive its type. For instance, that's possible if the instantiation is nested, and the attribute is on a library-level task. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"13.b/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"The task owning an attribute cannot, in general, finalize that attribute. That's because the attributes are finalized ",(0,i.jsx)("em",{children:"after"})," the task is terminated; moreover, a task may have attributes as soon as it is created; the task may never even have been activated. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"bounded-run-time-errors-1",children:"Bounded (Run-Time) Errors"}),"\n",(0,i.jsx)(l.A,{children:"13.2/1_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00165-01"]}),"\n",(0,i.jsxs)("p",{children:["{",(0,i.jsx)("em",{children:"8652/0071"}),"}"," If the package Ada.Task","_","Attributes is instantiated with a controlled type and the controlled type has user-defined Adjust or Finalize operations that in turn access task attributes by any of the above operations, then a call of Set","_","Value of the instantiated package constitutes a bounded error. The call may perform as expected or may result in forever blocking the calling task and subsequently some or all tasks of the partition. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"erroneous-execution-1",children:"Erroneous Execution"}),"\n",(0,i.jsx)(l.A,{children:"14_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["It is erroneous to dereference the access value returned by a given call on Reference after a subsequent call on Reinitialize for the same task attribute, or after the associated task terminates. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"14.a_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This allows the storage to be reclaimed for the object associated with an attribute upon Reinitialize or task termination. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"15_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["If a value of Task","_","Id is passed as a parameter to any of the operations declared in this package and the corresponding task object no longer exists, the execution of the program is erroneous.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"15.1/2_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00165-01","AI95-00237-01"]}),"\n",(0,i.jsxs)("p",{children:["{",(0,i.jsx)("em",{children:"8652/0071"}),"}"," An access to a task attribute via a value of type Attribute","_","Handle is erroneous if executed concurrently with another such access or a call of any of the operations declared in package Task","_","Attributes. An access to a task attribute is erroneous if executed concurrently with or after the finalization of the task attribute. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"15.a.1/1_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"There is no requirement of atomicity on accesses via a value of type Attribute","_","Handle. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"15.a.2/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"A task attribute can only be accessed after finalization through a value of type Attribute","_","Handle. Operations in package Task","_","Attributes cannot be used to access a task attribute after finalization, because either the master of the instance has been or is in the process of being left (in which case the instance is out of scope and thus cannot be called), or the associated task is already terminated (in which case Tasking","_","Error is raised for any attempt to call a task attribute operation). ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,i.jsx)(l.A,{children:"16/1_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00165-01"]}),"\n",(0,i.jsxs)("p",{children:["{",(0,i.jsx)("em",{children:"8652/0071"}),"}"," For a given attribute of a given task, the implementation shall perform the operations declared in this package atomically with respect to any of these operations of the same attribute of the same task. The granularity of any locking mechanism necessary to achieve such atomicity is implementation defined. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"16.a.1/1_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-defined",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"Granularity of locking for Task","_","Attributes.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"16.a_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"Hence, other than by dereferencing an access value returned by Reference, an attribute of a given task can be safely read and updated concurrently by multiple tasks. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"17/2_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),"\n",(0,i.jsxs)("p",{children:["After task attributes are finalized, the implementation shall reclaim any storage associated with the attributes. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"documentation-requirements-1",children:"Documentation Requirements"}),"\n",(0,i.jsx)(l.A,{children:"18_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The implementation shall document the limit on the number of attributes per task, if any, and the limit on the total storage for attribute values per task, if such a limit exists.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"19_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["In addition, if these limits can be configured, the implementation shall document how to configure them. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"19.a/2_C.7.2"}),(0,i.jsxs)(s.A,{type:"aarm",aarm:"note",children:[(0,i.jsx)("em",{children:"This paragraph was deleted."}),(0,i.jsx)("br",{})]})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"19.b/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{children:"Documentation Requirement: "}),"For package Task","_","Attributes, limits on the number and size of task attributes, and how to configure any limits.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"metrics",children:"Metrics"}),"\n",(0,i.jsx)(l.A,{children:"20/2_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00434-01"]}),"\n",(0,i.jsxs)("p",{children:["The implementation shall document the following metrics: A task calling the following subprograms shall execute at a sufficiently high priority as to not be preempted during the measurement period. This period shall start just before issuing the call and end just after the call completes. If the attributes of task T are accessed by the measurement tests, no other task shall access attributes of that task during the measurement period. For all measurements described here, the Attribute type shall be a scalar type whose size is equal to the size of the predefined type Integer. For each measurement, two cases shall be documented: one where the accessed attributes are of the calling task [(that is, the default value for the T parameter is used)], and the other, where T identifies another, nonterminated, task.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"21_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["The following calls (to subprograms in the Task","_","Attributes package) shall be measured: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"22_C.7.2"}),"\n",(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["a call to Value, where the return value is Initial","_","Value;",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.A,{children:"23_C.7.2"}),(0,i.jsxs)("li",{children:["a call to Value, where the return value is not equal to Initial","_","Value;",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.A,{children:"24_C.7.2"}),(0,i.jsxs)("li",{children:["a call to Reference, where the return value designates a value equal to Initial","_","Value;",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.A,{children:"25_C.7.2"}),(0,i.jsxs)("li",{children:["a call to Reference, where the return value designates a value not equal to Initial","_","Value;",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.A,{children:"26/2_C.7.2"}),(0,i.jsx)(d.A,{items:["AI95-00434-01"]}),(0,i.jsxs)("li",{children:["a call to Set","_","Value where the Val parameter is not equal to Initial","_","Value and the old attribute value is equal to Initial","_","Value;",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.A,{children:"27_C.7.2"}),(0,i.jsxs)("li",{children:["a call to Set","_","Value where the Val parameter is not equal to Initial","_","Value and the old attribute value is not equal to Initial","_","Value.",(0,i.jsx)("br",{})]})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"27.a/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{children:"Documentation Requirement: "}),"The metrics for the Task","_","Attributes package.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,i.jsx)(l.A,{children:"28/5_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0444-1"]}),"\n",(0,i.jsxs)("p",{children:["An implementation can avoid actually creating the object corresponding to a task attribute until its value is set to something other than that of Initial","_","Value, or until Reference is called for the task attribute. Similarly, when the value of the attribute is to be reinitialized to that of Initial","_","Value, the object may instead be finalized and its storage reclaimed, to be recreated when needed later. While the object does not exist, the function Value may simply return Initial","_","Value, rather than implicitly creating the object. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"28.a_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"The effect of this permission can only be observed if the assignment operation for the corresponding type has side effects. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"28.b/2_C.7.2"}),(0,i.jsx)(d.A,{items:["AI95-00114-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-note",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This permission means that even though every task has every attribute, storage need only be allocated for those attributes for which function Reference has been invoked or set to a value other than that of Initial","_","Value. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"29_C.7.2"}),"\n",(0,i.jsxs)("p",{children:["An implementation is allowed to place restrictions on the maximum number of attributes a task may have, the maximum size of each attribute, and the total storage size allocated for all the attributes of a task.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"implementation-advice",children:"Implementation Advice"}),"\n",(0,i.jsx)(l.A,{children:"30/5_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00434-01","AI12-0438-1"]}),"\n",(0,i.jsxs)("p",{children:["Some implementations are targeted to domains in which memory use at run time has to be completely deterministic. For such implementations, it is recommended that the storage for task attributes will be pre-allocated statically and not from the heap. This can be accomplished by either placing restrictions on the number and the size of the attributes of a task, or by using the pre-allocated storage for the first N attribute objects, and the heap for the others. In the latter case, N should be documented.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"30.a/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"If the target domain requires deterministic memory use at run time, storage for task attributes should be pre-allocated statically and the number of attributes pre-allocated should be documented.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"30.b/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"discussion",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"We don't mention \u201crestrictions on the size and number\u201d (that is, limits) in the text for the Annex, because it is covered by the Documentation Requirement above, and we try not to repeat requirements in the Annex (they're enough work to meet without having to do things twice). ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"30.1/2_C.7.2"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),"\n",(0,i.jsxs)("p",{children:["Finalization of task attributes and reclamation of associated storage should be performed as soon as possible after task termination. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"30.c/2_C.7.2"}),(0,i.jsx)(s.A,{type:"aarm",aarm:"implementation-advice",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"Finalization of task attributes and reclamation of associated storage should be performed as soon as possible after task termination.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"30.d/2_C.7.2"}),(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This is necessary because the normative wording only says that attributes are finalized \u201cafter\u201d task termination. Without this advice, waiting until the instance is finalized would meet the requirements (it is after termination, but may be a very long time after termination). We can't say anything more specific than this, as we do not want to require the overhead of an interaction with the tasking system to be done at a specific point. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"31/5_C.7.2"}),(0,i.jsx)(d.A,{items:["AI12-0442-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["NOTE 1   An attribute always exists (after instantiation), and has the initial value. An implementation can avoid using memory to store the attribute value until the first operation that changes the attribute value. The same holds true after Reinitialize.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"32/5_C.7.2"}),(0,i.jsx)(d.A,{items:["AI12-0442-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["NOTE 2   The result of the Reference function is always safe to use in the task body whose attribute is being accessed. However, when the result is being used by another task, the programmer will want to make sure that the task whose attribute is being accessed is not yet terminated. Failing to do so can make the program execution erroneous.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"wording-changes-from-ada-95-2",children:"Wording Changes from Ada 95"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"33.a/2_C.7.2"}),(0,i.jsx)(d.A,{items:["AI95-00165-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["{",(0,i.jsx)("em",{children:"8652/0071"}),"}"," ",(0,i.jsx)("strong",{children:"Corrigendum:"})," Clarified that use of task attribute operations from within a task attribute operation (by an Adjust or Finalize call) is a bounded error, and that concurrent use of attribute handles is erroneous.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"33.b/2_C.7.2"}),(0,i.jsx)(d.A,{items:["AI95-00237-01"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["Clarified the wording so that the finalization takes place after the termination of the task or when the instance is finalized (whichever is sooner). ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)("a",{id:"Subclause_C.7.3"}),"\n",(0,i.jsx)(t.h2,{id:"c73--the-package-task_termination",children:"C.7.3  The Package Task_Termination"}),"\n",(0,i.jsx)(t.h4,{id:"static-semantics-2",children:"Static Semantics"}),"\n",(0,i.jsx)(l.A,{children:"1/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["The following language-defined library package exists: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"2/5_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,i.jsx)(o.A,{language:"ada",children:(0,i.jsxs)(t.p,{children:["with Ada.Task","_","Identification;","\n","with Ada.Exceptions;","\n","package Ada.Task","_","Termination","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,i.jsx)(l.A,{children:"3/2_C.7.3"}),"\ntype Cause","_","Of","_","Termination is (Normal, Abnormal, Unhandled","_","Exception);","\n","\n",(0,i.jsx)(l.A,{children:"4/2_C.7.3"}),"\ntype Termination","_","Handler is access protected procedure","\n","     (Cause : in Cause","_","Of","_","Termination;","\n","      T     : in Ada.Task","_","Identification.Task","_","Id;","\n","      X     : in Ada.Exceptions.Exception","_","Occurrence);","\n","\n",(0,i.jsx)(l.A,{children:"5/2_C.7.3"}),"\nprocedure Set","_","Dependents","_","Fallback","_","Handler","\n","     (Handler: in Termination","_","Handler);","\n","   function Current","_","Task","_","Fallback","_","Handler return Termination","_","Handler;","\n","\n",(0,i.jsx)(l.A,{children:"6/2_C.7.3"}),"\nprocedure Set","_","Specific","_","Handler","\n","     (T       : in Ada.Task","_","Identification.Task","_","Id;","\n","      Handler : in Termination","_","Handler);","\n","   function Specific","_","Handler (T : Ada.Task","_","Identification.Task","_","Id)","\n","      return Termination","_","Handler;","\n","\n",(0,i.jsx)(l.A,{children:"7/2_C.7.3"}),"\nend Ada.Task","_","Termination;","\n"]})}),"\n",(0,i.jsx)(t.h4,{id:"dynamic-semantics-2",children:"Dynamic Semantics"}),"\n",(0,i.jsx)(l.A,{children:"8/3_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0202-1"]}),"\n",(0,i.jsxs)("p",{children:["The type Termination","_","Handler identifies a protected procedure to be executed by the implementation when a task terminates. Such a protected procedure is called a ",(0,i.jsx)("em",{children:"handler"}),". In all cases T identifies the task that is terminating. If the task terminates due to completing the last statement of its body, or as a result of waiting on a terminate alternative, and the finalization of the task completes normally, then Cause is set to Normal and X is set to Null","_","Occurrence. If the task terminates because it is being aborted, then Cause is set to Abnormal; X is set to Null","_","Occurrence if the finalization of the task completes normally. If the task terminates because of an exception raised by the execution of its ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0248",children:"task_body"})}),", then Cause is set to Unhandled","_","Exception; X is set to the associated exception occurrence if the finalization of the task completes normally. Independent of how the task completes, if finalization of the task propagates an exception, then Cause is either Unhandled","_","Exception or Abnormal, and X is an exception occurrence that identifies the Program","_","Error exception.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"9/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["Each task has two termination handlers, a ",(0,i.jsx)("em",{children:"fall-back handler"})," and a ",(0,i.jsx)("em",{children:"specific handler"}),". The specific handler applies only to the task itself, while the fall-back handler applies only to the dependent tasks of the task. A handler is said to be ",(0,i.jsx)("em",{children:"set"})," if it is associated with a nonnull value of type Termination","_","Handler, and ",(0,i.jsx)("em",{children:"cleared"})," otherwise. When a task is created, its specific handler and fall-back handler are cleared.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"10/3_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0264-1"]}),"\n",(0,i.jsxs)("p",{children:["The procedure Set","_","Dependents","_","Fallback","_","Handler changes the fall-back handler for the calling task: if Handler is ",(0,i.jsx)("strong",{children:"null"}),", that fall-back handler is cleared; otherwise, it is set to be Handler.",(0,i.jsx)("strong",{children:"all"}),". If a fall-back handler had previously been set it is replaced.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"11/3_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0264-1"]}),"\n",(0,i.jsxs)("p",{children:["The function Current","_","Task","_","Fallback","_","Handler returns the fall-back handler that is currently set for the calling task, if one is set; otherwise, it returns ",(0,i.jsx)("strong",{children:"null"}),".",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"12/3_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0264-1"]}),"\n",(0,i.jsxs)("p",{children:["The procedure Set","_","Specific","_","Handler changes the specific handler for the task identified by T: if Handler is ",(0,i.jsx)("strong",{children:"null"}),", that specific handler is cleared; otherwise, it is set to be Handler.",(0,i.jsx)("strong",{children:"all"}),". If a specific handler had previously been set it is replaced.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"12.a/3_C.7.3"}),(0,i.jsx)(d.A,{items:["AI05-0005-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"ramification",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{}),"This package cannot portably be used to set a handler on the program as a whole. It is possible to call Set","_","Specific","_","Handler with the environment task's ID. But any call to the handler would necessarily be a Bounded (Run-Time) Error, as the handler is called after the task's finalization has completed. In the case of the environment task, that includes any possible protected objects, and calling a protected object after it is finalized is a Bounded (Run-Time) Error (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.4",children:"9.4"}),"). This might work in a particular implementation, but it cannot be depended upon. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.A,{children:"13/3_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02","AI05-0264-1"]}),"\n",(0,i.jsxs)("p",{children:["The function Specific","_","Handler returns the specific handler that is currently set for the task identified by T, if one is set; otherwise, it returns ",(0,i.jsx)("strong",{children:"null"}),".",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"14/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["As part of the finalization of a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.1#S0248",children:"task_body"})}),", after performing the actions specified in ",(0,i.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6",children:"7.6"})," for finalization of a master, the specific handler for the task, if one is set, is executed. If the specific handler is cleared, a search for a fall-back handler proceeds by recursively following the master relationship for the task. If a task is found whose fall-back handler is set, that handler is executed; otherwise, no handler is executed.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"15/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["For Set","_","Specific","_","Handler or Specific","_","Handler, Tasking","_","Error is raised if the task identified by T has already terminated. Program","_","Error is raised if the value of T is Ada.Task","_","Identification.Null","_","Task","_","Id.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.A,{children:"16/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["An exception propagated from a handler that is invoked as part of the termination of a task has no effect.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(t.h4,{id:"erroneous-execution-2",children:"Erroneous Execution"}),"\n",(0,i.jsx)(l.A,{children:"17/2_C.7.3"}),"\n",(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),"\n",(0,i.jsxs)("p",{children:["For a call of Set","_","Specific","_","Handler or Specific","_","Handler, if the task identified by T no longer exists, the execution of the program is erroneous. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"extensions-to-ada-95-1",children:"Extensions to Ada 95"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"17.a/2_C.7.3"}),(0,i.jsx)(d.A,{items:["AI95-00266-02"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"note",children:(0,i.jsxs)(t.p,{children:["Package Task","_","Termination is new. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.A,{children:(0,i.jsx)(t.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(l.A,{children:"17.b/3_C.7.3"}),(0,i.jsx)(d.A,{items:["AI05-0202-1"]}),(0,i.jsx)(s.A,{type:"aarm",aarm:"correction",children:(0,i.jsxs)(t.p,{children:[(0,i.jsx)("strong",{})," Specified what is passed to the handler if the finalization of the task fails after it is completed. This was not specified at all in Ada 2005, so there is a possibility that some program depended on some other behavior of an implementation. But as this case is very unlikely (and only occurs when there is already a significant bug in the program - so should not occur in fielded systems), we're not listing this as an inconsistency. ",(0,i.jsx)("br",{})]})})]})]})}function A(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(j,{...e})}):j(e)}}}]);