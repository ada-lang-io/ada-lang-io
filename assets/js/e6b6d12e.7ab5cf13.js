"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8004],{4103:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>m,default:()=>j,frontMatter:()=>h,metadata:()=>t,toc:()=>x});const t=JSON.parse('{"id":"arm/AA-D/AA-D.14","title":"D.14 Execution Time","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-D/AA-D.14.mdx","sourceDirName":"arm/AA-D","slug":"/arm/AA-D/AA-D.14","permalink":"/docs/arm/AA-D/AA-D.14","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":168,"frontMatter":{"sidebar_position":168},"sidebar":"referenceManualSidebar","previous":{"title":"D.13 The Ravenscar and Jorvik Profiles","permalink":"/docs/arm/AA-D/AA-D.13"},"next":{"title":"D.15 Timing Events","permalink":"/docs/arm/AA-D/AA-D.15"}}');var s=i(4848),r=i(8453),a=i(3842),o=i(1435),d=i(1432),c=i(9162),l=i(4421);const h={sidebar_position:168},m="D.14 Execution Time",u={},x=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Metrics",id:"metrics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"D.14.1  Execution Time Timers",id:"d141--execution-time-timers",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"D.14.2  Group Execution Time Budgets",id:"d142--group-execution-time-budgets",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Erroneous Execution",id:"erroneous-execution-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-2",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"D.14.3  Execution Time of Interrupt Handlers",id:"d143--execution-time-of-interrupt-handlers",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4}];function p(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"d14-execution-time",children:"D.14 Execution Time"})}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsxs)(n.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,s.jsx)(n.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,s.jsx)(c.A,{children:"1/3"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0299-1"]}),"\n",(0,s.jsxs)("p",{children:["This subclause describes a language-defined package to measure execution time. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,s.jsx)(c.A,{children:"2/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The following language-defined library package exists: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"3/5"}),"\n",(0,s.jsx)(l.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsxs)(d.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["with Ada.Task","_","Identification;","\n","with Ada.Real","_","Time; use Ada.Real","_","Time;","\n","package Ada.Execution","_","Time","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,s.jsx)(c.A,{children:"4/2"}),"\ntype CPU","_","Time is private;","\n","   CPU","_","Time","_","First : constant CPU","_","Time;","\n","   CPU","_","Time","_","Last  : constant CPU","_","Time;","\n","   CPU","_","Time","_","Unit  : constant := implementation-defined-real-number;","\n","   CPU","_","Tick : constant Time","_","Span;","\n","\n",(0,s.jsx)(c.A,{children:"5/2"}),"\nfunction Clock","\n","     (T : Ada.Task","_","Identification.Task","_","Id","\n","          := Ada.Task","_","Identification.Current","_","Task)","\n","     return CPU","_","Time;","\n","\n",(0,s.jsx)(c.A,{children:"6/2"}),'\nfunction "+"  (Left : CPU',"_","Time; Right : Time","_","Span) return CPU","_","Time;","\n",'   function "+"  (Left : Time',"_","Span; Right : CPU","_","Time) return CPU","_","Time;","\n",'   function "-"  (Left : CPU',"_","Time; Right : Time","_","Span) return CPU","_","Time;","\n",'   function "-"  (Left : CPU',"_","Time; Right : CPU","_","Time)  return Time","_","Span;","\n","\n",(0,s.jsx)(c.A,{children:"7/2"}),'\nfunction "',"<",'"  (Left, Right : CPU',"_","Time) return Boolean;","\n",'   function "',"<",'=" (Left, Right : CPU',"_","Time) return Boolean;","\n",'   function "',">",'"  (Left, Right : CPU',"_","Time) return Boolean;","\n",'   function "',">",'=" (Left, Right : CPU',"_","Time) return Boolean;","\n","\n",(0,s.jsx)(c.A,{children:"8/2"}),"\nprocedure Split","\n","     (T : in CPU","_","Time; SC : out Seconds","_","Count; TS : out Time","_","Span);","\n","\n",(0,s.jsx)(c.A,{children:"9/2"}),"\nfunction Time","_","Of (SC : Seconds","_","Count;","\n","                     TS : Time","_","Span := Time","_","Span","_","Zero) return CPU","_","Time;","\n","\n",(0,s.jsx)(c.A,{children:"9.1/3"})]}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsxs)(n.p,{children:["Interrupt","_","Clocks","_","Supported : constant Boolean := implementation-defined;","\n","\n",(0,s.jsx)(c.A,{children:"9.2/3"})]}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsxs)(n.p,{children:["Separate","_","Interrupt","_","Clocks","_","Supported : constant Boolean :=","\n","     implementation-defined;","\n","\n",(0,s.jsx)(c.A,{children:"9.3/3"})]}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsxs)(n.p,{children:["function Clock","_","For","_","Interrupts return CPU","_","Time;","\n","\n",(0,s.jsx)(c.A,{children:"10/2"}),"\nprivate","\n","   ... -- not specified by the language","\n","end Ada.Execution","_","Time;","\n"]})]}),"\n",(0,s.jsx)(c.A,{children:"11/3"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0170-1","AI05-0269-1"]}),"\n",(0,s.jsxs)("p",{children:["The ",(0,s.jsx)("em",{children:"execution time"})," or CPU time of a given task is defined as the time spent by the system executing that task, including the time spent executing run-time or system services on its behalf. The mechanism used to measure execution time is implementation defined. The Boolean constant Interrupt","_","Clocks","_","Supported is set to True if the implementation separately accounts for the execution time of interrupt handlers. If it is set to False it is implementation defined which task, if any, is charged the execution time that is consumed by interrupt handlers. The Boolean constant Separate","_","Interrupt","_","Clocks","_","Supported is set to True if the implementation separately accounts for the execution time of individual interrupt handlers (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-D/AA-D.14#Subclause_D.14.3",children:"D.14.3"}),"). ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"11.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"The implementation-defined properties above and of the values declared in the package are repeated in Documentation Requirements, so we don't mark them as implementation-defined. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"12/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The type CPU","_","Time represents the execution time of a task. The set of values of this type corresponds one-to-one with an implementation-defined range of mathematical integers.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"13/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The CPU","_","Time value I represents the half-open execution-time interval that starts with I","*","CPU","_","Time","_","Unit and is limited by (I+1)","*","CPU","_","Time","_","Unit, where CPU","_","Time","_","Unit is an implementation-defined real number. For each task, the execution time value is set to zero at the creation of the task.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"13.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"Since it is implementation-defined which task is charged execution time for system services, the execution time value may become nonzero even before the start of the activation of the task. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"14/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["CPU","_","Time","_","First and CPU","_","Time","_","Last are the smallest and largest values of the CPU","_","Time type, respectively. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"14.1/3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["The execution time value for the function Clock","_","For","_","Interrupts is initialized to zero.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,s.jsx)(c.A,{children:"15/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["CPU","_","Time","_","Unit is the smallest amount of execution time representable by the CPU","_","Time type; it is expressed in seconds. A ",(0,s.jsx)("em",{children:"CPU clock tick"})," is an execution time interval during which the clock value (as observed by calling the Clock function) remains constant. CPU","_","Tick is the average length of such intervals.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"16/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The effects of the operators on CPU","_","Time and Time","_","Span are as for the operators defined for integer types.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"17/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The function Clock returns the current execution time of the task identified by T; Tasking","_","Error is raised if that task has terminated; Program","_","Error is raised if the value of T is Task","_","Identification.Null","_","Task","_","Id.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"18/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The effects of the Split and Time","_","Of operations are defined as follows, treating values of type CPU","_","Time, Time","_","Span, and Seconds","_","Count as mathematical integers. The effect of Split (T, SC, TS) is to set SC and TS to values such that T","*","CPU","_","Time","_","Unit = SC","*","1.0 + TS","*","CPU","_","Time","_","Unit, and 0.0 ","<","= TS","*","CPU","_","Time","_","Unit ","<"," 1.0. The value returned by Time","_","Of(SC,TS) is the execution-time value T such that T","*","CPU","_","Time","_","Unit=SC","*","1.0 + TS","*","CPU","_","Time","_","Unit.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"18.1/3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Clock","_","For","_","Interrupts returns the total cumulative time spent executing within all interrupt handlers. This time is not allocated to any task execution time clock. If Interrupt","_","Clocks","_","Supported is set to False the function raises Program","_","Error.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"erroneous-execution",children:"Erroneous Execution"}),"\n",(0,s.jsx)(c.A,{children:"19/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["For a call of Clock, if the task identified by T no longer exists, the execution of the program is erroneous. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,s.jsx)(c.A,{children:"20/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The range of CPU","_","Time values shall be sufficient to uniquely represent the range of execution times from the task start-up to 50 years of execution time later. CPU","_","Tick shall be no greater than 1 millisecond. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"documentation-requirements",children:"Documentation Requirements"}),"\n",(0,s.jsx)(c.A,{children:"21/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The implementation shall document the values of CPU","_","Time","_","First, CPU","_","Time","_","Last, CPU","_","Time","_","Unit, and CPU","_","Tick. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"21.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{children:"Documentation Requirement: "}),"The values of CPU","_","Time","_","First, CPU","_","Time","_","Last, CPU","_","Time","_","Unit, and CPU","_","Tick of package Execution","_","Time.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"22/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The implementation shall document the properties of the underlying mechanism used to measure execution times, such as the range of values supported and any relevant aspects of the underlying hardware or operating system facilities used. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"22.a/3"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{children:"Documentation Requirement: "}),"The properties of the mechanism used to implement package Execution","_","Time, including the values of the constants defined in the package.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"metrics",children:"Metrics"}),"\n",(0,s.jsx)(c.A,{children:"23/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The implementation shall document the following metrics:",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"24/2"}),"\n",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:["An upper bound on the execution-time duration of a clock tick. This is a value D such that if t1 and t2 are any execution times of a given task such that t1 ","<"," t2 and Clockt1 = Clockt2 then t2 \u2013 t1 ","<","= D.",(0,s.jsx)("br",{})]}),(0,s.jsx)(c.A,{children:"25/2"}),(0,s.jsxs)("li",{children:["An upper bound on the size of a clock jump. A clock jump is the difference between two successive distinct values of an execution-time clock (as observed by calling the Clock function with the same Task","_","Id).",(0,s.jsx)("br",{})]}),(0,s.jsx)(c.A,{children:"26/2"}),(0,s.jsxs)("li",{children:["An upper bound on the execution time of a call to the Clock function, in processor clock cycles.",(0,s.jsx)("br",{})]}),(0,s.jsx)(c.A,{children:"27/2"}),(0,s.jsxs)("li",{children:["Upper bounds on the execution times of the operators of the type CPU","_","Time, in processor clock cycles. ",(0,s.jsx)("br",{})]})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"27.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{children:"Documentation Requirement: "}),"The metrics for execution time.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,s.jsx)(c.A,{children:"28/5"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI12-0444-1"]}),"\n",(0,s.jsxs)("p",{children:["Implementations targeted to machines with word size smaller than 32 bits may omit support for the full range and granularity of the CPU","_","Time type.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-advice",children:"Implementation Advice"}),"\n",(0,s.jsx)(c.A,{children:"29/2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["When appropriate, implementations should provide configuration mechanisms to change the value of CPU","_","Tick. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29.a/2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-advice",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"When appropriate, implementations should provide configuration mechanisms to change the value of Execution","_","Time.CPU","_","Tick.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29.b/2"}),(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The package Execution","_","Time is new. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"incompatibilities-with-ada-2005",children:"Incompatibilities With Ada 2005"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29.c/3"}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["Function Clock","_","For","_","Interrupts, and constants Interrupt","_","Clocks","_","Supported and Separate","_","Interrupt","_","Clocks","_","Supported are added to Execution","_","Time. If Execution","_","Time is referenced in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", and an entity ",(0,s.jsx)("em",{children:"E"})," with a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-3/AA-3.1#S0022",children:"defining_identifier"})})," of one of the added entities is defined in a package that is also referenced in a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:"use_clause"})}),", the entity ",(0,s.jsx)("em",{children:"E"})," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29.d/3"}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["If Interrupt","_","Clocks","_","Supported is True, it is now possible to determine the execution time of interrupt handlers. This is not an inconsistency, as not charging any task for such time was a legitimate implementation for Ada 2005. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)("a",{id:"Subclause_D.14.1"}),"\n",(0,s.jsx)(n.h2,{id:"d141--execution-time-timers",children:"D.14.1  Execution Time Timers"}),"\n",(0,s.jsx)(c.A,{children:"1/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0299-1"]}),"\n",(0,s.jsxs)("p",{children:["This subclause describes a language-defined package that provides a facility for calling a handler when a task has used a defined amount of CPU time. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,s.jsx)(c.A,{children:"2/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The following language-defined library package exists: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"3/5_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsxs)(d.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["with System;","\n","package Ada.Execution","_","Time.Timers","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,s.jsx)(c.A,{children:"4/2_D.14.1"}),"\ntype Timer (T : not null access constant","\n","                       Ada.Task","_","Identification.Task","_","Id) is","\n","      tagged limited private;","\n","\n",(0,s.jsx)(c.A,{children:"5/5_D.14.1"})]}),(0,s.jsx)(l.A,{items:["AI12-0241-1"]}),(0,s.jsxs)(n.p,{children:["type Timer","_","Handler is","\n","      access protected procedure (TM : in out Timer)","\n","      with Nonblocking =",">"," False;","\n","\n",(0,s.jsx)(c.A,{children:"6/2_D.14.1"}),"\nMin","_","Handler","_","Ceiling : constant System.Any","_","Priority :=","\n","   implementation-defined;","\n","\n",(0,s.jsx)(c.A,{children:"7/2_D.14.1"}),"\nprocedure Set","_","Handler (TM      : in out Timer;","\n","                          In","_","Time : in Time","_","Span;","\n","                          Handler : in Timer","_","Handler);","\n","   procedure Set","_","Handler (TM      : in out Timer;","\n","                          At","_","Time : in CPU","_","Time;","\n","                          Handler : in Timer","_","Handler);","\n","   function Current","_","Handler (TM : Timer) return Timer","_","Handler;","\n","   procedure Cancel","_","Handler (TM        : in out Timer;","\n","                             Cancelled :    out Boolean);","\n","\n",(0,s.jsx)(c.A,{children:"8/2_D.14.1"}),"\nfunction Time","_","Remaining (TM : Timer) return Time","_","Span;","\n","\n",(0,s.jsx)(c.A,{children:"9/2_D.14.1"}),"\nTimer","_","Resource","_","Error : exception;","\n","\n",(0,s.jsx)(c.A,{children:"10/2_D.14.1"}),"\nprivate","\n","   ... -- not specified by the language","\n","end Ada.Execution","_","Time.Timers;","\n"]})]}),"\n",(0,s.jsx)(c.A,{children:"11/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The type Timer represents an execution-time event for a single task and is capable of detecting execution-time overruns. The access discriminant T identifies the task concerned. The type Timer needs finalization (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6",children:"7.6"}),").",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"12/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["An object of type Timer is said to be ",(0,s.jsx)("em",{children:"set"})," if it is associated with a nonnull value of type Timer","_","Handler and ",(0,s.jsx)("em",{children:"cleared"})," otherwise. All Timer objects are initially cleared. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"13/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The type Timer","_","Handler identifies a protected procedure to be executed by the implementation when the timer expires. Such a protected procedure is called a ",(0,s.jsx)("em",{children:"handler"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"13.a/2_D.14.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"Type Timer is tagged. This makes it possible to share a handler between several events. In simple cases, 'Access can be used to compare the parameter with a specific timer object (this works because a tagged type is a by-reference type). In more complex cases, a type extension of type Timer can be declared; a double type conversion can be used to access the extension data. An example of how this can be done can be found for the similar type Timing","_","Event, see ",(0,s.jsx)("a",{href:"/docs/arm/AA-D/AA-D.15",children:"D.15"}),". ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-semantics-1",children:"Dynamic Semantics"}),"\n",(0,s.jsx)(c.A,{children:"14/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["When a Timer object is created, or upon the first call of a Set","_","Handler procedure with the timer as parameter, the resources required to operate an execution-time timer based on the associated execution-time clock are allocated and initialized. If this operation would exceed the available resources, Timer","_","Resource","_","Error is raised.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"15/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The procedures Set","_","Handler associate the handler Handler with the timer TM: if Handler is ",(0,s.jsx)("strong",{children:"null"}),", the timer is cleared; otherwise, it is set. The first procedure Set","_","Handler loads the timer TM with an interval specified by the Time","_","Span parameter. In this mode, the timer TM ",(0,s.jsx)("em",{children:"expires"})," when the execution time of the task identified by TM.T.",(0,s.jsx)("strong",{children:"all"})," has increased by In","_","Time; if In","_","Time is less than or equal to zero, the timer expires immediately. The second procedure Set","_","Handler loads the timer TM with the absolute value specified by At","_","Time. In this mode, the timer TM expires when the execution time of the task identified by TM.T.",(0,s.jsx)("strong",{children:"all"})," reaches At","_","Time; if the value of At","_","Time has already been reached when Set","_","Handler is called, the timer expires immediately.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"15.a/2_D.14.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"Since an access-to-constant can designate a variable, the Task","_","Id value designated by the discriminant of a Timer object can be changed after the object is created. Thus, an implementation cannot use the value of the Task","_","Id other than where this Reference Manual specifies. For instance, the Task","_","Id should be read when the timer is set, but it should not be used when the timer expires (as it may designate a different task at that point). ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"16/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["A call of a procedure Set","_","Handler for a timer that is already set replaces the handler and the (absolute or relative) execution time; if Handler is not ",(0,s.jsx)("strong",{children:"null"}),", the timer remains set.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"17/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["When a timer expires, the associated handler is executed, passing the timer as parameter. The initial action of the execution of the handler is to clear the event.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"18/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Current","_","Handler returns the handler associated with the timer TM if that timer is set; otherwise, it returns ",(0,s.jsx)("strong",{children:"null"}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"19/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Cancel","_","Handler clears the timer if it is set. Cancelled is assigned True if the timer was set prior to it being cleared; otherwise, it is assigned False.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"20/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Time","_","Remaining returns the execution time interval that remains until the timer TM would expire, if that timer is set; otherwise, it returns Time","_","Span","_","Zero.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"21/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["The constant Min","_","Handler","_","Ceiling is the minimum ceiling priority required for a protected object with a handler to ensure that no ceiling violation will occur when that handler is invoked.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"22/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["As part of the finalization of an object of type Timer, the timer is cleared.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"23/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["For all the subprograms defined in this package, Tasking","_","Error is raised if the task identified by TM.T.",(0,s.jsx)("strong",{children:"all"})," has terminated, and Program","_","Error is raised if the value of TM.T.",(0,s.jsx)("strong",{children:"all"})," is Task","_","Identification.Null","_","Task","_","Id.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"24/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["An exception propagated from a handler invoked as part of the expiration of a timer has no effect.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"erroneous-execution-1",children:"Erroneous Execution"}),"\n",(0,s.jsx)(c.A,{children:"25/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["For a call of any of the subprograms defined in this package, if the task identified by TM.T.",(0,s.jsx)("strong",{children:"all"})," no longer exists, the execution of the program is erroneous.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-requirements-1",children:"Implementation Requirements"}),"\n",(0,s.jsx)(c.A,{children:"26/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["For a given Timer object, the implementation shall perform the operations declared in this package atomically with respect to any of these operations on the same Timer object. The replacement of a handler by a call of Set","_","Handler shall be performed atomically with respect to the execution of the handler.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"26.a/2_D.14.1"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"reason",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"This prevents various race conditions. In particular it ensures that if an event occurs when Set","_","Handler is changing the handler then either the new or old handler is executed in response to the appropriate event. It is never possible for a new handler to be executed in response to an old event ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"27/2_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),"\n",(0,s.jsxs)("p",{children:["When an object of type Timer is finalized, the system resources used by the timer shall be deallocated.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-permissions-1",children:"Implementation Permissions"}),"\n",(0,s.jsx)(c.A,{children:"28/3_D.14.1"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00307-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["Implementations may limit the number of timers that can be defined for each task. If this limit is exceeded, then Timer","_","Resource","_","Error is raised.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29/2_D.14.1"}),(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE   A Timer","_","Handler can be associated with several Timer objects.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95-1",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"29.a/2_D.14.1"}),(0,s.jsx)(l.A,{items:["AI95-00307-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The package Execution","_","Time.Timers is new. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)("a",{id:"Subclause_D.14.2"}),"\n",(0,s.jsx)(n.h2,{id:"d142--group-execution-time-budgets",children:"D.14.2  Group Execution Time Budgets"}),"\n",(0,s.jsx)(c.A,{children:"1/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0299-1"]}),"\n",(0,s.jsxs)("p",{children:["This subclause describes a language-defined package to assign execution time budgets to groups of tasks. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-2",children:"Static Semantics"}),"\n",(0,s.jsx)(c.A,{children:"2/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The following language-defined library package exists: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"3/5_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0169-1","AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsxs)(d.A,{language:"ada",children:[(0,s.jsxs)(n.p,{children:["with System;","\n","with System.Multiprocessors;","\n","package Ada.Execution","_","Time.Group","_","Budgets","\n","  with Nonblocking, Global =",">"," in out synchronized is","\n","\n",(0,s.jsx)(c.A,{children:"4/3_D.14.2"})]}),(0,s.jsx)(l.A,{items:["AI05-0092-1","AI05-0169-1"]}),(0,s.jsxs)(n.p,{children:["type Group","_","Budget(CPU : System.Multiprocessors.CPU :=","\n","                             System.Multiprocessors.CPU'First)","\n","    is tagged limited private;","\n","\n",(0,s.jsx)(c.A,{children:"5/5_D.14.2"})]}),(0,s.jsx)(l.A,{items:["AI12-0241-1"]}),(0,s.jsxs)(n.p,{children:["type Group","_","Budget","_","Handler is access","\n","       protected procedure (GB : in out Group","_","Budget)","\n","       with Nonblocking =",">"," False;","\n","\n",(0,s.jsx)(c.A,{children:"6/2_D.14.2"}),"\ntype Task","_","Array is array (Positive range ","<",">",") of","\n","                                  Ada.Task","_","Identification.Task","_","Id;","\n","\n",(0,s.jsx)(c.A,{children:"7/2_D.14.2"}),"\nMin","_","Handler","_","Ceiling : constant System.Any","_","Priority :=","\n","    implementation-defined;","\n"]})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"7.a.1/3_D.14.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"implementation-defined",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"The value of Min","_","Handler","_","Ceiling in Execution","_","Time.Group","_","Budgets.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"8/2_D.14.2"}),"\n",(0,s.jsx)(d.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["procedure Add","_","Task (GB : in out Group","_","Budget;","\n","                      T  : in Ada.Task","_","Identification.Task","_","Id);","\n","  procedure Remove","_","Task (GB: in out Group","_","Budget;","\n","                         T  : in Ada.Task","_","Identification.Task","_","Id);","\n","  function Is","_","Member (GB : Group","_","Budget;","\n","                      T : Ada.Task","_","Identification.Task","_","Id) return Boolean;","\n","  function Is","_","A","_","Group","_","Member","\n","     (T : Ada.Task","_","Identification.Task","_","Id) return Boolean;","\n","  function Members (GB : Group","_","Budget) return Task","_","Array;","\n","\n",(0,s.jsx)(c.A,{children:"9/2_D.14.2"}),"\nprocedure Replenish (GB : in out Group","_","Budget; To : in Time","_","Span);","\n","  procedure Add (GB : in out Group","_","Budget; Interval : in Time","_","Span);","\n","  function Budget","_","Has","_","Expired (GB : Group","_","Budget) return Boolean;","\n","  function Budget","_","Remaining (GB : Group","_","Budget) return Time","_","Span;","\n","\n",(0,s.jsx)(c.A,{children:"10/2_D.14.2"}),"\nprocedure Set","_","Handler (GB      : in out Group","_","Budget;","\n","                         Handler : in Group","_","Budget","_","Handler);","\n","  function Current","_","Handler (GB : Group","_","Budget)","\n","     return Group","_","Budget","_","Handler;","\n","  procedure Cancel","_","Handler (GB        : in out Group","_","Budget;","\n","                            Cancelled : out Boolean);","\n","\n",(0,s.jsx)(c.A,{children:"11/2_D.14.2"}),"\nGroup","_","Budget","_","Error : exception;","\n","\n",(0,s.jsx)(c.A,{children:"12/2_D.14.2"}),"\nprivate","\n","    --  not specified by the language","\n","end Ada.Execution","_","Time.Group","_","Budgets;","\n"]})}),"\n",(0,s.jsx)(c.A,{children:"13/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The type Group","_","Budget represents an execution time budget to be used by a group of tasks. The type Group","_","Budget needs finalization (see ",(0,s.jsx)("a",{href:"/docs/arm/AA-7/AA-7.6",children:"7.6"}),"). A task can belong to at most one group. Tasks of any priority can be added to a group.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"14/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["An object of type Group","_","Budget has an associated nonnegative value of type Time","_","Span known as its ",(0,s.jsx)("em",{children:"budget"}),", which is initially Time","_","Span","_","Zero. The type Group","_","Budget","_","Handler identifies a protected procedure to be executed by the implementation when the budget is ",(0,s.jsx)("em",{children:"exhausted"}),", that is, reaches zero. Such a protected procedure is called a ",(0,s.jsx)("em",{children:"handler"}),". ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"15/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["An object of type Group","_","Budget also includes a handler, which is a value of type Group","_","Budget","_","Handler. The handler of the object is said to be ",(0,s.jsx)("em",{children:"set"})," if it is not null and ",(0,s.jsx)("em",{children:"cleared"})," otherwise. The handler of all Group","_","Budget objects is initially cleared. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"15.a/2_D.14.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"Type Group","_","Budget is tagged. This makes it possible to share a handler between several events. In simple cases, 'Access can be used to compare the parameter with a specific group budget object (this works because a tagged type is a by-reference type). In more complex cases, a type extension of type Group","_","Budget can be declared; a double type conversion can be used to access the extension data. An example of how this can be done can be found for the similar type Timing","_","Event, see ",(0,s.jsx)("a",{href:"/docs/arm/AA-D/AA-D.15",children:"D.15"}),". ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-semantics-2",children:"Dynamic Semantics"}),"\n",(0,s.jsx)(c.A,{children:"16/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Add","_","Task adds the task identified by T to the group GB; if that task is already a member of some other group, Group","_","Budget","_","Error is raised.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"17/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Remove","_","Task removes the task identified by T from the group GB; if that task is not a member of the group GB, Group","_","Budget","_","Error is raised. After successful execution of this procedure, the task is no longer a member of any group.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"18/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Is","_","Member returns True if the task identified by T is a member of the group GB; otherwise, it returns False.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"19/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Is","_","A","_","Group","_","Member returns True if the task identified by T is a member of some group; otherwise, it returns False.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"20/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The function Members returns an array of values of type Task","_","Identification.Task","_","Id identifying the members of the group GB. The order of the components of the array is unspecified.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"21/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0092-1","AI05-0169-1"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Replenish loads the group budget GB with To as the Time","_","Span value. The exception Group","_","Budget","_","Error is raised if the Time","_","Span value To is nonpositive. Any execution on CPU of any member of the group of tasks results in the budget counting down, unless exhausted. When the budget becomes exhausted (reaches Time","_","Span","_","Zero), the associated handler is executed if the handler of group budget GB is set. Nevertheless, the tasks continue to execute.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"22/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Add modifies the budget of the group GB. A positive value for Interval increases the budget. A negative value for Interval reduces the budget, but never below Time","_","Span","_","Zero. A zero value for Interval has no effect. A call of procedure Add that results in the value of the budget going to Time","_","Span","_","Zero causes the associated handler to be executed if the handler of the group budget GB is set.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"23/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Budget","_","Has","_","Expired returns True if the budget of group GB is exhausted (equal to Time","_","Span","_","Zero); otherwise, it returns False.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"24/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The function Budget","_","Remaining returns the remaining budget for the group GB. If the budget is exhausted it returns Time","_","Span","_","Zero. This is the minimum value for a budget.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"25/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Set","_","Handler associates the handler Handler with the Group","_","Budget GB: if Handler is ",(0,s.jsx)("strong",{children:"null"}),", the handler of Group","_","Budget is cleared; otherwise, it is set.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"26/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["A call of Set","_","Handler for a Group","_","Budget that already has a handler set replaces the handler; if Handler is not ",(0,s.jsx)("strong",{children:"null"}),", the handler for Group","_","Budget remains set.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"27/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Current","_","Handler returns the handler associated with the group budget GB if the handler for that group budget is set; otherwise, it returns ",(0,s.jsx)("strong",{children:"null"}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"28/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The procedure Cancel","_","Handler clears the handler for the group budget if it is set. Cancelled is assigned True if the handler for the group budget was set prior to it being cleared; otherwise, it is assigned False.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"29/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The constant Min","_","Handler","_","Ceiling is the minimum ceiling priority required for a protected object with a handler to ensure that no ceiling violation will occur when that handler is invoked.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"30/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["The precision of the accounting of task execution time to a Group","_","Budget is the same as that defined for execution-time clocks from the parent package.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"31/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["As part of the finalization of an object of type Group","_","Budget all member tasks are removed from the group identified by that object.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"32/3_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["If a task is a member of a Group","_","Budget when it terminates, then as part of the finalization of the task it is removed from the group.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"33/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["For all the operations defined in this package, Tasking","_","Error is raised if the task identified by T has terminated, and Program","_","Error is raised if the value of T is Task","_","Identification.Null","_","Task","_","Id.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"34/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["An exception propagated from a handler invoked when the budget of a group of tasks becomes exhausted has no effect.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"erroneous-execution-2",children:"Erroneous Execution"}),"\n",(0,s.jsx)(c.A,{children:"35/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["For a call of any of the subprograms defined in this package, if the task identified by T no longer exists, the execution of the program is erroneous. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"implementation-requirements-2",children:"Implementation Requirements"}),"\n",(0,s.jsx)(c.A,{children:"36/2_D.14.2"}),"\n",(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),"\n",(0,s.jsxs)("p",{children:["For a given Group","_","Budget object, the implementation shall perform the operations declared in this package atomically with respect to any of these operations on the same Group","_","Budget object. The replacement of a handler, by a call of Set","_","Handler, shall be performed atomically with respect to the execution of the handler. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"36.a/2_D.14.2"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"reason",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"This prevents various race conditions. In particular it ensures that if the budget is exhausted when Set","_","Handler is changing the handler then either the new or old handler is executed and the exhausting event is not lost. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"37/2_D.14.2"}),(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE 1   Clearing or setting of the handler of a group budget does not change the current value of the budget. Exhaustion or loading of a budget does not change whether the handler of the group budget is set or cleared.",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"38/2_D.14.2"}),(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["NOTE 2   A Group","_","Budget","_","Handler can be associated with several Group","_","Budget objects. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-95-2",children:"Extensions to Ada 95"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"38.a/2_D.14.2"}),(0,s.jsx)(l.A,{items:["AI95-00354-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The package Execution","_","Time.Group","_","Budgets is new. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"inconsistencies-with-ada-2005",children:"Inconsistencies With Ada 2005"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"38.b/3_D.14.2"}),(0,s.jsx)(l.A,{items:["AI05-0169-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["A Group","_","Budget is now defined to work on a single processor. If an implementation managed to make this package work for programs running on a multiprocessor system, and a program depends on that fact, it could fail when ported to Ada 2012. We believe it is unlikely that such an implementation exists because of the difficulty of signalling other processors when the time reaches zero; in any case, depending on such an implementation is not portable. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)("a",{id:"Subclause_D.14.3"}),"\n",(0,s.jsx)(n.h2,{id:"d143--execution-time-of-interrupt-handlers",children:"D.14.3  Execution Time of Interrupt Handlers"}),"\n",(0,s.jsx)(c.A,{children:"1/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1","AI05-0299-1"]}),"\n",(0,s.jsxs)("p",{children:["This subclause describes a language-defined package to measure the execution time of interrupt handlers. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"static-semantics-3",children:"Static Semantics"}),"\n",(0,s.jsx)(c.A,{children:"2/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["The following language-defined library package exists: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"3/5_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI12-0241-1","AI12-0302-1"]}),"\n",(0,s.jsx)(d.A,{language:"ada",children:(0,s.jsxs)(n.p,{children:["with Ada.Interrupts;","\n","package Ada.Execution","_","Time.Interrupts","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","   function Clock (Interrupt : Ada.Interrupts.Interrupt","_","Id)","\n","        return CPU","_","Time;","\n","   function Supported (Interrupt : Ada.Interrupts.Interrupt","_","Id)","\n","        return Boolean;","\n","end Ada.Execution","_","Time.Interrupts;","\n"]})}),"\n",(0,s.jsx)(c.A,{children:"4/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["The execution time or CPU time of a given interrupt Interrupt is defined as the time spent by the system executing interrupt handlers identified by Interrupt, including the time spent executing run-time or system services on its behalf. The mechanism used to measure execution time is implementation defined. Time spent executing interrupt handlers is distinct from time spent executing any task. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"4.a/3_D.14.3"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)("strong",{}),"The implementation-defined mechanism here is the same as that covered by the Documentation Requirements of ",(0,s.jsx)("a",{href:"/docs/arm/AA-D/AA-D.14",children:"D.14"}),", so we don't repeat that requirement here. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(c.A,{children:"5/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["For each interrupt, the execution time value is initially set to zero. ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-semantics-3",children:"Dynamic Semantics"}),"\n",(0,s.jsx)(c.A,{children:"6/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Clock returns the current cumulative execution time of the interrupt identified by Interrupt. If Separate","_","Interrupt","_","Clocks","_","Supported is set to False the function raises Program","_","Error.",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(c.A,{children:"7/3_D.14.3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0170-1","AI05-0264-1"]}),"\n",(0,s.jsxs)("p",{children:["The function Supported returns True if the implementation is monitoring the execution time of the interrupt identified by Interrupt; otherwise, it returns False. For any Interrupt","_","Id Interrupt for which Supported(Interrupt) returns False, the function Clock(Interrupt) will return a value equal to Ada.Execution","_","Time.Time","_","Of(0).",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(n.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(c.A,{children:"7.a/3_D.14.3"}),(0,s.jsx)(l.A,{items:["AI05-0170-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(n.p,{children:["The package Execution","_","Time.Interrupts is new. ",(0,s.jsx)("br",{})]})})]})]})}function j(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);