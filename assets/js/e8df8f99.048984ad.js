"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2446],{19625:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>A,contentTitle:()=>l,default:()=>j,frontMatter:()=>o,metadata:()=>h,toc:()=>x});var n=s(74848),a=s(28453),i=s(13842),t=s(91435),d=(s(21432),s(79162)),c=s(34421);const o={sidebar_position:10},l="2.2 Lexical Elements, Separators, and Delimiters",h={id:"arm/AA-2/AA-2.2",title:"2.2 Lexical Elements, Separators, and Delimiters",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-2/AA-2.2.mdx",sourceDirName:"arm/AA-2",slug:"/arm/AA-2/AA-2.2",permalink:"/docs/arm/AA-2/AA-2.2",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"referenceManualSidebar",previous:{title:"2.1 Character Set",permalink:"/docs/arm/AA-2/AA-2.1"},next:{title:"2.3 Identifiers",permalink:"/docs/arm/AA-2/AA-2.3"}},A={},x=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}];function m(e){const r={a:"a",admonition:"admonition",h1:"h1",h4:"h4",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"22-lexical-elements-separators-and-delimiters",children:"2.2 Lexical Elements, Separators, and Delimiters"}),"\n",(0,n.jsx)(r.admonition,{type:"danger",children:(0,n.jsxs)(r.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.jsx)(r.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,n.jsx)(r.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,n.jsx)(d.A,{children:"1"}),"\n",(0,n.jsxs)("p",{children:["The text of a program consists of the texts of one or more ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0285",children:"compilation"})}),"s. The text of each ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0285",children:"compilation"})})," is a sequence of separate ",(0,n.jsx)("em",{children:"lexical elements"}),". Each lexical element is formed from a sequence of characters, and is either a delimiter, an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),", a reserved word, a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.4#S0006",children:"numeric_literal"})}),", a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.5#S0015",children:"character_literal"})}),", a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.6#S0016",children:"string_literal"})}),", or a comment. The meaning of a program depends only on the particular sequences of lexical elements that form its ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0285",children:"compilation"})}),"s, excluding ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),"s.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"2/3"}),"\n",(0,n.jsx)(c.A,{items:["AI95-00285-01","AI05-0262-1"]}),"\n",(0,n.jsxs)("p",{children:["The text of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0285",children:"compilation"})})," is divided into ",(0,n.jsx)("em",{children:"lines"}),". In general, the representation for an end of line is implementation defined. However, a sequence of one or more ",(0,n.jsxs)("code",{children:["format","_","effector"]}),"s other than the character whose code point is 16","#","09","#"," (CHARACTER TABULATION) signifies at least one end of line. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"2.a"}),(0,n.jsx)(i.A,{type:"aarm",aarm:"implementation-defined",children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)("strong",{}),"The representation for an end of line.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(d.A,{children:"3/2"}),"\n",(0,n.jsx)(c.A,{items:["AI95-00285-01"]}),"\n",(0,n.jsxs)("p",{children:["[In some cases an explicit ",(0,n.jsx)("em",{children:"separator"})," is required to separate adjacent lexical elements.] A separator is any of a ",(0,n.jsxs)("code",{children:["separator","_","space"]}),", a ",(0,n.jsxs)("code",{children:["format","_","effector"]}),", or the end of a line, as follows: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"4/2"}),"\n",(0,n.jsx)(c.A,{items:["AI95-00285-01"]}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["A ",(0,n.jsxs)("code",{children:["separator","_","space"]})," is a separator except within a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),", a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.6#S0016",children:"string_literal"})}),", or a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.5#S0015",children:"character_literal"})}),".",(0,n.jsx)("br",{})]}),(0,n.jsx)(d.A,{children:"5/3"}),(0,n.jsx)(c.A,{items:["AI95-00285-01","AI05-0262-1"]}),(0,n.jsxs)("li",{children:["The character whose code point is 16","#","09","#"," (CHARACTER TABULATION) is a separator except within a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),".",(0,n.jsx)("br",{})]}),(0,n.jsx)(d.A,{children:"6"}),(0,n.jsxs)("li",{children:["The end of a line is always a separator. ",(0,n.jsx)("br",{})]})]}),"\n",(0,n.jsx)(d.A,{children:"7"}),"\n",(0,n.jsxs)("p",{children:["One or more separators are allowed between any two adjacent lexical elements, before the first of each ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0285",children:"compilation"})}),", or after the last. At least one separator is required between an ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),", a reserved word, or a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.4#S0006",children:"numeric_literal"})})," and an adjacent ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.3#S0002",children:"identifier"})}),", reserved word, or ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.4#S0006",children:"numeric_literal"})}),".",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"7.1/3"}),"\n",(0,n.jsx)(c.A,{items:["AI05-0079-1"]}),"\n",(0,n.jsxs)("p",{children:["One or more ",(0,n.jsxs)("code",{children:["other","_","format"]})," characters are allowed anywhere that a separator is[; any such characters have no effect on the meaning of an Ada program].",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"8/2"}),"\n",(0,n.jsx)(c.A,{items:["AI95-00285-01"]}),"\n",(0,n.jsxs)("p",{children:["A ",(0,n.jsx)("em",{children:"delimiter"})," is either one of the following characters: ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"9/5"}),"\n",(0,n.jsx)(c.A,{items:["AI12-0125-3","AI12-0212-1"]}),"\n",(0,n.jsxs)("p",{class:"Indented2",children:["&    '    (    )    ","*","    +    ,    \u2013    .    /    :    ;    ","<","    =    ",">","    @    [    ]    |",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"10"}),"\n",(0,n.jsxs)("p",{children:["or one of the following ",(0,n.jsx)("em",{children:"compound delimiters"})," each composed of two adjacent special characters ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"11"}),"\n",(0,n.jsxs)("p",{class:"Indented2",children:["=",">","    ..    ","*","*","    :=    /=    ",">","=    ","<","=    ","<","<","    ",">",">","    ","<",">",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"12"}),"\n",(0,n.jsxs)("p",{children:["Each of the special characters listed for single character delimiters is a single delimiter except if this character is used as a character of a compound delimiter, or as a character of a ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),", ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.6#S0016",children:"string_literal"})}),", ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.5#S0015",children:"character_literal"})}),", or ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-2/AA-2.4#S0006",children:"numeric_literal"})}),".",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(d.A,{children:"13"}),"\n",(0,n.jsxs)("p",{children:["The following names are used when referring to compound delimiters:",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(r.h4,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,n.jsx)(d.A,{children:"14"}),"\n",(0,n.jsxs)("p",{children:["delimiter name=",">","arrow..double dot","*","*","double star, exponentiate:=assignment (pronounced: \u201cbecomes\u201d)/=inequality (pronounced: \u201cnot equal\u201d)",">","=greater than or equal","<","=less than or equal","<","<","left label bracket",">",">","right label bracket","<",">","boxAn implementation shall support lines of at least 200 characters in length, not counting any characters used to signify the end of a line. An implementation shall support lexical elements of at least 200 characters in length. The maximum supported line length and lexical element length are implementation defined. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"14.a"}),(0,n.jsx)(i.A,{type:"aarm",aarm:"implementation-defined",children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)("strong",{}),"Maximum supported line length and lexical element length.",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"14.b"}),(0,n.jsx)(i.A,{type:"aarm",aarm:"discussion",children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)("strong",{}),"From URG recommendation. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(t.A,{children:(0,n.jsx)(r.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"14.c/3"}),(0,n.jsx)(c.A,{items:["AI95-00285-01","AI05-0299-1"]}),(0,n.jsx)(i.A,{type:"aarm",aarm:"note",children:(0,n.jsxs)(r.p,{children:["The wording was updated to use the new character categories defined in the preceding subclause. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(t.A,{children:(0,n.jsx)(r.h4,{id:"extensions-to-ada-2005",children:"Extensions to Ada 2005"})}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"14.d/3"}),(0,n.jsx)(c.A,{items:["AI05-0079-1"]}),(0,n.jsx)(i.A,{type:"aarm",aarm:"correction",children:(0,n.jsxs)(r.p,{children:[(0,n.jsx)("strong",{})," Clarified that ",(0,n.jsxs)("code",{children:["other","_","format"]})," characters are allowed anywhere that separators are allowed. This was intended in Ada 2005, but didn't actually make it into the wording. ",(0,n.jsx)("br",{})]})})]}),"\n",(0,n.jsx)(t.A,{children:(0,n.jsx)(r.h4,{id:"wording-changes-from-ada-2012",children:"Wording Changes from Ada 2012"})}),"\n",(0,n.jsxs)(t.A,{children:[(0,n.jsx)(d.A,{children:"14.e/5"}),(0,n.jsx)(c.A,{items:["AI12-0125-3","AI12-0212-1"]}),(0,n.jsx)(i.A,{type:"aarm",aarm:"note",children:(0,n.jsxs)(r.p,{children:["Added square brackets and the ",(0,n.jsx)("code",{children:(0,n.jsx)("a",{href:"/docs/arm/AA-5/AA-5.2#S0174",children:"target_name"})})," symbol (see ",(0,n.jsx)("a",{href:"/docs/arm/AA-5/AA-5.2#Subclause_5.2.1",children:"5.2.1"}),") to the list of delimiters. ",(0,n.jsx)("br",{})]})})]})]})}function j(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}}}]);