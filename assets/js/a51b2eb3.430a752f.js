"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1814],{25097:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var i=s(74848),t=s(28453);const r={sidebar_position:100},a="Issues",l={id:"learn/getting-started/macos-issues/issues",title:"Issues",description:"- Linking error",source:"@site/docs/learn/getting-started/macos-issues/issues.md",sourceDirName:"learn/getting-started/macos-issues",slug:"/learn/getting-started/macos-issues/issues",permalink:"/docs/learn/getting-started/macos-issues/issues",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:100,frontMatter:{sidebar_position:100},sidebar:"tutorialSidebar",previous:{title:"Crates for macOS",permalink:"/docs/learn/getting-started/macos-issues/crates"},next:{title:"Tips and Tricks",permalink:"/docs/category/tips-and-tricks"}},o={},d=[{value:"<a>Linking error</a>",id:"linking-error",level:2},{value:"<a>Unhandled exceptions</a>",id:"unhandled-exceptions",level:2},{value:"<a>Transparent solution</a>",id:"transparent-solution",level:2},{value:"<a>The future</a>",id:"the-future",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"issues",children:"Issues"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#linking-error",children:"Linking error"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#unhandled-exceptions",children:"Unhandled exceptions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transparent-solution",children:"Transparent solution"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#the-future",children:"The future"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"linking-error",children:(0,i.jsx)("a",{name:"linking-error",children:"Linking error"})}),"\n",(0,i.jsx)(n.p,{children:"If you're running macOS 13.5 (Ventura) or later, you'll probably have been offered updates to version 15 of Xcode/the Command Line Tools. With version 15.0, we encountered the, rather fundamental, problem that all links failed, with a slew of messages including"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ld: Assertion failed: (resultIndex < sectData.atoms.size()), function findAtom, file Relocations.cpp, line 1336.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This happened because Apple had introduced a new linker (",(0,i.jsx)(n.code,{children:"ld"}),"). A workround for this issue turned out to be to use a version of the older linker included in the SDK, ",(0,i.jsx)(n.code,{children:"ld-classic"}),". You can tell ",(0,i.jsx)(n.code,{children:"gprbuild"})," or ",(0,i.jsx)(n.code,{children:"gnatmake"})," to do this from the command line by adding"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-largs -Wl,-ld_classic\n"})}),"\n",(0,i.jsxs)(n.p,{children:["(notice the change from dash to underscore!) This fix doesn't work with older SDKs that don't have ",(0,i.jsx)(n.code,{children:"ld-classic"})," - they would interpret it as looking for a library ",(0,i.jsx)(n.code,{children:"libd_classic"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The updated SDKs (version 15.1) fixed this issue, so you no longer needed the workround."}),"\n",(0,i.jsx)(n.h2,{id:"unhandled-exceptions",children:(0,i.jsx)("a",{name:"unhandled-exceptions",children:"Unhandled exceptions"})}),"\n",(0,i.jsx)(n.p,{children:"It turns out that there's a more subtle problem than the blatant failure to link: exception handling can be unreliable. If you get unhandled exceptions from code with a clearly visible exception handler, this is what's going on."}),"\n",(0,i.jsx)(n.p,{children:"This issue is also solved by using the classic linker."}),"\n",(0,i.jsx)(n.h2,{id:"transparent-solution",children:(0,i.jsx)("a",{name:"transparent-solution",children:"Transparent solution"})}),"\n",(0,i.jsxs)(n.p,{children:["We have a solution which transparently invokes ",(0,i.jsx)(n.code,{children:"ld-classic"})," if it's present in the SDK. The solution is to place a 'shim' named ",(0,i.jsx)(n.code,{children:"ld"})," where GCC will look for it and invoke it instead of directly calling ",(0,i.jsx)(n.code,{children:"/usr/bin/ld"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The latest release of the installer can be found ",(0,i.jsx)(n.a,{href:"https://github.com/simonjwright/xcode_15_fix/releases",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"the-future",children:(0,i.jsx)("a",{name:"the-future",children:"The future"})}),"\n",(0,i.jsx)(n.p,{children:"It turns out that the reason for the issue is that GCC mishandles the Darwin ABI by placing exception handling data in the wrong segment of the executable. This has been fixed in the GCC 14.0.1 pre-release, and it's hoped that it will be backported to GCC 13.3."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);