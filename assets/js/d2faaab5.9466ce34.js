"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["5338"],{3166:function(e,r,n){n.r(r),n.d(r,{frontMatter:()=>o,toc:()=>m,default:()=>u,metadata:()=>s,assets:()=>j,contentTitle:()=>x});var s=JSON.parse('{"id":"arm/AA-J/AA-J.7","title":"J.7. At Clauses","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-J/AA-J.7.mdx","sourceDirName":"arm/AA-J","slug":"/arm/AA-J/AA-J.7","permalink":"/docs/arm/AA-J/AA-J.7","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":200,"frontMatter":{"sidebar_position":200},"sidebar":"referenceManualSidebar","previous":{"title":"J.6. Numeric_Error","permalink":"/docs/arm/AA-J/AA-J.6"},"next":{"title":"J.8. Mod Clauses","permalink":"/docs/arm/AA-J/AA-J.8"}}'),i=n(5893),t=n(65),a=n(3393),d=n(2315),c=n(8514),l=n(1927),h=n(6470);let o={sidebar_position:200},x="J.7. At Clauses",j={},m=[{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"J.7.1  Interrupt Entries",id:"j71--interrupt-entries",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4}];function p(e){let r={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"j7-at-clauses",children:"J.7. At Clauses"})}),"\n",(0,i.jsx)(r.admonition,{type:"danger",children:(0,i.jsxs)(r.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,i.jsx)(r.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,i.jsx)(r.h4,{id:"syntax",children:"Syntax"}),"\n",(0,i.jsx)(l.Z,{children:"1"}),"\n",(0,i.jsx)(c.Z,{children:(0,i.jsxs)(r.p,{children:[(0,i.jsxs)("code",{children:["at","_","clause"]}),(0,i.jsx)("a",{id:"S0368"}),(0,i.jsx)("code",{children:" ::= "}),(0,i.jsx)("b",{children:"for"})," ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-4/AA-4.1#S0092",children:"direct_name"})})," ",(0,i.jsx)("b",{children:"use"})," ",(0,i.jsx)("b",{children:"at"})," ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})}),";",(0,i.jsx)("br",{})]})}),"\n",(0,i.jsx)(r.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,i.jsx)(l.Z,{children:"2"}),"\n",(0,i.jsxs)("p",{children:["An ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," of the form \u201Cfor ",(0,i.jsx)("i",{children:"x"})," use at ",(0,i.jsx)("i",{children:"y"}),";\u201D is equivalent to an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})})," of the form \u201Cfor ",(0,i.jsx)("i",{children:"x"}),"'Address use ",(0,i.jsx)("i",{children:"y"}),";\u201D. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"2.a"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(r.p,{children:[(0,i.jsx)("b",{}),"The preferred syntax for specifying the address of an entity is an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})})," specifying the Address attribute. Therefore, the special-purpose ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," syntax is now obsolete.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"2.b"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["The above equivalence implies, for example, that only one ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," is allowed for a given entity. Similarly, it is illegal to give both an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," and an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})})," specifying the Address attribute. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(d.Z,{children:(0,i.jsx)(r.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"2.c"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["We now allow to define the address of an entity using an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),". This is because Ada 83's ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," is so hard to remember: programmers often tend to write \u201Cfor X'Address use...;\u201D. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(d.Z,{children:(0,i.jsx)(r.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"2.d"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["Ada 83's ",(0,i.jsxs)("code",{children:["address","_","clause"]})," is now called an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})})," to avoid confusion with the new term \u201CAddress clause\u201D (that is, an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})})," for the Address attribute). ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)("a",{id:"Subclause_J.7.1"}),"\n",(0,i.jsx)(r.h2,{id:"j71--interrupt-entries",children:"J.7.1  Interrupt Entries"}),"\n",(0,i.jsx)(l.Z,{children:"1_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["[Implementations are permitted to allow the attachment of task entries to interrupts via the address clause. Such an entry is referred to as an ",(0,i.jsx)("i",{children:"interrupt entry"}),".",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"2_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The address of the task entry corresponds to a hardware interrupt in an implementation-defined manner. (See Ada.Interrupts.Reference in ",(0,i.jsx)("a",{href:"/docs/arm/AA-C/AA-C.3#Subclause_C.3.2",children:"C.3.2"}),".)] ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.h4,{id:"static-semantics-1",children:"Static Semantics"}),"\n",(0,i.jsx)(l.Z,{children:"3_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The following attribute is defined:",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"4_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["For any task entry X: ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"5_J.7.1"}),"\n",(0,i.jsxs)("dt",{children:[(0,i.jsx)("br",{}),"X'Address "]}),"\n",(0,i.jsxs)("dl",{children:[(0,i.jsxs)("dd",{children:["For a task entry whose address is specified (an ",(0,i.jsx)("i",{children:"interrupt entry"}),"), the value refers to the corresponding hardware interrupt. For such an entry, as for any other task entry, the meaning of this value is implementation defined. The value of this attribute is of the type of the subtype System.Address.",(0,i.jsx)("br",{})]}),(0,i.jsx)(l.Z,{children:"6_J.7.1"}),(0,i.jsxs)("dd",{children:["Address may be specified for single entries via an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),". ",(0,i.jsx)("br",{})]})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"6.a_J.7.1"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"reason",children:(0,i.jsxs)(r.p,{children:[(0,i.jsx)("b",{}),"Because of the equivalence of ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-J/AA-J.7#S0368",children:"at_clause"})}),"s and ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),"s, an interrupt entry may be specified via either notation. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.h4,{id:"dynamic-semantics",children:"Dynamic Semantics"}),"\n",(0,i.jsx)(l.Z,{children:"7_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["As part of the initialization of a task object, the address clause for an interrupt entry is elaborated[, which evaluates the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-4/AA-4.4#S0132",children:"expression"})})," of the address clause]. A check is made that the address specified is associated with some interrupt to which a task entry may be attached. If this check fails, Program","_","Error is raised. Otherwise, the interrupt entry is attached to the interrupt associated with the specified address.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"8_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["Upon finalization of the task object, the interrupt entry, if any, is detached from the corresponding interrupt and the default treatment is restored.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"9_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["While an interrupt entry is attached to an interrupt, the interrupt is reserved (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-C/AA-C.3",children:"C.3"}),").",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"10_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["An interrupt delivered to a task entry acts as a call to the entry issued by a hardware task whose priority is in the System.Interrupt","_","Priority range. It is implementation defined whether the call is performed as an ordinary entry call, a timed entry call, or a conditional entry call; which kind of call is performed can depend on the specific interrupt.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.h4,{id:"bounded-run-time-errors",children:"Bounded (Run-Time) Errors"}),"\n",(0,i.jsx)(l.Z,{children:"11_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["It is a bounded error to evaluate E'Caller (see ",(0,i.jsx)("a",{href:"/docs/arm/AA-C/AA-C.7#Subclause_C.7.1",children:"C.7.1"}),") in an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0258",children:"accept_statement"})})," for an interrupt entry. The possible effects are the same as for calling Current","_","Task from an entry body. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.h4,{id:"documentation-requirements",children:"Documentation Requirements"}),"\n",(0,i.jsx)(l.Z,{children:"12_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The implementation shall document to which interrupts a task entry may be attached. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"12.a/2_J.7.1"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:[(0,i.jsx)("b",{children:"Documentation Requirement: "}),"The interrupts to which a task entry may be attached.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(l.Z,{children:"13_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The implementation shall document whether the invocation of an interrupt entry has the effect of an ordinary entry call, conditional call, or a timed call, and whether the effect varies in the presence of pending interrupts. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"13.a/2_J.7.1"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:[(0,i.jsx)("b",{children:"Documentation Requirement: "}),"The type of entry call invoked for an interrupt entry.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,i.jsx)(l.Z,{children:"14_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The support for this subclause is optional.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"15_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["Interrupts to which the implementation allows a task entry to be attached may be designated as reserved for the entire duration of program execution[; that is, not just when they have an interrupt entry attached to them].",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"16/1_J.7.1"}),"\n",(0,i.jsx)(h.Z,{items:["AI95-00111-01"]}),"\n",(0,i.jsxs)("p",{children:["{",(0,i.jsx)("i",{children:"8652/0077"}),"}"," Interrupt entry calls may be implemented by having the hardware execute directly the appropriate ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0258",children:"accept_statement"})}),". Alternatively, the implementation is allowed to provide an internal interrupt handler to simulate the effect of a normal task calling the entry.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"17_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["The implementation is allowed to impose restrictions on the specifications and bodies of tasks that have interrupt entries.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"18_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["It is implementation defined whether direct calls (from the program) to interrupt entries are allowed.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"19_J.7.1"}),"\n",(0,i.jsxs)("p",{children:["If a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0269",children:"select_statement"})})," contains both a ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0275",children:"terminate_alternative"})})," and an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0273",children:"accept_alternative"})})," for an interrupt entry, then an implementation is allowed to impose further requirements for the selection of the ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.7#S0275",children:"terminate_alternative"})})," in addition to those given in ",(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.3",children:"9.3"}),". ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"20/1_J.7.1"}),(0,i.jsx)(h.Z,{items:["AI95-00111-01"]}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["NOTE 1   ","{",(0,i.jsx)("i",{children:"8652/0077"}),"}"," Queued interrupts correspond to ordinary entry calls. Interrupts that are lost if not immediately processed correspond to conditional entry calls. It is a consequence of the priority rules that an ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0258",children:"accept_statement"})})," executed in response to an interrupt can be executed with the active priority at which the hardware generates the interrupt, taking precedence over lower priority tasks, without a scheduling action.",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"21_J.7.1"}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["NOTE 2   Control information that is supplied upon an interrupt can be passed to an associated interrupt entry as one or more parameters of mode ",(0,i.jsx)("b",{children:"in"}),". ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(r.h4,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(l.Z,{children:"22_J.7.1"}),"\n",(0,i.jsxs)("p",{children:[(0,i.jsx)("i",{children:"Example of an interrupt entry:"})," ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(l.Z,{children:"23_J.7.1"}),"\n",(0,i.jsx)(c.Z,{language:"ada",children:(0,i.jsxs)(r.p,{children:["task Interrupt","_","Handler is","\n","  entry Done;","\n","  for Done'Address use Ada.Interrupts.Reference(Ada.Interrupts.Names.Device","_","Done);","\n","end Interrupt","_","Handler;","\n"]})}),"\n",(0,i.jsx)(d.Z,{children:(0,i.jsx)(r.h4,{id:"wording-changes-from-ada-83-1",children:"Wording Changes from Ada 83"})}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"23.a/2_J.7.1"}),(0,i.jsx)(h.Z,{items:["AI95-00114-01"]}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["RM83-13.5.1 did not adequately address the problems associated with interrupts. This feature is now obsolescent and is replaced by the Ada 95 interrupt model as specified in the Systems Programming Annex. ",(0,i.jsx)("br",{})]})})]}),"\n",(0,i.jsx)(d.Z,{children:(0,i.jsx)(r.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,i.jsxs)(d.Z,{children:[(0,i.jsx)(l.Z,{children:"23.b/2_J.7.1"}),(0,i.jsx)(h.Z,{items:["AI95-00111-01"]}),(0,i.jsx)(a.Z,{type:"aarm",aarm:"note",children:(0,i.jsxs)(r.p,{children:["{",(0,i.jsx)("i",{children:"8652/0077"}),"}"," ",(0,i.jsx)("b",{children:"Corrigendum:"})," The undefined term ",(0,i.jsx)("i",{children:"accept body"})," was replaced by ",(0,i.jsx)("code",{children:(0,i.jsx)("a",{href:"/docs/arm/AA-9/AA-9.5#S0258",children:"accept_statement"})}),". ",(0,i.jsx)("br",{})]})})]})]})}function u(e={}){let{wrapper:r}={...(0,t.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);