"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["347"],{6587:function(e,n,a){a.r(n),a.d(n,{frontMatter:()=>l,toc:()=>o,default:()=>u,metadata:()=>i,assets:()=>d,contentTitle:()=>t});var i=JSON.parse('{"id":"style-guide/s10/04","title":"10.4 Data Structures","description":"Dynamic Arrays","source":"@site/docs/style-guide/s10/04.mdx","sourceDirName":"style-guide/s10","slug":"/style-guide/s10/04","permalink":"/docs/style-guide/s10/04","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"10.4 Data Structures"},"sidebar":"styleGuideSidebar","previous":{"title":"10.3 Program Structure","permalink":"/docs/style-guide/s10/03"},"next":{"title":"10.5 Algorithms","permalink":"/docs/style-guide/s10/05"}}'),r=a(5893),s=a(65);let l={title:"10.4 Data Structures"},t=void 0,d={},o=[{value:"Dynamic Arrays",id:"dynamic-arrays",level:3},{value:"guideline",id:"guideline",level:4},{value:"rationale",id:"rationale",level:4},{value:"Zero-Based Arrays",id:"zero-based-arrays",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Unconstrained Records",id:"unconstrained-records",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Records and Arrays",id:"records-and-arrays",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Record and Array Aggregates",id:"record-and-array-aggregates",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"rationale",id:"rationale-4",level:4}];function c(e){let n={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"dynamic-arrays",children:"Dynamic Arrays"}),"\n",(0,r.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use constrained arrays when measured performance indicates."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,r.jsx)(n.p,{children:"If array bounds are not known until run-time, then calculations of these\nbounds may affect run-time performance. Using named constants or static\nexpressions as array bounds may provide better performance than using\nvariables or nonstatic expressions. Thus, if the values of Lower and\nUpper are not determined until run-time, then:"}),"\n",(0,r.jsx)(n.p,{children:"... is array (Lower .. Upper) of ..."}),"\n",(0,r.jsx)(n.p,{children:"may cause address and offset calculations to be delayed until run-time,\nintroducing a performance penalty. See NASA (1992) for a detailed\ndiscussion of the tradeoffs and alternatives."}),"\n",(0,r.jsx)(n.h3,{id:"zero-based-arrays",children:"Zero-Based Arrays"}),"\n",(0,r.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use zero-based indexing for arrays when measured performance\nindicates."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,r.jsx)(n.p,{children:"For some compilers, offset calculations for an array whose lower bound\nis 0 (either the integer zero or the first value of an enumeration type)\nare simplified. For other compilers, optimization is more likely if the\nlower bound is 1."}),"\n",(0,r.jsx)(n.h3,{id:"unconstrained-records",children:"Unconstrained Records"}),"\n",(0,r.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use fixed-size components for records when measured performance\nindicates."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ada",children:"subtype Line_Range   is Integer range 0 .. Max_Lines;\nsubtype Length_Range is Integer range 0 .. Max_Length;\n\n-- Note that Max_Lines and Max_Length need to be static\ntype Paragraph_Body is array (Line_Range range <>, Length_Range range <>) of Character;\n\ntype Paragraph (Lines : Line_Range := 0; Line_Length : Length_Range := 0) is\n   record\n      Text : Paragraph_Body (1 .. Lines, 1 .. Line_Length);\n   end record;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,r.jsx)(n.p,{children:"Determine the size and speed impact of unconstrained records having\ncomponents depending on discriminants. Some compilers will allocate the\nmaximum possible size to each object of the type; others will use\npointers to the dependent components, incurring a possible heap\nperformance penalty. Consider the possibility of using fixed-size\ncomponents."}),"\n",(0,r.jsx)(n.h3,{id:"records-and-arrays",children:"Records and Arrays"}),"\n",(0,r.jsx)(n.h4,{id:"guideline-3",children:"guideline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Define arrays of records as parallel arrays when measured\nperformance indicates."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ada",children:"    -- Array of records\n    Process (Student (Index).Name, Student (Index).Grade);\n    -- Record of arrays\n    Process (Student.Name (Index), Student.Grade (Index));\n    -- Parallel arrays\n    Process (Name (Index), Grade (Index));\n"})}),"\n",(0,r.jsx)(n.h4,{id:"rationale-3",children:"rationale"}),"\n",(0,r.jsx)(n.p,{children:"Determine the impact of structuring data as arrays of records, records\ncontaining arrays, or parallel arrays. Some implementations of Ada will\nshow significant performance differences among these examples."}),"\n",(0,r.jsx)(n.h3,{id:"record-and-array-aggregates",children:"Record and Array Aggregates"}),"\n",(0,r.jsx)(n.h4,{id:"guideline-4",children:"guideline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use a sequence of assignments for an aggregation when measured\nperformance indicates."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"rationale-4",children:"rationale"}),"\n",(0,r.jsx)(n.p,{children:'Determine the impact of using an aggregate versus a sequence of\nassignments. Using an aggregate generally requires the use of a\ntemporary variable. If the aggregate is "static" (i.e., its size and\ncomponents are known at compile- or link-time, allowing link-time\nallocation and initialization), then it will generally be more efficient\nthan a sequence of assignments. If the aggregate is "dynamic," then a\nseries of assignments may be more efficient because no temporary\nvariable is needed.'}),"\n",(0,r.jsx)(n.p,{children:"See Guideline 5.6.10 for a discussion of aggregates from the point of\nview of readability and maintainability."}),"\n",(0,r.jsx)(n.p,{children:"See Guideline 10.6.1 for a discussion of extension aggregates."})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);