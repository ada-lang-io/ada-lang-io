"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8714],{52329:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>h,default:()=>b,frontMatter:()=>p,metadata:()=>m,toc:()=>f});var i=t(91716),a=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,n,t)=>n in e?a(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,u=(e,n)=>{for(var t in n||(n={}))l.call(n,t)&&d(e,t,n[t]);if(s)for(var t of s(n))c.call(n,t)&&d(e,t,n[t]);return e};const p={title:"9.5 Multiple Inheritance"},h=void 0,m={unversionedId:"style-guide/s9/05",id:"style-guide/s9/05",title:"9.5 Multiple Inheritance",description:"Ada provides several mechanisms to support multiple inheritance, where",source:"@site/docs/style-guide/s9/05.mdx",sourceDirName:"style-guide/s9",slug:"/style-guide/s9/05",permalink:"/docs/style-guide/s9/05",draft:!1,tags:[],version:"current",frontMatter:{title:"9.5 Multiple Inheritance"},sidebar:"styleGuideSidebar",previous:{title:"9.4 Managing Visibility",permalink:"/docs/style-guide/s9/04"},next:{title:"9.6 Summary",permalink:"/docs/style-guide/s9/06"}},g={},f=[{value:"Multiple Inheritance Techniques",id:"multiple-inheritance-techniques",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4}],_={toc:f};function b(e){var n,t=e,{components:a}=t,d=((e,n)=>{var t={};for(var i in e)l.call(e,i)&&n.indexOf(i)<0&&(t[i]=e[i]);if(null!=e&&s)for(var i of s(e))n.indexOf(i)<0&&c.call(e,i)&&(t[i]=e[i]);return t})(t,["components"]);return(0,i.kt)("wrapper",(n=u(u({},_),d),o(n,r({components:a,mdxType:"MDXLayout"}))),(0,i.kt)("p",null,'Ada provides several mechanisms to support multiple inheritance, where\nmultiple inheritance is a means for incrementally building new\nabstractions from existing ones, as defined at the beginning of this\nchapter. Specifically, Ada supports multiple inheritance module\ninclusion (via multiple with/use clauses), multiple inheritance\n"is-implemented-using" via private extensions and record composition,\nand multiple inheritance mixins via the use of generics, formal\npackages, and access discriminants (Taft 1994).'),(0,i.kt)("h3",u({},{id:"multiple-inheritance-techniques"}),"Multiple Inheritance Techniques"),(0,i.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using type composition for implementation, as opposed to\ninterface, inheritance."),(0,i.kt)("li",{parentName:"ul"},'Consider using a generic to "mix in" functionality to a derivative\nof some core abstraction.'),(0,i.kt)("li",{parentName:"ul"},'Consider using access discriminants to support "full" multiple\ninheritance where an object must be referenceable as an entity of\ntwo or more distinct unrelated abstractions.')),(0,i.kt)("h4",u({},{id:"example"}),"example"),(0,i.kt)("p",null,"Both examples that follow are taken directly from Taft (1994). The first\nshows how to use multiple inheritance techniques to create an abstract\ntype whose interface inherits from one type and whose implementation\ninherits from another type. The second example shows how to enhance the\nfunctionality of a basic abstraction by mixing in new features."),(0,i.kt)("p",null,"The abstract type Set_Of_Strings provides the interface to inherit:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"\ntype Set_Of_Strings is abstract tagged limited private;\ntype Element_Index is new Natural;  -- Index within set.\nNo_Element : constant Element_Index := 0;\nInvalid_Index : exception;\nprocedure Enter(\n  -- Enter an element into the set, return the index\n  Set : in out Set_Of_Strings;\n  S : String;\n  Index : out Element_Index) is abstract;\nprocedure Remove(\n  -- Remove an element from the set; ignore if not there\n  Set : in out Set_Of_Strings;\n  S : String) is abstract;\nprocedure Combine(\n  -- Combine Additional_Set into Union_Set\n  Union_Set : in out Set_Of_Strings;\n  Additional_Set : Set_Of_Strings) is abstract;\nprocedure Intersect(\n  -- Remove all elements of Removal_Set from Intersection_Set\n  Intersection_Set : in out Set_Of_Strings;\n  Removal_Set : Set_Of_Strings) is abstract;\nfunction Size(Set : Set_Of_Strings) return Element_Index\n  is abstract;\n  -- Return a count of the number of elements in the set\nfunction Index(\n  -- Return the index of a given element;\n  -- return No_Element if not there.\n  Set : Set_Of_Strings;\n  S : String) return Element_Index is abstract;\nfunction Element(Index : Element_Index) return String is abstract;\n  -- Return element at given index position\n  -- raise Invalid_Index if no element there.\nprivate\n  type Set_Of_Strings is abstract tagged limited ...\n\nThe type Hashed_Set derives its interface from Set_of_Strings and its implementation from an existing (concrete) type Hash_Table:\n\ntype Hashed_Set(Table_Size : Positive) is\n  new Set_Of_Strings with private;\n-- Now we give the specs of the operations being implemented\nprocedure Enter(\n  -- Enter an element into the set, return the index\n  Set : in out Hashed_Set;\n  S : String;\n  Index : out Element_Index);\nprocedure Remove(\n  -- Remove an element from the set; ignore if not there\n  Set : in out Hashed_Set;\n  S : String);\n  -- . . . etc.\nprivate\n  type Hashed_Set(Table_Size : Positive) is\n    new Set_Of_Strings with record\n      Table : Hash_Table(1..Table_Size);\n    end record;\n")),(0,i.kt)("p",null,'In the package body, you define the bodies of the operations (i.e.,\nEnter, Remove,Combine, Size, etc.) using the operations available on\nHash_Table. You must also provide any necessary "glue" code.'),(0,i.kt)("p",null,"In this second example, the type Basic_Window responds to various\nevents and calls:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"\ntype Basic_Window is tagged limited private;\nprocedure Display(W : Basic_Window);\nprocedure Mouse_Click(W     : in out Basic_Window;\n                      Where :        Mouse_Coords);\n          . . .\n")),(0,i.kt)("p",null,"You use mixins to add features such as labels, borders, menu bar, etc.:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"generic\n  type Some_Window is new Window with private;\n  -- take in any descendant of Window\npackage Label_Mixin is\n  type Window_With_Label is new Some_Window with private;\n    -- Jazz it up somehow.\n  -- Overridden operations:\n  procedure Display(W : Window_With_Label);\n  -- New operations:\n  procedure Set_Label(W : in out Window_With_Label; S : String);\n    -- Set the label\n  function Label(W : Window_With_Label) return String;\n    -- Fetch the label\nprivate\n  type Window_With_Label is\n    new Some_Window with record\n      Label : String_Quark := Null_Quark;\n        -- An XWindows-Like unique ID for a string\n    end record;\n")),(0,i.kt)("p",null,"In the generic body, you implement any overridden operations as well as\nthe new operations. For example, you could implement the overridden\nDisplay operation using some of the inherited operations:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"procedure Display(W : Window_With_Label) is\nbegin\n    Display(Some_Window(W));\n      -- First display the window normally,\n      -- by passing the buck to the parent type.\n    if W.Label /= Null_Quark then\n      -- Now display the label if it is not null\n        Display_On_Screen(XCoord(W), YCoord(W)-5, Value(W.Label));\n          -- Use two inherited functions on Basic_Window\n          -- to get the coordinates where to display the label.\n    end if;\nend Display;\n")),(0,i.kt)("p",null,"Assuming you have defined several generics with these additional\nfeatures, to create the desired window, you use a combination of generic\ninstantiations and private type extension, as shown in the following\ncode:"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"\n  type My_Window is new Basic_Window with private;\n  . . .\nprivate\n  package Add_Label is new Label_Mixin(Basic_Window);\n  package Add_Border is\n    new Border_Mixin(Add_Label.Window_With_Label);\n  package Add_Menu_Bar is\n    new Menu_Bar_Mixin(Add_Border.Window_With_Border);\n  type My_Window is\n    new Add_Menu_Bar.Window_With_Menu_Bar with null record;\n      -- Final window is a null extension of Window_With_Menu_Bar.\n      -- We could instead make a record extension and\n      -- add components for My_Window over and above those\n      -- needed by the mixins.\n")),(0,i.kt)("p",null,'The following example shows "full" multiple inheritance.'),(0,i.kt)("p",null,"Assume previous definition of packages for Savings_Account and\nChecking_Account. The following example shows the definition of an\ninterest-bearing checking account (NOW account):"),(0,i.kt)("pre",null,(0,i.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"with Savings_Account;\nwith Checking_Account;\npackage NOW_Account is\n\n   type Object is tagged limited private;\n\n   type Savings (Self : access Object'Class) is\n      new Savings_Account.Object with null record;\n\n   -- These need to be overridden to call through to \"Self\"\n   procedure Deposit (Into_Account : in out Savings; ...);\n   procedure Withdraw (...);\n   procedure Earn_Interest (...);\n   function Interest (...) return Float;\n   function Balance (...) return Float;\n   type Checking (Self : access Object'Class) is\n      new Checking_Account.Object with null record;\n\n   procedure Deposit (Into_Account : in out Checking; ...);\n   ...\n   function Balance (...) return Float;\n\n   -- These operations will call-through to Savings_Account or\n   -- Checking_Account operations. \"Inherits\" in this way all savings and\n   -- checking operations\n\n   procedure Deposit (Into_Account : in out Object; ...);\n   ...\n   procedure Earn_Interest (...);\n   ...\n   function Balance (...) return Float;\n\nprivate\n\n   -- Could alternatively have Object be derived from either\n   -- Savings_Account.Object or Checking_Account.Object\n   type Object is tagged\n      record\n         As_Savings  : Savings (Object'Access);\n         As_Checking : Checking (Object'Access);\n      end record;\n\nend NOW_Account;\n")),(0,i.kt)("p",null,"Another possibility is that the savings and checking accounts are both\nimplemented based on a common Account abstraction, resulting in\ninheriting a Balance state twice for NOW_Account.Object. To resolve\nthis ambiguity, you need to use an abstract type hierarchy for the\nmultiple inheritance of interface and separate mixins for the multiple\ninheritance of implementation."),(0,i.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,i.kt)("p",null,"In other languages such as Eiffel and C++, multiple inheritance serves\nmany purposes. In Eiffel, for instance, you must use inheritance both\nfor module inclusion and for inheritance itself (Taft 1994). Ada\nprovides context clauses for module inclusion and child libraries for\nfiner modularization control. Ada does not provide a separate syntax for\nmultiple inheritance. Rather, it provides a set of building blocks in\ntype extension and composition that allow you to mix in additional\nbehaviors."),(0,i.kt)("p",null,"A library of mixins allows the client to mix and match in order to\ndevelop an implementation. Also see Guideline 8.3.8 about implementing\nmixins."),(0,i.kt)("p",null,"You should not use multiple inheritance to derive an abstraction that is\nessentially unrelated to its parent(s). Thus, you should not try to\nderive a menu abstraction by inheriting from a command line type and a\nwindow type. However, if you have a basic abstraction such as a window,\nyou can use multiple inheritance mixins to create a more sophisticated\nabstraction, where a mixin is the package containing the type(s) and\noperations that will extend the parent abstraction."),(0,i.kt)("p",null,'Use self-referential data structures to implement types with "full"\nmultiple inheritance ("multiple polymorphism").'),(0,i.kt)("p",null,"A common mistake is to use multiple inheritance for parts-of relations.\nWhen a type is composed of several others types, you should use\nheterogeneous data structuring techniques, discussed in Guideline 5.4.2."))}b.isMDXComponent=!0}}]);