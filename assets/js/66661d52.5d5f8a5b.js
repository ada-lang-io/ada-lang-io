"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2173],{77137:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=t(58168),o=(t(96540),t(15680));const i={title:"3.3 Comments"},r=void 0,s={unversionedId:"style-guide/s3/03",id:"style-guide/s3/03",title:"3.3 Comments",description:"Comments in source text are a controversial issue. There are arguments",source:"@site/docs/style-guide/s3/03.mdx",sourceDirName:"style-guide/s3",slug:"/style-guide/s3/03",permalink:"/docs/style-guide/s3/03",draft:!1,tags:[],version:"current",frontMatter:{title:"3.3 Comments"},sidebar:"styleGuideSidebar",previous:{title:"3.2 Naming Conventions",permalink:"/docs/style-guide/s3/02"},next:{title:"3.4 Using Types",permalink:"/docs/style-guide/s3/04"}},l={},d=[{value:"General Comments",id:"general-comments",level:3},{value:"guideline",id:"guideline",level:4},{value:"rationale",id:"rationale",level:4},{value:"automation notes",id:"automation-notes",level:4},{value:"File Headers",id:"file-headers",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"instantiation",id:"instantiation",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Program Unit Specification Headers",id:"program-unit-specification-headers",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"instantiation",id:"instantiation-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-1",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Program Unit Body Headers",id:"program-unit-body-headers",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"instantiation",id:"instantiation-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-2",level:4},{value:"Data Comments",id:"data-comments",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Statement Comments",id:"statement-comments",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-3",level:4},{value:"Marker Comments",id:"marker-comments",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-4",level:4}],h={toc:d},m="wrapper";function u(e){let{components:n,...t}=e;return(0,o.yg)(m,(0,a.A)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Comments in source text are a controversial issue. There are arguments\nboth for and against the view that comments enhance readability. In\npractice, the biggest problem with comments is that people often fail to\nupdate them when the associated source text is changed, thereby making\nthe commentary misleading. Commentary should be reserved for expressing\nneeded information that cannot be expressed in code and highlighting\ncases where there are overriding reasons to violate one of the\nguidelines. If possible, source text should use self-explanatory names\nfor objects and program units, and it should use simple, understandable\nprogram structures so that little additional commentary is needed. The\nextra effort in selecting (and entering) appropriate names and the extra\nthought needed to design clean and understandable program structures are\nfully justified."),(0,o.yg)("p",null,'Use comments to state the intent of the code. Comments that provide an\noverview of the code help the maintenance programmer see the forest for\nthe trees. The code itself is the detailed "how" and should not be\nparaphrased in the comments.'),(0,o.yg)("p",null,"Comments should be minimized. They should provide needed information\nthat cannot be expressed in the Ada language, emphasize the structure of\ncode, and draw attention to deliberate and necessary violations of the\nguidelines. Comments are present either to draw attention to the real\nissue being exemplified or to compensate for incompleteness in the\nsample program."),(0,o.yg)("p",null,"Maintenance programmers need to know the causal interaction of\nnoncontiguous pieces of code to get a global, more or less complete\nsense of the program. They typically acquire this kind of information\nfrom mental simulation of parts of the code. Comments should be\nsufficient enough to support this process (Soloway et al. 1986)."),(0,o.yg)("p",null,"This section presents general guidelines about how to write good\ncomments. It then defines several different classes of comments with\nguidelines for the use of each. The classes are file headers, program\nunit specification headers, program unit body headers, data comments,\nstatement comments, and marker comments."),(0,o.yg)("h3",{id:"general-comments"},"General Comments"),(0,o.yg)("h4",{id:"guideline"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Make the code as clear as possible to reduce the need for comments."),(0,o.yg)("li",{parentName:"ul"},"Never repeat information in a comment that is readily available in\nthe code."),(0,o.yg)("li",{parentName:"ul"},"Where a comment is required, make it concise and complete."),(0,o.yg)("li",{parentName:"ul"},"Use proper grammar and spelling in comments."),(0,o.yg)("li",{parentName:"ul"},"Make comments visually distinct from the code."),(0,o.yg)("li",{parentName:"ul"},"Structure comments in header so that information can be\nautomatically extracted by a tool.")),(0,o.yg)("h4",{id:"rationale"},"rationale"),(0,o.yg)("p",null,"The structure and function of well-written code is clear without\ncomments. Obscured or badly structured code is hard to understand,\nmaintain, or reuse regardless of comments. Bad code should be improved,\nnot explained. Reading the code itself is the only way to be absolutely\npositive about what the code does; therefore, the code should be made as\nreadable as possible."),(0,o.yg)("p",null,"Using comments to duplicate information in the code is a bad idea for\nseveral reasons. First, it is unnecessary work that decreases\nproductivity. Second, it is very difficult to correctly maintain the\nduplication as the code is modified. When changes are made to existing\ncode, it is compiled and tested to make sure that it is once again\ncorrect. However, there is no automatic mechanism to make sure that the\ncomments are correctly updated to reflect the changes. Very often, the\nduplicate information in a comment becomes obsolete at the first code\nchange and remains so through the life of the software. Third, when\ncomments about an entire system are written from the limited point of\nview of the author of a single subsystem, the comments are often\nincorrect from the start."),(0,o.yg)("p",null,"Comments are necessary to reveal information difficult or impossible to\nobtain from the code. Subsequent chapters of this book contain examples\nof such comments. Completely and concisely present the required\ninformation."),(0,o.yg)("p",null,"The purpose of comments is to help readers understand the code.\nMisspelled, ungrammatical, ambiguous, or incomplete comments defeat this\npurpose. If a comment is worth adding, it is worth adding correctly in\norder to increase its usefulness."),(0,o.yg)("p",null,"Making comments visually distinct from the code by indenting them,\ngrouping them together into headers, or highlighting them with dashed\nlines is useful because it makes the code easier to read. Subsequent\nchapters of this book elaborate on this point."),(0,o.yg)("h4",{id:"automation-notes"},"automation notes"),(0,o.yg)("p",null,"The guideline about storing redundant information in comments applies\nonly to manually generated comments. There are tools that automatically\nmaintain information about the code (e.g., calling units, called units,\ncross-reference information, revision histories, etc.), storing it in\ncomments in the same file as the code. Other tools read comments but do\nnot update them, using the information from the comments to\nautomatically generate detailed design documents and other reports."),(0,o.yg)("p",null,"The use of such tools is encouraged and may require that you structure\nyour header comments so they can be automatically extracted and/or\nupdated. Beware that tools that modify the comments in a file are only\nuseful if they are executed frequently enough. Automatically generated\nobsolete information is even more dangerous than manually generated\nobsolete information because it is more trusted by the reader."),(0,o.yg)("p",null,"Revision histories are maintained much more accurately and completely by\nconfiguration management tools. With no tool support, it is very common\nfor an engineer to make a change and forget to update the revision\nhistory. If your configuration management tool is capable of maintaining\nrevision histories as comments in the source file, then take advantage\nof that capability, regardless of any compromise you might have to make\nabout the format or location of the revision history. It is better to\nhave a complete revision history appended to the end of the file than to\nhave a partial one formatted nicely and embedded in the file header."),(0,o.yg)("h3",{id:"file-headers"},"File Headers"),(0,o.yg)("h4",{id:"guideline-1"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Put a file header on each source file."),(0,o.yg)("li",{parentName:"ul"},"Place ownership, responsibility, and history information for the\nfile in the file header.")),(0,o.yg)("h4",{id:"instantiation"},"instantiation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Put a copyright notice in the file header."),(0,o.yg)("li",{parentName:"ul"},"Put the author's name and department in the file header."),(0,o.yg)("li",{parentName:"ul"},"Put a revision history in the file header, including a summary of\neach change, the date, and the name of the person making the change.")),(0,o.yg)("h4",{id:"example"},"example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\n--      Copyright (c) 1991, Software Productivity Consortium, Inc.\n--      All rights reserved.\n--\n-- Author: J. Smith\n-- Department:System Software Department\n--\n-- Revision History:\n--   7/9/91 J. Smith\n--     - Added function Size_Of to support queries of node sizes.\n--     - Fixed bug in Set_Size which caused overlap of large nodes.\n--   7/1/91 M. Jones\n--     - Optimized clipping algorithm for speed.\n--   6/25/91 J. Smith\n--     - Original version.\n------------------------------------------------------------------------\n")),(0,o.yg)("h4",{id:"rationale-1"},"rationale"),(0,o.yg)("p",null,"Ownership information should be present in each file if you want to be\nsure to protect your rights to the software. Furthermore, for high\nvisibility, it should be the first thing in the file."),(0,o.yg)("p",null,"Responsibility and revision history information should be present in\neach file for the sake of future maintainers; this is the header\ninformation most trusted by maintainers because it accumulates. It does\nnot evolve. There is no need to ever go back and modify the author's\nname or the revision history of a file. As the code evolves, the\nrevision history should be updated to reflect each change. At worst, it\nwill be incomplete; it should rarely be wrong. Also, the number and\nfrequency of changes and the number of different people who made the\nchanges over the history of a unit can be good indicators of the\nintegrity of the implementation with respect to the design."),(0,o.yg)("p",null,"Information about how to find the original author should be included in\nthe file header, in addition to the author's name, to make it easier for\nmaintainers to find the author in case questions arise. However,\ndetailed information like phone numbers, mail stops, office numbers, and\ncomputer account user names are too volatile to be very useful. It is\nbetter to record the department for which the author was working when\nthe code was written. This information is still useful if the author\nmoves offices, changes departments, or even leaves the company because\nthe department is likely to retain responsibility for the original\nversion of the code."),(0,o.yg)("h4",{id:"notes"},"notes"),(0,o.yg)("p",null,"With modern configuration management systems, explicitly capturing\nversion history as header comments may be superfluous. The configuration\nmanagement tool maintains a more reliable and consistent (from a content\npoint of view) change history. Some systems can re-create earlier\nversions of a unit."),(0,o.yg)("h3",{id:"program-unit-specification-headers"},"Program Unit Specification Headers"),(0,o.yg)("h4",{id:"guideline-2"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Put a header on the specification of each program unit."),(0,o.yg)("li",{parentName:"ul"},"Place information required by the user of the program unit in the\nspecification header."),(0,o.yg)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the specification\nheader that is present in the specification."),(0,o.yg)("li",{parentName:"ul"},"Explain what the unit does, not how or why it does it."),(0,o.yg)("li",{parentName:"ul"},"Describe the complete interface to the program unit, including any\nexceptions it can raise and any global effects it can have."),(0,o.yg)("li",{parentName:"ul"},"Do not include information about how the unit fits into the\nenclosing software system."),(0,o.yg)("li",{parentName:"ul"},"Describe the performance (time and space) characteristics of the\nunit.")),(0,o.yg)("h4",{id:"instantiation-1"},"instantiation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Put the name of the program unit in the header."),(0,o.yg)("li",{parentName:"ul"},"Briefly explain the purpose of the program unit."),(0,o.yg)("li",{parentName:"ul"},"For packages, describe the effects of the visible subprograms on\neach other and how they should be used together."),(0,o.yg)("li",{parentName:"ul"},"List all exceptions that can be raised by the unit."),(0,o.yg)("li",{parentName:"ul"},"List all global effects of the unit."),(0,o.yg)("li",{parentName:"ul"},"List preconditions and postconditions of the unit."),(0,o.yg)("li",{parentName:"ul"},"List hidden tasks activated by the unit."),(0,o.yg)("li",{parentName:"ul"},"Do not list the names of parameters of a subprogram."),(0,o.yg)("li",{parentName:"ul"},"Do not list the names of package subprograms just to list them."),(0,o.yg)("li",{parentName:"ul"},"Do not list the names of all other units used by the unit."),(0,o.yg)("li",{parentName:"ul"},"Do not list the names of all other units that use the unit.")),(0,o.yg)("h4",{id:"example-1"},"example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"     ------------------------------------------------------------------------\n     -- AUTOLAYOUT\n     --\n     -- Purpose:\n     --   This package computes positional information for nodes and arcs\n     --   of a directed graph.  It encapsulates a layout algorithm which is\n     --   designed to minimize the number of crossing arcs and to emphasize\n     --   the primary direction of arc flow through the graph.\n     --\n     -- Effects:\n     --   - The expected usage is:\n     --     1. Call Define for each node and arc to define the graph.\n     --     2. Call Layout to assign positions to all nodes and arcs.\n     --     3. Call Position_Of for each node and arc to determine the\n     --        assigned coordinate positions.\n     --   - Layout can be called multiple times, and recomputes the\n     --     positions of all currently defined nodes and arcs each time.\n     --   - Once a node or arc has been defined, it remains defined until\n     --     Clear is called to delete all nodes and arcs.\n     --\n     -- Performance:\n     --   This package has been optimized for time, in preference to space.\n     --   Layout times are on the order of N*log(N) where N is the number\n     --   of nodes, but memory space is used inefficiently.\n     ------------------------------------------------------------------------\n\n     package Autolayout is\n\n        ...\n\n        ---------------------------------------------------------------------\n        -- Define\n        --\n        -- Purpose:\n        --   This procedure defines one node of the current graph.\n        -- Exceptions:\n        --   Node_Already_Defined\n        ---------------------------------------------------------------------\n        procedure Define\n              (New_Node : in     Node);\n\n        ---------------------------------------------------------------------\n        -- Layout\n        --\n        -- Purpose:\n        --   This procedure assigns coordinate positions to all defined\n        --   nodes and arcs.\n        -- Exceptions:\n        --   None.\n        ---------------------------------------------------------------------\n        procedure Layout;\n\n        ---------------------------------------------------------------------\n        -- Position_Of\n        --\n        -- Purpose:\n        --   This function returns the coordinate position of the\n        --   specified node.  The default position (0,0) is returned if no\n        --   position has been assigned yet.\n        -- Exceptions:\n        --   Node_Not_Defined\n        ---------------------------------------------------------------------\n        function Position_Of (Current : in     Node)\n              return Position;\n\n        ...\n\n     end Autolayout;\n")),(0,o.yg)("h4",{id:"rationale-2"},"rationale"),(0,o.yg)("p",null,"The purpose of a header comment on the specification of a program unit\nis to help the user understand how to use the program unit. From reading\nthe program unit specification and header, a user should know everything\nnecessary to use the unit. It should not be necessary to read the body\nof the program unit. Therefore, there should be a header comment on each\nprogram unit specification, and each header should contain all usage\ninformation not expressed in the specification itself. Such information\nincludes the units' effects on each other and on shared resources,\nexceptions raised, and time/space characteristics. None of this\ninformation can be determined from the Ada specification of the program\nunit."),(0,o.yg)("p",null,"When you duplicate information in the header that can be readily\nobtained from the specification, the information tends to become\nincorrect during maintenance. For example, do not make a point of\nlisting all parameter names, modes, or subtypes when describing a\nprocedure. This information is already available from the procedure\nspecification. Similarly, do not list all subprograms of a package in\nthe header unless this is necessary to make some important statement\nabout the subprograms."),(0,o.yg)("p",null,"Do not include information in the header that the user of the program\nunit does not need. In particular, do not include information about how\na program unit performs its function or why a particular algorithm was\nused. This information should be hidden in the body of the program unit\nto preserve the abstraction defined by the unit. If the user knows such\ndetails and makes decisions based on that information, the code may\nsuffer when that information is later changed."),(0,o.yg)("p",null,'When describing the purpose of the unit, avoid referring to other parts\nof the enclosing software system. It is better to say "this unit does\u2026"\nthan to say "this unit is called by Xyz to do\u2026." The unit should be\nwritten in such a way that it does not know or care which unit is\ncalling it. This makes the unit much more general purpose and reusable.\nIn addition, information about other units is likely to become obsolete\nand incorrect during maintenance.'),(0,o.yg)("p",null,"Include information about the performance (time and space)\ncharacteristics of the unit. Much of this information is not present in\nthe Ada specification, but it is required by the user. To integrate the\nunit into a system, the user needs to understand the resource usage\n(CPU, memory, etc.) of the unit. It is especially important to note that\nwhen a subprogram call causes activation of a task hidden in a package\nbody, the task may continue to consume resources after the subroutine\nends."),(0,o.yg)("h4",{id:"notes-1"},"notes"),(0,o.yg)("p",null,"Some projects have deferred most of the commentary to the end rather\nthan at the beginning of the program unit. Their rationale is that\nprogram units are written once and read many times and that long header\ncomments make the start of the specification difficult to find."),(0,o.yg)("h4",{id:"exceptions"},"exceptions"),(0,o.yg)("p",null,"Where a group of program units are closely related or simple to\nunderstand, it is acceptable to use a single header for the entire group\nof program units. For example, it makes sense to use a single header to\ndescribe the behavior of Max and Min functions; Sin, Cos, and Tan\nfunctions; or a group of functions to query related attributes of an\nobject encapsulated in a package. This is especially true when each\nfunction in the set is capable of raising the same exceptions."),(0,o.yg)("h3",{id:"program-unit-body-headers"},"Program Unit Body Headers"),(0,o.yg)("h4",{id:"guideline-3"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Place information required by the maintainer of the program unit in\nthe body of the header"),(0,o.yg)("li",{parentName:"ul"},"Explain how and why the unit performs its function, not what the\nunit does."),(0,o.yg)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the header that is\nreadily apparent from reading the code."),(0,o.yg)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the body header that\nis available in the specification header.")),(0,o.yg)("h4",{id:"instantiation-2"},"instantiation"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Put the name of the program unit in the header."),(0,o.yg)("li",{parentName:"ul"},"Record portability issues in the header."),(0,o.yg)("li",{parentName:"ul"},"Summarize complex algorithms in the header."),(0,o.yg)("li",{parentName:"ul"},"Record reasons for significant or controversial implementation\ndecisions."),(0,o.yg)("li",{parentName:"ul"},"Record discarded implementation alternatives, along with the reason\nfor discarding them."),(0,o.yg)("li",{parentName:"ul"},"Record anticipated changes in the header, especially if some work\nhas already been done to the code to make the changes easy to\naccomplish.")),(0,o.yg)("h4",{id:"example-2"},"example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\n-- Autolayout\n--\n-- Implementation Notes:\n--   - This package uses a heuristic algorithm to minimize the number\n--     of arc crossings.  It does not always achieve the true minimum\n--     number which could theoretically be reached.  However it does a\n--     nearly perfect job in relatively little time.  For details about\n--     the algorithm, see ...\n--\n-- Portability Issues:\n--   - The native math package Math_Lib is used for computations of\n--     coordinate positions.\n--   - 32-bit integers are required.\n--   - No operating system specific routines are called.\n--\n-- Anticipated Changes:\n--   - Coordinate_Type below could be changed from integer to float\n--     with little effort.  Care has been taken to not depend on the\n--     specific characteristics of integer arithmetic.\n------------------------------------------------------------------------\npackage body Autolayout is\n\n   ...\n\n   ---------------------------------------------------------------------\n   -- Define\n   --\n   -- Implementation Notes:\n   --   - This routine stores a node in the general purpose Graph data\n   --     structure, not the Fast_Graph structure because ...\n   ---------------------------------------------------------------------\n   procedure Define\n         (New_Node : in     Node) is\n   begin\n      ...\n   end Define;\n\n   ---------------------------------------------------------------------\n   -- Layout\n   --\n   -- Implementation Notes:\n   --   - This routine copies the Graph data structure (optimized for\n   --     fast random access) into the Fast_Graph data structure\n   --     (optimized for fast sequential iteration), then performs the\n   --     layout, and copies the data back to the Graph structure.  This\n   --     technique was introduced as an optimization when the algorithm\n   --     was found to be too slow, and it produced an order of\n   --     magnitude improvement.\n   ---------------------------------------------------------------------\n   procedure Layout is\n   begin\n      ...\n   end Layout;\n\n   ---------------------------------------------------------------------\n   -- Position_Of\n   ---------------------------------------------------------------------\n   function Position_Of (Current : in     Node)\n         return Position is\n   begin\n      ...\n   end Position_Of;\n\n   ...\n\nend Autolayout;\n")),(0,o.yg)("h4",{id:"rationale-3"},"rationale"),(0,o.yg)("p",null,"The purpose of a header comment on the body of a program unit is to help\nthe maintainer of the program unit to understand the implementation of\nthe unit, including tradeoffs among different techniques. Be sure to\ndocument all decisions made during implementation to prevent the\nmaintainer from making the same mistakes you made. One of the most\nvaluable comments to a maintainer is a clear description of why a change\nbeing considered will not work."),(0,o.yg)("p",null,"The header is also a good place to record portability concerns. The\nmaintainer may have to port the software to a different environment and\nwill benefit from a list of nonportable features. Furthermore, the act\nof collecting and recording portability issues focuses attention on\nthese issues and may result in more portable code from the start."),(0,o.yg)("p",null,"Summarize complex algorithms in the header if the code is difficult to\nread or understand without such a summary, but do not merely paraphrase\nthe code. Such duplication is unnecessary and hard to maintain.\nSimilarly, do not repeat the information from the header of the program\nunit specification."),(0,o.yg)("h4",{id:"notes-2"},"notes"),(0,o.yg)("p",null,"It is often the case that a program unit is self-explanatory so that it\ndoes not require a body header to explain how it is implemented or why.\nIn such a case, omit the header entirely, as in the case with\nPosition_Of above. Be sure, however, that the header you omit truly\ncontains no information. For example, consider the difference between\nthe two header sections:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"-- Implementation Notes:  None.\n")),(0,o.yg)("p",null,"and:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"-- NonPortable Features:  None.\n")),(0,o.yg)("p",null,'The first is a message from the author to the maintainer saying "I can\'t\nthink of anything else to tell you," while the second may mean "I\nguarantee that this unit is entirely portable."'),(0,o.yg)("h3",{id:"data-comments"},"Data Comments"),(0,o.yg)("h4",{id:"guideline-4"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Comment on all data types, objects, and exceptions unless their\nnames are self-explanatory."),(0,o.yg)("li",{parentName:"ul"},"Include information on the semantic structure of complex,\npointer-based data structures."),(0,o.yg)("li",{parentName:"ul"},"Include information about relationships that are maintained between\ndata objects."),(0,o.yg)("li",{parentName:"ul"},"Omit comments that merely repeat the information in the name."),(0,o.yg)("li",{parentName:"ul"},"Include information on redispatching for tagged types in cases where\nyou intend the specializations (i.e., derived types) to override\nthese redispatching operations.")),(0,o.yg)("h4",{id:"example-3"},"example"),(0,o.yg)("p",null,"Objects can be grouped by purpose and commented as:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"...\n\n---------------------------------------------------------------------\n-- Current position of the cursor in the currently selected text\n-- buffer, and the most recent position explicitly marked by the\n-- user.\n-- Note:  It is necessary to maintain both current and desired\n--        column positions because the cursor cannot always be\n--        displayed in the desired position when moving between\n--        lines of different lengths.\n---------------------------------------------------------------------\nDesired_Column : Column_Counter;\nCurrent_Column : Column_Counter;\nCurrent_Row    : Row_Counter;\nMarked_Column  : Column_Counter;\nMarked_Row     : Row_Counter;\n")),(0,o.yg)("p",null,"The conditions under which an exception is raised should be commented:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"---------------------------------------------------------------------\n-- Exceptions\n---------------------------------------------------------------------\nNode_Already_Defined : exception;   -- Raised when an attempt is made\n                                    --|   to define a node with an\n                                    --|   identifier which already\n                                    --|   defines a node.\nNode_Not_Defined     : exception;   -- Raised when a reference is\n                                    --|   made to a node which has\n                                    --|   not been defined.\n")),(0,o.yg)("p",null,"Here is a more complex example, involving multiple record and access\ntypes that are used to form a complex data structure:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},'---------------------------------------------------------------------\n-- These data structures are used to store the graph during the\n-- layout process. The overall organization is a sorted list of\n-- "ranks," each containing a sorted list of nodes, each containing\n-- a list of incoming arcs and a list of outgoing arcs.\n-- The lists are doubly linked to support forward and backward\n-- passes for sorting. Arc lists do not need to be doubly linked\n-- because order of arcs is irrelevant.\n--\n-- The nodes and arcs are doubly linked to each other to support\n-- efficient lookup of all arcs to/from a node, as well as efficient\n-- lookup of the source/target node of an arc.\n---------------------------------------------------------------------\n\ntype Arc;\ntype Arc_Pointer is access Arc;\n\ntype Node;\ntype Node_Pointer is access Node;\n\ntype Node is\n   record\n      Id       : Node_Pointer;-- Unique node ID supplied by the user.\n      Arc_In   : Arc_Pointer;\n      Arc_Out  : Arc_Pointer;\n      Next     : Node_Pointer;\n      Previous : Node_Pointer;\n   end record;\n\ntype Arc is\n   record\n      ID     : Arc_ID;        -- Unique arc ID supplied by the user.\n      Source : Node_Pointer;\n      Target : Node_Pointer;\n      Next   : Arc_Pointer;\n   end record;\n\ntype Rank;\ntype Rank_Pointer is access Rank;\n\ntype Rank is\n   record\n      Number     : Level_ID;  -- Computed ordinal number of the rank.\n      First_Node : Node_Pointer;\n      Last_Node  : Node_Pointer;\n      Next       : Rank_Pointer;\n      Previous   : Rank_Pointer;\n   end record;\n\nFirst_Rank : Rank_Pointer;\nLast_Rank  : Rank_Pointer;\n')),(0,o.yg)("h4",{id:"rationale-4"},"rationale"),(0,o.yg)("p",null,"It is very useful to add comments explaining the purpose, structure, and\nsemantics of the data structures. Many maintainers look at the data\nstructures first when trying to understand the implementation of a unit.\nUnderstanding the data that can be stored, along with the relationships\nbetween the different data items and the flow of data through the unit,\nis an important first step in understanding the details of the unit."),(0,o.yg)("p",null,"In the first example above, the names Current_Column and Current_Row\nare relatively self-explanatory. The name Desired_Column is also well\nchosen, but it leaves the reader wondering what the relationship is\nbetween the current column and the desired column. The comment explains\nthe reason for having both."),(0,o.yg)("p",null,'Another advantage of commenting on the data declarations is that the\nsingle set of comments on a declaration can replace multiple sets of\ncomments that might otherwise be needed at various places in the code\nwhere the data is manipulated. In the first example above, the comment\nbriefly expands on the meaning of "current" and "marked." It states that\nthe "current" position is the location of the cursor, the "current"\nposition is in the current buffer, and the "marked" position was marked\nby the user. This comment, along with the mnemonic names of the\nvariables, greatly reduces the need for comments at individual\nstatements throughout the code.'),(0,o.yg)("p",null,"It is important to document the full meaning of exceptions and under\nwhat conditions they can be raised, as shown in the second example\nabove, especially when the exceptions are declared in a package\nspecification. The reader has no other way to find out the exact meaning\nof the exception (without reading the code in the package body)."),(0,o.yg)("p",null,'Grouping all the exceptions together, as shown in the second example,\ncan provide the reader with the effect of a "glossary" of special\nconditions. This is useful when many different subprograms in the\npackage can raise the same exceptions. For a package in which each\nexception can be raised by only one subprogram, it may be better to\ngroup related subprograms and exceptions together.'),(0,o.yg)("p",null,"When commenting exceptions, it is better to describe the exception's\nmeaning in general terms than to list all the subprograms that can cause\nthe exception to be raised; such a list is harder to maintain. When a\nnew routine is added, it is likely that these lists will not be updated.\nAlso, this information is already present in the comments describing the\nsubprograms, where all exceptions that can be raised by the subprogram\nshould be listed. Lists of exceptions by subprogram are more useful and\neasier to maintain than lists of subprograms by exception."),(0,o.yg)("p",null,"In the third example, the names of the record fields are short and\nmnemonic, but they are not completely self-explanatory. This is often\nthe case with complex data structures involving access types. There is\nno way to choose the record and field names so that they completely\nexplain the overall organization of the records and pointers into a\nnested set of sorted lists. The comments shown are useful in this case.\nWithout them, the reader would not know which lists are sorted, which\nlists are doubly linked, or why. The comments express the intent of the\nauthor with respect to this complex data structure. The maintainer still\nhas to read the code if he wants to be sure that the double links are\nall properly maintained. Keeping this in mind when reading the code\nmakes it much easier for the maintainer to find a bug where one pointer\nis updated and the opposite one is not."),(0,o.yg)("p",null,"See Guideline 9.3.1 for the rationale for documenting the use of\nredispatching operations. (Redispatching means converting an argument of\none primitive operation to a class-wide type and making a dispatching\ncall to another primitive operation.) The rationale in Guideline 9.3.1\ndiscusses whether such documentation should be in the specification or\nthe body."),(0,o.yg)("h3",{id:"statement-comments"},"Statement Comments"),(0,o.yg)("h4",{id:"guideline-5"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Minimize comments embedded among statements."),(0,o.yg)("li",{parentName:"ul"},"Use comments only to explain parts of the code that are not obvious."),(0,o.yg)("li",{parentName:"ul"},"Comment intentional omissions from the code."),(0,o.yg)("li",{parentName:"ul"},"Do not use comments to paraphrase the code."),(0,o.yg)("li",{parentName:"ul"},"Do not use comments to explain remote pieces of code, such as\nsubprograms called by the current unit."),(0,o.yg)("li",{parentName:"ul"},"Where comments are necessary, make them visually distinct from the\ncode.")),(0,o.yg)("h4",{id:"example-4"},"example"),(0,o.yg)("p",null,"The following is an example of very poorly commented code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"...\n\n-- Loop through all the strings in the array Strings, converting\n-- them to integers by calling Convert_To_Integer on each one,\n-- accumulating the sum of all the values in Sum, and counting them\n-- in Count.  Then divide Sum by Count to get the average and store\n-- it in Average. Also, record the maximum number in the global\n-- variable Max_Number.\n\nfor I in Strings'Range loop\n   -- Convert each string to an integer value by looping through\n   -- the characters which are digits, until a nondigit is found,\n   -- taking the ordinal value of each, subtracting the ordinal value\n   -- of '0', and multiplying by 10 if another digit follows.  Store\n   -- the result in Number.\n   Number := Convert_To_Integer(Strings(I));\n   -- Accumulate the sum of the numbers in Total.\n   Sum := Sum + Number;\n   -- Count the numbers.\n   Count := Count + 1;\n\n   -- Decide whether this number is more than the current maximum.\n   if Number > Max_Number then\n      -- Update the global variable Max_Number.\n      Max_Number := Number;\n   end if;\n\nend loop;\n-- Compute the average.\nAverage := Sum / Count;\n")),(0,o.yg)("p",null,"The following is improved by not repeating things in the comments that\nare obvious from the code, not describing the details of what goes in\ninside of ",(0,o.yg)("inlineCode",{parentName:"p"},"Convert_To_Integer"),", deleting an erroneous comment (the one\non the statement that accumulates the sum), and making the few remaining\ncomments more visually distinct from the code."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"Sum_Integers_Converted_From_Strings:\n   for I in Strings'Range loop\n      Number := Convert_To_Integer(Strings(I));\n      Sum := Sum + Number;\n      Count := Count + 1;\n\n      -- The global Max_Number is computed here for efficiency.\n      if Number > Max_Number then\n         Max_Number := Number;\n      end if;\n\n   end loop Sum_Integers_Converted_From_Strings;\n\nAverage := Sum / Count;\n")),(0,o.yg)("h4",{id:"rationale-5"},"rationale"),(0,o.yg)("p",null,"The improvements shown in the example are not improvements merely by\nreducing the total number of comments; they are improvements by reducing\nthe number of useless comments."),(0,o.yg)("p",null,"Comments that paraphrase or explain obvious aspects of the code have no\nvalue. They are a waste of effort for the author to write and the\nmaintainer to update. Therefore, they often end up becoming incorrect.\nSuch comments also clutter the code, hiding the few important comments."),(0,o.yg)("p",null,"Comments describing what goes on inside another unit violate the\nprinciple of information hiding. The details about Convert_To_Integer\n(deleted above) are irrelevant to the calling unit, and they are better\nleft hidden in case the algorithm ever changes. Examples explaining what\ngoes on elsewhere in the code are very difficult to maintain and almost\nalways become incorrect at the first code modification."),(0,o.yg)("p",null,"The advantage of making comments visually distinct from the code is that\nit makes the code easier to scan, and the few important comments stand\nout better. Highlighting unusual or special code features indicates that\nthey are intentional. This assists maintainers by focusing attention on\ncode sections that are likely to cause problems during maintenance or\nwhen porting the program to another implementation."),(0,o.yg)("p",null,'Comments should be used to document code that is nonportable,\nimplementation-dependent, environment-dependent, or tricky in any way.\nThey notify the reader that something unusual was put there for a\nreason. A beneficial comment would be one explaining a work around for a\ncompiler bug. If you use a lower level (not "ideal" in the software\nengineering sense) solution, comment on it. Information included in the\ncomments should state why you used that particular construct. Also\ninclude documentation on the failed attempts, for example, using a\nhigher level structure. This kind of comment is useful to maintainers\nfor historical purposes. You show the reader that a significant amount\nof thought went into the choice of a construct.'),(0,o.yg)("p",null,'Finally, comments should be used to explain what is not present in the\ncode as well as what is present. If you make a conscious decision to not\nperform some action, like deallocating a data structure with which you\nappear to be finished, be sure to add a comment explaining why not.\nOtherwise, a maintainer may notice the apparent omission and "correct"\nit later, thus introducing an error.'),(0,o.yg)("p",null,"See also Guideline 9.3.1 for a discussion of what kind of documentation\nyou should provide regarding tagged types and redispatching."),(0,o.yg)("h4",{id:"notes-3"},"notes"),(0,o.yg)("p",null,"Further improvements can be made on the above example by declaring the\nvariables Count and Sum in a local block so that their scope is limited\nand their initializations occur near their usage, e.g., by naming the\nblock Compute_Average or by moving the code into a function called\nAverage_Of. The computation of Max_Number can also be separated from\nthe computation of Average. However, those changes are the subject of\nother guidelines; this example is only intended to illustrate the proper\nuse of comments."),(0,o.yg)("h3",{id:"marker-comments"},"Marker Comments"),(0,o.yg)("h4",{id:"guideline-6"},"guideline"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Use pagination markers to mark program unit boundaries (see\nGuideline 2.1.7)."),(0,o.yg)("li",{parentName:"ul"},"Repeat the unit name in a comment to mark the ",(0,o.yg)("inlineCode",{parentName:"li"},"begin")," of a package\nbody, subprogram body, task body, or block if the ",(0,o.yg)("inlineCode",{parentName:"li"},"begin")," is\npreceded by declarations."),(0,o.yg)("li",{parentName:"ul"},"For long or heavily nested ",(0,o.yg)("inlineCode",{parentName:"li"},"if")," and ",(0,o.yg)("inlineCode",{parentName:"li"},"case")," statements, mark the end\nof the statement with a comment summarizing the condition governing\nthe statement."),(0,o.yg)("li",{parentName:"ul"},"For long or heavily nested ",(0,o.yg)("inlineCode",{parentName:"li"},"if")," statements, mark the ",(0,o.yg)("inlineCode",{parentName:"li"},"else")," part\nwith a comment summarizing the conditions governing this portion of\nthe statement.")),(0,o.yg)("h4",{id:"example-5"},"example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ada"},"if    A_Found then\n   ...\nelsif B_Found then\n   ...\n\nelse  -- A and B were both not found\n   ...\n\n   if Count = Max then\n      ...\n\n   end if;\n\n   ...\nend if;  -- A_Found\n\n------------------------------------------------------------------------\npackage body Abstract_Strings is\n   ...\n\n   ---------------------------------------------------------------------\n   procedure Concatenate (...) is\n   begin\n      ...\n   end Concatenate;\n   ---------------------------------------------------------------------\n\n   ...\nbegin  -- Abstract_Strings\n   ...\nend Abstract_Strings;\n------------------------------------------------------------------------\n")),(0,o.yg)("h4",{id:"rationale-6"},"rationale"),(0,o.yg)("p",null,"Marker comments emphasize the structure of code and make it easier to\nscan. They can be lines that separate sections of code or descriptive\ntags for a construct. They help the reader resolve questions about the\ncurrent position in the code. This is more important for large units\nthan for small ones. A short marker comment fits on the same line as the\nreserved word with which it is associated. Thus, it adds information\nwithout clutter."),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"if"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"elsif"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"else"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"end if")," of an ",(0,o.yg)("inlineCode",{parentName:"p"},"if")," statement are often\nseparated by long sequences of statements, sometimes involving other\n",(0,o.yg)("inlineCode",{parentName:"p"},"if")," statements. As shown in the first example, marker comments\nemphasize the association of the keywords of the same statement over a\ngreat visual distance. Marker comments are not necessary with the block\nstatement and loop statement because the syntax of these statements\nallows them to be named with the name repeated at the end. Using these\nnames is better than using marker comments because the compiler verifies\nthat the names at the beginning and end match."),(0,o.yg)("p",null,"The sequence of statements of a package body is often very far from the\nfirst line of the package. Many subprogram bodies, each containing many\n",(0,o.yg)("inlineCode",{parentName:"p"},"begin")," lines, may occur first. As shown in the second example, the\nmarker comment emphasizes the association of the begin with the package."),(0,o.yg)("h4",{id:"notes-4"},"notes"),(0,o.yg)("p",null,"Repeating names and noting conditional expressions clutters the code if\noverdone. It is visual distance, especially page breaks, that makes\nmarker comments beneficial."))}u.isMDXComponent=!0}}]);