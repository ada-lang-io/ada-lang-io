"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["2453"],{1151:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>o,toc:()=>c,default:()=>h,metadata:()=>i,assets:()=>l,contentTitle:()=>s});var i=JSON.parse('{"id":"learn/glossary","title":"Glossary","description":"Terminology","source":"@site/docs/learn/glossary.md","sourceDirName":"learn","slug":"/learn/glossary","permalink":"/docs/learn/glossary","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":80,"frontMatter":{"sidebar_position":80},"sidebar":"tutorialSidebar","previous":{"title":"Syntax Cheat Sheet","permalink":"/docs/learn/cheat-sheet"},"next":{"title":"Books","permalink":"/docs/learn/books"}}'),a=n(5893),r=n(65);let o={sidebar_position:80},s="Glossary",l={},c=[{value:"<code>&lt;&gt;</code>",id:"",level:3},{value:"<code>&#39;</code>",id:"-1",level:3},{value:"ABE",id:"abe",level:3},{value:"allocator",id:"allocator",level:3},{value:"access type",id:"access-type",level:3},{value:"access-to-object type",id:"access-to-object-type",level:3},{value:"access-to-subprogram type",id:"access-to-subprogram-type",level:3},{value:"aggregate",id:"aggregate",level:3},{value:"aliased",id:"aliased",level:3},{value:"aspect",id:"aspect",level:3},{value:"attribute",id:"attribute",level:3},{value:"ATC",id:"atc",level:3},{value:"bounded error",id:"bounded-error",level:3},{value:"completion",id:"completion",level:3},{value:"component",id:"component",level:3},{value:"configuration pragma",id:"configuration-pragma",level:3},{value:"controlled type",id:"controlled-type",level:3},{value:"definite type",id:"definite-type",level:3},{value:"discriminant",id:"discriminant",level:3},{value:"entry",id:"entry",level:3},{value:"erroneous behavior",id:"erroneous-behavior",level:3},{value:"indefinite type",id:"indefinite-type",level:3},{value:"limited type",id:"limited-type",level:3},{value:"parent",id:"parent",level:3},{value:"pragma",id:"pragma",level:3},{value:"progenitor",id:"progenitor",level:3},{value:"qualification",id:"qualification",level:3},{value:"subprogram",id:"subprogram",level:3},{value:"subtype",id:"subtype",level:3},{value:"tagged type",id:"tagged-type",level:3},{value:"type conversion",id:"type-conversion",level:3},{value:"unchecked type conversion",id:"unchecked-type-conversion",level:3}];function d(e){let t={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"glossary",children:"Glossary"})}),"\n",(0,a.jsx)(t.p,{children:"Terminology"}),"\n",(0,a.jsx)(t.h3,{id:"",children:(0,a.jsx)(t.code,{children:"<>"})}),"\n",(0,a.jsx)(t.p,{children:'"Box". Used for defaults or also "not specified."'}),"\n",(0,a.jsx)(t.h3,{id:"-1",children:(0,a.jsx)(t.code,{children:"'"})}),"\n",(0,a.jsx)(t.p,{children:'"Tick". Access built-in attributes of types.'}),"\n",(0,a.jsx)(t.h3,{id:"abe",children:"ABE"}),"\n",(0,a.jsx)(t.p,{children:'"Access before elaboration"'}),"\n",(0,a.jsx)(t.h3,{id:"allocator",children:"allocator"}),"\n",(0,a.jsx)(t.p,{children:'"new" construct that allocates storage and returns a pointer.\nFailure to allocate results in an exception being raised.'}),"\n",(0,a.jsx)(t.h3,{id:"access-type",children:"access type"}),"\n",(0,a.jsx)(t.p,{children:"Similar to a pointer, a type which refers to the placement of another object in memory."}),"\n",(0,a.jsx)(t.h3,{id:"access-to-object-type",children:"access-to-object type"}),"\n",(0,a.jsx)(t.p,{children:"Pointer type that points to an object in memory. It can be divided further into access-to-constant vs access-to-variable, named access vs anonymous access, pool-specific access (that can only point to the heap) vs general access (that can point to both heap and stack)."}),"\n",(0,a.jsx)(t.h3,{id:"access-to-subprogram-type",children:"access-to-subprogram type"}),"\n",(0,a.jsx)(t.p,{children:"Pointer type that points to a subprogram (function or procedure)."}),"\n",(0,a.jsx)(t.h3,{id:"aggregate",children:"aggregate"}),"\n",(0,a.jsx)(t.p,{children:"The literal value for a composite object (array, record or container). A comma-separated list of values enclosed in parentheses or square-brackets (for homogeneous collections only, and only since Ada 2022)."}),"\n",(0,a.jsx)(t.h3,{id:"aliased",children:"aliased"}),"\n",(0,a.jsx)(t.p,{children:"Objects (both variables and components) can be declared explicitly as aliased, so that it is valid to use attribute Access to point to the object."}),"\n",(0,a.jsx)(t.h3,{id:"aspect",children:"aspect"}),"\n",(0,a.jsx)(t.p,{children:"Additional specifications attached to a declaration, either related to its behavior (like preconditions and postconditions for subprograms) or its representation (like size or alignment for objects)."}),"\n",(0,a.jsx)(t.h3,{id:"attribute",children:"attribute"}),"\n",(0,a.jsx)(t.p,{children:"Value or function attached to a type or object, which can be retrieved using the syntax Type'Attribute or Object'Attribute. For example, attributes First and Last denote the first and last indexes of a (constrained) array type, or of any array object."}),"\n",(0,a.jsx)(t.h3,{id:"atc",children:"ATC"}),"\n",(0,a.jsx)(t.p,{children:'"Asynchronous transfer of control"'}),"\n",(0,a.jsx)(t.h3,{id:"bounded-error",children:"bounded error"}),"\n",(0,a.jsx)(t.p,{children:"The result of a violation of Ada program semantics, when the consequences of the error are precisely bounded by the language. E.g. reading an uninitialized variable may lead to any value of the corresponding base type being read."}),"\n",(0,a.jsx)(t.h3,{id:"completion",children:"completion"}),"\n",(0,a.jsx)(t.p,{children:"An initial declaration for a type, constant, subprogram or package may be completed by a second declaration, called the completion of the initial declaration."}),"\n",(0,a.jsx)(t.h3,{id:"component",children:"component"}),"\n",(0,a.jsx)(t.p,{children:"A record field or array element."}),"\n",(0,a.jsx)(t.h3,{id:"configuration-pragma",children:"configuration pragma"}),"\n",(0,a.jsx)(t.p,{children:"A pragma at the very start of a file, or even provided in a separate file depending on the compiler, that applies to the compilation unit as a whole."}),"\n",(0,a.jsx)(t.h3,{id:"controlled-type",children:"controlled type"}),"\n",(0,a.jsx)(t.p,{children:"Type that supports RAII (Resource Acquisition Is Initialization) through the insertion by the compiler of calls to specific procedures at object creation, assignment and end-of-life."}),"\n",(0,a.jsx)(t.h3,{id:"definite-type",children:"definite type"}),"\n",(0,a.jsx)(t.p,{children:"A type for which it requires no explicit constraint or initial value when declared."}),"\n",(0,a.jsx)(t.h3,{id:"discriminant",children:"discriminant"}),"\n",(0,a.jsx)(t.p,{children:"Special field in record types, which may be used to control the structure of the type itself, either through a variant-clause (so the presence of other fields depends on the value of the discriminant) or through the constraint on the array subtype for the last field (so the size of this field depends on the value of the discriminant)."}),"\n",(0,a.jsx)(t.h3,{id:"entry",children:"entry"}),"\n",(0,a.jsx)(t.p,{children:"The other kind of callable entities, in addition to subprograms. It is used for queued operations called concurrently, as part of a task or protected object API."}),"\n",(0,a.jsx)(t.h3,{id:"erroneous-behavior",children:"erroneous behavior"}),"\n",(0,a.jsx)(t.p,{children:"The result of a violation of Ada program semantics, when the consequences of the error are not bounded by the language. E.g. deactivating runtime checks and violating the corresponding conditions may lead to arbitrary code execution."}),"\n",(0,a.jsx)(t.h3,{id:"indefinite-type",children:"indefinite type"}),"\n",(0,a.jsx)(t.p,{children:"A type for which you cannot declare an object without supply bounds a constraint or an initial value."}),"\n",(0,a.jsx)(t.h3,{id:"limited-type",children:"limited type"}),"\n",(0,a.jsx)(t.p,{children:"An uncopyable type."}),"\n",(0,a.jsx)(t.h3,{id:"parent",children:"parent"}),"\n",(0,a.jsx)(t.p,{children:"Non-abstract tagged type being extended."}),"\n",(0,a.jsx)(t.h3,{id:"pragma",children:"pragma"}),"\n",(0,a.jsx)(t.p,{children:"A directive to the compiler. There are many different pragmas defined in Ada, and even more are compiler-specific."}),"\n",(0,a.jsx)(t.h3,{id:"progenitor",children:"progenitor"}),"\n",(0,a.jsx)(t.p,{children:"Additional interfaces inherited."}),"\n",(0,a.jsx)(t.h3,{id:"qualification",children:"qualification"}),"\n",(0,a.jsx)(t.p,{children:"Expression is used to verify that an object respects the constraint of a subtype, using the syntax Subtype'Object. This is different from type conversion, as the object and its qualification share the same type."}),"\n",(0,a.jsx)(t.h3,{id:"subprogram",children:"subprogram"}),"\n",(0,a.jsx)(t.p,{children:"A function (returning a result) or procedure (with no result). This does not include entries of tasks or protected objects, which are used for queued operations called concurrently."}),"\n",(0,a.jsx)(t.h3,{id:"subtype",children:"subtype"}),"\n",(0,a.jsx)(t.p,{children:"A type together with additional constraints, like a range of values for a scalar type. An object can be freely converted to a different subtype of the same type, but the corresponding constraint will be checked at runtime if necessary."}),"\n",(0,a.jsx)(t.h3,{id:"tagged-type",children:"tagged type"}),"\n",(0,a.jsx)(t.p,{children:'A type with an associated "tag", which specifies its type and allows for dynamic dispatch.'}),"\n",(0,a.jsx)(t.h3,{id:"type-conversion",children:"type conversion"}),"\n",(0,a.jsx)(t.p,{children:"Expression to change the type of its argument, typically between different scalar types. There are no implicit type conversions in Ada."}),"\n",(0,a.jsx)(t.h3,{id:"unchecked-type-conversion",children:"unchecked type conversion"}),"\n",(0,a.jsx)(t.p,{children:"Blind conversion of a bit pattern from one type to another, using the predefined generic function Ada.Unchecked_Conversion which must be instantiated with the types of source and target."})]})}function h(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);