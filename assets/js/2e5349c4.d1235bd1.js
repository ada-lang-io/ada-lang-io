"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7020],{4600:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>x,contentTitle:()=>A,default:()=>p,frontMatter:()=>h,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"arm/AA-13/AA-13.8","title":"13.8 Machine Code Insertions","description":"This Reference Manual output has not been verified,","source":"@site/docs/arm/AA-13/AA-13.8.mdx","sourceDirName":"arm/AA-13","slug":"/arm/AA-13/AA-13.8","permalink":"/docs/arm/AA-13/AA-13.8","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":112,"frontMatter":{"sidebar_position":112},"sidebar":"referenceManualSidebar","previous":{"title":"13.7 The Package System","permalink":"/docs/arm/AA-13/AA-13.7"},"next":{"title":"13.9 Unchecked Type Conversions","permalink":"/docs/arm/AA-13/AA-13.9"}}');var a=n(4848),i=n(8453),d=n(3204),c=n(4220),o=n(8069),t=n(8011),l=n(6465);const h={sidebar_position:112},A="13.8 Machine Code Insertions",x={},m=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4}];function j(e){const s={a:"a",admonition:"admonition",h1:"h1",h4:"h4",header:"header",p:"p",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"138-machine-code-insertions",children:"13.8 Machine Code Insertions"})}),"\n",(0,a.jsx)(s.admonition,{type:"danger",children:(0,a.jsxs)(s.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.jsx)(s.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n",(0,a.jsx)(t.A,{children:"1"}),"\n",(0,a.jsxs)("p",{children:["[ A machine code insertion can be achieved by a call to a subprogram whose ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0166",children:"sequence_of_statements"})})," contains ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s.] ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(s.h4,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsx)(t.A,{children:"2"}),"\n",(0,a.jsx)(o.A,{children:(0,a.jsxs)(s.p,{children:[(0,a.jsxs)("code",{children:["code","_","statement"]}),(0,a.jsx)("a",{id:"S0357"}),(0,a.jsx)("code",{children:" ::= "}),(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})}),";",(0,a.jsx)("br",{})]})}),"\n",(0,a.jsx)(t.A,{children:"3"}),"\n",(0,a.jsxs)("p",{class:"Indented2",children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," is only allowed in the ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-11/AA-11.2#S0304",children:["handled","_","sequence","_","of","_","statements"]})})," of a ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})}),". If a ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})})," contains any ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:["code","_","statement"]})}),"s, then within this ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-6/AA-6.3#S0216",children:["subprogram","_","body"]})})," the only allowed form of ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-5/AA-5.1#S0167",children:"statement"})})," is a ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:["code","_","statement"]})})," (labeled or not), the only allowed ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-3/AA-3.11#S0087",children:["declarative","_","item"]})}),"s are ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-8/AA-8.4#S0235",children:["use","_","clause"]})}),"s, and no ",(0,a.jsx)("code",{children:(0,a.jsxs)("a",{href:"/docs/arm/AA-11/AA-11.2#S0305",children:["exception","_","handler"]})})," is allowed (",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-2/AA-2.7#S0018",children:"comment"})}),"s and ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-2/AA-2.8#S0019",children:"pragma"})}),"s are allowed as usual). ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(s.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,a.jsx)(t.A,{children:"4"}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," is expected to be of any type. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(s.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,a.jsx)(t.A,{children:"5"}),"\n",(0,a.jsxs)("p",{children:["The ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," shall be of a type declared in package System.Machine","_","Code. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"5.a"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)("strong",{}),"This includes types declared in children of System.Machine","_","Code. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(t.A,{children:"6"}),"\n",(0,a.jsxs)("p",{children:["A ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," shall appear only within the scope of a ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-10/AA-10.1#S0294",children:"with_clause"})})," that mentions package System.Machine","_","Code. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"6.a"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"ramification",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)("strong",{}),"Note that this is not a note; without this rule, it would be possible to write machine code in compilation units which depend on System.Machine","_","Code only indirectly. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(s.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,a.jsx)(t.A,{children:"7"}),"\n",(0,a.jsxs)("p",{children:["The contents of the library package System.Machine","_","Code (if provided) are implementation defined. The meaning of ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s is implementation defined. [Typically, each ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})})," represents a machine instruction or assembly directive.] ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"7.a"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)("strong",{}),"For example, an instruction might be a record with an Op","_","Code component and other components for the operands. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"7.b"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"implementation-defined",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)("strong",{}),"The contents of the visible part of package System.Machine","_","Code, and the meaning of ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(s.h4,{id:"implementation-permissions",children:"Implementation Permissions"}),"\n",(0,a.jsx)(t.A,{children:"8"}),"\n",(0,a.jsxs)("p",{children:["An implementation may place restrictions on ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s. An implementation is not required to provide package System.Machine","_","Code. ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"9/5"}),(0,a.jsx)(l.A,{items:["AI12-0440-1"]}),(0,a.jsx)(d.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(s.p,{children:["NOTE 1   An implementation can provide implementation-defined pragmas specifying register conventions and calling conventions.",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"10/2"}),(0,a.jsx)(l.A,{items:["AI95-00318-02"]}),(0,a.jsx)(d.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(s.p,{children:["NOTE 2   Machine code functions are exempt from the rule that a return statement is required. In fact, return statements are forbidden, since only ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})}),"s are allowed. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"10.a"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"discussion",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)("strong",{}),"The idea is that the author of a machine code subprogram knows the calling conventions, and refers to parameters and results accordingly. The implementation should document where to put the result of a machine code function, for example, \u201cScalar results are returned in register 0\u201d. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"11"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(s.p,{children:["NOTE 3   Intrinsic subprograms (see ",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.3#Subclause_6.3.1",children:"6.3.1"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-6/AA-6.3#Subclause_6.3.1",children:"Conformance Rules"}),"\u201d) can also be used to achieve machine code insertions. Interface to assembly language can be achieved using the features in ",(0,a.jsx)("a",{href:"/docs/arm/AA-B/",children:"Annex B"}),", \u201c",(0,a.jsx)("a",{href:"/docs/arm/AA-B/",children:"Interface to Other Languages"}),"\u201d. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(s.h4,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(t.A,{children:"12"}),"\n",(0,a.jsxs)("p",{children:[(0,a.jsx)("em",{children:"Example of a code statement:"})," ",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(t.A,{children:"13/3"}),"\n",(0,a.jsx)(l.A,{items:["AI05-0229-1"]}),"\n",(0,a.jsx)(o.A,{language:"ada",children:(0,a.jsxs)(s.p,{children:["M : Mask;","\n","procedure Set","_","Mask","\n","  with Inline;","\n","\n",(0,a.jsx)(t.A,{children:"14"}),"\nprocedure Set","_","Mask is","\n","  use System.Machine","_","Code; -- assume \u201cwith System.Machine","_","Code;\u201d appears somewhere above","\n","begin","\n","  SI","_","Format'(Code =",">"," SSM, B =",">"," M'Base","_","Reg, D =",">"," M'Disp);","\n","  --  Base","_","Reg and Disp are implementation-defined attributes","\n","end Set","_","Mask;","\n"]})}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(s.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"14.a"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(s.p,{children:["Machine code functions are allowed in Ada 95; in Ada 83, only procedures were allowed. ",(0,a.jsx)("br",{})]})})]}),"\n",(0,a.jsx)(c.A,{children:(0,a.jsx)(s.h4,{id:"wording-changes-from-ada-83",children:"Wording Changes from Ada 83"})}),"\n",(0,a.jsxs)(c.A,{children:[(0,a.jsx)(t.A,{children:"14.b"}),(0,a.jsx)(d.A,{type:"aarm",aarm:"note",children:(0,a.jsxs)(s.p,{children:["The syntax for ",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-13/AA-13.8#S0357",children:"code_statement"})})," is changed to say \u201c",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.7#S0163",children:"qualified_expression"})}),"\u201d instead of \u201c",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-3/AA-3.2#S0028",children:"subtype_mark"})}),"'",(0,a.jsx)("code",{children:(0,a.jsx)("a",{href:"/docs/arm/AA-4/AA-4.3#S0107",children:"record_aggregate"})}),"\u201d. Requiring the type of each instruction to be a record type is overspecification. ",(0,a.jsx)("br",{})]})})]})]})}function p(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(j,{...e})}):j(e)}}}]);