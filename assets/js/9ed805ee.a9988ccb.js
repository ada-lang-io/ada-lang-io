"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2474],{8451:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"style-guide/s9/02","title":"9.2 Tagged Type Hierarchies","description":"You should use inheritance primarily as a mechanism for implementing a","source":"@site/docs/style-guide/s9/02.mdx","sourceDirName":"style-guide/s9","slug":"/style-guide/s9/02","permalink":"/docs/style-guide/s9/02","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"9.2 Tagged Type Hierarchies"},"sidebar":"styleGuideSidebar","previous":{"title":"9.1 Object-Oriented Design","permalink":"/docs/style-guide/s9/01"},"next":{"title":"9.3 Tagged Type Operations","permalink":"/docs/style-guide/s9/03"}}');var a=t(4848),o=t(8453);const s={title:"9.2 Tagged Type Hierarchies"},r=void 0,c={},l=[{value:"Tagged Types",id:"tagged-types",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Properties of Dispatching Operations",id:"properties-of-dispatching-operations",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Controlled Types",id:"controlled-types",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Abstract Types",id:"abstract-types",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes",level:4}];function d(e){const n={blockquote:"blockquote",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:'You should use inheritance primarily as a mechanism for implementing a\nclass hierarchy from an object-oriented design. A class hierarchy should\nbe a generalization/specialization ("is-a") relationship. This\nrelationship may also be referred to as "is-a-kind-of," not to be\nconfused with "is an instance of." This "is-a" usage of inheritance is\nin contrast to other languages in which inheritance is used also to\nprovide the equivalent of the Ada context clauses with and use. In Ada,\nyou first identify the external modules of interest via with clauses and\nthen choose selectively whether to make only the name of the module\n(package) visible or its contents (via a use clause).'}),"\n",(0,a.jsx)(n.h3,{id:"tagged-types",children:"Tagged Types"}),"\n",(0,a.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Consider using type extension when designing an is-a\n(generalization/specialization) hierarchy."}),"\n",(0,a.jsx)(n.li,{children:"Use tagged types to preserve a common interface across differing\nimplementations (Taft 1995a)."}),"\n",(0,a.jsx)(n.li,{children:"When defining a tagged type in a package, consider including a\ndefinition of a general access type to the corresponding class-wide\ntype."}),"\n",(0,a.jsx)(n.li,{children:"In general, define only one tagged type per package."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,a.jsx)(n.p,{children:"Consider the type structure for a set of two-dimensional geometric\nobjects positioned in a Cartesian coordinate system (Barnes 1996). The\nancestor or root type Object is a tagged record. The components common\nto this type and all its descendants are an x and y coordinate. Various\ndescendant types include points, circles, and arbitrary shapes. Except\nfor points, these descendant types extend the root type with additional\ncomponents; for example, the circle adds a radius component:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"type Object is tagged\n   record\n      X_Coord : Float;\n      Y_Coord : Float;\n   end record;\n\ntype Circle is new Object with\n   record\n      Radius : Float;\n   end record;\n\ntype Point is new Object with null record;\n\ntype Shape is new Object with\n   record\n      -- other components\n      ...\n   end record;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The following is an example of general access type to the corresponding\nclass-wide type:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"package Employee is\n   type Object is tagged limited private;\n   type Reference is access all Object'class;\n   ...\nprivate\n   ...\nend Employee;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,a.jsx)(n.p,{children:"You can derive new types from both tagged and untagged types, but the\neffects of this derivation are different. When you derive from an\nuntagged type, you are creating a new type whose implementation is\nidentical to the parent. Values of the derived types are subject to\nstrong type checking; thus, you cannot mix the proverbial apples and\noranges. When you derive a new type from an untagged type, you are not\nallowed to extend it with new components. You are effectively creating a\nnew interface without changing the underlying implementation (Taft\n1995a)."}),"\n",(0,a.jsx)(n.p,{children:"In deriving from a tagged type, you can extend the type with new\ncomponents. Each descendant can extend a common interface (the\nparent's). The union of a tagged type and its descendants form a class,\nand a class offers some unique features not available to untagged\nderivations. You can write class-wide operations that can be applied to\nany object that is a member of the class. You can also provide new\nimplementations for the descendants of tagged types, either by\noverriding inherited primitive operations or by creating new primitive\noperations. Finally, tagged types can be used as the basis for multiple\ninheritance building blocks (see Guideline 9.5.1)."}),"\n",(0,a.jsx)(n.p,{children:"Reference semantics are very commonly used in object-oriented\nprogramming. In particular, heterogeneous polymorphic data structures\nbased on tagged types require the use of access types. It is convenient\nto have a common definition for such a type provided to any client of\nthe package defining the tagged type. A heterogeneous polymorphic data\nstructure is a composite data structure (such as an array) whose\nelements have a homogeneous interface (i.e., an access to class-wide\ntype) and whose elements' implementations are heterogeneous (i.e., the\nimplementation of the elements uses different specific types). See also\nGuidelines 9.3.5 on polymorphism and 9.4.1 on managing visibility of\ntagged type hierarchies."}),"\n",(0,a.jsx)(n.p,{children:'In Ada, the primitive operations of a type are implicitly associated\nwith the type through scoping rules. The definition of a tagged type and\na set of operations corresponds together to the "traditional"\nobject-oriented programming concept of a "class." Putting these into a\npackage provides a clean encapsulation mechanism.'}),"\n",(0,a.jsx)(n.h4,{id:"exceptions",children:"exceptions"}),"\n",(0,a.jsx)(n.p,{children:"If the root of the hierarchy does not define a complete set of values\nand operations, then use an abstract tagged type (see Guideline 9.2.4).\nThis abstract type can be thought of as the least common denominator of\nthe class, essentially a conceptual and incomplete type."}),"\n",(0,a.jsx)(n.p,{children:"If a descendant needs to remove one of the components or primitive\noperations of its ancestor, it may not be appropriate to extend the\ntagged type."}),"\n",(0,a.jsx)(n.p,{children:"An exception to using reference semantics is when a type is exported\nthat would not be used in a data structure or made part of a collection."}),"\n",(0,a.jsx)(n.p,{children:"If the implementation of two tagged types requires mutual visibility and\nthe two types are generally used together, then it may be best to define\nthem together in one package, though thought should be given to using\nchild packages instead (see Guideline 9.4.1). Also, it can be convenient\nto define a small hierarchy of (completely) abstract types (or a small\npart of a larger hierarchy) all in one package specification; however,\nthe negative impact on maintainability may outweigh the convenience. You\ndo not provide a package body in this situation unless you have declared\nnonabstract operations on members of the hierarchy."}),"\n",(0,a.jsx)(n.h3,{id:"properties-of-dispatching-operations",children:"Properties of Dispatching Operations"}),"\n",(0,a.jsx)(n.h4,{id:"guideline-1",children:"guideline"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The implementation of the dispatching operations of each type in a\nderivation class rooted in a tagged type T should conform to the\nexpected semantics of the corresponding dispatching operations of\nthe class-wide type T'Class."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-1",children:"example"}),"\n",(0,a.jsx)(n.p,{children:"The key point of both of the alternatives in the following example is\nthat it must be possible to use the class-wide type\nTransaction.Object'Class polymorphically without having to study the\nimplementations of each of the types derived from the root type\nTransaction.Object. In addition, new transactions can be added to the\nderivation class without invalidating the existing transaction\nprocessing code. These are the important practical consequences of the\ndesign rule captured in the guideline:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"with Database;\npackage Transaction is\n\n   type Object (Data : access Database.Object'Class) is abstract tagged limited\n      record\n         Has_Executed : Boolean := False;\n      end record;\n\n   function Is_Valid (T : Object) return Boolean;\n   -- checks that Has_Executed is False\n\n   procedure Execute (T : in out Object);\n   -- sets Has_Executed to True\n\n   Is_Not_Valid : exception;\n\nend Transaction;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The precondition of Execute(T) for all T in Transaction.Object'Class is\nthat Is_Valid(T) is True. The postcondition is the T.Has_Executed =\nTrue. This model is trivially satisfied by the root type\nTransaction.Object."}),"\n",(0,a.jsx)(n.p,{children:"Consider the following derived type:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"with Transaction;\nwith Personnel;\npackage Pay_Transaction is\n   type Object is new Transaction.Object with\n      record\n         Employee     : Personnel.Name;\n         Hours_Worked : Personnel.Time;\n      end record;\n   function Is_Valid (T : Object) return Boolean;\n   -- checks that Employee is a valid name, Hours_Worked is a valid\n   -- amount of work time and Has_Executed = False\n   procedure Has_Executed (T : in out Object);\n   -- computes the pay earned by the Employee for the given Hours_Worked\n   -- and updates this in the database T.Data, then sets Has_Executed to True\nend Pay_Transaction;\n"})}),"\n",(0,a.jsx)(n.p,{children:'The precondition for the specific operation Pay_Transaction.Execute(T)\nis that Pay_Transaction.Is_Valid(T) is True, which is the same\nprecondition as for the dispatching operation Execute on the class-wide\ntype. (The actual validity check is different, but the statement of the\n"precondition" is the same.) The postcondition for\nPay_Transaction.Execute(T) includes T.Has_Executed = True but also\nincludes the appropriate condition on T.Data for computation of pay.'}),"\n",(0,a.jsx)(n.p,{children:"The class-wide transaction type can then be properly used as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"type Transaction_Reference is access all Transaction.Object'Class;\ntype Transaction_List is array (Positive range <>) of Transaction_Reference;\nprocedure Process (Action : in Transaction_List) is\nbegin\n   for I in Action'Range loop\n   -- Note that calls to Is_Valid and Execute are dispatching\n      if Transaction.Is_Valid(Action(I).all) then\n         -- the precondition for Execute is satisfied\n         Transaction.Execute(Action(I).all);\n         -- the postcondition Action(I).Has_Executed = True is\n         -- guaranteed to be satisfied (as well as any stronger conditions\n         -- depending on the specific value of Action(I))\n      else\n         -- deal with the error\n         ...\n      end if;\n   end loop;\nend Process;\n"})}),"\n",(0,a.jsx)(n.p,{children:'If you had not defined the operation Is_Valid on transactions, then the\nvalidity condition for pay computation (valid name and hours worked)\nwould have to directly become the precondition for\nPay_Transaction.Execute. But this would be a "stronger" precondition\nthan that on the class-wide dispatching operation, violating the\nguideline. As a result of this violation, there would be no way to\nguarantee the precondition of a dispatching call to Execute, leading to\nunexpected failures.'}),"\n",(0,a.jsx)(n.p,{children:'An alternative resolution to this problem is to define an exception to\nbe raised by an Execute operation when the transaction is not valid.\nThis behavior becomes part of the semantic model for the class-wide\ntype: the precondition for Execute(T) becomes simply True (i.e., always\nvalid), but the postcondition becomes "either" the exception is not\nraised and Has_Executed = True "or" the exception is raised and\nHas_Executed = False. The implementations of Execute in all derived\ntransaction types would then need to satisfy the new postcondition. It\nis important that the "same" exception be raised by "all"\nimplementations because this is part of the expected semantic model of\nthe class-wide type.'}),"\n",(0,a.jsx)(n.p,{children:"With the alternative approach, the above processing loop becomes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"procedure Process (Action : in Transaction_List) is\nbegin\n\n   for I in Action'Range loop\n\n    Process_A_Transaction:\n      begin\n\n         -- there is no precondition for Execute\n         Transaction.Execute (Action(I).all);\n         -- since no exception was raised, the postcondition\n         -- Action(I).Has_Executed = True is guaranteed (as well as\n         -- any stronger condition depending on the specific value of\n         -- Action(I))\n\n      exception\n         when Transaction.Is_Not_Valid =>\n            -- the exception was raised, so Action(I).Has_Executed = False\n\n            -- deal with the error\n            ...\n\n      end Process_A_Transaction;\n\n   end loop;\n\nend Process;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"rationale-1",children:"rationale"}),"\n",(0,a.jsx)(n.p,{children:'All the properties expected of a class-wide type by clients of that type\nshould be meaningful for any specific types in the derivation class of\nthe class-wide type. This rule is related to the object-oriented\nprogramming "substitutability principle" for consistency between the\nsemantics of an object-oriented superclass and its subclasses (Wegner\nand Zdonik 1988). However, the separation of the polymorphic class-wide\ntype T\'Class from the root specific type T in Ada 95 clarifies this\nprinciple as a design rule on derivation classes rather than a\ncorrectness principle for derivation itself.'}),"\n",(0,a.jsx)(n.p,{children:"When a dispatching operation is used on a variable of a class-wide type\nT'Class, the actual implementation executed will depend dynamically on\nthe actual tag of the value in the variable. In order to rationally use\nT'Class, it must be possible to understand the semantics of the\noperations on T'Class without having to study the implementation of the\noperations for each of the types in the derivation class rooted in T.\nFurther, a new type added to this derivation class should not invalidate\nthis overall understanding of T'Class because this could invalidate\nexisting uses of the class-wide type. Thus, there needs to be an overall\nset of semantic properties of the operations of T'Class that is\npreserved by the implementations of the corresponding dispatching\noperations of all the types in the derivation class."}),"\n",(0,a.jsx)(n.p,{children:'One way to capture the semantic properties of an operation is to define\na "precondition" that must be true before the operation is invoked and a\n"postcondition" that must be true (given the precondition) after the\noperation has executed. You can (formally or informally) define pre- and\npostconditions for each operation of T\'Class without reference to the\nimplementations of dispatching operations of specific types. These\nsemantic properties define the "minimum" set of properties common to all\ntypes in the derivation class. To preserve this minimum set of\nproperties, the implementation of the dispatching operations of all the\ntypes in the derivation class rooted in T (including the root type T)\nshould have (the same or) weaker preconditions than the corresponding\noperations of T\'Class and (the same or) stronger postconditions than the\nT\'Class operations. This means that any invocation of a dispatching\noperation on T\'Class will result in the execution of an implementation\nthat requires no more than what is expected of the dispatching operation\nin general (though it could require less) and delivers a result that is\nno less than what is expected (though it could do more).'}),"\n",(0,a.jsx)(n.h4,{id:"exceptions-1",children:"exceptions"}),"\n",(0,a.jsx)(n.p,{children:"Tagged types and type extension may sometimes be used primarily for type\nimplementation reasons rather than for polymorphism and dispatching. In\nparticular, a nontagged private type may be implemented using a type\nextension of a tagged type. In such cases, it may not be necessary for\nthe implementation of the derived type to preserve the semantic\nproperties of the class-wide type because the membership of the new type\nin the tagged type derivation class will not generally be known to\nclients of the type."}),"\n",(0,a.jsx)(n.h3,{id:"controlled-types",children:"Controlled Types"}),"\n",(0,a.jsx)(n.h4,{id:"guideline-2",children:"guideline"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'Consider using a controlled type whenever a type allocates resources\nthat must be deallocated or otherwise "cleaned up" on destruction or\noverwriting.'}),"\n",(0,a.jsx)(n.li,{children:'Use a derivation from a controlled type in preference to providing\nan explicit "cleanup" operation that must be called by clients of\nthe type.'}),"\n",(0,a.jsx)(n.li,{children:"When overriding the adjustment and finalization procedures derived\nfrom controlled types, define the finalization procedure to undo the\neffects of the adjustment procedure."}),"\n",(0,a.jsx)(n.li,{children:"Derived type initialization procedures should call the\ninitialization procedure of their parent as part of their\ntype-specific initialization."}),"\n",(0,a.jsx)(n.li,{children:"Derived type finalization procedures should call the finalization\nprocedure of their parent as part of their type-specific\nfinalization."}),"\n",(0,a.jsx)(n.li,{children:"Consider deriving a data structure's components rather than the\nenclosing data structure from a controlled type."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-2",children:"example"}),"\n",(0,a.jsx)(n.p,{children:"The following example demonstrates the use of controlled types in the\nimplementation of a simple linked list. Because the Linked_List type is\nderived from Ada.Finalization.Controlled, the Finalize procedure will be\ncalled automatically when objects of the Linked_List type complete\ntheir scope of execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"with Ada.Finalization;\npackage Linked_List_Package is\n   type Iterator is private;\n   type Data_Type is ...\n   type Linked_List is new Ada.Finalization.Controlled with private;\n   function Head (List : Linked_List) return Iterator;\n   procedure Get_Next (Element  : in out Iterator;\n                       Data     :    out Data_Type);\n   procedure Add (List     : in out Linked_List;\n                  New_Data : in     Data_Type);\n   procedure Finalize (List : in out Linked_List); -- reset Linked_List structure\n   -- Initialize and Adjust are left to the default implementation.\nprivate\n   type Node;\n   type Node_Ptr is access Node;\n   type Node is\n      record\n         Data : Data_Type;\n         Next : Node_Ptr;\n      end record;\n   type Iterator is new Node_Ptr;\n   type Linked_List is new Ada.Finalization.Controlled with\n      record\n         Number_Of_Items : Natural := 0;\n         Root            : Node_Ptr;\n      end record;\nend Linked_List_Package;\n--------------------------------------------------------------------------\npackage body Linked_List_Package is\n\n   function Head (List : Linked_List) return Iterator is\n      Head_Node_Ptr : Iterator;\n   begin\n      Head_Node_Ptr := Iterator (List.Root);\n      return Head_Node_Ptr;  -- Return the head element of the list\n   end Head;\n\n   procedure Get_Next (Element : in out Iterator;\n                       Data    :    out Data_Type) is\n   begin\n      --\n      -- Given an element, return the next element (or null)\n      --\n   end Get_Next;\n\n   procedure Add (List     : in out Linked_List;\n                  New_Data : in     Data_Type) is\n   begin\n      --\n      -- Add a new element to the head of the list\n      --\n   end Add;\n\n   procedure Finalize (List : in out Linked_List) is\n   begin\n      -- Release all storage used by the linked list\n      --   and reinitialize.\n   end Finalize;\n\nend Linked_List_Package;\n"})}),"\n",(0,a.jsx)(n.h4,{id:"rationale-2",children:"rationale"}),"\n",(0,a.jsx)(n.p,{children:"The three controlling operations, Initialize, Adjust, and Finalize,\nserve as automatically called procedures that control three primitive\nactivities in the life of an object (Ada Reference Manual 1995, \xa77.6).\nWhen an assignment to an object of a type derived from Controlled\noccurs, adjustment and finalization work in tandem. Finalization cleans\nup the object being overwritten (e.g., reclaims heap space), then\nadjustment finishes the assignment work once the value being assigned\nhas been copied (e.g., to implement a deep copy)."}),"\n",(0,a.jsx)(n.p,{children:"You can ensure that the derived type's initialization is consistent with\nthat of the parent by calling the parent type's initialization from the\nderived type's initialization."}),"\n",(0,a.jsx)(n.p,{children:"You can ensure that the derived type's finalization is consistent with\nthat of the parent by calling the parent type's finalization from the\nderived type's finalization."}),"\n",(0,a.jsx)(n.p,{children:"In general, you should call parent initialization before\ndescendant-specific initialization. Similarly, you should call parent\nfinalization after descendant-specific finalization. (You may position\nthe parent initialization and/or finalization at the beginning or end of\nthe procedure.)"}),"\n",(0,a.jsx)(n.h3,{id:"abstract-types",children:"Abstract Types"}),"\n",(0,a.jsx)(n.h4,{id:"guideline-3",children:"guideline"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Consider using abstract types and operations in creating\nclassification schemes, for example, a taxonomy, in which only the\nleaf objects will be meaningful in the application."}),"\n",(0,a.jsx)(n.li,{children:"Consider declaring root types and internal nodes in a type tree as\nabstract."}),"\n",(0,a.jsx)(n.li,{children:"Consider using abstract types for generic formal derived types."}),"\n",(0,a.jsx)(n.li,{children:"Consider using abstract types to develop different implementations\nof a single abstraction."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"example-3",children:"example"}),"\n",(0,a.jsx)(n.p,{children:"In a banking application, there are a wide variety of account types,\neach with different features and restrictions. Some of the variations\nare fees, overdraft protection, minimum balances, allowable account\nlinkages (e.g., checking and savings), and rules on opening the account.\nCommon to all bank accounts are ownership attributes: unique account\nnumber, owner name(s), and owner tax identification number(s). Common\noperations across all types of accounts are opening, depositing,\nwithdrawing, providing current balance, and closing. The common\nattributes and operations describe the conceptual bank account. This\nidealized bank account can form the root of a\ngeneralization/specialization hierarchy that describes the bank's array\nof products. By using abstract tagged types, you ensure that only\naccount objects corresponding to a specific product will be created.\nBecause any abstract operations must be overridden with each derivation,\nyou ensure that any restrictions for a specialized account are\nimplemented (e.g., how and when the account-specific fee structure is\napplied):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ada",children:"--------------------------------------------------------------------------\npackage Bank_Account_Package is\n\n   type Bank_Account_Type is abstract tagged limited private;\n   type Money is delta 0.01 digits 15;\n\n   -- The following abstract operations must be overridden for\n   --   each derivation, thus ensuring that any restrictions\n   --   for specialized accounts will be implemented.\n\n   procedure Open (Account : in out Bank_Account_Type) is abstract;\n\n   procedure Close (Account : in out Bank_Account_Type) is abstract;\n\n   procedure Deposit (Account : in out Bank_Account_Type;\n                      Amount  : in     Money) is abstract;\n\n   procedure Withdraw (Account : in out Bank_Account_Type;\n                       Amount  : in     Money) is abstract;\n\n   function Balance (Account : Bank_Account_Type)\n     return Money is abstract;\n\nprivate\n   type Account_Number_Type is ...\n   type Account_Owner_Type  is ...\n   type Tax_ID_Number_Type  is ...\n\n   type Bank_Account_Type is abstract tagged limited\n      record\n         Account_Number : Account_Number_Type;\n         Account_Owner  : Account_Owner_Type;\n         Tax_ID_Number  : Tax_ID_Number_Type;\n      end record;\nend Bank_Account_Package;\n--------------------------------------------------------------------------\n-- Now, other specialized accounts such as a savings account can\n-- be derived from Bank_Account_Type as in the following example.\n-- Note that abstract types are still used to ensure that only\n-- account objects corresponding to specific products will be\n-- created.with Bank_Account_Package;\nwith Bank_Account_Package;\npackage Savings_Account_Package is\n   type Savings_Account_Type is abstract\n      new Bank_Account_Package.Bank_Account_Type with private;\n   -- We must override the abstract operations provided\n   --   by Bank_Account_Package.  Since we are still declaring\n   --   these operations to be abstract, they must also be\n   --   overridden by the specializations of Savings_Account_Type.\n   procedure Open (Account : in out Savings_Account_Type) is abstract;\n   procedure Close (Account : in out Savings_Account_Type) is abstract;\n\n   procedure Deposit (Account : in out Savings_Account_Type;\n                      Amount  : in     Bank_Account_Package.Money) is abstract;\n\n   procedure Withdraw (Account : in out Savings_Account_Type;\n                       Amount  : in     Bank_Account_Package.Money) is abstract;\n\n   function Balance (Account : Savings_Account_Type)\n     return Bank_Account_Package.Money is abstract;\n\nprivate\n   type Savings_Account_Type is abstract\n      new Bank_Account_Package.Bank_Account_Type with\n         record\n            Minimum_Balance : Bank_Account_Package.Money;\n         end record;\nend Savings_Account_Package;\n\n--------------------------------------------------------------------------\n"})}),"\n",(0,a.jsx)(n.p,{children:"See the abstract set package in Guideline 9.5.1 for an example of\ncreating an abstraction with a single interface and the potential for\nmultiple implementations. The example only shows one possible\nimplementation; however, you could provide an alternate implementation\nof the Hashed_Set abstraction using other data structures."}),"\n",(0,a.jsx)(n.h4,{id:"rationale-3",children:"rationale"}),"\n",(0,a.jsx)(n.p,{children:'In many classification schemes, for example, a taxonomy, only objects at\nthe leaves of the classification tree are meaningful in the application.\nIn other words, the root of the hierarchy does not define a complete set\nof values and operations for use by the application. The use of\n"abstract" guarantees that there will be no objects of the root or\nintermediate nodes. Concrete derivations of the abstract types and\nsubprograms are required so that the leaves of the tree become objects\nthat a client can manipulate.'}),"\n",(0,a.jsx)(n.p,{children:'You can only declare abstract subprograms when the root type is also\nabstract. This is useful as you build an abstraction that forms the\nbasis for a family of abstractions. By declaring the primitive\nsubprograms to be abstract, you can write the "common class-wide parts\nof a system . . . without being dependent on the properties of any\nspecific type at all" (Rationale 1995, \xa74.2).'}),"\n",(0,a.jsx)(n.p,{children:"Abstract types and operations can help you resolve problems when your\ntagged type hierarchy violates the expected semantics of the class-wide\ntype dispatching operations. The Rationale (1995, \xa74.2) explains:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"When building an abstraction that is to form the basis of a class\nof types, it is often convenient not to provide actual subprograms for\nthe root type but just abstract subprograms which can be replaced when\ninherited. This is only allowed if the root type is declared as\nabstract; objects of an abstract type cannot exist. This technique\nenables common class-wide parts of a system to be written without being\ndependent on the properties of any specific type at all. Dispatching\nalways works because it is known that there can never be any objects of\nthe abstract type and so the abstract subprograms could never be called."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"See Guidelines 8.3.8 and 9.2.1."}),"\n",(0,a.jsx)(n.p,{children:"The multiple inheritance techniques discussed in Guideline 9.5.1 make\nuse of abstract tagged types. The basic abstraction is defined using an\nabstract tagged (limited) private type (whose full type declaration is a\nnull record) with a small set of abstract primitive operations. While\nabstract operations have no bodies and thus cannot be called, they are\ninherited. Derivatives of the abstraction then extend the root type with\ncomponents that provide the data representation and override the\nabstract operations to provide callable implementations (Rationale 1995,\n\xa74.4.3). This technique allows you to build multiple implementations of\na single abstraction. You declare a single interface and vary the\nspecifics of the data representation and operation implementation."}),"\n",(0,a.jsx)(n.h4,{id:"notes",children:"notes"}),"\n",(0,a.jsx)(n.p,{children:"When you use abstract data types as described in this guideline, you can\nhave multiple implementations of the same abstraction available to you\nwithin a single program. This technique differs from the idea of writing\nmultiple package bodies to provide different implementations of the\nabstraction defined in a package specification because with the package\nbody technique, you can only include one of the implementations (i.e.,\nbodies) in your program."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);