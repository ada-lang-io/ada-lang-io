"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3908],{19788:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>x,contentTitle:()=>h,default:()=>f,frontMatter:()=>c,metadata:()=>A,toc:()=>j});var s=n(74848),i=n(28453),a=n(13842),o=n(91435),t=n(21432),d=n(79162),l=n(34421);const c={sidebar_position:56},h="6.6 Overloading of Operators",A={id:"arm/AA-6/AA-6.6",title:"6.6 Overloading of Operators",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-6/AA-6.6.mdx",sourceDirName:"arm/AA-6",slug:"/arm/AA-6/AA-6.6",permalink:"/docs/arm/AA-6/AA-6.6",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:56,frontMatter:{sidebar_position:56},sidebar:"referenceManualSidebar",previous:{title:"6.5 Return Statements",permalink:"/docs/arm/AA-6/AA-6.5"},next:{title:"6.7 Null Procedures",permalink:"/docs/arm/AA-6/AA-6.7"}},x={},j=[{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}];function p(e){const r={a:"a",admonition:"admonition",h1:"h1",h4:"h4",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{id:"66-overloading-of-operators",children:"6.6 Overloading of Operators"}),"\n",(0,s.jsx)(r.admonition,{type:"warning",children:(0,s.jsxs)(r.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,s.jsx)(r.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n","\n",(0,s.jsx)(d.A,{children:"1"}),"\n",(0,s.jsxs)("p",{children:["An ",(0,s.jsx)("em",{children:"operator"})," is a function whose ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0199",children:"designator"})})," is an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0202",children:"operator_symbol"})}),". [Operators, like other functions, may be overloaded.] ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(r.h4,{id:"name-resolution-rules",children:"Name Resolution Rules"}),"\n",(0,s.jsx)(d.A,{children:"2"}),"\n",(0,s.jsxs)("p",{children:["Each use of a unary or binary operator is equivalent to a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.4#S0218",children:"function_call"})})," with ",(0,s.jsxs)("em",{children:["function","_"]}),(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.1#S0093",children:"prefix"})})," being the corresponding ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0202",children:"operator_symbol"})}),", and with (respectively) one or two positional actual parameters being the operand(s) of the operator (in order). ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"2.a/5"}),(0,s.jsx)(l.A,{items:["AI05-0299-1","AI12-0449-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("strong",{children:"To be honest: "}),"We also use the term operator (in Clause ",(0,s.jsx)("a",{href:"../AA-4/",children:"4"})," and in ",(0,s.jsx)("a",{href:"../AA-6/AA-6.1",children:"6.1"}),") to refer to one of the syntactic categories defined in ",(0,s.jsx)("a",{href:"../AA-4/AA-4.5",children:"4.5"}),", \u201c",(0,s.jsx)("a",{href:"../AA-4/AA-4.5",children:"Operators and Expression Evaluation"}),"\u201d whose names end with \u201c","_","operator:\u201d ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0142",children:["logical","_","operator"]})}),", ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0143",children:["relational","_","operator"]})}),", ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0144",children:["binary","_","adding","_","operator"]})}),", ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0145",children:["unary","_","adding","_","operator"]})}),", ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0146",children:["multiplying","_","operator"]})}),", and ",(0,s.jsx)("code",{children:(0,s.jsxs)("a",{href:"../AA-4/AA-4.5#S0147",children:["highest","_","precedence","_","operator"]})}),". ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"2.b/3"}),(0,s.jsx)(l.A,{items:["AI05-0005-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("strong",{}),"This equivalence extends to uses of ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.4#S0218",children:"function_call"})})," in most other language rules. However, as often happens, the equivalence is not perfect, as operator calls are not a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.1#S0091",children:"name"})}),", while a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.4#S0218",children:"function_call"})})," is a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.1#S0091",children:"name"})}),". Thus, operator calls cannot be used in contexts that require a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.1#S0091",children:"name"})})," (such as a rename of an object). A direct fix for this problem would be very disruptive, and thus we have not done that. However, qualifying an operator call can be used as a workaround in contexts that require a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.1#S0091",children:"name"})}),". ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(r.h4,{id:"legality-rules",children:"Legality Rules"}),"\n",(0,s.jsx)(d.A,{children:"3/3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0143-1"]}),"\n",(0,s.jsxs)("p",{children:["The ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0196",children:"subprogram_specification"})})," of a unary or binary operator shall have one or two parameters, respectively. The parameters shall be of mode ",(0,s.jsx)("strong",{children:"in"}),". A generic function instantiation whose ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0199",children:"designator"})})," is an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0202",children:"operator_symbol"})})," is only allowed if the specification of the generic function has the corresponding number of parameters, and they are all of mode ",(0,s.jsx)("strong",{children:"in"}),".",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"4"}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-3/AA-3.7#S0063",children:"Default_expression"})}),"s are not allowed for the parameters of an operator (whether the operator is declared with an explicit ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-6/AA-6.1#S0196",children:"subprogram_specification"})})," or by a ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-12/AA-12.3#S0315",children:"generic_instantiation"})}),").",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"5"}),"\n",(0,s.jsxs)("p",{children:['An explicit declaration of "/=" shall not have a result type of the predefined type Boolean. ',(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(r.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,s.jsx)(d.A,{children:"6/3"}),"\n",(0,s.jsx)(l.A,{items:["AI05-0128-1"]}),"\n",(0,s.jsxs)("p",{children:['An explicit declaration of "=" whose result type is Boolean implicitly declares an operator "/=" that gives the complementary result. ',(0,s.jsx)("br",{})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"6.a/3"}),(0,s.jsx)(l.A,{items:["AI05-0128-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"discussion",children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("strong",{}),'A "/=" defined by this rule is considered user-defined, which means that it will be inherited by a derived type. \u201cUser-defined\u201d means \u201cnot language-defined\u201d for the purposes of inheritance, that is anything other than predefined operators. ',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"7/5"}),(0,s.jsx)(l.A,{items:["AI12-0440-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(r.p,{children:['NOTE   The operators "+" and "\u2013" are both unary and binary operators, and hence can be overloaded with both one- and two-parameter functions. ',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(r.h4,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(d.A,{children:"8"}),"\n",(0,s.jsxs)("p",{children:[(0,s.jsx)("em",{children:"Examples of user-defined operators:"})," ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(d.A,{children:"9"}),"\n",(0,s.jsx)(t.A,{language:"ada",children:(0,s.jsxs)(r.p,{children:['function "+" (Left, Right : Matrix) return Matrix;',"\n",'function "+" (Left, Right : Vector) return Vector;',"\n","\n","--  assuming that A, B, and C are of the type Vector","\n","--  the following two statements are equivalent:","\n","\n","A := B + C;","\n",'A := "+"(B, C);',"\n"]})}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(r.h4,{id:"extensions-to-ada-83",children:"Extensions to Ada 83"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"9.a"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(r.p,{children:['Explicit declarations of "=" are now permitted for any combination of parameter and result types.',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"9.b"}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(r.p,{children:['Explicit declarations of "/=" are now permitted, so long as the result type is not Boolean. ',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:(0,s.jsx)(r.h4,{id:"wording-changes-from-ada-2005",children:"Wording Changes from Ada 2005"})}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"9.c/3"}),(0,s.jsx)(l.A,{items:["AI05-0128-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"correction",children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)("strong",{}),' Corrected the wording so that only explicit declarations of "=" cause an implicit declaration of "/="; otherwise, we could get multiple implicit definitions of "/=" without an obvious way to chose between them.',(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(d.A,{children:"9.d/3"}),(0,s.jsx)(l.A,{items:["AI05-0143-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(r.p,{children:["Added wording so that operators only allow parameters of mode ",(0,s.jsx)("strong",{children:"in"}),". This was made necessary by the elimination elsewhere of the restriction that function parameters be only of mode ",(0,s.jsx)("strong",{children:"in"}),". ",(0,s.jsx)("br",{})]})})]})]})}function f(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);