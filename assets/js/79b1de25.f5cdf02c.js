"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([["6541"],{59029:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,toc:()=>l,default:()=>h,metadata:()=>i,assets:()=>c,contentTitle:()=>s});var i=JSON.parse('{"id":"style-guide/s4/03","title":"4.3 Exceptions","description":"This section addresses the issue of exceptions in the context of program","source":"@site/docs/style-guide/s4/03.mdx","sourceDirName":"style-guide/s4","slug":"/style-guide/s4/03","permalink":"/docs/style-guide/s4/03","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"4.3 Exceptions"},"sidebar":"styleGuideSidebar","previous":{"title":"4.2 Visibility","permalink":"/docs/style-guide/s4/02"},"next":{"title":"4.4 Summary","permalink":"/docs/style-guide/s4/04"}}'),o=t(85893),r=t(50065);let a={title:"4.3 Exceptions"},s=void 0,c={},l=[{value:"Using Exceptions to Help Define an Abstraction",id:"using-exceptions-to-help-define-an-abstraction",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4}];function d(e){let n={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"This section addresses the issue of exceptions in the context of program\nstructures. It discusses how exceptions should be used as part of the\ninterface to a unit, including what exceptions to declare and raise and\nunder what conditions to raise them. Information on how to handle,\npropagate, and avoid raising exceptions is found in Guideline 5.8.\nGuidelines on how to deal with portability issues are in Guideline 7.5."}),"\n",(0,o.jsx)(n.h3,{id:"using-exceptions-to-help-define-an-abstraction",children:"Using Exceptions to Help Define an Abstraction"}),"\n",(0,o.jsx)(n.h4,{id:"guideline",children:"guideline"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"For unavoidable internal errors for which no user recovery is\npossible, declare a single user-visible exception. Inside the\nabstraction, provide a way to distinguish between the different\ninternal errors."}),"\n",(0,o.jsx)(n.li,{children:"Do not borrow an exception name from another context."}),"\n",(0,o.jsx)(n.li,{children:"Export (declare visibly to the user) the names of all exceptions\nthat can be raised."}),"\n",(0,o.jsx)(n.li,{children:"In a package, document which exceptions can be raised by each\nsubprogram and task entry."}),"\n",(0,o.jsx)(n.li,{children:"Do not raise exceptions for internal errors that can be avoided or\ncorrected within the unit."}),"\n",(0,o.jsx)(n.li,{children:"Do not raise the same exception to report different kinds of errors\nthat are distinguishable by the user of the unit."}),"\n",(0,o.jsx)(n.li,{children:"Provide interrogative functions that allow the user of a unit to\navoid causing exceptions to be raised."}),"\n",(0,o.jsx)(n.li,{children:"When possible, avoid changing state information in a unit before\nraising an exception."}),"\n",(0,o.jsx)(n.li,{children:"Catch and convert or handle all predefined and compiler-defined\nexceptions at the earliest opportunity."}),"\n",(0,o.jsx)(n.li,{children:"Do not explicitly raise predefined or implementation-defined\nexceptions."}),"\n",(0,o.jsx)(n.li,{children:"Never let an exception propagate beyond its scope."}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"example",children:"example"}),"\n",(0,o.jsx)(n.p,{children:"This package specification defines two exceptions that enhance the\nabstraction:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ada",children:"-------------------------------------------------------------------------\ngeneric\n   type Element is private;\npackage Stack is\n\n   function Stack_Empty return Boolean;\n   function Stack_Full  return Boolean;\n\n   procedure Pop  (From_Top :    out Element);\n   procedure Push (Onto_Top : in     Element);\n\n   -- Raised when Pop is used on empty stack.\n   Underflow : exception;\n\n   -- Raised when Push is used on full stack.\n   Overflow  : exception;\n\nend Stack;\n-------------------------------------------------------------------------\n...\n----------------------------------------------------------------------\nprocedure Pop (From_Top :    out Element) is\nbegin\n   ...\n\n   if Stack_Empty then\n      raise Underflow;\n\n   else -- Stack contains at least one element\n      Top_Index := Top_Index - 1;\n      From_Top  := Data(Top_Index + 1);\n\n   end if;\nend Pop;\n--------------------------------------------------------------------\n...\n"})}),"\n",(0,o.jsx)(n.h4,{id:"rationale",children:"rationale"}),"\n",(0,o.jsx)(n.p,{children:"Exceptions should be used as part of an abstraction to indicate error\nconditions that the abstraction is unable to prevent or correct. Because\nthe abstraction is unable to correct such an error, it must report the\nerror to the user. In the case of a usage error (e.g., attempting to\ninvoke operations in the wrong sequence or attempting to exceed a\nboundary condition), the user may be able to correct the error. In the\ncase of an error beyond the control of the user, the user may be able to\nwork around the error if there are multiple mechanisms available to\nperform the desired operation. In other cases, the user may have to\nabandon use of the unit, dropping into a degraded mode of limited\nfunctionality. In any case, the user must be notified."}),"\n",(0,o.jsx)(n.p,{children:"Exceptions are a good mechanism for reporting such errors because they\nprovide an alternate flow of control for dealing with errors. This\nallows error-handling code to be kept separate from the code for normal\nprocessing. When an exception is raised, the current operation is\naborted and control is transferred directly to the appropriate exception\nhandler."}),"\n",(0,o.jsx)(n.p,{children:"Several of the guidelines above exist to maximize the ability of the\nuser to distinguish and correct different kinds of errors. Declaring new\nexception names, rather than raising exceptions declared in other\npackages, reduces the coupling between packages and also makes different\nexceptions more distinguishable. Exporting the names of all exceptions\nthat a unit can raise, rather than declaring them internally to the\nunit, makes it possible for users of the unit to refer to the names in\nexception handlers. Otherwise, the user would be able to handle the\nexception only with an others handler. Finally, use comments to document\nexactly which of the exceptions declared in a package can be raised by\neach subprogram or task entry making it possible for the user to know\nwhich exception handlers are appropriate in each situation."}),"\n",(0,o.jsx)(n.p,{children:"In situations where there are errors for which the abstraction user can\ntake no intelligent action (e.g., there is no workaround or degraded\nmode), it is better to export a single internal error exception. Within\nthe package, you should consider distinguishing between the different\ninternal errors. For instance, you could record or handle different\nkinds of internal error in different ways. When you propagate the error\nto the user, however, you should use a special internal error exception,\nindicating that no user recovery is possible. You should also provide\nrelevant information when you propagate the error, using the facilities\nprovided in Ada.Exceptions. Thus, for any abstraction, you effectively\nprovide N + 1 different exceptions: N different recoverable errors and\none irrecoverable error for which there is no mapping to the\nabstraction. Both the application requirements and what the client\nneeds/wants in terms of error information help you identify the\nappropriate exceptions for an abstraction."}),"\n",(0,o.jsx)(n.p,{children:"Because they cause an immediate transfer of control, exceptions are\nuseful for reporting unrecoverable errors, which prevent an operation\nfrom being completed, but not for reporting status or modes incidental\nto the completion of an operation. They should not be used to report\ninternal errors that a unit was able to correct invisibly to the user."}),"\n",(0,o.jsx)(n.p,{children:"To provide the user with maximum flexibility, it is a good idea to\nprovide interrogative functions that the user can call to determine\nwhether an exception would be raised if a subprogram or task entry were\ninvoked. The function Stack_Empty in the above example is such a\nfunction. It indicates whether Underflow would be raised if Pop were\ncalled. Providing such functions makes it possible for the user to avoid\ntriggering exceptions."}),"\n",(0,o.jsx)(n.p,{children:"To support error recovery by its user, a unit should try to avoid\nchanging state during an invocation that raises an exception. If a\nrequested operation cannot be completely and correctly performed, then\nthe unit should either detect this before changing any internal state\ninformation or should revert to the state at the time of the request.\nFor example, after raising the exception Underflow, the stack package in\nthe above example should remain in exactly the same state it was in when\nPop was called. If it were to partially update its internal data\nstructures for managing the stack, then future Push and Pop operations\nwould not perform correctly. This is always desirable, but not always\npossible."}),"\n",(0,o.jsx)(n.p,{children:"User-defined exceptions should be used instead of predefined or\ncompiler-defined exceptions because they are more descriptive and more\nspecific to the abstraction. The predefined exceptions are very general\nand can be triggered by many different situations. Compiler-defined\nexceptions are nonportable and have meanings that are subject to change\neven between successive releases of the same compiler. This introduces\ntoo much uncertainty for the creation of useful handlers."}),"\n",(0,o.jsx)(n.p,{children:"If you are writing an abstraction, remember that the user does not know\nabout the units you use in your implementation. That is an effect of\ninformation hiding. If any exception is raised within your abstraction,\nyou must catch it and handle it. The user is not able to provide a\nreasonable handler if the original exception is allowed to propagate out\nof the body of your abstraction. You can still convert the exception\ninto a form intelligible to the user if your abstraction cannot\neffectively recover on its own."}),"\n",(0,o.jsx)(n.p,{children:"Converting an exception means raising a user-defined exception in the\nhandler for the original exception. This introduces a meaningful name\nfor export to the user of the unit. Once the error situation is couched\nin terms of the application, it can be handled in those terms."})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);